

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="OneAmx">
  <meta name="keywords" content="">
  
    <meta name="description" content="Linux内核数据结构之Radix Tree ⛷️转载自：https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;533338300  1.概述radix tree，又称做基数树，是一种适合于构建key与value相关联的数据结构。在linux内核中，radix tree由 include&#x2F;linux&#x2F;radix-tree.h和lib&#x2F;radix-tree.c两个文">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核数据结构之Radix Tree">
<meta property="og:url" content="http://example.com/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/index.html">
<meta property="og:site_name" content="疯狂少年">
<meta property="og:description" content="Linux内核数据结构之Radix Tree ⛷️转载自：https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;533338300  1.概述radix tree，又称做基数树，是一种适合于构建key与value相关联的数据结构。在linux内核中，radix tree由 include&#x2F;linux&#x2F;radix-tree.h和lib&#x2F;radix-tree.c两个文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-7930d31f29a67d19368b67ae6ef01f9e_720w.webp">
<meta property="og:image" content="http://example.com/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-5c589cf83d7cedaf904f868a70d180da_720w.webp">
<meta property="og:image" content="http://example.com/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-ba5eb6f207a226081887c7538385946f_720w.webp">
<meta property="og:image" content="http://example.com/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-f6d4715694b6319c8c382409e9661b71_720w.webp">
<meta property="og:image" content="http://example.com/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-2d55465cd47c99ae29ada718c9f71872_720w.webp">
<meta property="og:image" content="http://example.com/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-ced652319751af276ab00cb7cb73fc2c_720w.webp">
<meta property="og:image" content="http://example.com/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-979fe6a7d6d0381c1fa395bec719ad4e_720w.webp">
<meta property="og:image" content="http://example.com/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-44a3bd4416f1139bfd6c04f0160f3871_720w.webp">
<meta property="og:image" content="http://example.com/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-003fd8d09948205b03761f50c3b73fed_720w.webp">
<meta property="og:image" content="http://example.com/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-31c0362e3f9dac199b884733f6086d42_r.jpg">
<meta property="og:image" content="http://example.com/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-818b4dcba36f5ef364e719b08840c665_r.jpg">
<meta property="article:published_time" content="2023-11-20T14:21:44.000Z">
<meta property="article:modified_time" content="2023-11-20T14:57:29.558Z">
<meta property="article:author" content="OneAmx">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-7930d31f29a67d19368b67ae6ef01f9e_720w.webp">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Linux内核数据结构之Radix Tree - 疯狂少年</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/mouse.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"5f9d3edcc5e93f7fb0c85cf03554f3aa","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?5f9d3edcc5e93f7fb0c85cf03554f3aa";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>疯狂少年</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Linux内核数据结构之Radix Tree"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-20 22:21" pubdate>
          2023年11月20日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          151 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          浏览 <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Linux内核数据结构之Radix Tree</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Linux内核数据结构之Radix-Tree"><a href="#Linux内核数据结构之Radix-Tree" class="headerlink" title="Linux内核数据结构之Radix Tree"></a>Linux内核数据结构之Radix Tree</h1><blockquote>
<p>⛷️转载自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/533338300">https://zhuanlan.zhihu.com/p/533338300</a></p>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>radix tree，又称做基数树，是一种适合于构建key与value相关联的数据结构。在linux内核中，radix tree由 include&#x2F;linux&#x2F;radix-tree.h和lib&#x2F;radix-tree.c两个文件实现。</p>
<p>在linux内核中pagecache就是用radix tree构建的page index与page ptr (指向struct page)的关联。详见struct address_space 中的page_tree。这里的(key,value)对， 就是(index， ptr)对。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>		*<span class="hljs-title">host</span>;</span>		<span class="hljs-comment">/* owner: inode, block_device */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_root</span>	<span class="hljs-title">page_tree</span>;</span><br>        ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>radix tree中的每一个内部节点最多拥有r个child，r&#x3D;2^n (n&gt;&#x3D;1), 这里的n被称做基数。 n个bit称作一个bit簇。</p>
<p>在linux内核的radix tree实现代码中，基数最为最关键的参数被定义成6（RADIX_TREE_MAP_SHIFT），也就是说一个bit簇是6个bit。所以linux内核中radix tree的一个内部节点最多可以有64个child。</p>
<p>radix tree的所有叶子节点都在最下面一层（图中红色节点），其他节点都是为了构建radix tree树而创建出来的内部节点。叶子节点包含index-ptr对中的ptr item， 下图中将ptr用红色来标记为item。</p>
<img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-7930d31f29a67d19368b67ae6ef01f9e_720w.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 100%;">

<p>假设key值等于0x840FF, 其二进制按照6bit一簇可以写成，000010-000100 -000011 -111111，从左到右的index值分别为2, 4, 3, 63。那么根据key值0x840FF找到value的过程就只需要4步：</p>
<p>第一步，在最上层的节点A中找到index为2的slot，其slot[2]指针指向第二层节点中的节点B。</p>
<p>第二步，在节点B中找到index为4的slot，其slot[4]指针指向第三层节点中的节点C。</p>
<p>第三步，在节点C中找到index为3的slot，其slot[3]指针指向第三层节点中的节点D。</p>
<p>第四步，在节点D中找到index为63的slot，其slot[63]指针指向叶子节点item E。</p>
<h2 id="2-数据结构初识"><a href="#2-数据结构初识" class="headerlink" title="2.数据结构初识"></a>2.数据结构初识</h2><h3 id="struct-radix-tree-root"><a href="#struct-radix-tree-root" class="headerlink" title="struct radix_tree_root"></a>struct radix_tree_root</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* root tags are stored in gfp_mask, shifted by __GFP_BITS_SHIFT */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_root</span> &#123;</span><br>	<span class="hljs-type">gfp_t</span>			gfp_mask;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span>	__<span class="hljs-title">rcu</span> *<span class="hljs-title">rnode</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>每一棵radix tree都必须有struct radix_tree_root这样一个数据结构。其中</p>
<ul>
<li>gfp_mask：bit 0-bit24 用做内存分配的标记，在分配struct radix_tree_node结构时，传递给内存分配函数kmem_cache_alloc。bit25-27用作root tags。tag的作用下文再细说。</li>
<li>rnode： rnode用来指向顶层的struct radix_tree_node，也就是radix tree的第一个内部节点；当radix tree 只有一个叶子节点，并且叶子节点的index为0时，也可以可以直接指向一个叶子节点，即(index，ptr)对中的ptr。</li>
</ul>
<h3 id="struct-radix-tree-node"><a href="#struct-radix-tree-node" class="headerlink" title="struct radix_tree_node"></a>struct radix_tree_node</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The radix_tree_node structure is never embedded in other data structures.</span><br><span class="hljs-comment"> * As a result, there&#x27;s no need to preserve the size.  Because the structure</span><br><span class="hljs-comment"> * is reachable via others, though, we need to preserve the original contents</span><br><span class="hljs-comment"> * for the kabi checker.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> &#123;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> 	shift, 	<span class="hljs-comment">/* Bits remaining in each slot */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> 	offset	<span class="hljs-comment">/* Slot offset in parent */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>	count;<br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>			<span class="hljs-comment">/* Used when ascending tree */</span><br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">parent</span>;</span><br>			<span class="hljs-comment">/* For tree user */</span><br>			<span class="hljs-type">void</span> *private_data;<br>		&#125;;<br>		<span class="hljs-comment">/* Used when freeing node */</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span>	<span class="hljs-title">rcu_head</span>;</span><br>	&#125;;<br>	<span class="hljs-comment">/* For tree user */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">private_list</span>;</span><br>	<span class="hljs-type">void</span> __rcu	*slots[RADIX_TREE_MAP_SIZE];<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS];<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>struct radix_tree_node结构代表radix tree的一个内部节点。</p>
<ul>
<li>shift：与当前内部节点在radix tree中所处的层级相关，最低一层的节点，shift为0，倒数第二层shift为6。 shift从低往高， 逐层递增6</li>
<li>offset：表示与当前内部节点相关联的父节点slot数组下标</li>
<li>count：表示当前节点包含的child节点的个数，child节点可以是内部节点也可以是叶子节点。</li>
<li>parent：指向parent 节点</li>
<li>tags：这里的tags是二维数组，在64bit系统中，这个数组的定义tag[3][1]相当于一维数组</li>
<li>slots：指针数组slot[64]， 每个元素指向一个下一级的radix_tree_node结构，或者是叶子节点</li>
</ul>
<h2 id="3-radix-tree的几种形态"><a href="#3-radix-tree的几种形态" class="headerlink" title="3.radix tree的几种形态"></a>3.radix tree的几种形态</h2><h3 id="形态1：空树"><a href="#形态1：空树" class="headerlink" title="形态1：空树"></a>形态1：空树</h3><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-5c589cf83d7cedaf904f868a70d180da_720w.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 100%;">

<h3 id="形态2：只有一个index为0的叶子结点"><a href="#形态2：只有一个index为0的叶子结点" class="headerlink" title="形态2：只有一个index为0的叶子结点"></a>形态2：只有一个index为0的叶子结点</h3><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-ba5eb6f207a226081887c7538385946f_720w.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom:100%;">

<h3 id="形态3：层高为1的情形"><a href="#形态3：层高为1的情形" class="headerlink" title="形态3：层高为1的情形"></a>形态3：层高为1的情形</h3><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-f6d4715694b6319c8c382409e9661b71_720w.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom:100%;">

<h3 id="形态4：层高为2的情形"><a href="#形态4：层高为2的情形" class="headerlink" title="形态4：层高为2的情形"></a>形态4：层高为2的情形</h3><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-2d55465cd47c99ae29ada718c9f71872_720w.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom:100%;">

<h3 id="形态5：层高为3的情形"><a href="#形态5：层高为3的情形" class="headerlink" title="形态5：层高为3的情形"></a>形态5：层高为3的情形</h3><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-ced652319751af276ab00cb7cb73fc2c_720w.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom:100%;">

<h2 id="4-节点内存管理"><a href="#4-节点内存管理" class="headerlink" title="4.节点内存管理"></a>4.节点内存管理</h2><h3 id="节点内存的分配"><a href="#节点内存的分配" class="headerlink" title="节点内存的分配"></a>节点内存的分配</h3><p><strong>radix_tree_node_alloc</strong></p>
<p>分配struct radix_tree_node内存时，radix_tree_node_alloc优先选择从当前cpu上的内存池分配内存。如果内存池没有内存了，这时才会直接调用kmem_cache_alloc函数从radix_tree_node_cachep slab分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This assumes that the caller has performed appropriate preallocation, and</span><br><span class="hljs-comment"> * that the caller has pinned this thread of control to the current CPU.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> radix_tree_node *<br><span class="hljs-title function_">radix_tree_node_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> radix_tree_root *root)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">ret</span> =</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-type">gfp_t</span> gfp_mask = root_gfp_mask(root);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Preload code isn&#x27;t irq safe and it doesn&#x27;t make sense to use</span><br><span class="hljs-comment">	 * preloading during an interrupt anyway as all the allocations have</span><br><span class="hljs-comment">	 * to be atomic. So just do normal allocation when in interrupt.</span><br><span class="hljs-comment">	 */</span><br>        <span class="hljs-comment">/* 优先从percpu的内存池分配内存 */</span><br>	<span class="hljs-keyword">if</span> (!(gfp_mask &amp; __GFP_WAIT) &amp;&amp; !in_interrupt()) &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_preload</span> *<span class="hljs-title">rtp</span>;</span><br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Provided the caller has preloaded here, we will always</span><br><span class="hljs-comment">		 * succeed in getting a node here (and never reach</span><br><span class="hljs-comment">		 * kmem_cache_alloc)</span><br><span class="hljs-comment">		 */</span><br>		rtp = this_cpu_ptr(&amp;radix_tree_preloads);<br>		<span class="hljs-keyword">if</span> (rtp-&gt;nr) &#123;<br>			ret = rtp-&gt;nodes;<br>			rtp-&gt;nodes = ret-&gt;private_data;<br>			ret-&gt;private_data = <span class="hljs-literal">NULL</span>;<br>			rtp-&gt;nr--;<br>		&#125;<br>	&#125;<br>        <span class="hljs-comment">/*percpu的内存池不能满足要求时，才直接从radix_tree_node_cachep这个slab申请内存 */</span><br>	<span class="hljs-keyword">if</span> (ret == <span class="hljs-literal">NULL</span>)<br>		ret = kmem_cache_alloc(radix_tree_node_cachep, gfp_mask);<br><br>	BUG_ON(radix_tree_is_internal_node(ret));<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>radix_tree_preload_end</strong></p>
<p>分配struct radix_tree_node内存时，radix_tree_node_alloc优先选择从当前cpu上的内存池分配内存。如果内存池没有内存了，这时才会直接调用kmem_cache_alloc函数从radix_tree_node_cachep slab分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This assumes that the caller has performed appropriate preallocation, and</span><br><span class="hljs-comment"> * that the caller has pinned this thread of control to the current CPU.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> radix_tree_node *<br><span class="hljs-title function_">radix_tree_node_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> radix_tree_root *root)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">ret</span> =</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-type">gfp_t</span> gfp_mask = root_gfp_mask(root);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Preload code isn&#x27;t irq safe and it doesn&#x27;t make sense to use</span><br><span class="hljs-comment">	 * preloading during an interrupt anyway as all the allocations have</span><br><span class="hljs-comment">	 * to be atomic. So just do normal allocation when in interrupt.</span><br><span class="hljs-comment">	 */</span><br>        <span class="hljs-comment">/* 优先从percpu的内存池分配内存 */</span><br>	<span class="hljs-keyword">if</span> (!(gfp_mask &amp; __GFP_WAIT) &amp;&amp; !in_interrupt()) &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_preload</span> *<span class="hljs-title">rtp</span>;</span><br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Provided the caller has preloaded here, we will always</span><br><span class="hljs-comment">		 * succeed in getting a node here (and never reach</span><br><span class="hljs-comment">		 * kmem_cache_alloc)</span><br><span class="hljs-comment">		 */</span><br>		rtp = this_cpu_ptr(&amp;radix_tree_preloads);<br>		<span class="hljs-keyword">if</span> (rtp-&gt;nr) &#123;<br>			ret = rtp-&gt;nodes;<br>			rtp-&gt;nodes = ret-&gt;private_data;<br>			ret-&gt;private_data = <span class="hljs-literal">NULL</span>;<br>			rtp-&gt;nr--;<br>		&#125;<br>	&#125;<br>        <span class="hljs-comment">/*percpu的内存池不能满足要求时，才直接从radix_tree_node_cachep这个slab申请内存 */</span><br>	<span class="hljs-keyword">if</span> (ret == <span class="hljs-literal">NULL</span>)<br>		ret = kmem_cache_alloc(radix_tree_node_cachep, gfp_mask);<br><br>	BUG_ON(radix_tree_is_internal_node(ret));<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>radix_tree_load_root</strong></p>
<p>radix tree的实现文件中很多重要的函数， 比如__radix_tree_lookup、__radix_tree_create等函数，其开始部分都要调用radix_tree_load_root。那么radix_tree_load_root这个函数是干什么呢？ 在分析__radix_tree_lookup之前，我们有必要把radix_tree_load_root函数先看一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-title function_">radix_tree_load_root</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> radix_tree_root *root,</span><br><span class="hljs-params">		<span class="hljs-keyword">struct</span> radix_tree_node **nodep, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *maxindex)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">node</span> =</span> rcu_dereference_raw(root-&gt;rnode);<br><br>	*nodep = node;<br><br>	<span class="hljs-keyword">if</span> (likely(radix_tree_is_internal_node(node))) &#123;<br>		node = entry_to_node(node);<br>		*maxindex = node_maxindex(node);<br>		<span class="hljs-keyword">return</span> node-&gt;shift + RADIX_TREE_MAP_SHIFT;<br>	&#125;<br><br>	*maxindex = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数radix_tree_load_root的参数：</p>
<ul>
<li>root：标识radix tree的root</li>
<li>nodep：输出参数，用来返回radix tree的第一个节点的地址</li>
<li>maxindex：输出参数，用来返回radix tree的当前能容纳的最大的inde值</li>
</ul>
<p>函数返回值：</p>
<ul>
<li>如果radix tree目前是空树（形态1）或者只有一个index为0的叶子结点，此时返回0</li>
<li>其他形态，返回值等于第一个节点的shift值+6.</li>
</ul>
<p>函数radix_tree_load_root，先取得struct radix_tree_root的rnode指针。因为一棵radix tree有且仅有一个struct radix_tree_root结构，而rnode指向radix tree 的第一个节点，通过它才能遍历整棵radix tree。</p>
<p>从前文radix的形态介绍中，我们知道rnode可以等于NULL， 此时表示一棵空树；rnode也可以直接指向一个叶子节点； rnode大多数情况是指向一个内部节点。rnode&#x3D;&#x3D;NULL很好判断，那么rnode不等于NULL时，如何判断其指向一个内部节点还是叶子节点呢？目前程序利用指针的最后两个bit来进行判断。</p>
<p>radix_tree_is_internal_node用来判断节点是否为内部节点，返回值为true表示ptr指向的节点是内部节点，false表示ptr为NULL值或者是叶子节点。这里假定叶子节点的内存地址至少是按照4字节对齐的，也就是说，bit0~1需要为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RADIX_TREE_ENTRY_MASK		3UL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RADIX_TREE_INTERNAL_NODE	1UL</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">radix_tree_is_internal_node</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ptr &amp; RADIX_TREE_ENTRY_MASK) ==<br>				RADIX_TREE_INTERNAL_NODE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数entry_to_node用来实现将ptr指针的bit0~1掩掉，也就是将ptr转换为radix_tree_node结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> radix_tree_node *<span class="hljs-title function_">entry_to_node</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ptr &amp; ~RADIX_TREE_INTERNAL_NODE);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="节点查找过程"><a href="#节点查找过程" class="headerlink" title="节点查找过程"></a>节点查找过程</h3><p><strong>radix_tree_descend</strong></p>
<p>要查找index对应的ptr item，需要从第一个节点开始逐层下降，最终寻找到radix tree的叶子节点。已知需要经由某一层级的parent节点，该函数计算经由parent节点的哪一个slot才能继续往下进展一层。</p>
<p>函数radix_tree_descend的参数：</p>
<ul>
<li>parent：输入参数，标识radix tree的一个中间节点，要查找index对应的ptr item，需要经由此节点</li>
<li>nodep：输出参数，要查找index对应的ptr item，需要经由parent节点的下一级节点</li>
<li>index：输入参数，待查找节点的index</li>
</ul>
<p>函数返回值：经由当前parent节点的slot</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">radix_tree_descend</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> radix_tree_node *parent,</span><br><span class="hljs-params">			<span class="hljs-keyword">struct</span> radix_tree_node **nodep, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> index)</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset = (index &gt;&gt; parent-&gt;shift) &amp; RADIX_TREE_MAP_MASK;<br>	<span class="hljs-type">void</span> **entry = rcu_dereference_raw(parent-&gt;slots[offset]);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_RADIX_TREE_MULTIORDER</span><br>	<span class="hljs-keyword">if</span> (radix_tree_is_internal_node(entry)) &#123;<br>		<span class="hljs-keyword">if</span> (is_sibling_entry(parent, entry)) &#123;<br>			<span class="hljs-type">void</span> **sibentry = (<span class="hljs-type">void</span> **) entry_to_node(entry);<br>			offset = get_slot_offset(parent, sibentry);<br>			entry = rcu_dereference_raw(*sibentry);<br>		&#125;<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	*nodep = (<span class="hljs-type">void</span> *)entry;<br>	<span class="hljs-keyword">return</span> offset;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>offset &#x3D; (index &gt;&gt; parent-&gt;shift) &amp; RADIX_TREE_MAP_MASK； 这句话计算index在当前层级的6bit 索引， 也就是在parent节点中的slot编号。parent-&gt;slots[offset]指向下一级中间节点或者叶子节点。</p>
<p><strong>__radix_tree_lookup</strong></p>
<p>函数__radix_tree_lookup查找radix tree中与index对应的ptr item。</p>
<p>函数__radix_tree_lookup的参数：</p>
<ul>
<li>root：输入参数，标识radix tree的root</li>
<li>index：输入参数，待查找节点的index</li>
<li>nodep：输出参数，用来返回index对应的ptr item的parent节点</li>
<li>slotp：输出参数，用来返回index对应的ptr item关联的slot的地址</li>
</ul>
<p>函数返回值：index对应的ptr item</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *	__radix_tree_lookup	-	lookup an item in a radix tree</span><br><span class="hljs-comment"> *	@root:		radix tree root</span><br><span class="hljs-comment"> *	@index:		index key</span><br><span class="hljs-comment"> *	@nodep:		returns node</span><br><span class="hljs-comment"> *	@slotp:		returns slot</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *	Lookup and return the item at position @index in the radix</span><br><span class="hljs-comment"> *	tree @root.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *	Until there is more than one item in the tree, no nodes are</span><br><span class="hljs-comment"> *	allocated and @root-&gt;rnode is used as a direct slot instead of</span><br><span class="hljs-comment"> *	pointing to a node, in which case *@nodep will be NULL.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> *__radix_tree_lookup(<span class="hljs-keyword">struct</span> radix_tree_root *root, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> index,<br>			  <span class="hljs-keyword">struct</span> radix_tree_node **nodep, <span class="hljs-type">void</span> ***slotp)<br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">node</span>, *<span class="hljs-title">parent</span>;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> maxindex;<br>	<span class="hljs-type">void</span> **slot;<br><br> restart:<br>	parent = <span class="hljs-literal">NULL</span>;<br>	slot = (<span class="hljs-type">void</span> **)&amp;root-&gt;rnode;<br>	radix_tree_load_root(root, &amp;node, &amp;maxindex);<br>	<span class="hljs-keyword">if</span> (index &gt; maxindex)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-keyword">while</span> (radix_tree_is_internal_node(node)) &#123;<br>		<span class="hljs-type">unsigned</span> offset;<br><br>		<span class="hljs-keyword">if</span> (node == RADIX_TREE_RETRY)<br>			<span class="hljs-keyword">goto</span> restart;<br>		parent = entry_to_node(node);<br>		offset = radix_tree_descend(parent, &amp;node, index);<br>		slot = parent-&gt;slots + offset;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (nodep)<br>		*nodep = parent;<br>	<span class="hljs-keyword">if</span> (slotp)<br>		*slotp = slot;<br><br>	<span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="节点插入"><a href="#节点插入" class="headerlink" title="节点插入"></a>节点插入</h3><p><strong>radix_tree_extend</strong></p>
<p>函数radix_tree_extend实现radix tree纵向的生长，也就是让radix tree的高度值变大。因为每升高一层，radix tree的第一个节点的shift值都会递增6，从而使得radix tree能容纳的最大index扩大64倍，最终实现index &lt;&#x3D;( (1 &lt;&lt; shift) - 1)。</p>
<p>函数radix_tree_extend的参数：</p>
<ul>
<li>root：输入参数，标识radix tree的root</li>
<li>index：输入参数，待查找节点的index。在radix tree中要有足够的高度能够容纳该index</li>
<li>shift：与当前radixtree第一个节点的shift值相关联，这个值决定了树的高度。如果radix tree为空树（形态1）或者radix tree只有一个index为0的叶子节点(形态2)，则shift &#x3D; 0；其他的情况，shift &#x3D; 第一个内部节点的shift值+ 6</li>
</ul>
<p>radix tree最多能够容纳的index的最大值，取决于radix tree第一个内部节点的shift值。不同的shift值，能够覆盖的index最大值如下表：</p>
<table>
<thead>
<tr>
<th>shift</th>
<th>index的最大值</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>2^6 - 1</td>
</tr>
<tr>
<td>6</td>
<td>2^12 - 1</td>
</tr>
<tr>
<td>12</td>
<td>2^18 - 1</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>6*n</td>
<td>2^(shift+6) - 1</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *	Extend a radix tree so it can store key @index.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">radix_tree_extend</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> radix_tree_root *root,</span><br><span class="hljs-params">				<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> index, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shift)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">slot</span>;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> maxshift;<br>	<span class="hljs-type">int</span> tag;<br><br>	<span class="hljs-comment">/* Figure out what the shift should be.  */</span><br>        <span class="hljs-comment">/* 该while循环用来计算，radix tree 需要生长到的高度 */</span><br>	maxshift = shift;<br>	<span class="hljs-keyword">while</span> (index &gt; shift_maxindex(maxshift))<br>		maxshift += RADIX_TREE_MAP_SHIFT;<br><br>       <span class="hljs-comment">/* 对于空树，跳过下面的树纵向生长的过程 */</span><br>	slot = root-&gt;rnode;<br>	<span class="hljs-keyword">if</span> (!slot)<br>		<span class="hljs-keyword">goto</span> out;<br><br>        <span class="hljs-comment">/* 下面是树纵向生长的过程</span><br><span class="hljs-comment">           程序走到这里， 表示root-&gt;rnode已经存在 */</span><br>	<span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">/* 分配一个node, 该新分配的node将关联到root-&gt;rnode</span><br><span class="hljs-comment">		  也就是说这个新分配的node将成为根节点，原先的根节点反而成为新分</span><br><span class="hljs-comment">                  配节点的子节点 */</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">node</span> =</span> radix_tree_node_alloc(root);<br><br>		<span class="hljs-keyword">if</span> (!node)<br>			<span class="hljs-keyword">return</span> -ENOMEM;<br><br>		<span class="hljs-comment">/* Propagate the aggregated tag info into the new root */</span><br>		<span class="hljs-keyword">for</span> (tag = <span class="hljs-number">0</span>; tag &lt; RADIX_TREE_MAX_TAGS; tag++) &#123;<br>			<span class="hljs-keyword">if</span> (root_tag_get(root, tag))<br>				tag_set(node, tag, <span class="hljs-number">0</span>);<br>		&#125;<br><br>		BUG_ON(shift &gt; BITS_PER_LONG);<br>		node-&gt;shift = shift;<br>		node-&gt;offset = <span class="hljs-number">0</span>;<br>		node-&gt;count = <span class="hljs-number">1</span>;<br>		node-&gt;parent = <span class="hljs-literal">NULL</span>;<br><br>                <span class="hljs-comment">/* slot是之前的根节点， 现在变成了node的子节点 */</span><br>		<span class="hljs-keyword">if</span> (radix_tree_is_internal_node(slot))<br>			entry_to_node(slot)-&gt;parent = node;<br>                <span class="hljs-comment">/* 原先的根节点关联到新分配节点的slot[0]上 */</span><br>		node-&gt;slots[<span class="hljs-number">0</span>] = slot;<br>		slot = node_to_entry(node);<br>		rcu_assign_pointer(root-&gt;rnode, slot);<br>		shift += RADIX_TREE_MAP_SHIFT;<br>	&#125; <span class="hljs-keyword">while</span> (shift &lt;= maxshift);<br>out:<br>        <span class="hljs-comment">/* 这里最后返回的时候，maxshift还要在加6，因为__radix_tree_create</span><br><span class="hljs-comment">          函数在while循环的判断条件是，当order=0，且shift=0， 循环就结束了 */</span><br>	<span class="hljs-keyword">return</span> maxshift + RADIX_TREE_MAP_SHIFT;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>考虑场景1：radix_tree_extend函数执行前，只有一个叶子节点</p>
<ul>
<li>调用radix_tree_extend函数时，index &#x3D; 60，shift &#x3D; 0</li>
<li>maxshift &#x3D; 0，index &#x3D; 60，shift &#x3D;0，while (index &gt; shift_maxindex(maxshift))条件不能满足，所以maxshift 不需要递增了</li>
<li>root-&gt;rnode 不等于NULL，slot &#x3D; root-&gt;rnode。开始执行do{}while循环,</li>
<li>分配一个内部节点node(图中A节点)，node-&gt;shift &#x3D; 0, node-&gt;count &#x3D; 1，node-&gt;slot[0]&#x3D;item0， root-&gt;rnode &#x3D; node</li>
<li>返回值是（0 + RADIX_TREE_MAP_SHIFT）&#x3D; 6</li>
</ul>
<img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-979fe6a7d6d0381c1fa395bec719ad4e_720w.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;">

<p>考虑场景2：radix_tree_extend函数执行前，已经有一个内部节点A</p>
<ul>
<li>调用radix_tree_extend函数时，index &#x3D; 64，shift &#x3D; 6</li>
<li>maxshift &#x3D; 6，index &#x3D; 64, shift &#x3D; 6, while(index &gt; shift_maxindex(maxshift))条件不能满足，所以maxshift 不需要递增了</li>
<li>root-&gt;rnode 不等于NULL，slot &#x3D; root-&gt;rnode， 即slot指向A节点。执行do{}while循环</li>
<li>分配一个内部节点node (图中B节点)，node-&gt;shift &#x3D; 6, node-&gt;count &#x3D; 1, node-&gt;slot[0]&#x3D;item0， root-&gt;rnode &#x3D; node； A的父节点指向B；</li>
<li>返回值是（maxshift + RADIX_TREE_MAP_SHIFT）&#x3D; 12</li>
</ul>
<img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-44a3bd4416f1139bfd6c04f0160f3871_720w.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;">

<p><strong>__radix_tree_create</strong></p>
<p>函数__radix_tree_create在保持现有高度的基础上，在查找index的路径上添加中间节点。其实这里所说的保持现有高度并不准确，比如对于一个空树，在查找index的路径上添加中间节点的过程中，实现了树高度的生长。</p>
<p>函数radix_tree_extend的参数：</p>
<ul>
<li>root：输入参数，标识radix tree的root</li>
<li>index：输入参数，待查找节点的index</li>
<li>order， 这是在CONFIG_RADIX_TREE_MULTIORDER使能时才使用的参数，正常情况下order &#x3D; 0</li>
<li>shift：与当前radixtree第一个节点的shift值相关联，这个值决定了树的高度。如果radix tree为空树（形态1）或者radix tree只有一个index为0的叶子节点(形态2)，则shift &#x3D; 0；其他的情况，shift &#x3D; 第一个内部节点的shift值+ 6</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"> *	__radix_tree_create	-	create a slot in a radix tree<br> *	@root:		radix tree root<br> *	@index:		index key<br> *	@order:		index occupies <span class="hljs-number">2</span>^order aligned slots<br> *	@nodep:		returns node<br> *	@slotp:		returns slot<br> *<br> *	Create, <span class="hljs-keyword">if</span> necessary, and <span class="hljs-keyword">return</span> the node and slot <span class="hljs-keyword">for</span> an item<br> *	at position @index in the radix tree @root.<br> *<br> *	Until there is more than one item in the tree, no nodes are<br> *	allocated and @root-&gt;rnode is used as a direct slot instead of<br> *	pointing to a node, in which <span class="hljs-keyword">case</span> *@nodep will be <span class="hljs-literal">NULL</span>.<br> *<br> *	Returns -ENOMEM, or <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> success.<br> */<br><span class="hljs-type">int</span> __radix_tree_create(<span class="hljs-keyword">struct</span> radix_tree_root *root, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> index,<br>			<span class="hljs-type">unsigned</span> order, <span class="hljs-keyword">struct</span> radix_tree_node **nodep,<br>			<span class="hljs-type">void</span> ***slotp)<br>&#123;<br>	<span class="hljs-keyword">struct</span> radix_tree_node *node = <span class="hljs-literal">NULL</span>, *child;<br>	<span class="hljs-type">void</span> **slot = (<span class="hljs-type">void</span> **)&amp;root-&gt;rnode;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> maxindex;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shift, offset = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> max = index | ((<span class="hljs-number">1UL</span> &lt;&lt; order) - <span class="hljs-number">1</span>);<br><br>       <span class="hljs-comment">/* radix_tree_load_root函数获取root-&gt;rnode,  获取当前root-&gt;rnode所能覆盖的最大的</span><br><span class="hljs-comment">          index值</span><br><span class="hljs-comment">          对于返回值shift：如果radix tree为空树(形态1)或者radix tree只有一个index为0的</span><br><span class="hljs-comment">          叶子节点(形态2),则shift为0；</span><br><span class="hljs-comment">          其他的情况，shift为radix tree第一个内部节点的shift值+6  */</span><br>	shift = radix_tree_load_root(root, &amp;child, &amp;maxindex);<br><br>	<span class="hljs-comment">/* Make sure the tree is high enough.  */</span><br>        <span class="hljs-comment">/* 如果要查找的index值比当前node所能覆盖的最大index值还要大，这时需要实现radix </span><br><span class="hljs-comment">           tree高度的生长, 这项任务由radix_tree_extend函数完成</span><br><span class="hljs-comment">           radix_tree_extend函数返回时，我们期望radix tree 已经有足够的高度能够容纳</span><br><span class="hljs-comment">           输入参数index。但是有一种例外，就是当root-&gt;rnode为NULL时，树的高度还不能够</span><br><span class="hljs-comment">           容纳输入参数index */</span><br>	<span class="hljs-keyword">if</span> (max &gt; maxindex) &#123;<br>		<span class="hljs-type">int</span> error = radix_tree_extend(root, max, shift);<br>		<span class="hljs-keyword">if</span> (error &lt; <span class="hljs-number">0</span>)<br>			<span class="hljs-keyword">return</span> error;<br>		shift = error;<br>		child = root-&gt;rnode;<br>		<span class="hljs-keyword">if</span> (order == shift)<br>			shift += RADIX_TREE_MAP_SHIFT;<br>	&#125;<br><br>	<span class="hljs-keyword">while</span> (shift &gt; order) &#123;<br>		shift -= RADIX_TREE_MAP_SHIFT;<br>                <span class="hljs-comment">/* 如果当前节点为NULL，表示到达与index对应的item路径上中间节点缺失，</span><br><span class="hljs-comment">                   这时需要把中间节点补上 */</span><br>		<span class="hljs-keyword">if</span> (child == <span class="hljs-literal">NULL</span>) &#123;<br>			<span class="hljs-comment">/* Have to add a child node.  */</span><br>			child = radix_tree_node_alloc(root);<br>			<span class="hljs-keyword">if</span> (!child)<br>				<span class="hljs-keyword">return</span> -ENOMEM;<br>			child-&gt;shift = shift;<br>			child-&gt;offset = offset;<br>			child-&gt;parent = node;<br>			rcu_assign_pointer(*slot, node_to_entry(child));<br>			<span class="hljs-keyword">if</span> (node)<br>				node-&gt;count++;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!radix_tree_is_internal_node(child)) <span class="hljs-comment">/* 到达叶子节点，停止 */</span><br>			<span class="hljs-keyword">break</span>;<br><br>		<span class="hljs-comment">/* Go a level down */</span><br>                <span class="hljs-comment">/* 往树叶方向下降一级，这里调用radix_tree_descend找到下一级内部节点 */</span><br>		node = entry_to_node(child);<br>		offset = radix_tree_descend(node, &amp;child, index);<br>		slot = &amp;node-&gt;slots[offset];<br>	&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_RADIX_TREE_MULTIORDER</span><br>	<span class="hljs-comment">/* Insert pointers to the canonical entry */</span><br>	<span class="hljs-keyword">if</span> (order &gt; shift) &#123;<br>		<span class="hljs-type">unsigned</span> i, n = <span class="hljs-number">1</span> &lt;&lt; (order - shift);<br>		offset = offset &amp; ~(n - <span class="hljs-number">1</span>);<br>		slot = &amp;node-&gt;slots[offset];<br>		child = node_to_entry(slot);<br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>			<span class="hljs-keyword">if</span> (slot[i])<br>				<span class="hljs-keyword">return</span> -EEXIST;<br>		&#125;<br><br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>			rcu_assign_pointer(slot[i], child);<br>			node-&gt;count++;<br>		&#125;<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>         <span class="hljs-comment">/* 函数返回时，要填写item所在的父内部节点，以及与item对应slot的地址 */</span><br>	<span class="hljs-keyword">if</span> (nodep)<br>		*nodep = node;<br>	<span class="hljs-keyword">if</span> (slotp)<br>		*slotp = slot;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>考虑场景1：__radix_tree_create函数执行前，radix tree 是一个空树，如下左图； 参数index &#x3D; 63， order &#x3D; 0</p>
<ul>
<li>调用radix_tree_load_root函数前，max &#x3D; 63</li>
<li>调用radix_tree_load_root函数后，child &#x3D; NULL，maxindex &#x3D; 0, shift &#x3D; 0</li>
<li>max &gt; maxindex 条件满足，调用radix_tree_extend函数; 由于root-&gt;rnode &#x3D;&#x3D;NULL, radix_tree_extend函数里面do while{}循环被跳过，函数返回值是6</li>
<li>回到__radix_tree_create函数，shift &#x3D;6，child&#x3D;NULL， 开始执行while循环</li>
<li>shift递减后，shift&#x3D; 0，由于child&#x3D;&#x3D;NULL，分配一个内部节点child（图中A节点），child-&gt;shift &#x3D; 0, child-&gt;offset &#x3D; 0， child-&gt;parent &#x3D; NULL。root-&gt;rnode &#x3D; child</li>
<li>往树叶方向下降一级，调用radix_tree_descend后,offset&#x3D;63，child &#x3D;NULL, slot &#x3D; &amp;root-&gt;rnode-&gt;slots[63]</li>
<li>nodep&#x3D;root-&gt;rnode,即图中A节点；slotp&#x3D;&amp;root-&gt;rnode-&gt;slots[63]，即A节点的slots[63]的地址</li>
</ul>
<img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-003fd8d09948205b03761f50c3b73fed_720w.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;">

<p>考虑场景2：__radix_tree_create函数执行前，radix tree 已经有两层内部节点，如下左图。 参数index &#x3D; 64， order &#x3D; 0</p>
<ul>
<li>调用radix_tree_load_root函数前，max &#x3D; 64</li>
<li>调用radix_tree_load_root函数后，child &#x3D;B节点，maxindex &#x3D; 64*64-1, shift &#x3D; 12</li>
<li>max &gt; maxindex 条件不满足</li>
<li>开始执行while循环， shift&#x3D;12</li>
<li>shift递减后，shift&#x3D; 6，由于child！&#x3D;NULL，需要往树叶方向下降一级。node &#x3D; B，调用radix_tree_descend后, offset&#x3D;1，child &#x3D;NULL, slot &#x3D; &amp;root-&gt;rnode-&gt;slots[1]</li>
<li>再次循环，shift递减后，shift&#x3D; 0， 由于child&#x3D;&#x3D;NULL， 分配内部节点C, C-&gt;shift &#x3D; 0, C-&gt;offset&#x3D; 1, C-&gt;parent &#x3D; B, B-&gt;slot[1] &#x3D; C</li>
<li>往树叶方向下降一级。node &#x3D; C，调用radix_tree_descend后, offset&#x3D;0，child &#x3D;NULL, slot &#x3D; &amp;C-&gt;-&gt;slots[0]</li>
</ul>
<img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-31c0362e3f9dac199b884733f6086d42_r.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;">

<p><strong>__radix_tree_insert</strong></p>
<p>函数__radix_tree_insert的参数：</p>
<ul>
<li>root：输入参数，标识radix tree的root</li>
<li>index：输入参数，待查找节点的index</li>
<li>order， 这是在CONFIG_RADIX_TREE_MULTIORDER使能时才使用的参数，正常情况下order &#x3D; 0</li>
<li>item：与index关联的指针，需要插入到radix tree的合适位置</li>
</ul>
<p>有了前文的各种铺垫，__radix_tree_insert函数就很简单了，__radix_tree_create函数之后，node指向了待插入指针item的父节点，slot是item插入位置的slot的地址。调用rcu_assign_pointer(<em>slot, item)操作相当于</em>slot &#x3D; item。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *	__radix_tree_insert    -    insert into a radix tree</span><br><span class="hljs-comment"> *	@root:		radix tree root</span><br><span class="hljs-comment"> *	@index:		index key</span><br><span class="hljs-comment"> *	@order:		key covers the 2^order indices around index</span><br><span class="hljs-comment"> *	@item:		item to insert</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *	Insert an item into the radix tree at position @index.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> __radix_tree_insert(<span class="hljs-keyword">struct</span> radix_tree_root *root, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> index,<br>			<span class="hljs-type">unsigned</span> order, <span class="hljs-type">void</span> *item)<br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">node</span>;</span><br>	<span class="hljs-type">void</span> **slot;<br>	<span class="hljs-type">int</span> error;<br><br>	BUG_ON(radix_tree_is_internal_node(item));<br><br>         <span class="hljs-comment">/* 调用__radix_tree_create函数，用来获取item插入的位置。函数返回后，slot变量保存着item插入位置的地址  */</span><br>	error = __radix_tree_create(root, index, order, &amp;node, &amp;slot);<br>	<span class="hljs-keyword">if</span> (error)<br>		<span class="hljs-keyword">return</span> error;<br>	<span class="hljs-keyword">if</span> (*slot != <span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span> -EEXIST;<br><br>         <span class="hljs-comment">/* 将item填写到待插入位置 */</span><br>	rcu_assign_pointer(*slot, item);<br><br>	<span class="hljs-keyword">if</span> (node) &#123;<br>		<span class="hljs-type">unsigned</span> offset = get_slot_offset(node, slot);<br>		node-&gt;count++;<span class="hljs-comment">/* node为item所关联的父节点， item插入后node的子节点个数递增 */</span><br>		BUG_ON(tag_get(node, <span class="hljs-number">0</span>, offset));<br>		BUG_ON(tag_get(node, <span class="hljs-number">1</span>, offset));<br>		BUG_ON(tag_get(node, <span class="hljs-number">2</span>, offset));<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		BUG_ON(root_tags_get(root));<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>EXPORT_SYMBOL(__radix_tree_insert);<br></code></pre></td></tr></table></figure>

<img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-818b4dcba36f5ef364e719b08840c665_r.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;">

<ul>
<li>上左图是radix tree的初始形态：树高两层，最大能容纳的index为64*64-1。</li>
<li>调用__radix_tree_create函数， 函数参数index&#x3D;64， order&#x3D;0；index为64二进制表示为0000 0000-0100 0000，按照没6bit为一个簇来表示，则变成 000001-000000， 所以idnex64在radix tree在第一层中的offset是1， 第二层中的offset是0。 __radix_tree_create函数指向后，radix tree变成了上中图的形态，即在第二层添加了一个中间节点C，C关联到B节点的offset&#x3D;1的slot上。C节点的offset为0的slot位置是index 64要插入的位置。</li>
<li>将index 64 的item插入后，变成了上右图的形状。C节点的offset为0的slot位置上插入了item64。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Linux内核数据结构之Radix Tree</div>
      <div>http://example.com/2023/11/20/Linux内核数据结构之Radix-Tree/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>OneAmx</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/" title="f2fs文件系统文件查找">
                        <span class="hidden-mobile">f2fs文件系统文件查找</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>
  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>

  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
  <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
  <script type="text/javascript" src="/js/fireworks.js"></script>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":250,"height":500},"mobile":{"show":true}});</script></body>
</html>
