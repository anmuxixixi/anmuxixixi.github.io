

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="OneAmx">
  <meta name="keywords" content="">
  
    <meta name="description" content="安卓Watchdog机制以及问题分析转载链接：http:&#x2F;&#x2F;duanqz.github.io&#x2F;2015-10-12-Watchdog-Analysis#section-1 1.概览Watchdog的中文的“看门狗”，有保护的意思。最早引入Watchdog是在单片机系统中，由于单片机的工作环境容易受到外界磁场的干扰，导致程序“跑飞”，造成整个系统无法正常工作，因此，引入了一个“看门狗”，对单片机的运">
<meta property="og:type" content="article">
<meta property="og:title" content="安卓Watchdog机制以及问题分析">
<meta property="og:url" content="http://example.com/2023/08/10/%E5%AE%89%E5%8D%93Watchdog%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="喝口白桃呜龙">
<meta property="og:description" content="安卓Watchdog机制以及问题分析转载链接：http:&#x2F;&#x2F;duanqz.github.io&#x2F;2015-10-12-Watchdog-Analysis#section-1 1.概览Watchdog的中文的“看门狗”，有保护的意思。最早引入Watchdog是在单片机系统中，由于单片机的工作环境容易受到外界磁场的干扰，导致程序“跑飞”，造成整个系统无法正常工作，因此，引入了一个“看门狗”，对单片机的运">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-10T11:54:27.000Z">
<meta property="article:modified_time" content="2023-08-10T13:00:42.622Z">
<meta property="article:author" content="OneAmx">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>安卓Watchdog机制以及问题分析 - 喝口白桃呜龙</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/mouse.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>喝口白桃呜龙</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="安卓Watchdog机制以及问题分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-10 19:54" pubdate>
          2023年8月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          160 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          浏览 <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">安卓Watchdog机制以及问题分析</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="安卓Watchdog机制以及问题分析"><a href="#安卓Watchdog机制以及问题分析" class="headerlink" title="安卓Watchdog机制以及问题分析"></a>安卓Watchdog机制以及问题分析</h1><p><strong>转载链接：<a target="_blank" rel="noopener" href="http://duanqz.github.io/2015-10-12-Watchdog-Analysis#section-1">http://duanqz.github.io/2015-10-12-Watchdog-Analysis#section-1</a></strong></p>
<h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h2><p><code>Watchdog</code>的中文的“看门狗”，有保护的意思。最早引入Watchdog是在单片机系统中，由于单片机的工作环境容易受到外界磁场的干扰，导致程序“跑飞”，造成整个系统无法正常工作，因此，引入了一个“看门狗”，对单片机的运行状态进行实时监测，针对运行故障做一些保护处理，譬如让系统重启。这种Watchdog属于硬件层面，必须有硬件电路的支持。</p>
<p>Linux也引入了Watchdog，在Linux内核下，当Watchdog启动后，便设定了一个定时器，如果在超时时间内没有对&#x2F;dev&#x2F;Watchdog进行写操作，则会导致系统重启。通过定时器实现的Watchdog属于软件层面。</p>
<p>Android设计了一个软件层面Watchdog，用于保护一些重要的系统服务，当出现故障时，通常会让Android系统重启。由于这种机制的存在，就经常会出现一些system_server进程被Watchdog杀掉而发生手机重启的问题。</p>
<p>本文期望回答以下问题：</p>
<blockquote>
<ol>
<li>Watchdog是怎么工作的？这涉及到Watchdog的工作机制。</li>
<li>遇到Watchdog的问题该怎么办？这涉及到分析Watchdog问题的惯用方法。</li>
</ol>
</blockquote>
<h2 id="2-Watchdog机制"><a href="#2-Watchdog机制" class="headerlink" title="2.Watchdog机制"></a>2.Watchdog机制</h2><p>我们以<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/Watchdog.java">frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;Watchdog.java</a>为蓝本，分析Watchdog的实现逻辑。为了描述方便，ActivityManagerService， PackageManagerService， WindowManagerService会分别简称为AMS, PKMS, WMS。</p>
<h3 id="2-1-Watchdog的初始化"><a href="#2-1-Watchdog的初始化" class="headerlink" title="2.1 Watchdog的初始化"></a>2.1 Watchdog的初始化</h3><p>Android的Watchdog是一个单例线程，在System Server时就会初始化Watchdog。Watchdog在初始化时，会构建很多<strong>HandlerChecker</strong>，大致可以分为两类：</p>
<ul>
<li><strong>Monitor Checker</strong>，用于检查是Monitor对象可能发生的死锁, AMS, PKMS, WMS等核心的系统服务都是Monitor对象。</li>
<li><strong>Looper Checker</strong>，用于检查线程的消息队列是否长时间处于工作状态。Watchdog自身的消息队列，Ui, Io, Display这些全局的消息队列都是被检查的对象。此外，一些重要的线程的消息队列，也会加入到<strong>Looper Checker</strong>中，譬如AMS, PKMS，这些是在对应的对象初始化时加入的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">Watchdog</span><span class="hljs-params">()</span> &#123;<br>    ....<br>    mMonitorChecker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(FgThread.getHandler(),<br>                <span class="hljs-string">&quot;foreground thread&quot;</span>, DEFAULT_TIMEOUT);<br>    mHandlerCheckers.add(mMonitorChecker);<br>    mHandlerCheckers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper()),<br>                <span class="hljs-string">&quot;main thread&quot;</span>, DEFAULT_TIMEOUT));<br>    mHandlerCheckers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(UiThread.getHandler(),<br>                <span class="hljs-string">&quot;ui thread&quot;</span>, DEFAULT_TIMEOUT));<br>    mHandlerCheckers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(IoThread.getHandler(),<br>                <span class="hljs-string">&quot;i/o thread&quot;</span>, DEFAULT_TIMEOUT));<br>    mHandlerCheckers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(DisplayThread.getHandler(),<br>                <span class="hljs-string">&quot;display thread&quot;</span>, DEFAULT_TIMEOUT));<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>两类<strong>HandlerChecker</strong>的侧重点不同，<strong>Monitor Checker</strong>预警我们不能长时间持有核心系统服务的对象锁，否则会阻塞很多函数的运行; <strong>Looper Checker</strong>预警我们不能长时间的霸占消息队列，否则其他消息将得不到处理。这两类都会导致系统卡住(System Not Responding)。</p>
<h3 id="2-2-添加Watchdog检测对象"><a href="#2-2-添加Watchdog检测对象" class="headerlink" title="2.2 添加Watchdog检测对象"></a>2.2 添加Watchdog检测对象</h3><p>Watchdog初始化以后，就可以作为system_server进程中的一个单独的线程运行了。但这个时候，还不能触发Watchdog的运行，因为AMS, PKMS等系统服务还没有加入到Watchdog的监测集。 所谓监测集，就是需要Watchdog关注的对象，Android中有成千上万的消息队列在同时运行，然而，Watchdog毕竟是系统层面的东西，它只会关注一些核心的系统服务。</p>
<p>Watchdog提供两个方法，分别用于添加<strong>Monitor Checker</strong>对象和<strong>Looper Checker</strong>对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMonitor</span><span class="hljs-params">(Monitor monitor)</span> &#123;<br>    <span class="hljs-comment">// 将monitor对象添加到Monitor Checker中，</span><br>    <span class="hljs-comment">// 在Watchdog初始化时，可以看到Monitor Checker本身也是一个HandlerChecker对象</span><br>    mMonitors.add(monitor);<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addThread</span><span class="hljs-params">(Handler thread, <span class="hljs-type">long</span> timeoutMillis)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (isAlive()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Threads can&#x27;t be added once the Watchdog is running&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> thread.getLooper().getThread().getName();<br>        <span class="hljs-comment">// 为Handler构建一个HandlerChecker对象，其实就是**Looper Checker**</span><br>        mHandlerCheckers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(thread, name, timeoutMillis));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>被Watchdog监测的对象，都需要将自己添加到Watchdog的监测集中。以下是AMS的类定义和构造器的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ActivityManagerNative</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watchdog</span>.Monitor, BatteryStatsImpl.BatteryCallback &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ActivityManagerService</span><span class="hljs-params">(Context systemContext)</span> &#123;<br>        ...<br>        Watchdog.getInstance().addMonitor(<span class="hljs-built_in">this</span>);<br>        Watchdog.getInstance().addThread(mHandler);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>AMS实现了Watchdog.Monitor接口，这个接口只有一个方法，就是monitor()，它的作用后文会再解释。这里可以看到在AMS的构造器中，将自己添加到Monitor Checker对象中，然后将自己的handler添加到Looper Checker对象中。 其他重要的系统服务添加到Watchdog的代码逻辑都与AMS差不多。</p>
<p>整个Android系统中，被monitor的对象并不多，十个手指头就能数出来Watchdog.Monitor的实现类的个数。</p>
<h3 id="2-3-Watchdog的监测机制"><a href="#2-3-Watchdog的监测机制" class="headerlink" title="2.3 Watchdog的监测机制"></a>2.3 Watchdog的监测机制</h3><p>Watchdog本身是一个线程，它的run()方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">waitedHalf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            ...<br>            <span class="hljs-comment">// 1. 调度所有的HandlerChecker</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;mHandlerCheckers.size(); i++) &#123;<br>                <span class="hljs-type">HandlerChecker</span> <span class="hljs-variable">hc</span> <span class="hljs-operator">=</span> mHandlerCheckers.get(i);<br>                hc.scheduleCheckLocked();<br>            &#125;<br>            ...<br>            <span class="hljs-comment">// 2. 开始定期检查</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-keyword">while</span> (timeout &gt; <span class="hljs-number">0</span>) &#123;<br>                ...<br>                <span class="hljs-keyword">try</span> &#123;<br>                    wait(timeout);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Log.wtf(TAG, e);<br>                &#125;<br>                ...<br>                timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);<br>            &#125;<br> <br>            <span class="hljs-comment">// 3. 检查HandlerChecker的完成状态</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">waitState</span> <span class="hljs-operator">=</span> evaluateCheckerCompletionLocked();<br>            <span class="hljs-keyword">if</span> (waitState == COMPLETED) &#123;<br>                ...<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitState == WAITING) &#123;<br>                ...<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitState == WAITED_HALF) &#123;<br>                ...<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br> <br>            <span class="hljs-comment">// 4. 存在超时的HandlerChecker</span><br>            blockedCheckers = getBlockedCheckersLocked();<br>            subject = describeCheckersLocked(blockedCheckers);<br>            allowRestart = mAllowRestart;<br>        &#125;<br>        ...<br>        <span class="hljs-comment">// 5. 保存日志，判断是否需要杀掉系统进程</span><br>        Slog.w(TAG, <span class="hljs-string">&quot;*** GOODBYE!&quot;</span>);<br>        Process.killProcess(Process.myPid());<br>        System.exit(<span class="hljs-number">10</span>);<br>    &#125; <span class="hljs-comment">// end of while (true)</span><br> <br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码片段主要的运行逻辑如下：</p>
<ol>
<li>Watchdog运行后，便开始无限循环，依次调用每一个HandlerChecker的scheduleCheckLocked()方法</li>
<li>调度完HandlerChecker之后，便开始定期检查是否超时，每一次检查的间隔时间由<strong>CHECK_INTERVAL</strong>常量设定，为30秒</li>
<li>每一次检查都会调用evaluateCheckerCompletionLocked()方法来评估一下HandlerChecker的完成状态：<ul>
<li>COMPLETED表示已经完成</li>
<li>WAITING和WAITED_HALF表示还在等待，但未超时</li>
<li>OVERDUE表示已经超时。默认情况下，timeout是1分钟，但监测对象可以通过传参自行设定，譬如PKMS的<strong>Handler Checker</strong>的超时是10分钟</li>
</ul>
</li>
<li>如果超时时间到了，还有HandlerChecker处于未完成的状态(OVERDUE)，则通过getBlockedCheckersLocked()方法，获取阻塞的HandlerChecker，生成一些描述信息</li>
<li>保存日志，包括一些运行时的堆栈信息，这些日志是我们解决Watchdog问题的重要依据。如果判断需要杀掉system_server进程，则给当前进程(system_server)发送signal 9</li>
</ol>
<p>只要Watchdog没有发现超时的任务，HandlerChecker就会被不停的调度，那HandlerChecker具体做一些什么检查呢？ 直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChecker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleCheckLocked</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Looper Checker中是不包含monitor对象的，判断消息队列是否处于空闲</span><br>        <span class="hljs-keyword">if</span> (mMonitors.size() == <span class="hljs-number">0</span> &amp;&amp; mHandler.getLooper().isIdling()) &#123;<br>            mCompleted = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ...<br>        <span class="hljs-comment">// 将Monitor Checker的对象置于消息队列之前，优先运行</span><br>        mHandler.postAtFrontOfQueue(<span class="hljs-built_in">this</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 依次调用Monitor对象的monitor()方法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; size ; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Watchdog.<span class="hljs-built_in">this</span>) &#123;<br>                mCurrentMonitor = mMonitors.get(i);<br>            &#125;<br>            mCurrentMonitor.monitor();<br>        &#125;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>对于<strong>Looper Checker</strong>而言，会判断线程的消息队列是否处于空闲状态。 如果被监测的消息队列一直闲不下来，则说明可能已经阻塞等待了很长时间</li>
<li>对于<strong>Monitor Checker</strong>而言，会调用实现类的monitor方法，譬如上文中提到的AMS.monitor()方法， 方法实现一般很简单，就是获取当前类的对象锁，如果当前对象锁已经被持有，则monitor()会一直处于wait状态，直到超时，这种情况下，很可能是线程发生了死锁</li>
</ul>
<p><strong>至此，我们已经分析了Watchdog的工作机制，回答了我们提出的第一个问题：</strong></p>
<p><strong>Watchdog定时检查一些重要的系统服务，举报长时间阻塞的事件，甚至杀掉system_server进程，让Android系统重启。</strong></p>
<h2 id="3-问题分析方法"><a href="#3-问题分析方法" class="headerlink" title="3.问题分析方法"></a>3.问题分析方法</h2><h3 id="3-1-日志获取"><a href="#3-1-日志获取" class="headerlink" title="3.1 日志获取"></a>3.1 日志获取</h3><p>Andriod的日志门类繁多，而且，为了调试的需要，设备厂商和应用开发者都会在AOSP的基础上增加很多日志。 面对如此庞大复杂的日志系统，通常只有对应领域的专家才能看懂其透露的细节信息，就像去医院就诊，医生一看检查报告就知道患者身体出了什么问题，而外行对这些诊断信息往往是束手无策的。</p>
<p>解决Watchdog相关的问题，对日志的要求比较高，有些问题与当时的系统环境相关，仅仅凭借单一的日志并不能定位问题。 以下罗列出获取Android日志的一些重要手段，部分场景下，Watchdog相关的问题甚至需要以下所有的日志：</p>
<ul>
<li><strong>logcat</strong> 通过<code>adb logcat</code>命令输出Android的一些当前运行日志，可以通过logcat的 <strong>-b</strong> 参数指定要输出的日志缓冲区，缓冲区对应着logcat的一种日志类型。 高版本的logcat可以使用 <strong>-b all</strong> 获取到所有缓冲区的日志<ul>
<li>event 通过android.util.EventLog工具类打印的日志，一些重要的系统事件会使用此类日志</li>
<li>main 通过android.util.Log工具类打印的日志，应用程序，尤其是基于SDK的应用程序，会使用此类日志</li>
<li>system 通过android.util.Slog工具类打印的日志，系统相关的日志一般都是使用此类日志，譬如SystemServer</li>
<li>radio 通过android.util.Rlog工具类打印的日志，通信模块相关的日志一般都是使用此类日志，譬如RIL</li>
</ul>
</li>
<li><strong>dumpsys</strong> 通过<code>adb dumpsys</code>命令输出一些重要的系统服务信息，譬如内存、电源、磁盘等， 工作原理可以查阅<a target="_blank" rel="noopener" href="http://duanqz.github.io/2015-07-19-Intro-to-dumpsys">dumpsys介绍</a>一文</li>
<li><strong>traces</strong> 该文件记录了一个时间段的函数调用栈信息，通常在应用发生ANR(Application Not Responding)时，会触发打印各进程的函数调用栈。 站在Linux的角度，其实就是向进程发送SIGNAL_QUIT(3)请求，譬如，我们可以通过<code>adb shell kill -3 &lt;pid&gt;</code>命令，打印指定进程的的trace。 SIGNAL_QUIT(3)表面意思有一点误导，它其实并不会导致进程退出。输出一般在 <em>&#x2F;data&#x2F;anr&#x2F;traces.txt</em> 文件中，当然，这是可以灵活配置的， Android提供的系统属性dalvik.vm.stack-trace-file可以用来配置生成traces文件的位置。</li>
<li><strong>binder</strong> 通过Binder跨进程调用的日志，可以通过<code>adb shell cat</code>命令从 &#x2F;proc&#x2F;binder 下取出对应的日志<ul>
<li>failed_transaction_log</li>
<li>transaction_log</li>
<li>transactions</li>
<li>stats</li>
</ul>
</li>
<li><strong>dropbox</strong> 为了记录历史的logcat日志，Android引入了Dropbox，将历史日志持久化到磁盘中(<strong>&#x2F;data&#x2F;system&#x2F;dropbox</strong>)。 logcat的缓冲区大小毕竟是有限的，所以需要循环利用，这样历史的日志信息就会被冲掉。在一些自动化测试的场景下，譬如Monkey需要长时间的运行， 就需要把历史的日志全都保存下来。</li>
<li><strong>tombstone</strong> tombstone错误一般由Dalvik错误、native层的代码问题导致的。当系统发生tombstone时，内核会上报一个严重的警告信号， 上层收到后，把当前的调用栈信息持久化到磁盘中(<strong>&#x2F;data&#x2F;tombstone</strong>)</li>
<li><strong>bugreport</strong> 通过<code>adb bugreport</code>命令输出，日志内容多到爆，logcat, traces, dmesg, dumpsys, binder的日志都包含在其中。 由于输出bugreport的时间很长，当系统发生错误时，我们再执行bugreport往往就来不及了(此时，系统可能都已经重启了)，所以，要动用bugreport就需要结合一些其他机制， 譬如在杀掉system_server进程之前，先让bugreport运行完</li>
</ul>
<h3 id="3-2-问题定位"><a href="#3-2-问题定位" class="headerlink" title="3.2 问题定位"></a>3.2 问题定位</h3><p>Watchdog出现的日志很明显，logcat中的event, system中都会有体现，要定位问题，可以从检索日志中的watchdog关键字开始。</p>
<p>发生Watchdog检测超时这么重要的系统事件，Android会打印一个EventLog：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">watchdog: Blocked <span class="hljs-keyword">in</span> handler XXX    <span class="hljs-comment"># 表示HandlerChecker超时了</span><br>watchdog: Blocked <span class="hljs-keyword">in</span> monitor XXX    <span class="hljs-comment"># 表示MonitorChecker超时了</span><br></code></pre></td></tr></table></figure>

<p>Watchdog是运行在system_server进程中，会打印一些System类型的日志。在手机处于非调试状态时，伴随Watchdog出现的往往是system_server进程被杀，从而系统重启。 当Watchdog要主动杀掉system_server进程时，以下关键字就会出现在SystemLog中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: XXX<br>Watchdog: XXX<br>Watchdog: <span class="hljs-string">&quot;*** GOODBYE!</span><br></code></pre></td></tr></table></figure>

<p>当我们在日志中检索到上述两类关键信息时，说明“Watchdog显灵”了，从另一个角度来理解，就是“System Not Responding”了。 接下来，我们需要进一步定位在watchdog出现之前，system_server进程在干什么，处于一个什么状态。 这与排除”Application Not Responding“问题差不多，我们需要进程的traces信息、当前系统的CPU运行信息、IO信息。</p>
<p>找到Watchddog出现之前的traces.txt文件，这个时间差最好不要太大，因为Watchdog默认的超时时间是1分钟，太久以前的traces并不能说明问题。 诱导Watchdong出现的直接原因其实就是system_server中某个线程被阻塞了，这个信息在event和system的log中清晰可见。 我们以一个systemLog为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked <span class="hljs-keyword">in</span> monitor com.android.server.wm.WindowManagerService on foreground thread (android.fg)<br></code></pre></td></tr></table></figure>

<p>Watchdog告诉我们<strong>Monitor Checker</strong>超时了，具体在哪呢？ 名为<strong>android.fg</strong>的线程在WindowManagerService的monitor()方法被阻塞了。这里隐含了两层意思：</p>
<ol>
<li>WindowManagerService实现了Watchdog.Monitor这个接口，并将自己作为<strong>Monitor Checker</strong>的对象加入到了Watchdog的监测集中</li>
<li>monitor()方法是运行在<strong>android.fg</strong>线程中的。Android将<strong>android.fg</strong>设计为一个全局共享的线程，意味着它的消息队列可以被其他线程共享， Watchdog的<strong>Monitor Checker</strong>就是使用的<strong>android.fg</strong>线程的消息队列。因此，出现<strong>Monitor Checker</strong>的超时，肯定是<strong>android.fg</strong>线程阻塞在monitor()方法上。</li>
</ol>
<p>我们打开system_server进程的traces，检索 <strong>android.fg</strong> 可以快速定位到该线程的函数调用栈：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;android.fg&quot;</span> prio=5 tid=25 Blocked<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=1 dsCount=0 obj=0x12eef900 self=0x7f7a8b1000<br>  | sysTid=973 <span class="hljs-built_in">nice</span>=0 cgrp=default <span class="hljs-built_in">sched</span>=0/0 handle=0x7f644e9000<br>  | state=S schedstat=( 3181688530 2206454929 8991 ) utm=251 stm=67 core=1 HZ=100<br>  | stack=0x7f643e7000-0x7f643e9000 stackSize=1036KB<br>  | held mutexes=<br>  at com.android.server.wm.WindowManagerService.monitor(WindowManagerService.java:13125)<br>  - waiting to lock &lt;0x126dccb8&gt; (a java.util.HashMap) held by thread 91<br>  at com.android.server.Watchdog<span class="hljs-variable">$HandlerChecker</span>.run(Watchdog.java:204)<br>  at android.os.Handler.handleCallback(Handler.java:815)<br>  at android.os.Handler.dispatchMessage(Handler.java:104)<br>  at android.os.Looper.loop(Looper.java:194)<br>  at android.os.HandlerThread.run(HandlerThread.java:61)<br>  at com.android.server.ServiceThread.run(ServiceThread.java:46)<br></code></pre></td></tr></table></figure>

<p><strong>android.fg</strong>线程调用栈告诉我们几个关键的信息：</p>
<ul>
<li>这个线程当前的状态是<strong>Blocked</strong>，阻塞</li>
<li>由Watchdog发起调用monitor()，这是一个Watchdog检查，阻塞已经超时</li>
<li>**waiting to lock &lt;0x126dccb8&gt;**： 阻塞的原因是monitor()方法中在等锁&lt;0x126dccb8&gt;</li>
<li><strong>held by thread 91</strong>： 这个锁被编号为91的线程持有，需要进一步观察91号线程的状态。</li>
</ul>
<blockquote>
<p>题外话：每一个进程都会对自己所辖的线程编号，从1开始。1号线程通常就是我们所说的主线程。 线程在Linux系统中还有一个全局的编号，由sysTid表示。我们在logcat等日志中看到的一般是线程的全局编号。 譬如，本例中android.fg线程在system_server进程中的编号是25，系统全局编号是973。</p>
</blockquote>
<p>可以在traces.txt文件中检索 tid&#x3D;91 来快速找到91号线程的函数调用栈信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;Binder_C&quot;</span> prio=5 tid=91 Native<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=1 dsCount=0 obj=0x12e540a0 self=0x7f63289000<br>  | sysTid=1736 <span class="hljs-built_in">nice</span>=0 cgrp=default <span class="hljs-built_in">sched</span>=0/0 handle=0x7f6127c000<br>  | state=S schedstat=( 96931835222 49673449591 260122 ) utm=7046 stm=2647 core=2 HZ=100<br>  | stack=0x7f5ffbc000-0x7f5ffbe000 stackSize=1008KB<br>  | held mutexes=<br>  at libcore.io.Posix.writeBytes(Native method)<br>  at libcore.io.Posix.write(Posix.java:258)<br>  at libcore.io.BlockGuardOs.write(BlockGuardOs.java:313)<br>  at libcore.io.IoBridge.write(IoBridge.java:537)<br>  at java.io.FileOutputStream.write(FileOutputStream.java:186)<br>  at com.android.internal.util.FastPrintWriter.flushBytesLocked(FastPrintWriter.java:334)<br>  at com.android.internal.util.FastPrintWriter.flushLocked(FastPrintWriter.java:355)<br>  at com.android.internal.util.FastPrintWriter.appendLocked(FastPrintWriter.java:303)<br>  at com.android.internal.util.FastPrintWriter.<span class="hljs-built_in">print</span>(FastPrintWriter.java:466)<br>  - locked &lt;@addr=0x134c4910&gt; (a com.android.internal.util.FastPrintWriter<span class="hljs-variable">$DummyWriter</span>)<br>  at com.android.server.wm.WindowState.dump(WindowState.java:1510)<br>  at com.android.server.wm.WindowManagerService.dumpWindowsNoHeaderLocked(WindowManagerService.java:12279)<br>  at com.android.server.wm.WindowManagerService.dumpWindowsLocked(WindowManagerService.java:12266)<br>  at com.android.server.wm.WindowManagerService.dump(WindowManagerService.java:12654)<br>  - locked &lt;0x126dccb8&gt; (a java.util.HashMap)<br>  at android.os.Binder.dump(Binder.java:324)<br>  at android.os.Binder.onTransact(Binder.java:290)<br></code></pre></td></tr></table></figure>

<p>91号线程的名字是<strong>Binder_C</strong>，它的函数调用栈告诉我们几个关键信息：</p>
<ul>
<li>Native，表示线程处于运行状态(RUNNING)，并且正在执行JNI方法</li>
<li>在WindowManagerService.dump()方法申请了锁&lt;0x126dccb8&gt;，这个锁正是<strong>android.fg</strong>线程所等待的</li>
<li>FileOutputStream.write()表示<strong>Binder_C</strong>线程在执行IO写操作，正式因为这个写操作一直在阻塞，导致线程持有的锁不能释放</li>
</ul>
<blockquote>
<p>题外话：关于Binder线程。当Android进程启动时，就会创建一个线程池，专门处理Binder事务。线程池中会根据当前的binder线程计数器的值来构造新创建的binder线程, 线程名”Binder_%X”，X是十六进制。当然，线程池的线程数也有上限，默认情况下为16，所以，可以看到 Binder_1 ~ Binder_F 这样的线程命名。</p>
</blockquote>
<p>聪明的你看到这或许已经能够想到解决办法了，在这个IO写操作上加一个超时机制，并且这个超时小于Watchdog的超时，不就可以让线程释放它所占有的锁了吗？ 是的，这确实可以作为一个临时解决方案(Workaround)，或者说一个保护机制。但我们可以再往深处想一想，这个IO写操作为什么会阻塞：</p>
<ul>
<li>是不是IO缓冲区满了，导致写阻塞呢？</li>
<li>是不是写操作有什么锁，导致这个write方法在等锁呢？</li>
<li>是不是当前系统的IO负载过于高，导致写操作效率很低呢？</li>
</ul>
<p>这都需要我们再进一步从日志中去找原因。如果已有的日志不全，找不到论据，我们还需要设计场景来验证假设，解决问题的难度陡然上升。</p>
<h3 id="3-3-场景还原"><a href="#3-3-场景还原" class="headerlink" title="3.3 场景还原"></a>3.3 场景还原</h3><p>我们经历了两个关键步骤：</p>
<ol>
<li>通过event或system类型的日志，发现了Watchdog杀掉system_server导致系统重启</li>
<li>通过traces日志，发了导致Watchdog出现的具体线程操作</li>
</ol>
<p>这两个过程基本就涵盖了Watchdog的运行机制了，但这并没有解决问题啊。我们需要找到线程阻塞的原因是什么，然而，线程阻塞的原因就千奇百怪了。 如果有问题出现的现场，并且问题可以重现，那么我们可以通过调试的手段来分析问题产生的原因。 如果问题只是偶然出现，甚至只有一堆日志，我们就需要从日志中来还原问题出现的场景，这一步才是真正考验大家Android&#x2F;Linux功底的地方。</p>
<p>继续以上述问题为例，我们来进一步还原问题出现的场景，从Java层的函数调用栈来看：</p>
<ul>
<li>首先，跨进程发起了Binder.dump()方法的调用：at android.os.Binder.dump(Binder.java:324)</li>
<li>然后，进入了WMS的dump()：at com.android.server.wm.WindowManagerService.dump(WindowManagerService.java:12654)</li>
<li>接着，发生了写文件操作：at java.io.FileOutputStream.write(FileOutputStream.java:186)</li>
<li>最后，调用了JNI方法：at libcore.io.Posix.writeBytes(Native method)</li>
</ul>
<p><strong>Binder_C</strong>线程要出现这种函数调用栈，我们可以初步确定是Android接受了如下命令 (dumpsys原理请查阅<a target="_blank" rel="noopener" href="http://duanqz.github.io/2015-07-19-Intro-to-dumpsys">dumpsys介绍</a>一文)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ adb shell dumpsys window<br></code></pre></td></tr></table></figure>

<p>当通过命令行运行以上命令时，客户端(PC)的adb server会向服务端(手机)的adbd发送指令， adbd进程会fork出一个叫做dumpsys的子进程，dumpsys进程再利用Binder机制和system_server通信 (adb的实现原理可以查阅<a target="_blank" rel="noopener" href="http://duanqz.github.io/2015-05-21-Intro-adb">adb介绍</a>一文)。</p>
<p>仅凭这个还是分析不出问题所在，我们需要启用内核的日志了。当调用JNI方法libcore.io.Posix.writeBytes()时，会触发系统调用， Linux会从用户态切换到内核态，内核的函数调用栈也可以从traces中找到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">kernel: __switch_to+0x74/0x8c<br>kernel: pipe_wait+0x60/0x9c<br>kernel: pipe_write+0x278/0x5cc<br>kernel: do_sync_write+0x90/0xcc<br>kernel: vfs_write+0xa4/0x194<br>kernel: SyS_write+0x40/0x8c<br>kernel: cpu_switch_to+0x48/0x4c<br></code></pre></td></tr></table></figure>

<p>在Java层，明确指明要写文件(FileOutputStream)，正常情况下，系统调用write()就完事了，但Kernel却打开了一个管道，最终阻塞在了pipe_wait()方法。 什么场景下会打开一个管道，而且管道会阻塞呢？一系列的猜想和验证过程接踵而至。</p>
<p>这里有必要先补充一些基础知识了：</p>
<ul>
<li><p><strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/biyeymyhjob/archive/2012/11/03/2751593.html">Linux进程间通信之管道(pipe)</a></strong></p>
<p>Linux的管道实现借助了文件系统的file结构和VFS(Virtual File System)，通过将两个file结构指向同一个临时的VFS索引节点，而这个VFS索引节点又指向一个物理页面时， 实际上就建立了一个管道。</p>
<p>这就解释了为什么发起系统调用write的时候，打开了一个管道。因为dumpsys和system_server进程，将自己的file结构指向了同一个VFS索引节点。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="http://blog.csdn.net/sj13051180/article/details/47865803">管道挂起的案例</a></strong></p>
<p>管道是一个生产者-消费者模型，当缓冲区满时，则生产者不能往管道中再写数据了，需等到消费者读数据。如果消费者来不及处理缓冲区的数据，或者锁定缓冲区，则生产者就挂起了。</p>
<p>结合到例子中的场景，system_server进程无法往管道中写数据，很可能是dumpsys进程一直忙碌来不及处理新的数据。</p>
</li>
</ul>
<p>接下来，需要再从日志中寻找dumpsys进程的运行状态了：</p>
<ul>
<li>是不是dumpsys进程的负载太高？</li>
<li>是不是dumpsys进程死掉了，导致一直没有处理缓冲区数据？</li>
<li>是不是dumpsys进程有死锁？</li>
</ul>
<p>接下来的分析过程已经偏离Watchdog机制越来越远了，我们点到为止。</p>
<p>小伙伴们可以看到，场景还原涉及到的知识点非常之宽泛，而且有一定的深度。在没有现场的情况下，伴随一系列的假设和验证过程，充满了不确定性和发现问题的喜悦。 正所谓，同问题做斗争，其乐无穷！</p>
<p><strong>至此，我们分析Watchdog问题的惯用方法，回答前面提出来的第二个问题：</strong></p>
<p><strong>通过event或system类型的logcat日志，检索Watchdog出现的关键信息；通过traces，分析出导致Watchdog检查超时的直接原因；通过其他日志，还原出问题出现的场景。</strong></p>
<h2 id="4-实例分析"><a href="#4-实例分析" class="headerlink" title="4.实例分析"></a>4.实例分析</h2><p>在上面介绍Watchdog问题分析方法的时候，我们其实已经举了一个例子。通常，比较容易定位导致Watchdog出现的直接原因(Direct Cause)，但很难找到更深层次的原因(Root Cause)。 这个小节，我们再介绍一个实例，来分析Watchdog出现的另一种场景。诚然，仅凭几个例子，远不够涵盖Watchdog的所有问题，我们的章法还是按照一定的方法论来深究问题。</p>
<p>回顾一下解决问题三部曲：</p>
<ol>
<li>日志获取。日志种类繁多，分析Watchdog问题，宁滥毋缺</li>
<li>问题定位。从logcat中锁定watchdog的出现，从traces锁定直接原因</li>
<li>场景还原。结合各类日志，不断假设验证</li>
</ol>
<p><strong>以CPU占用过高的场景为例：<a target="_blank" rel="noopener" href="http://duanqz.github.io/2015-10-12-Watchdog-Analysis">下载该问题的全部日志</a></strong></p>
<p><strong>从sys_log中，检索到了Watchdog的出现关键信息</strong></p>
<blockquote>
<p>TIPS: 在sys_log中搜索关键字”WATCHDOG KILLING SYSTEM PROCESS”</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bas">10-14 17:10:51.548   892  1403 W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked in handler on ActivityManager (ActivityManager)<br></code></pre></td></tr></table></figure>

<p>这是一个Watchdog的<strong>Looper Checker</strong>超时，由于ActivityManager这个线程一直处于忙碌状态，导致Watchdog检查超时。 Watchdog出现的时间是<strong>10-14 17:10:51.548</strong>左右，需要从traces.txt中找到这个时间段的system_server进程的函数调用栈信息， system_server的进程号是892。</p>
<p><strong>从traces.txt中找到对应的函数调用栈</strong></p>
<p>traces.txt包含很多进程在不同时间段的函数调用栈信息，为了检索的方便，首先可以将traces.txt分块。 笔者写了一个<a target="_blank" rel="noopener" href="https://github.com/duanqz">工具</a>，可以从traces.txt文件中分割出指定进程号的函数调用栈信息。</p>
<blockquote>
<p>TIPS: 在system_server的traces中(通过工具分割出的system_server_892_2015-10-14-17:09:06文件)搜索关键字”ActivityManager”</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;ActivityManager&quot;</span> prio=5 tid=17 TimedWaiting<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=1 dsCount=0 obj=0x12c0e6d0 self=0x7f84caf000<br>  | sysTid=938 <span class="hljs-built_in">nice</span>=-2 cgrp=default <span class="hljs-built_in">sched</span>=0/0 handle=0x7f7d887000<br>  | state=S schedstat=( 107864628645 628257779012 60356 ) utm=7799 stm=2987 core=2 HZ=100<br>  | stack=0x7f6e68f000-0x7f6e691000 stackSize=1036KB<br>  | held mutexes=<br>  at java.lang.Object.<span class="hljs-built_in">wait</span>!(Native method)<br>  - waiting on &lt;0x264ff09d&gt; (a com.android.server.am.ActivityManagerService<span class="hljs-variable">$5</span>)<br>  at java.lang.Object.<span class="hljs-built_in">wait</span>(Object.java:422)<br>  at com.android.server.am.ActivityManagerService.dumpStackTraces(ActivityManagerService.java:5395)<br>  at com.android.server.am.ActivityManagerService.dumpStackTraces(ActivityManagerService.java:5282)<br>  at com.android.server.am.ActivityManagerService<span class="hljs-variable">$AnrActivityManagerService</span>.dumpStackTraces(ActivityManagerService.java:22676)<br>  at com.mediatek.anrmanager.ANRManager<span class="hljs-variable">$AnrDumpMgr</span>.dumpAnrDebugInfoLocked(SourceFile:1023)<br>  at com.mediatek.anrmanager.ANRManager<span class="hljs-variable">$AnrDumpMgr</span>.dumpAnrDebugInfo(SourceFile:881)<br>  at com.android.server.am.ActivityManagerService.appNotResponding(ActivityManagerService.java:6122)<br>  - locked &lt;0x21c77912&gt; (a com.mediatek.anrmanager.ANRManager<span class="hljs-variable">$AnrDumpRecord</span>)<br>  at com.android.server.am.BroadcastQueue<span class="hljs-variable">$AppNotResponding</span>.run(BroadcastQueue.java:228)<br>  at android.os.Handler.handleCallback(Handler.java:815)<br>  at android.os.Handler.dispatchMessage(Handler.java:104)<br>  at android.os.Looper.loop(Looper.java:192)<br>  at android.os.HandlerThread.run(HandlerThread.java:61)<br>  at com.android.server.ServiceThread.run(ServiceThread.java:46)<br></code></pre></td></tr></table></figure>

<p>ActivityManager线程实际上运行着AMS的消息队列，这个函数调用栈的关键信息：</p>
<ul>
<li>线程状态为TimedWaiting, 这表示当前线程阻塞在一个超时的wait()方法</li>
<li>正在处理广播消息超时发生的ANR(Application Not Responding)，需要将当前的函数调用栈打印出来</li>
<li>最终在&lt;0x264ff09d&gt;等待，可以从<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActivityManagerService.java#4830">AMS的源码</a> 中找到这一处锁的源码，因为dumpStackTraces()会写文件，所以AMS设计了一个200毫秒的超时锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">observer.wait(<span class="hljs-number">200</span>);  <span class="hljs-comment">// Wait for write-close, give up after 200msec</span><br></code></pre></td></tr></table></figure>

<p><strong>还原问题的场景</strong></p>
<p>从ActivityManager这个线程的调用栈，我们就会有一些疑惑：</p>
<ul>
<li>是哪个应用发生了ANR？为什么会发生ANR？</li>
<li>超时锁只用200毫秒就释放了，为什么会导致Watchdog检查超时？(AMS的Looper默认超时是1分钟)</li>
</ul>
<p>带着这些疑惑，我们再回到日志中：</p>
<p>从sys_log中，可以检索到Watchdog出现的时间点(<strong>17:10:51.548</strong>)之前，com.android.systemui发生了ANR，从而引发AMS打印函数调用栈:</p>
<blockquote>
<p>⭐<strong>TIPS: 在sys_log中检索”ANR in”关键字或在event_log中检索”anr”关键字</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager: ANR in com.android.systemui, time=<span class="hljs-number">27097912</span><br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager: Reason: Broadcast of Intent &#123; act=android.intent.action.TIME_TICK flg=<span class="hljs-number">0x50000114</span> (has extras) &#125;<br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager: Load: <span class="hljs-number">89.22</span> / <span class="hljs-number">288.15</span> / <span class="hljs-number">201.91</span><br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager: Android time :[<span class="hljs-number">2015</span>-<span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.14</span>] [<span class="hljs-number">27280.396</span>]<br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager: CPU usage from 17016ms to 0ms ago:<br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager:   <span class="hljs-number">358</span>% <span class="hljs-number">23682</span>/float_bessel: <span class="hljs-number">358</span>% user + <span class="hljs-number">0</span>% kernel<br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager:   <span class="hljs-number">57</span>% <span class="hljs-number">23604</span>/debuggerd64: <span class="hljs-number">3.8</span>% user + <span class="hljs-number">53</span>% kernel / faults: <span class="hljs-number">11369</span> minor<br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager:   <span class="hljs-number">2</span>% <span class="hljs-number">892</span>/system_server: <span class="hljs-number">0.9</span>% user + <span class="hljs-number">1</span>% kernel / faults: <span class="hljs-number">136</span> minor<br></code></pre></td></tr></table></figure>

<p>从这个日志信息中，我们两个疑惑就释然了：</p>
<p>发生ANR之前的CPU负载远高于正常情况好几倍(Load： 89.22 &#x2F; 288.15 &#x2F; 201.91)，在这种CPU负载下，com.android.systemui进程发生处理广播消息超时(Reason: Broadcast of Intent)再正常不过了。 在这之前CPU都被<strong>float_bessel</strong>这个进程给占了，这货仅凭一己之力就耗了358%的CPU资源。</p>
<p>observer.wait(200)在调用后，便进入排队等待唤醒状态(Waiting)，在等待200毫秒后，便重新开始申请CPU资源，而此时，CPU资源一直被<strong>float_bessel</strong>占着没有释放，所以该线程一直在等CPU资源。 等了1分钟后，Watchdog跳出来说“不行，你已经等了1分钟了，handler处理其他消息了”。</p>
<p>在多核情况下，CPU的使用率统计会累加多个核的使用率，所以会出现超过100%的情况。那么<strong>float_bessel</strong>究竟是什么呢？它是一个Linux的测试样本，贝塞尔函数的计算，耗的就是CPU。</p>
<p>这样，该问题的场景我们就还原出来了：在压力测试的环境下，CPU被<strong>float_bessel</strong>运算占用，导致com.android.systemui进程发生ANR，从而引发AMS打印trace; 但由于AMS一直等不到CPU资源，Watchdog检测超时，杀掉system_server进程，系统重启。</p>
<p>对于压力测试而言，我们一般会设定一个通过标准，在某些压力情况下，出现一些错误是允许的。对于Android实际用户的使用场景而言，本例中的压力通常是不存在的，所以在实际项目中，这种类型的Watchdog问题，我们一般不解决。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>Android中Watchdog用来看护system_server进程，system_server进程运行着系统最终要的服务，譬如AMS、PKMS、WMS等， 当这些服务不能正常运转时，Watchdog可能会杀掉system_server，让系统重启。</p>
<p>Watchdog的实现利用了锁和消息队列机制。当system_server发生死锁或消息队列一直处于忙碌状态时，则认为系统已经没有响应了(System Not Responding)。</p>
<p>在分析Watchdog问题的时候，首先要有详尽的日志，其次要能定位出导致Watchdog超时的直接原因，最重要的是能还原出问题发生的场景。</p>
<blockquote>
<ol>
<li>从logcat中锁定watchdog的出现【WATCHDOG KILLING SYSTEM PROCESS:】</li>
<li>从traces锁定直接原因</li>
</ol>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>安卓Watchdog机制以及问题分析</div>
      <div>http://example.com/2023/08/10/安卓Watchdog机制以及问题分析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>OneAmx</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/08/10/%E3%80%90Android%E3%80%91%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-ANR-%E6%97%A5%E5%BF%97/" title="【Android】如何分析 ANR 日志">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【Android】如何分析 ANR 日志</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/08/fork%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/" title="【实验】fork子进程超时控制">
                        <span class="hidden-mobile">【实验】fork子进程超时控制</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>
  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>

  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
  <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
  <script type="text/javascript" src="/js/fireworks.js"></script>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":250,"height":500},"mobile":{"show":true}});</script></body>
</html>
