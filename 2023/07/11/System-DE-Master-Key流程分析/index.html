

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="OneAmx">
  <meta name="keywords" content="">
  
    <meta name="description" content="System DE Master Key流程分析 参考：https:&#x2F;&#x2F;blog.csdn.net&#x2F;cs_tech&#x2F;article&#x2F;details&#x2F;127593457?spm&#x3D;1001.2014.3001.5506 仅作自己学习备忘，侵权联系删除  1. 创建 System DE Master Key 流程下图展示了在设备第一次启动时，创建 System DE Master Key 的完整流程，在">
<meta property="og:type" content="article">
<meta property="og:title" content="System DE Master Key流程分析">
<meta property="og:url" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="疯狂少年">
<meta property="og:description" content="System DE Master Key流程分析 参考：https:&#x2F;&#x2F;blog.csdn.net&#x2F;cs_tech&#x2F;article&#x2F;details&#x2F;127593457?spm&#x3D;1001.2014.3001.5506 仅作自己学习备忘，侵权联系删除  1. 创建 System DE Master Key 流程下图展示了在设备第一次启动时，创建 System DE Master Key 的完整流程，在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/b325b451b58545b2aa95646471b01109.png">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/a564146a9d814d8987692446b88e4d1f.png">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230711231226553.png">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/da064c351cf545baac70a0203018796f.png">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230711231926237.png">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712213844099.png">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712215850630.png">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/d231d91958ff4902bc5118818bb13942.png">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/e885b34443284656a74001cbcaaef2c1.png">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/9ef600a59078447a938051efb9099422.png">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230717225544268.png">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/9ff061c0788748cbadc82023fc2f90b6.png">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712233532925.png">
<meta property="og:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712233104163.png">
<meta property="article:published_time" content="2023-07-11T14:46:31.000Z">
<meta property="article:modified_time" content="2023-07-17T15:46:33.945Z">
<meta property="article:author" content="OneAmx">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/b325b451b58545b2aa95646471b01109.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>System DE Master Key流程分析 - 疯狂少年</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/mouse.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"5f9d3edcc5e93f7fb0c85cf03554f3aa","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?5f9d3edcc5e93f7fb0c85cf03554f3aa";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>疯狂少年</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="System DE Master Key流程分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-11 22:46" pubdate>
          2023年7月11日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          26k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          215 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          浏览 <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">System DE Master Key流程分析</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="System-DE-Master-Key流程分析"><a href="#System-DE-Master-Key流程分析" class="headerlink" title="System DE Master Key流程分析"></a>System DE Master Key流程分析</h1><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/cs_tech/article/details/127593457?spm=1001.2014.3001.5506">https://blog.csdn.net/cs_tech/article/details/127593457?spm=1001.2014.3001.5506</a></p>
<p>仅作自己学习备忘，侵权联系删除</p>
</blockquote>
<h2 id="1-创建-System-DE-Master-Key-流程"><a href="#1-创建-System-DE-Master-Key-流程" class="headerlink" title="1. 创建 System DE Master Key 流程"></a>1. 创建 System DE Master Key 流程</h2><p>下图展示了在设备第一次启动时，创建 System DE Master Key 的完整流程，在这个章节会对其拆分，分别介绍。</p>
<img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/b325b451b58545b2aa95646471b01109.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;">

<h3 id="1-1-创建-System-DE-Master-Key"><a href="#1-1-创建-System-DE-Master-Key" class="headerlink" title="1.1 创建 System DE Master Key"></a>1.1 创建 System DE Master Key</h3><p>在 vold 函数 fscrypt_initialize_systemwide_keys 中，Vold 通过 keymaster HAL 向 keymaster TA 请求创建 Master Key。在请求参数中， km::TAG_STORAGE_KEY 表明了创建一个用于存储器加密的 Master Key，HLOS 将这个 key 用作 System DE Master Key。</p>
<img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/a564146a9d814d8987692446b88e4d1f.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 50%;">

<p>这里要注意 keymaster TA 不会直接将 Master Key 的明文直接返回到 HLOS，而是 Master Key Blob。那么 Master Key Blob 是怎么生成的？</p>
<ol>
<li>KM TA 首选创建一个 AES 算法加密 key，作为 Master Key；</li>
<li>使用由 SHK 派生出来的 KEK 将 Master Key 加密，并把密文存放到特殊数据结构，即 key blob；</li>
<li>再使用由 SHK 派生出来的 HMAC Key 通过 HMAC 算法对 key blob 签名；</li>
<li>这样就生成了 Master Key Blob，返回到 HLOS 的 Vold；</li>
</ol>
<p><strong>疑问：SHK 是什么？KEK 是什么？HMAC Key 是什么？</strong></p>
<p>① SHK 是设备使能 secure boot 后，生成的一个每个设备唯一、软件或者固件无法导出的 key，TZ 可以从 SHK 派生出各种用途的 key。</p>
<p>② KEK 派生自 SHK ，用于加密 KM TA 生成的 key，因为 key 不允许暴露在 HLOS：</p>
<ul>
<li>当 HLOS 请求 KM TA 生成 key 时，可以使用 KEK 将 key 加密成 key blob 后返回给 HLOS；</li>
<li>key 只能在 secure world 下使用（包括：加密、解密、签名、校验等操作）。因此时 HLOS 有需求时，请求 KM TA 执行相关操作，需要将数据和 key blob 一起传给 KM TA，KM TA 使用 KEK 解密 key blob 得到 key，再对数据执行相关的操作；</li>
</ul>
<p>③ HMAC Key 派生自 SHK ，用于对 key blob 签名，保证了  key blob 不被恶意篡改或者检查是否损坏；</p>
<p><strong>疑问：为什么 TZ 要将 key 加密后返回 HLOS 呢？</strong></p>
<p>在实际用户场景中，各种各样的进程可能会创建几十个甚至几百个用于各种各样的任务的 key，加密后返回 HLOS，由使用者自行管理，那么 TZ 就无需维护较大的存储区域以及这些 key 与客户端的联系。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> KeyGeneration <span class="hljs-title">makeGen</span><span class="hljs-params">(<span class="hljs-type">const</span> EncryptionOptions&amp; options)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> KeyGeneration&#123;FSCRYPT_MAX_KEY_SIZE, <span class="hljs-literal">true</span>, options.use_hw_wrapped_key&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">retrieveOrGenerateKey</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key_path, <span class="hljs-type">const</span> std::string&amp; tmp_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-type">const</span> KeyAuthentication&amp; key_authentication, <span class="hljs-type">const</span> KeyGeneration&amp; gen,</span></span><br><span class="hljs-params"><span class="hljs-function">                           KeyBuffer* key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pathExists</span>(key_path)) &#123;<br>        <span class="hljs-built_in">LOG</span>(DEBUG) &lt;&lt; <span class="hljs-string">&quot;Key exists, using: &quot;</span> &lt;&lt; key_path;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">retrieveKey</span>(key_path, key_authentication, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!gen.allow_gen) &#123;<br>            <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;No key found in &quot;</span> &lt;&lt; key_path;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Creating new key in &quot;</span> &lt;&lt; key_path;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateStorageKey</span>(gen, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 生成Master Key</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">storeKeyAtomically</span>(key_path, tmp_path, key_authentication, *key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 生成最终的加密秘钥encrypted key</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里先调用generateStorageKey生成Master Key：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">generateStorageKey</span><span class="hljs-params">(<span class="hljs-type">const</span> KeyGeneration&amp; gen, KeyBuffer* key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (gen.use_hw_wrapped_key) &#123;  <span class="hljs-comment">/* 使用硬件生成密钥 */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">generateWrappedStorageKey</span>(key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">/* 纯软生成随机秘钥 */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">randomKey</span>(gen.keysize, key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用generateWrappedStorageKey生成秘钥</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">generateWrappedStorageKey</span><span class="hljs-params">(KeyBuffer* key)</span> </span>&#123;<br>    Keymaster keymaster;  <span class="hljs-comment">// 创建对象</span><br>    <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string key_temp;<br>    <span class="hljs-keyword">auto</span> paramBuilder = km::<span class="hljs-built_in">AuthorizationSetBuilder</span>().<span class="hljs-built_in">AesEncryptionKey</span>(AES_KEY_BYTES * <span class="hljs-number">8</span>);<br>    paramBuilder.<span class="hljs-built_in">Authorization</span>(km::TAG_STORAGE_KEY);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeymasterKey</span>(keymaster, paramBuilder, &amp;key_temp)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//</span><br>    *key = <span class="hljs-built_in">KeyBuffer</span>(key_temp.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-built_in">memcpy</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(key-&gt;<span class="hljs-built_in">data</span>()), key_temp.<span class="hljs-built_in">c_str</span>(), key-&gt;<span class="hljs-built_in">size</span>());  <span class="hljs-comment">// 将临时生成的秘钥拷贝到key中</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">generateKeymasterKey</span><span class="hljs-params">(Keymaster&amp; keymaster,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> km::AuthorizationSetBuilder&amp; paramBuilder,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 std::string* key)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> paramsWithRollback = paramBuilder;<br>    paramsWithRollback.<span class="hljs-built_in">Authorization</span>(km::TAG_ROLLBACK_RESISTANCE);<br>    <span class="hljs-keyword">if</span> (!keymaster.<span class="hljs-built_in">generateKey</span>(paramsWithRollback, key)) &#123; <span class="hljs-comment">// 调用keymaster对象的generateKey方法</span><br>        <span class="hljs-keyword">if</span> (!keymaster.<span class="hljs-built_in">generateKey</span>(paramBuilder, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Keymaster::generateKey</span><span class="hljs-params">(<span class="hljs-type">const</span> km::AuthorizationSet&amp; inParams, std::string* key)</span> </span>&#123;<br>    ks2::KeyDescriptor in_key = &#123;<br>            .domain = ks2::Domain::BLOB,<br>            .alias = std::<span class="hljs-literal">nullopt</span>,<br>            .nspace = VOLD_NAMESPACE,<br>            .blob = std::<span class="hljs-literal">nullopt</span>,<br>    &#125;;<br>    ks2::KeyMetadata keyMetadata;<br>    <span class="hljs-comment">// securityLevel是共享智能指针std::shared_ptr&lt;ks2::IKeystoreSecurityLevel&gt; securityLevel;</span><br>    <span class="hljs-keyword">auto</span> rc = securityLevel-&gt;<span class="hljs-built_in">generateKey</span>(in_key, std::<span class="hljs-literal">nullopt</span>, inParams.<span class="hljs-built_in">vector_data</span>(), <span class="hljs-number">0</span>, &#123;&#125;, &amp;keyMetadata);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">logKeystore2ExceptionIfPresent</span>(rc, <span class="hljs-string">&quot;generateKey&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (keyMetadata.key.blob == std::<span class="hljs-literal">nullopt</span>) &#123;<br>        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;keystore2 generated key blob was null&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (key) *key = std::<span class="hljs-built_in">string</span>(keyMetadata.key.blob-&gt;<span class="hljs-built_in">begin</span>(), keyMetadata.key.blob-&gt;<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-built_in">zeroize_vector</span>(keyMetadata.key.blob.<span class="hljs-built_in">value</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里面有个地方需要说明一下，IKeystoreSecurityLevel这个里面提供的aidl接口，参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42135087/article/details/125172636">https://blog.csdn.net/weixin_42135087/article/details/125172636</a></p>
</blockquote>
<img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230711231226553.png" srcset="/img/loading.gif" lazyload alt="image-20230711231226553" style="zoom:67%;">

<h3 id="1-2-HLOS-把-System-DE-Master-Key-Blob-加密后保存到文件系统"><a href="#1-2-HLOS-把-System-DE-Master-Key-Blob-加密后保存到文件系统" class="headerlink" title="1.2 HLOS 把 System DE Master Key Blob 加密后保存到文件系统"></a>1.2 HLOS 把 System DE Master Key Blob 加密后保存到文件系统</h3><p>在上一个步骤中，KM TA 创建了 Master Key （ km::TAG_STORAGE_KEY FBE），并以 key blob 的形式返回到 HLOS。在 vold 收到 Master Key Blob 后，又将这个 key blob 加密后保存到文件系统中。</p>
<img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/da064c351cf545baac70a0203018796f.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;">

<p><strong>疑问：Master Key Blob 已经是密文了，为什么 vold 还要将 key blob 二次加密？</strong></p>
<p>这个操作似乎有点多余，如果对 key 加密一次不安全，那么加密两次也不见得更安全，或者为什么不加密更多次呢？</p>
<p>这里我们要从 FBE 的设计来看，<strong>Google 把 userdata 分区划分了不同安全等级的存储位置，但仅使用不同的密钥并不能体现出安全等级这个概念，而是要从对密钥的约束来体现，比如经过什么样的认证后，哪些位置的数据才允许访问，言下之意就是对应的加密密钥才允许被使用。</strong>那怎么认证呢？</p>
<p>System DE Master Key 的安全认证正是通过二次加密来体现的，但是加密 Master Key 的 key （KEK） 怎么做到这一点呢？System DE 的设计初衷就是相应的存储位置是设备绑定，即这些存储位置的数据只能在特定的设备（CPU、存储器绑定）上才能解密和访问。Master Key 只负责用户加解密文件的数据，但是特定的设备怎么保证呢？</p>
<p>这就是加密 Master Key 的 key 要达成的目标，我们把这个 key 称作 KSK（Key Strorage Key，这不是专有名词，而是按照 Google 代码变量名来命名 ）。</p>
<p>从流程图中可以看出，在创建 KSK 时需要指定 app id（即表明谁创建的？）。同样后续使用这个 key 时，也必须指定相同的 appid。appid 的组成中包括设备绑定的信息（每台设备，KSK 的 appid 不一样，因为从它的创建流程可以看出，包括两个随机数 Secdiscardable 和 storage_binding_info.seed）。不仅如此，在 KM TA 内部还会将 secure boot 状态、设备锁状态、安全补丁日期等等信息和 KSK 绑定，在使用 KSK 之前，会校验相关的信息是否严格匹配，只有完全满足后，KSK 才允许用于解密 Master Blob。这些约束的实现都是在 KM TA 完成的。</p>
<p>这里举几个实际的例子说明：</p>
<blockquote>
<p><strong>例1：把一台设备的存储器所有数据，dump 到另外一台完全一致的设备上，用户数据为什么无法解密？</strong></p>
<p>因为 KSK 已经和 secure boot 状态绑定，在另外一台设备上，无法知道 EKE，进而无法解密 KSK blob，KSK 即无法被使用。当然被 KSK 加密的 master key blob 也无法解密，自然获取不到 master key 。实际实现不只如此简单，这里不做详细介绍。</p>
<p><strong>例2：同一台设备，如果 OTA 更新到安全补丁日期升级的软件后，再回滚到旧软件版本，用户数据为什么无法解密？</strong></p>
<p>因为 KSK 已经和安全补丁日期绑定，安全补丁日期不能减小。安全补丁日期回滚后，KSK 将不可用。</p>
<p><strong>例3：设备第一次开机是在设备锁（也叫 fastboot锁）锁定的情况下开机，那么 unlock 设备锁后，用户数据为什么无法解密？</strong></p>
<p>因为 KSK 和设备锁的状态绑定，如果设备锁的状态出现反转，KSK 将不可用。</p>
</blockquote>
<p><strong>疑问：加密 Master Key Blob 的 key KSK 从何而来 ？</strong></p>
<p>和 Master Key 类似，都是由 KM TA 创建的，并以 key blob 的形式返回 HLOS，由 vold 自行管理。这里注意创建 key 时，参数 km::AuthorizationSet 不一样，这就导致在 KM TA 内部，它们的管理和用途都是不一样。</p>
<p>vold 请求 KM TA 创建 KSK 所使用的 appid的参数、KSK Blob、加密后的 Master Key Blob 被存储到 &#x2F;data&#x2F;unencrypted&#x2F;key&#x2F;：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ls /data/unencrypted/key/ -l</span><br>total 16<br>-rw------- 1 root root   268 1970-01-03 04:47 encrypted_key<br>-rw------- 1 root root   194 1970-01-03 04:47 keymaster_key_blob<br>-rw------- 1 root root 16384 1970-01-03 04:47 secdiscardable<br>-rw------- 1 root root    10 1970-01-03 04:47 stretching<br>-rw------- 1 root root     1 1970-01-03 04:47 version<br></code></pre></td></tr></table></figure>

<p><strong>疑问：第一次开机时，为什么要把 KSK blob  和 加密后的 Master Key Blob 保存到文件系统？</strong></p>
<p>后续每次开机，可以直接通过 KSK blob （&#x2F;data&#x2F;unencrypted&#x2F;key&#x2F;keymaster_key_blob）解密Master Key Blob 的密文（&#x2F;data&#x2F;unencrypted&#x2F;keyencrypted_key）得到 Master Key Blob，这个动作是在 TZ 内部完成的，有了 Master Key Blob，那么可以将 Master Key 安装到 kernel keyring，详见下文。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">storeKey</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; dir, <span class="hljs-type">const</span> KeyAuthentication&amp; auth, <span class="hljs-type">const</span> KeyBuffer&amp; key)</span> </span>&#123;<br>	<span class="hljs-comment">// 将kCurrentVersion(1)写入到/data/unencrypted/key/version</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kCurrentVersion, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_version)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string secdiscardable_hash;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">createSecdiscardable</span>(dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_secdiscardable, &amp;secdiscardable_hash)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string stretching = <span class="hljs-built_in">getStretching</span>(auth);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(stretching, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_stretching)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string appId;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateAppId</span>(auth, stretching, secdiscardable_hash, &amp;appId)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string encryptedKey;<br>    <span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;<br>        Keymaster keymaster;<br>        <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        std::string kmKey;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeyStorageKey</span>(keymaster, appId, &amp;kmKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kmKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_keymaster_key_blob)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        km::AuthorizationSet keyParams = <span class="hljs-built_in">beginParams</span>(appId);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithKeymasterKey</span>(keymaster, dir, keyParams, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithoutKeymaster</span>(appId, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(encryptedKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_encrypted_key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">FsyncDirectory</span>(dir)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-2-1-写入version"><a href="#1-2-1-写入version" class="headerlink" title="1.2.1 写入version"></a>1.2.1 写入version</h4><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230711231926237.png" srcset="/img/loading.gif" lazyload alt="image-20230711231926237" style="zoom: 67%;">

<h4 id="1-2-2-写入secdiscardable"><a href="#1-2-2-写入secdiscardable" class="headerlink" title="1.2.2 写入secdiscardable"></a>1.2.2 写入secdiscardable</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// filename: /data/unencrypted/key/secdiscardable</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">createSecdiscardable</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename, std::string* hash)</span> </span>&#123;<br>    std::string secdiscardable;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">readRandomBytesOrLog</span>(SECDISCARDABLE_BYTES, &amp;secdiscardable)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 通过/dev/urandom生成随机数</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(secdiscardable, filename)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 将生成的随机数保存到/data/unencrypted/key/secdiscardable</span><br>    <span class="hljs-built_in">hashWithPrefix</span>(kHashPrefix_secdiscardable, secdiscardable, hash); <span class="hljs-comment">// 将生成的随机数取hash</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-2-3-写入stretching"><a href="#1-2-3-写入stretching" class="headerlink" title="1.2.3 写入stretching"></a>1.2.3 写入stretching</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string stretching = <span class="hljs-built_in">getStretching</span>(auth); <span class="hljs-comment">// 如果有锁屏密码值为none，没有锁屏密码为nopassword</span><br><span class="hljs-built_in">writeStringToFile</span>(stretching, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_stretching);<span class="hljs-comment">// 将stretching值写入到/data/unencrypted/key/stretching</span><br><br><br><span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">getStretching</span><span class="hljs-params">(<span class="hljs-type">const</span> KeyAuthentication&amp; auth)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;<br>        <span class="hljs-keyword">return</span> kStretch_nopassword;  <span class="hljs-comment">// nopassword</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> kStretch_none;  <span class="hljs-comment">// none</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里得说下什么情况下，auth的usesKeymaster返回true</p>
<img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712213844099.png" srcset="/img/loading.gif" lazyload alt="image-20230712213844099" style="zoom:50%;">

<p>我们知道这个secret是从FWK传下来的锁屏Credential。</p>
<p><strong>所以如果secret为空，也就是没有设置锁屏密码，返回True！</strong></p>
<h4 id="1-2-4-写入keymaster-key-blob"><a href="#1-2-4-写入keymaster-key-blob" class="headerlink" title="1.2.4 写入keymaster_key_blob"></a>1.2.4 写入keymaster_key_blob</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string appId;<br><span class="hljs-comment">// // 生成appId，如果设置了锁屏密码，则为appId = secdiscardable_hash + auth.secret；没有设置锁屏密码，则appId = secdiscardable_hash</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateAppId</span>(auth, stretching, secdiscardable_hash, &amp;appId)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>std::string encryptedKey;<br><span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;  <span class="hljs-comment">// 没有锁屏密码的时候</span><br>    Keymaster keymaster;<br>    <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string kmKey;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeyStorageKey</span>(keymaster, appId, &amp;kmKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 将生成的KSK Blob写入到/data/unencrypted/key/keymaster_key_blob</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kmKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_keymaster_key_blob)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    km::AuthorizationSet keyParams = <span class="hljs-built_in">beginParams</span>(appId);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithKeymasterKey</span>(keymaster, dir, keyParams, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 有锁屏密码的时候生成随机encryptedKey</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithoutKeymaster</span>(appId, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（1）generateKeyStorageKey生成KSK Blob</p>
<p>这里System CE Master Key走的是keymaster管理分支</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">generateKeyStorageKey<br>     -&gt; generateKeymasterKey<br>    	-&gt; keymaster.generateKey<br></code></pre></td></tr></table></figure>

<p>最终还是调用了keymaster的generateKey方法（1.1节创建Master Key的时候已经创建过一次了），不同点在于：</p>
<ul>
<li>第一次生成的是Master Key的Blob</li>
<li>这次生成的是KeyStorageKey（简称KSK）的Blob</li>
<li>至于为什么要再生成KSK Blob，上面博主已经写得很清楚了</li>
</ul>
<p>（2）encryptWithKeymasterKey将生成的KSK Blob对Master Key Blob二次加密，生成最终的encryptedKey</p>
<h4 id="1-2-5-写入encrypted-key"><a href="#1-2-5-写入encrypted-key" class="headerlink" title="1.2.5 写入encrypted_key"></a>1.2.5 写入encrypted_key</h4><p>上面生成了最终的加密秘钥encrypted_key，随后写入到&#x2F;data&#x2F;unencrypted&#x2F;key&#x2F;encrypted_key</p>
<img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712215850630.png" srcset="/img/loading.gif" lazyload alt="image-20230712215850630" style="zoom:67%;">

<h3 id="1-3-安装-Master-Key-到-kernel-keyring"><a href="#1-3-安装-Master-Key-到-kernel-keyring" class="headerlink" title="1.3 安装 Master Key 到 kernel keyring"></a>1.3 安装 Master Key 到 kernel keyring</h3><p>在上一步骤中，已经成功创建了 Master Key，那接下来就是要把 Master Key 注册到 kernel keyring。在文件 I&#x2F;O 时可以通过  Encryption Policy 的 master_key_identifier 字段从 kernel keyring 中找到 Master Key。</p>
<p>在这个步骤中的两个重点操作：</p>
<ol>
<li>安装 Master Key 到 kernel keyring；</li>
<li>生成 Master Key 的 master_key_identifier；</li>
</ol>
<p>软件流程图如下所示：</p>
<img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/d231d91958ff4902bc5118818bb13942.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 80%;">

<p>流程图比较复杂，接下来根据疑问来分解图中的步骤。</p>
<p><strong>疑问： Master Key 不是不允许暴露在 HLOS 吗？那注册到 kernel keyring 的 Master Key 从何而来？</strong></p>
<p>实际上是 Master Key 的 Wrapped Key 被注册到 kernel keyring ，毕竟 Master Key 确实不能暴露在 HLOS。那 Wrapped Key 从何而来？</p>
<img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/e885b34443284656a74001cbcaaef2c1.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 80%;">

<p> 从图中可知，生成 Wrapped Key 的过程：</p>
<ol>
<li>vold 把 Master Key Blob 传送到 KM TA，请求创建 Wrapped Key；</li>
<li>KM TA 使用 HMAC Key 校验 Master Key Blob ；</li>
<li>KM TA 使用 KEK 解密 Master Key Blob 得到 Master Key；</li>
<li>KM TA 使用 Ephemeral Key 通过 AES Wrap Key RFC3394 Algorithm 生成 Master Key 的 Wrapped Key<ol>
<li>Ephemeral Key：从 SHK  派生而来，但是每次设备重启（cold reboot）都会改变，意味着 Wrapped Key 每次设置重启都不一样；</li>
<li>AES Wrap Key RFC3394 Algorithm：详见 <a target="_blank" rel="noopener" href="https://www.ietf.org/rfc/rfc3394.txt">Advanced Encryption Standard (AES) Key Wrap Algorithm</a></li>
</ol>
</li>
<li>KM TA 将生成的 Wrapped Key 返回 HLOS vold；</li>
<li>Vold 通过系统调用 ioctl  FS_IOC_ADD_ENCRYPTION_KEY，将 Wrapped Key 安装到 Kernel Keyring</li>
</ol>
<blockquote>
<ul>
<li>相反，KM TA 可以使用 Ephemeral Key 通过 AES Unwrap Key RFC3394 Algorithm  将 Wrapped Key 转成 Master Key。因此后面 HLOS 再软件流程中可以把  Wrapped Key 当作 Master Key，在实际执行操作时，KM TA 会将 Wrapped Key 自动转换成 Master Key 后再执行；</li>
<li>AES Wrap Key RFC3394 Algorithm 是什么？可以简单的理解为 AES 算法是专门用于数据加解密，而 AES Wrap Key RFC3394 Algorithm 专门用于加解密 AES Key;</li>
</ul>
</blockquote>
<p><strong>疑问：master_key_identifier 是怎么产生的？怎么通过 master_key_identifier 找到 Master Key？</strong></p>
<p>首先给出一张软件流程图，可以看到 master_key_identifier  是在安装 Wrapped Key 的过程中生成的，并且随系统调用返回到 vold 进程。<br><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/9ef600a59078447a938051efb9099422.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;"></p>
<p>生成 master_key_identifier  的步骤有：</p>
<ol>
<li>Kernel 函数 fscrypt_derive_raw_secret 将 Wrapped Key 发送到 TZ KM TA，请求 Master Key 派生 raw secret ；</li>
<li>KM TA 接收到请求后，使用 Ephemeral Key 通过 Unwrap Wrapped Key 得到 Master Key；</li>
<li>KM TA 通过 KDF ，使得 Master Key 派生出一个 key，并将这个派生 key 返回 HLOS Linux kernel</li>
<li>Linux Kernel 使用从 TZ 返回的派生 key 作为 KDF key，继续通过 KDF 派生出一个 key，这个 key 作为 master_key_identifier；</li>
</ol>
<hr>
<h4 id="1-3-1-重要的数据结构"><a href="#1-3-1-重要的数据结构" class="headerlink" title="1.3.1 重要的数据结构"></a>1.3.1 重要的数据结构</h4><h5 id="1-3-1-1-结构体key"><a href="#1-3-1-1-结构体key" class="headerlink" title="1.3.1.1 结构体key"></a>1.3.1.1 结构体key</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> &#123;</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyring_index_key</span> <span class="hljs-title">index_key</span>;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>			<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	hash;<br>			<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>	len_desc;<br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key_type</span>	*<span class="hljs-title">type</span>;</span>		<span class="hljs-comment">/* type of key */</span><br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key_tag</span>	*<span class="hljs-title">domain_tag</span>;</span>	<span class="hljs-comment">/* Domain of operation */</span><br>			<span class="hljs-type">char</span>		*description;<br>		&#125;;<br>	&#125;;<br><br><br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		<span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">key_payload</span> <span class="hljs-title">payload</span>;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>			<span class="hljs-comment">/* Keyring bits */</span><br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">name_link</span>;</span><br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">assoc_array</span> <span class="hljs-title">keys</span>;</span><br>		&#125;;<br>	&#125;;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>有几个值得注意的点：</p>
<ul>
<li>index_key，类型为keyring_index_key，最终我们要通过这个变量获取master key</li>
<li>keyring和key的区别在于，keyring有一个keys关联数组，其类型为assoc_array，这个关联数组中存储了所有的master key</li>
</ul>
<h5 id="1-3-1-2-结构体变量key-type-keyring"><a href="#1-3-1-2-结构体变量key-type-keyring" class="headerlink" title="1.3.1.2 结构体变量key_type_keyring"></a>1.3.1.2 结构体变量key_type_keyring</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key_type</span> <span class="hljs-title">key_type_keyring</span> =</span> &#123;<br>	.name		= <span class="hljs-string">&quot;keyring&quot;</span>,<br>	.def_datalen	= <span class="hljs-number">0</span>,<br>	.preparse	= keyring_preparse,<br>	.free_preparse	= keyring_free_preparse,<br>	.instantiate	= keyring_instantiate,<br>	.revoke		= keyring_revoke,<br>	.destroy	= keyring_destroy,<br>	.describe	= keyring_describe,<br>	.read		= keyring_read,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>关于keyring相关的操作都在这个结构体里面了…</p>
<h4 id="1-3-2-添加秘钥"><a href="#1-3-2-添加秘钥" class="headerlink" title="1.3.2 添加秘钥"></a>1.3.2 添加秘钥</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fscrypt_ioctl_add_key</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">void</span> __user *_uarg)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> file_inode(filp)-&gt;i_sb;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fscrypt_add_key_arg</span> __<span class="hljs-title">user</span> *<span class="hljs-title">uarg</span> =</span> _uarg;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fscrypt_add_key_arg</span> <span class="hljs-title">arg</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fscrypt_master_key_secret</span> <span class="hljs-title">secret</span>;</span><br>	<span class="hljs-type">int</span> err;<br>	<br>    <span class="hljs-comment">// 将用户空间的参数传入到内核空间,这里传进来的就是master key</span><br>	<span class="hljs-keyword">if</span> (copy_from_user(&amp;arg, uarg, <span class="hljs-keyword">sizeof</span>(arg))) <span class="hljs-keyword">return</span> -EFAULT;<br><br>	<span class="hljs-built_in">memset</span>(&amp;secret, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(secret));<br><br>	err = add_master_key(sb, &amp;secret, &amp;arg.key_spec);<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230717225544268.png" srcset="/img/loading.gif" lazyload alt="image-20230717225544268" style="zoom: 50%;">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add_master_key</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params">			  <span class="hljs-keyword">struct</span> fscrypt_master_key_secret *secret,</span><br><span class="hljs-params">			  <span class="hljs-keyword">struct</span> fscrypt_key_specifier *key_spec)</span> &#123;<br>    <span class="hljs-keyword">return</span> do_add_master_key(sb, secret, key_spec);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_add_master_key</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params">			     <span class="hljs-keyword">struct</span> fscrypt_master_key_secret *secret,</span><br><span class="hljs-params">			     <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> fscrypt_key_specifier *mk_spec)</span><br>&#123;<br>	<span class="hljs-type">static</span> <span class="hljs-title function_">DEFINE_MUTEX</span><span class="hljs-params">(fscrypt_add_key_mutex)</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">key</span>;</span><br>	<span class="hljs-type">int</span> err;<br><br>	mutex_lock(&amp;fscrypt_add_key_mutex); <span class="hljs-comment">/* serialize find + link */</span><br>	key = fscrypt_find_master_key(sb, mk_spec);<br>	<span class="hljs-keyword">if</span> (IS_ERR(key)) &#123;<br>		err = allocate_filesystem_keyring(sb);<br>		err = add_new_master_key(secret, mk_spec, sb-&gt;s_master_keys);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">// ...</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">allocate_filesystem_keyring</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb)</span> &#123;<br>	<span class="hljs-type">char</span> description[FSCRYPT_FS_KEYRING_DESCRIPTION_SIZE];<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">keyring</span>;</span><br>    <br>    <span class="hljs-comment">// 将sb-&gt;s_id格式化成[&quot;fscrypt-%s&quot;, sb-&gt;s_id]保存到description变量中</span><br>    <span class="hljs-comment">// 这边的sb-&gt;s_id就是Data分区对应的设备名，如fscrypt-sda61</span><br>	format_fs_keyring_description(description, sb);  <br>	keyring = keyring_alloc(description, GLOBAL_ROOT_UID, GLOBAL_ROOT_GID, current_cred(), KEY_POS_SEARCH |<br>				  KEY_USR_SEARCH | KEY_USR_READ | KEY_USR_VIEW, KEY_ALLOC_NOT_IN_QUOTA, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// ----------------------------------------------------------------------------</span><br><span class="hljs-keyword">struct</span> key *<span class="hljs-title function_">keyring_alloc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *description, <span class="hljs-type">kuid_t</span> uid, <span class="hljs-type">kgid_t</span> gid,</span><br><span class="hljs-params">			  <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> cred *cred, <span class="hljs-type">key_perm_t</span> perm,</span><br><span class="hljs-params">			  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags,</span><br><span class="hljs-params">			  <span class="hljs-keyword">struct</span> key_restriction *restrict_link,</span><br><span class="hljs-params">			  <span class="hljs-keyword">struct</span> key *dest)</span> &#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">keyring</span>;</span><br>	<br>    <span class="hljs-comment">// 申请keyring，将description设置到keyring的index_key成员变量中</span><br>	keyring = key_alloc(&amp;key_type_keyring, description, uid, gid, cred, perm, flags, restrict_link);<br>	<span class="hljs-keyword">if</span> (!IS_ERR(keyring)) &#123;<br>		ret = key_instantiate_and_link(keyring, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, dest, <span class="hljs-literal">NULL</span>);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> keyring;<br>&#125;<br><br><span class="hljs-keyword">struct</span> key *<span class="hljs-title function_">key_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> key_type *type, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *desc,</span><br><span class="hljs-params">		      <span class="hljs-type">kuid_t</span> uid, <span class="hljs-type">kgid_t</span> gid, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> cred *cred,</span><br><span class="hljs-params">		      <span class="hljs-type">key_perm_t</span> perm, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags,</span><br><span class="hljs-params">		      <span class="hljs-keyword">struct</span> key_restriction *restrict_link)</span> &#123;<br>	<span class="hljs-comment">// ...</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">key</span>;</span><br>	key-&gt;index_key.desc_len = desclen;<br>	key-&gt;index_key.description = kmemdup(desc, desclen + <span class="hljs-number">1</span>, GFP_KERNEL);<br>	key-&gt;index_key.type = type;<br>	key_set_index_key(&amp;key-&gt;index_key);<br>	<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>









<h2 id="2-User-0-CE-Master-Key"><a href="#2-User-0-CE-Master-Key" class="headerlink" title="2.User.0 CE Master Key"></a>2.User.0 CE Master Key</h2><p>当用户设置用户锁屏密码后， User CE Master  key 的认证方式会改变，受用户密码保护，只有密码校验成功后，才能得到 User.0 CE Master Key，并将其安装到 kernel keyring。</p>
<p>User.0 CE Master Key 相关的认证数据被存储到目录 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;current 下。我们对比一下未设置锁屏密码和设置锁屏密码后，该目录下的文件差异：</p>
<ul>
<li>未设置锁屏密码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; adb shell <span class="hljs-built_in">ls</span> /data/misc/vold/user_keys/ce/0/current -l<br>-rw------- 1 root root   268 2022-11-05 22:08 encrypted_key<br>-rw------- 1 root root   194 2022-11-05 22:08 keymaster_key_blob<br>-rw------- 1 root root 16384 2022-11-05 22:08 secdiscardable<br>-rw------- 1 root root    10 2022-11-05 22:08 stretching<br>-rw------- 1 root root     1 2022-11-05 22:08 version<br></code></pre></td></tr></table></figure>

<ul>
<li>设置锁屏密码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; adb shell <span class="hljs-built_in">ls</span> /data/misc/vold/user_keys/ce/0/current -l<br>-rw------- 1 root root   268 2022-11-05 22:11 encrypted_key<br>-rw------- 1 root root 16384 2022-11-05 22:11 secdiscardable<br>-rw------- 1 root root     4 2022-11-05 22:11 stretching<br>-rw------- 1 root root     1 2022-11-05 22:11 version<br></code></pre></td></tr></table></figure>

<p>可以看到设置锁屏密码后，少了文件 keymaster_key_blob。在介绍 System DE Master Key 时已经知道，keymaster_key_blob 是 KM TA 创建的一个用于加密 Master Key Blob 的 key（上文称其为 KSK），用于保证 Master Key Blob 的安全性，作为设备绑定认证的一种实现，即 KSK 只能在唯一的设备（和CPU、存储器等器件绑定）上可用。</p>
<p>在用户设置锁屏密码后，认证更加严格，不仅要唯一的设备，而且需要用户输入正确的锁屏密码。因此，Master Key Blob  不再用 KSK 加密，它已经不能满足需求。</p>
<p><strong>疑问：encrypted_key 仍然存在，表明仍然使用对 Master Key Blob 加密的方式实现认证。但是加密 Master Key Blob 的 key 从哪里来？和用户锁屏密码存在什么关系？</strong></p>
<p>我们先看以下用户设置锁屏密码时，导致 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;current 下文件内容变化的流程：</p>
<img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/9ff061c0788748cbadc82023fc2f90b6.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;">

<p>AuthenticationToken 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthenticationToken</span> &#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> mVersion;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * Here is the relationship between these fields:</span><br><span class="hljs-comment">	 * Generate two random block P0 and P1. P1 is recorded in mEscrowSplit1 but P0 is not.</span><br><span class="hljs-comment">	 * mSyntheticPassword = hash(P0 || P1)</span><br><span class="hljs-comment">	 * E0 = P0 encrypted under syntheticPassword, recoreded in mEncryptedEscrowSplit0.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-meta">@NonNull</span> <span class="hljs-type">byte</span>[] mSyntheticPassword;<br>	<span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-type">byte</span>[] mEncryptedEscrowSplit0;<br>	<span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-type">byte</span>[] mEscrowSplit1;<br> <br>	AuthenticationToken(<span class="hljs-type">byte</span> version) &#123;<br>		mVersion = version;<br>	&#125;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * Derives a subkey from the synthetic password. For v3 and later synthetic passwords the</span><br><span class="hljs-comment">	 * subkeys are 256-bit; for v1 and v2 they are 512-bit.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] deriveSubkey(<span class="hljs-type">byte</span>[] personalization) &#123;<br>		<span class="hljs-keyword">if</span> (mVersion == SYNTHETIC_PASSWORD_VERSION_V3) &#123;<br>			<span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">SP800Derive</span>(mSyntheticPassword))<br>				.withContext(personalization, PERSONALISATION_CONTEXT);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">return</span> SyntheticPasswordCrypto.personalisedHash(personalization,<br>					mSyntheticPassword);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] deriveDiskEncryptionKey() &#123;<br>		<span class="hljs-keyword">return</span> deriveSubkey(PERSONALIZATION_FBE_KEY);<br>	&#125;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * Re-creates synthetic password from both escrow splits. See javadoc for</span><br><span class="hljs-comment">	 * AuthenticationToken.mSyntheticPassword for details on what each block means.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recreate</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] escrowSplit0, <span class="hljs-type">byte</span>[] escrowSplit1)</span> &#123;<br>		mSyntheticPassword = bytesToHex(SyntheticPasswordCrypto.personalisedHash(<br>				PERSONALIZATION_SP_SPLIT, escrowSplit0, escrowSplit1));<br>	&#125;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * Assign escrow data to this auth token. This is a prerequisite to call</span><br><span class="hljs-comment">	 * &#123;<span class="hljs-doctag">@link</span> AuthenticationToken#recreateFromEscrow&#125;.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEscrowData</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> <span class="hljs-type">byte</span>[] encryptedEscrowSplit0,</span><br><span class="hljs-params">			<span class="hljs-meta">@Nullable</span> <span class="hljs-type">byte</span>[] escrowSplit1)</span> &#123;<br>		mEncryptedEscrowSplit0 = encryptedEscrowSplit0;<br>		mEscrowSplit1 = escrowSplit1;<br>	&#125;<br>		<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * Generates a new random synthetic password with escrow data.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">static</span> AuthenticationToken <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-type">AuthenticationToken</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthenticationToken</span>(SYNTHETIC_PASSWORD_VERSION_V3);<br>		<span class="hljs-type">byte</span>[] escrowSplit0 = secureRandom(SYNTHETIC_PASSWORD_LENGTH);<br>		<span class="hljs-type">byte</span>[] escrowSplit1 = secureRandom(SYNTHETIC_PASSWORD_LENGTH);<br>		result.recreate(escrowSplit0, escrowSplit1);<br>		<span class="hljs-type">byte</span>[] encrypteEscrowSplit0 = SyntheticPasswordCrypto.encrypt(result.mSyntheticPassword,<br>				PERSONALIZATION_E0, escrowSplit0);<br>		result.setEscrowData(encrypteEscrowSplit0,  escrowSplit1);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结合代码和流程图可以看到，用户设置密码后，框架会直接调到 vold 执行更换 MasterKey 认证方式：</p>
<ol>
<li>调用函数 fscrypt_add_user_key_auth(user_id, serial, secret_hex），增加对 CE Master Key 的认证方式：<ol>
<li>首先，加载 keymaster_key_blob ，使用 KSK 解密 encrypted_key，得到 Master CE Key Blob；</li>
<li>接着，生成新的 appid，appid 由 fscrypt_add_user_key_auth 传入的参数 secret_hex 组成；</li>
<li>将 appid Hash 成 AES Key;</li>
<li>使用生成的 AES Key 加密  Master CE Key Blob，得到 encrypted_key；</li>
<li>将新的认证数据存储到 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;cx0000000000 下；</li>
<li>此时 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0 下已经存在两种 CE Master Key 的认证方式，如下所示</li>
</ol>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 老的认证方式，通过 KM key KSK 认证</span><br>&gt; adb shell <span class="hljs-built_in">ls</span> /data/misc/vold/user_keys/ce/0/current<br>encrypted_key<br>keymaster_key_blob<br>secdiscardable<br>stretching<br>version<br> <br><span class="hljs-comment"># 新的认证方式，通过用户密码校验认证</span><br>&gt; adb shell <span class="hljs-built_in">ls</span> /data/misc/vold/user_keys/ce/0/cx0000000000<br>encrypted_key<br>secdiscardable<br>stretching<br>version<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>调用 fscrypt_fixate_newest_user_key_auth，清除老的认证方式，改用用户密码认证，完成后，&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;cx0000000000 的内容将覆盖 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;current。vold 会打出如下的 log ：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">vold    : fscrypt_fixate_newest_user_key_auth 0<br>vold    : Deleting key /data/misc/vold/user_keys/ce/0/current/keymaster_key_blob from Keymaster<br>vold    : /system/bin/secdiscard<br>vold    :     --<br>vold    :     /data/misc/vold/user_keys/ce/0/current/encrypted_key<br>vold    :     /data/misc/vold/user_keys/ce/0/current/secdiscardable<br>vold    :     /data/misc/vold/user_keys/ce/0/current/keymaster_key_blob<br>vold    : /system/bin/rm<br>vold    :     -rf<br>vold    :     /data/misc/vold/user_keys/ce/0/current<br>vold    : Renaming /data/misc/vold/user_keys/ce/0/cx0000000000 to /data/misc/vold/user_keys/ce/0/current<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-1-token与secret"><a href="#2-1-token与secret" class="headerlink" title="2.1 token与secret"></a>2.1 token与secret</h3><p>在Android系统重的设置密码、清除密码、修改密码，都是调用到LockSettingsService.java的setLockCredential函数进行的，而setLockCredential又调用了setLockCredentialInternal。【引用：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42135087/article/details/109726612?spm=1001.2014.3001.5506%E3%80%91">https://blog.csdn.net/weixin_42135087/article/details/109726612?spm=1001.2014.3001.5506】</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从[代码改变世界ctw](https://blog.csdn.net/weixin_42135087)大哥的博客中可以知道，当我们创建了设置用户密码的时候会调用到setLockCredentialInternal ，下面的调用栈如下：</span><br><br>setLockCredentialInternal -&gt; setUserKeyProtection -&gt; addUserKeyAuth<br></code></pre></td></tr></table></figure>

<p>⭐ 在我阅读代码的时候，暂且将：</p>
<ul>
<li>token理解成TEE世界发给我们的令牌，只有这个令牌我们才能做我们的事情，其本质是一个byte[]数组<ul>
<li>推荐文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42800689/article/details/84071690">auth认证相关</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42135087/article/details/107861296">android密码解锁&#x2F;指纹解锁返回的authToken深度解剖</a></li>
<li>经过gatekeeper、生物认证（人脸、指纹）验证后返回的authToken，该authToken是经过了共享Hmackey签名的。所以在keystore使用一些功能的时候，会传下来这个authtoken，必须验证这个authtoken，才能进行后面的业务逻辑。【来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42135087/article/details/124565234">android gatekeeper(locksetting密码锁)学习这一篇就够了</a>】</li>
<li>🔕但是注意一下：<strong>FBE是不需要这个authtoken的</strong></li>
</ul>
</li>
<li>secret就理解成锁屏密码，只不过会从密码包装一下变成了LockscreenCredential对象，又通过secretFromCredential包装成了一个byte数组</li>
</ul>
<img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712233532925.png" srcset="/img/loading.gif" lazyload alt="image-20230712233532925" style="zoom: 50%;">



<h3 id="2-2-addUserKeyAuth层层调用"><a href="#2-2-addUserKeyAuth层层调用" class="headerlink" title="2.2  addUserKeyAuth层层调用"></a>2.2  addUserKeyAuth层层调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\locksettings\LockSettingsService.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUserKeyAuth</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> mUserManager.getUserInfo(userId);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">callingId</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>    <span class="hljs-comment">// 调用SMS的addUserKeyAuth方法</span><br>    mStorageManager.addUserKeyAuth(userId, userInfo.serialNumber, token, secret);<br>&#125;<br><br><span class="hljs-comment">// ---------------------------------------------------------------</span><br><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\StorageManagerService.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUserKeyAuth</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">int</span> serialNumber, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret)</span> &#123;<br>    mVold.addUserKeyAuth(userId, serialNumber, encodeBytes(token), encodeBytes(secret));<br>&#125;<br><br><span class="hljs-comment">// ---------------------------------------------------------------</span><br><span class="hljs-comment">// system\vold\VoldNativeService.cpp</span><br>binder::Status VoldNativeService::addUserKeyAuth(int32_t userId, int32_t userSerial,<br>                                                 const std::string&amp; token,<br>                                                 const std::string&amp; secret) &#123;<br>    <span class="hljs-keyword">if</span> (!token_empty(token)) &#123;<br>        LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;Vold doesn&#x27;t use auth tokens, but non-empty token passed to addUserKeyAuth.&quot;</span>;<br>        <span class="hljs-keyword">return</span> binder::Status::fromServiceSpecificError(-EINVAL);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> translateBool(fscrypt_add_user_key_auth(userId, userSerial, secret));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的注释可以看出，Vold服务是不需要AuthToken的，所以不需要向FBE传递。</p>
<h3 id="2-3-fscrypt-add-user-key-auth开始添加用户权限"><a href="#2-3-fscrypt-add-user-key-auth开始添加用户权限" class="headerlink" title="2.3 fscrypt_add_user_key_auth开始添加用户权限"></a>2.3 fscrypt_add_user_key_auth开始添加用户权限</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fscrypt_add_user_key_auth</span><span class="hljs-params">(<span class="hljs-type">userid_t</span> user_id, <span class="hljs-type">int</span> serial, <span class="hljs-type">const</span> std::string&amp; secret_hex)</span> </span>&#123;<br>	<span class="hljs-comment">// 判断是否支持文件级加密</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">fscrypt_is_native</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 还原锁屏码</span><br>    <span class="hljs-keyword">auto</span> auth = <span class="hljs-built_in">authentication_from_hex</span>(secret_hex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fscrypt_rewrap_user_key</span>(user_id, serial, kEmptyAuthentication, *auth);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用fscrypt_rewrap_user_key</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">fscrypt_rewrap_user_key</span><span class="hljs-params">(<span class="hljs-type">userid_t</span> user_id, <span class="hljs-type">int</span> serial,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> android::vold::KeyAuthentication&amp; retrieve_auth,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> android::vold::KeyAuthentication&amp; store_auth)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前用户的CE_KEY目录: /data/misc/vold/user_keys/ce/&lt;userid&gt;</span><br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> directory_path = <span class="hljs-built_in">get_ce_key_directory_path</span>(user_id);<br>    KeyBuffer ce_key;<br>    std::string ce_key_current_path = <span class="hljs-built_in">get_ce_key_current_path</span>(directory_path); <span class="hljs-comment">// /data/misc/vold/user_keys/ce/&lt;userid&gt;/current</span><br>    <span class="hljs-built_in">retrieveKey</span>(ce_key_current_path, kEmptyAuthentication, &amp;ce_key);<br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> paths = <span class="hljs-built_in">get_ce_key_paths</span>(directory_path);<br>    std::string ce_key_path;<br>    <span class="hljs-comment">// 新路径: /data/misc/vold/user_keys/ce/&lt;userid&gt;/current/cx%010u，例如/data/misc/vold/user_keys/ce/0/current/cx0000000000</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">get_ce_key_new_path</span>(directory_path, paths, &amp;ce_key_path)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// user_key_temp: /data/misc/vold/user_keys/temp</span><br>    <span class="hljs-comment">// 保存CE Key</span><br>    <span class="hljs-keyword">if</span> (!android::vold::<span class="hljs-built_in">storeKeyAtomically</span>(ce_key_path, user_key_temp, store_auth, ce_key))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>历史总是惊人的相似【1.1节创建System DE Master Key】</strong>，这里又调用storeKeyAtomically保存当前用户的User CE Master Key</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">storeKeyAtomically</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key_path, <span class="hljs-type">const</span> std::string&amp; tmp_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> KeyAuthentication&amp; auth, <span class="hljs-type">const</span> KeyBuffer&amp; key)</span> </span>&#123;<br>    <span class="hljs-comment">// 后面会将tmp_path换成Key_path，所以我直接改为key_path</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">storeKey</span>(key_path, auth, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用storeKey【⭐ 这里所有的操作即使都是在&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;temp中处理的，只是后面会有RenameKeyDir和FsyncParentDirectory操作，只要操作成功了，就相当于<code>/data/misc/vold/user_keys/ce/&lt;userid&gt;/current</code>】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">storeKey</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; dir, <span class="hljs-type">const</span> KeyAuthentication&amp; auth, <span class="hljs-type">const</span> KeyBuffer&amp; key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">mkdir</span>(dir.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0700</span>)) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;key mkdir &quot;</span> &lt;&lt; dir;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 向/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/version中写入1</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kCurrentVersion, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_version)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 创建随机的secdiscardable_hash值</span><br>    std::string secdiscardable_hash;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">createSecdiscardable</span>(dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_secdiscardable, &amp;secdiscardable_hash)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 如果有锁屏密码，则stretching为none; 如果没有锁屏密码，则stretching为nopassword</span><br>    std::string stretching = <span class="hljs-built_in">getStretching</span>(auth);<br>    <span class="hljs-comment">// 向/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/stretching中写入stretching的值</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(stretching, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_stretching)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 生成appId，如果设置了锁屏密码，则为appId = hash + auth.secret；没有设置锁屏密码，则appId = hash</span><br>    std::string appId;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateAppId</span>(auth, stretching, secdiscardable_hash, &amp;appId)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string encryptedKey;<br>    <span class="hljs-comment">// 如果没有设置锁屏密码，使用keymaster管理</span><br>    <span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;<br>        Keymaster keymaster;<br>        <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        std::string kmKey;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeyStorageKey</span>(keymaster, appId, &amp;kmKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kmKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_keymaster_key_blob)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        km::AuthorizationSet keyParams = <span class="hljs-built_in">beginParams</span>(appId);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithKeymasterKey</span>(keymaster, dir, keyParams, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 设置了锁屏密码，不适用keymaster</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithoutKeymaster</span>(appId, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将加密后的CE key写入/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/encrypted_key</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(encryptedKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_encrypted_key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">FsyncDirectory</span>(dir)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>非常感谢大佬的博客，收益良多。在博主的基础上，加上了自己的一点点理解。</p>
<p>其中：</p>
<ul>
<li>每一个小节分界线以上是博主原文</li>
<li>分界线以下是我的理解</li>
</ul>
<hr>
<img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712233104163.png" srcset="/img/loading.gif" lazyload alt="image-20230712233104163" style="zoom:80%;">

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="category-chain-item">Android学习笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Android/">#Android</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>System DE Master Key流程分析</div>
      <div>http://example.com/2023/07/11/System-DE-Master-Key流程分析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>OneAmx</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月11日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" title="struct结构体内存对齐">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">struct结构体内存对齐</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="贺利坚汇编原理学习笔记">
                        <span class="hidden-mobile">贺利坚汇编原理学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>
  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>

  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
  <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
  <script type="text/javascript" src="/js/fireworks.js"></script>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":250,"height":500},"mobile":{"show":true}});</script></body>
</html>
