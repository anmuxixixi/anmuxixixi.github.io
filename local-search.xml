<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解计算机系统——链接</title>
    <link href="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/"/>
    <url>/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解计算机系统——链接"><a href="#深入理解计算机系统——链接" class="headerlink" title="深入理解计算机系统——链接"></a>深入理解计算机系统——链接</h1><blockquote><p>声明：本文为学习计算机系统的笔记，供自己复习使用；按照<strong>yaaangmin</strong>的github声明，请勿进行商用</p><p>所有内容均整理自：<strong>yaaangmin</strong></p><p>其github地址为：<a href="https://github.com/yangminz/bcst_csapp">https://github.com/yangminz/bcst_csapp</a></p></blockquote><h2 id="1-可执行可链接格式"><a href="#1-可执行可链接格式" class="headerlink" title="1.可执行可链接格式"></a>1.可执行可链接格式</h2><p>首先，我们考虑什么是文件系统（File System)上的文件。我们知道，文件都是持久地储存在磁盘等设备上的，但它的实质仍然是二进制序列。只要我们对序列进行恰当的描述，我们就可以获得想要的全部信息。为了将某一文件的二进制串与其他文件的二进制串区别开，我们需要指定这一文件的类型与大小等信息，这些信息存放在文件二进制串的起始地址，也即首部（Header)。</p><h3 id="1-1-ELF-Header"><a href="#1-1-ELF-Header" class="headerlink" title="1.1 ELF Header"></a>1.1 ELF Header</h3><p>对于ELF，首部的信息包括文件类型、机器类型等信息。在Linux读取ELF文件时，Linux将ELF Header从Byte翻译为内存中的数据结构：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405210514169.png" alt="image-20230405210514169" style="zoom:80%;"><p>数据结构<strong>Elf64_Ehdr</strong>包含了很多信息，但对我们而言，我们只需要知道Header 是如何定位到节头表( Section Header Table,SHT)的。Header中的 Elf64_Ehdr.e_shoff 是SHT对ELF起始地址的Byte偏置，Elf64_Ehdr.e_shentsize描述SHT每一项的Byte大小，Elf64_Ehdr.e_shentnum 描述 SHT描述表项的数量，这样，我们就可以通过后两项计算出SHT的大小。Header中的Elf64_Ehdr.e_shstrndx则是SHT中一个特殊节<strong>字符串</strong>表的段索引，Header可以借此计算ELF中每一项的字符串。</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405210554302.png" alt="image-20230405210554302" style="zoom: 80%;"><p>我们举一个例子，使我们洞见ELF文件的数据结构，考虑如下的elf.c源文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> data1 = <span class="hljs-number">0xdddddddd11111111</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> data2 = <span class="hljs-number">0xdddddddd22222222</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span> &#123;&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><p>使用gcc编译得到它的ELF文件：<code>gcc -c elf.c -o elf.o</code>，其中-c的含义是仅编译源文件生成ELF文件，但不对ELF文件进行链接。生成ELF文件以后，利用hexdump查看ELF文件<code>elf.o</code>的内容。</p><p>hexdump获得elf.o的二进制内容后，按照Elf64_Ehdr的结构格式，我们可以解读ELF的Header。首先，我们可以计算得到sizeof(Elf64_Ehdr) &#x3D; 64Byte，因此Header占据ELF文件的低64Byte。这样我们就得到了elf.o的Header：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405211548347.png" alt="image-20230405211548347" style="zoom:80%;"><p>起始位置的16Bytes为 Magic Number,在这之后偏移2+2+4+8+8&#x3D;24Bytes,大小为8Bytes的数据为Elf64_Ehdr.e_shoff，也即SHT起始地址对ELF文件的偏移，数值为 0x00000000000002b0。在这之后，对Elf64_Ehdr.e_shoff偏移为4Bytes 的位置储存了ELF文件Header的大小：Elf64_Ehdr.e_ehsize &#x3D;0x0040。再之后2+2&#x3D;4 Bytes即 Elf64_Ehdr.e_shentsize，也即为SHT每一项的大小，数值为0x0040。最后两个2Bytes的数分别是 Elf64_Ehdr.e_shnum &#x3D; 0x000b以及Elf64_Ehdr.e_shstrndx &#x3D; 0x000a。</p><h3 id="1-2-节头表SHT"><a href="#1-2-节头表SHT" class="headerlink" title="1.2 节头表SHT"></a>1.2 节头表SHT</h3><p>SHT描述了ELF中不同的<strong>节(Section)<strong>，包括</strong>数据节(.data)<strong>、</strong>代码节(.text）</strong>等。这些Section中的数据是由编译器生成的，按照Section 的组织写入到磁盘上的ELF文件中。SHT的每一项可以被数据结构Elf64_Shdr所描：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405212130069.png" alt="image-20230405212130069" style="zoom: 80%;"><p>这样，我们可以通过SHT找到ELF内的任一Section，常见的Section有.text，.data，.rodata，.bss，.symtab，.rel.txt，.rel.data，.strtab，它们可以被Elf64_Shdr.sh_name确定：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405212311898.png" alt="image-20230405212311898" style="zoom:80%;"><p>在elf.o的Header中，我们可以发现SHT距离ELF文件的起始位置偏移为688Byte，并且每一项的大小为64Byte，共11项，那么我们可以找到SHT对应的二进制段。但由于这段代码太长了，因此只截取了.text和.data这两节：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405212446493.png" alt="image-20230405212446493"><p>和解析Header一样，对于SHT的每一个表项，按照结构Elf64_Shdr 逐个 Byte解析，我们就得到了.text对 ELF文件的偏移: .sh_offset &#x3D; 0x0000000000000040【.data对ELF文件的偏移为0x0000000000000050】。回忆起我们先前得知Header 的大小就是0x40，也即64 Bytes，因此.text所处的位置正是Header之后。并且，它的大小为.sh_size &#x3D;0x000000000000000e【实际上为了对齐，会进行补零】，就说明func1()与 func2()两个函数占据了14 Bytes(但目前我们并不知道每一个函数的真正位置)。对于.data，我们可以同样进行解析。readelf -s elf.o 会给我们相同的结论（我们省略了其他表项)。</p><p>值得一提的是，SHT中总存在[o]项，它被视为未定义的符号所在Section，SHN_UNDEF，也就是0。同时，这一SHT表项的值总是64 Bytes的0:</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405212718033.png" alt="image-20230405212718033" style="zoom:80%;"><h3 id="1-3-符号表"><a href="#1-3-符号表" class="headerlink" title="1.3 符号表"></a>1.3 符号表</h3><p>最后，我们要定位到每一个符号在ELF中所处的位置，这就需要一个特别的Section，<code>symtab</code>，也就是<strong>符号表</strong>(Symbol Table)。符号表被用来描述.c源文件中可以<strong>被其他ELF使用的符号</strong>。对于什么是符号Symbol，其实有必要先从编译器的角度去观察.c源文件。这部分工作主要是编译中语义分析(Semantic Analysis)的过程，通过语法中的环境(Environment)和范围(Scope)来进行管理。其中Environment映射在编译器中也被称为符号表，我们很快便能发现<strong>编译和链接语境下的符号表其实是含义相同的</strong>。</p><p>考虑赋值语句<code>int a = 0xaaaaaaaa</code>，在这里，终结符a就是我们通常所说的左值，其实它会被处理为一个字符串；终结符0xaaaaaaaa是我们所说的右值，被处理为数值。当我们在在.c源文件中引用终结符a时，其实做了两部映射(Two-Stage Mapping)；</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405192412069.png" alt="image-20230405192412069" style="zoom:67%;"><p>在C语言中，每一个对象（函数、变量）有它可见的Scope，也就是说在Scope内，这个对象是可以被引用的。而在不同的Scope内，Environment未必相同。我们仔细考虑C语言的语法，很容易发现源文件可以被区分为不同的**块(Block)**，它们通常被一组花括号<code>&#123;&#125;</code>所包围，天然地对应一颗有关Block的树（考虑最外层为根节点）。</p><p>假设当前有一个<code>.c</code>文件，其源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> g_var_init = <span class="hljs-number">0xffffffff</span>;<br><span class="hljs-type">int</span> g_var_uninit;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_undef</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func_def</span><span class="hljs-params">(<span class="hljs-type">int</span> func_param)</span><br>&#123;<br>    <span class="hljs-type">int</span> func_var = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> <br>    &#123;<br>        <span class="hljs-type">int</span> loop_var = <span class="hljs-number">1</span>;<br>        func_var += <span class="hljs-number">1</span>;<br>        g_var_init += <span class="hljs-number">1</span>;<br>        <br>        func_undef();<br>    &#125; <span class="hljs-keyword">while</span> (func_var &lt; func_param)<br>&#125;<br><br>voud <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    func_def();<br>&#125;<br></code></pre></td></tr></table></figure><p>相应的，考虑它的Block树，以及每一个Block内可见的对象：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405193201163.png" alt="image-20230405193201163" style="zoom: 80%;"><p>我们可以发现，每当进入一个sub-block以前，sub-block会复制当前block的environment，同时，在sub-block以内，新定义的变量、传入函数的参数，也都会被视为在sub-block内新的映射。因此，我们在进入新的sub-block时，可以更新Environment，从而实现了对Environment的维护。</p><p>我们已知<strong>C语言不允许在函数内定义函数</strong>，这个简单的事实将整个.c源文件分为扁平的两层：<strong>函数内部（Internal）、函数外部（External）</strong>，如下图。我们已知函数Scope内的数据实在Run-Time Stack上分配的，因此函数内Scope的Enviroment映射到栈。而函数外部，也就是函数本身以及全局变量，他们的Environment需要我们额外维护，这也就是编译器在ELF文件中生成的符号表。</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405193923601.png" alt="image-20230405193923601" style="zoom:80%;"><p>因此,<strong>外部</strong>的函数与变量是<strong>对链接可见的</strong>，也因此它们能够被其他ELF文件所引用。这就是我们在链接时所说的符号——一个函数(Function)，一个全局变量(Global Variable)，或一个静态变量(Static Variable)。</p><p>根据我们对符号的理解，按照定义和引用，可以将符号分为以下三种类型。假定source1.c是我们当前可见的源文件，source2.c是被链接的ELF的源文件。</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405195017042.png" alt="image-20230405195017042" style="zoom:80%;"><p>其中被static修饰的，被称为局部符号(Local Symbol〉或静态符号(Static Symbol)，只对同一源文件中的函数可见。在本地有定义，但没有被static修饰的，是普通的全局符号(Global Symbol)，对链接中所有的源文件可见。被<strong>extern</strong>修饰的，说明在当前的源文件中没有定义，而只在 extern 处有声明，方便当前源文件中的函数对它进行引用。</p><p>全局符号  我们考察elf.o中的例子，data1与data2是作为变量的符号，func1与func2是作为函数的符号，它们是典型的全局符号。我们来观察全局符号是怎样在ELF被找到的。从ELF Header计算偏移量到Section Header Table，当我们读取到表项为<code>.symtab</code>时，就开始处理符号表，符号表表项的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include\uapi\linux\elf.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf64_sym</span> &#123;</span><br>  Elf64_Word st_name;<span class="hljs-comment">/* Symbol name, index in string tbl */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_info;<span class="hljs-comment">/* Type and binding attributes */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_other;<span class="hljs-comment">/* No defined meaning, 0 */</span><br>  Elf64_Half st_shndx;<span class="hljs-comment">/* Associated section index */</span><br>  Elf64_Addr st_value;<span class="hljs-comment">/* Value of the symbol */</span><br>  Elf64_Xword st_size;<span class="hljs-comment">/* Associated symbol size */</span><br>&#125; Elf64_Sym;<br></code></pre></td></tr></table></figure><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405195558160.png" alt="image-20230405195558160" style="zoom: 80%;"><p>查看SHT</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405195628645.png" alt="image-20230405195628645" style="zoom:60%;"><p><code>.symtab</code>时elf.o SHT中的 [8] 表项，它对于ELF文件的偏移为 0x000000e0，占据0x120Byte，并且.symtab中的每一个元素都有固定的大小，Elf64_Shdr.sh_entrsize &#x3D; 0x0000000000000018。</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405195923966.png" alt="image-20230405195923966" style="zoom: 67%;"><p>这样，我们可以计算得到.symtab一共有12项。并且四项关于data1，data2，func1，func2：</p><p>通过<code>hexdump -C elf.o</code>后，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs shell">00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|<br>00000010  01 00 3e 00 01 00 00 00  00 00 00 00 00 00 00 00  |..&gt;.............|<br>00000020  00 00 00 00 00 00 00 00  a8 02 00 00 00 00 00 00  |................|<br>00000030  00 00 00 00 40 00 00 00  00 00 40 00 0b 00 0a 00  |....@.....@.....|<br>00000040  55 48 89 e5 90 5d c3 55  48 89 e5 90 5d c3 00 00  |UH...].UH...]...|<br>00000050  11 11 11 11 dd dd dd dd  22 22 22 22 dd dd dd dd  |........&quot;&quot;&quot;&quot;....|<br>00000060  00 47 43 43 3a 20 28 55  6f 73 20 38 2e 33 2e 30  |.GCC: (Uos 8.3.0|<br>00000070  2e 33 2d 33 2b 72 65 62  75 69 6c 64 29 20 38 2e  |.3-3+rebuild) 8.|<br>00000080  33 2e 30 00 00 00 00 00  14 00 00 00 00 00 00 00  |3.0.............|<br>00000090  01 7a 52 00 01 78 10 01  1b 0c 07 08 90 01 00 00  |.zR..x..........|<br>000000a0  1c 00 00 00 1c 00 00 00  00 00 00 00 07 00 00 00  |................|<br>000000b0  00 41 0e 10 86 02 43 0d  06 42 0c 07 08 00 00 00  |.A....C..B......|<br>000000c0  1c 00 00 00 3c 00 00 00  00 00 00 00 07 00 00 00  |....&lt;...........|<br>000000d0  00 41 0e 10 86 02 43 0d  06 42 0c 07 08 00 00 00  |.A....C..B......|<br>000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>000000f0  00 00 00 00 00 00 00 00  01 00 00 00 04 00 f1 ff  |................|<br>00000100  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000110  00 00 00 00 03 00 01 00  00 00 00 00 00 00 00 00  |................|<br>00000120  00 00 00 00 00 00 00 00  00 00 00 00 03 00 02 00  |................|<br>00000130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000140  00 00 00 00 03 00 03 00  00 00 00 00 00 00 00 00  |................|<br>00000150  00 00 00 00 00 00 00 00  00 00 00 00 03 00 05 00  |................|<br>00000160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000170  00 00 00 00 03 00 06 00  00 00 00 00 00 00 00 00  |................|<br>00000180  00 00 00 00 00 00 00 00  00 00 00 00 03 00 04 00  |................|<br>00000190  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>000001a0  07 00 00 00 11 00 02 00  00 00 00 00 00 00 00 00  |................|<br>000001b0  08 00 00 00 00 00 00 00  0d 00 00 00 11 00 02 00  |................|<br>000001c0  08 00 00 00 00 00 00 00  08 00 00 00 00 00 00 00  |................|<br>000001d0  13 00 00 00 12 00 01 00  00 00 00 00 00 00 00 00  |................|<br>000001e0  07 00 00 00 00 00 00 00  19 00 00 00 12 00 01 00  |................|<br>000001f0  07 00 00 00 00 00 00 00  07 00 00 00 00 00 00 00  |................|<br>00000200  00 65 6c 66 2e 63 00 64  61 74 61 31 00 64 61 74  |.elf.c.data1.dat|<br>00000210  61 32 00 66 75 6e 63 31  00 66 75 6e 63 32 00 00  |a2.func1.func2..|<br>00000220  20 00 00 00 00 00 00 00  02 00 00 00 02 00 00 00  | ...............|<br>00000230  00 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  |........@.......|<br>00000240  02 00 00 00 02 00 00 00  07 00 00 00 00 00 00 00  |................|<br>00000250  00 2e 73 79 6d 74 61 62  00 2e 73 74 72 74 61 62  |..symtab..strtab|<br>00000260  00 2e 73 68 73 74 72 74  61 62 00 2e 74 65 78 74  |..shstrtab..text|<br>00000270  00 2e 64 61 74 61 00 2e  62 73 73 00 2e 63 6f 6d  |..data..bss..com|<br>00000280  6d 65 6e 74 00 2e 6e 6f  74 65 2e 47 4e 55 2d 73  |ment..note.GNU-s|<br>00000290  74 61 63 6b 00 2e 72 65  6c 61 2e 65 68 5f 66 72  |tack..rela.eh_fr|<br>000002a0  61 6d 65 00 00 00 00 00  00 00 00 00 00 00 00 00  |ame.............|<br>000002b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>000002e0  00 00 00 00 00 00 00 00  1b 00 00 00 01 00 00 00  |................|<br>000002f0  06 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000300  40 00 00 00 00 00 00 00  0e 00 00 00 00 00 00 00  |@...............|<br>00000310  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>00000320  00 00 00 00 00 00 00 00  21 00 00 00 01 00 00 00  |........!.......|<br>00000330  03 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000340  50 00 00 00 00 00 00 00  10 00 00 00 00 00 00 00  |P...............|<br>00000350  00 00 00 00 00 00 00 00  08 00 00 00 00 00 00 00  |................|<br>00000360  00 00 00 00 00 00 00 00  27 00 00 00 08 00 00 00  |........&#x27;.......|<br>00000370  03 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000380  60 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |`...............|<br>00000390  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>000003a0  00 00 00 00 00 00 00 00  2c 00 00 00 01 00 00 00  |........,.......|<br>000003b0  30 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |0...............|<br>000003c0  60 00 00 00 00 00 00 00  24 00 00 00 00 00 00 00  |`.......$.......|<br>000003d0  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>000003e0  01 00 00 00 00 00 00 00  35 00 00 00 01 00 00 00  |........5.......|<br>000003f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000400  84 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000410  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>00000420  00 00 00 00 00 00 00 00  4a 00 00 00 01 00 00 00  |........J.......|<br>00000430  02 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000440  88 00 00 00 00 00 00 00  58 00 00 00 00 00 00 00  |........X.......|<br>00000450  00 00 00 00 00 00 00 00  08 00 00 00 00 00 00 00  |................|<br>00000460  00 00 00 00 00 00 00 00  45 00 00 00 04 00 00 00  |........E.......|<br>00000470  40 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |@...............|<br>00000480  20 02 00 00 00 00 00 00  30 00 00 00 00 00 00 00  | .......0.......|<br>00000490  08 00 00 00 06 00 00 00  08 00 00 00 00 00 00 00  |................|<br>000004a0  18 00 00 00 00 00 00 00  01 00 00 00 02 00 00 00  |................|<br>000004b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>000004c0  e0 00 00 00 00 00 00 00  20 01 00 00 00 00 00 00  |........ .......|<br>000004d0  09 00 00 00 08 00 00 00  08 00 00 00 00 00 00 00  |................|<br>000004e0  18 00 00 00 00 00 00 00  09 00 00 00 03 00 00 00  |................|<br>000004f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000500  00 02 00 00 00 00 00 00  1f 00 00 00 00 00 00 00  |................|<br>00000510  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>00000520  00 00 00 00 00 00 00 00  11 00 00 00 03 00 00 00  |................|<br>00000530  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000540  50 02 00 00 00 00 00 00  54 00 00 00 00 00 00 00  |P.......T.......|<br>00000550  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>*<br>00000568<br></code></pre></td></tr></table></figure><p><strong>以data1为例，介绍其在符号表中的各种含义：</strong></p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405200137407.png" alt="image-20230405200137407" style="zoom:80%;"><ul><li>根据Elf64_Sym.st_name可以查到符号在字符表中的名字，st_name&#x3D;0x7，从字符串表偏移0x7Byte，直到遇到第一个字符串终结符00(<code>\0</code>)，所得到的字符串为：<u>64 61 74 61 31 00</u>，转译为ASCII码的字符为’d’,’a’,’t’,’a’,’1’,’\0’。</li></ul><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405200642983.png" alt="image-20230405200642983" style="zoom:80%;"><ul><li>符号data1的Section索引为Elf64_Sym.st_index &#x3D; 0x2，那么在SHT中，编号为[2] 的表项是 <code>.data</code>节，因此我们确定了data1所在的Section。再根据Elf64_Sym.st_value&#x3D;0x0，我们知道data1对<code>.data</code>节的偏移为0，到此为止是Environment映射。由符号表，我们得到data1占据Elf64_Sym.st_size &#x3D; 0x8 Byte。至此，我们也完成了Type的映射，可以获得data1的数值了：【.data节的偏移量为0x50，且data1对.data偏移为0，data1数值占据8字节】</li></ul><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405201014924.png" alt="image-20230405201014924" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>操作系统,编译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux模块加载时的版本检查机制</title>
    <link href="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux模块加载时的版本检查机制"><a href="#Linux模块加载时的版本检查机制" class="headerlink" title="Linux模块加载时的版本检查机制"></a>Linux模块加载时的版本检查机制</h1><blockquote><p>参考：<a href="https://www.jb51.cc/python/3860648.html">https://www.jb51.cc/python/3860648.html</a></p></blockquote><p>Linux 的迅速发展致使相邻版本的内核之间亦存在较大的差异，即在版本补丁号（Patch Level，即内核版本号的第四位数）相邻的内核之间。为此 Linux 的开发者为了保证内核的稳定，Linux 在加载模块到内核时对模块采用了版本校验机制。当被期望加载模块的系统环境与模块的构建环境相左时，通常会出现如清单 1 所示的装载模块失败。</p><h2 id="1-模块加载校验失败"><a href="#1-模块加载校验失败" class="headerlink" title="1.模块加载校验失败"></a>1.模块加载校验失败</h2><p>首先，我们看一下当模块加载时候的报错信息：</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402204428316.png" alt="image-20230402204428316" style="zoom:100%;"><p>模块 hello.ko 构建时的环境与当前系统不一致，导致工具 insmod 在尝试装载模块 hello.ko 到内核时失败。hello.ko 是一个仅使用了函数 printk 的普通模块（。我们通过命令 dmesg获取模块装载失败的具体原因。从日志打印的<code>disagree about version of sysmbol module layout</code>可以看出，模块 hello.ko 装载失败是由于<strong>模块中 module_layout 的导出符号的版本信息与当前内核中的不符</strong>。</p><p>函数 module_layout 被定义在内核模块版本选项 MODVERSIONS（即内核可装载模块的版本校验选项）之后。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># kernel\module.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MODVERSIONS</span><br><span class="hljs-comment">/* Generate the signature for all relevant module structures here.</span><br><span class="hljs-comment"> * If these change, we don&#x27;t want to try to parse the module. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">module_layout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> module *mod,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> modversion_info *ver,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> kernel_param *kp,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> kernel_symbol *ks,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> tracepoint * <span class="hljs-type">const</span> *tp)</span><br>&#123;<br>&#125;<br>EXPORT_SYMBOL(module_layout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>那么我们如何比对内核的module_layout 和 外部模块的module_layout值呢？</p><h3 id="1-1-比对内核与模块module-layout的CRC"><a href="#1-1-比对内核与模块module-layout的CRC" class="headerlink" title="1.1 比对内核与模块module_layout的CRC"></a>1.1 比对内核与模块module_layout的CRC</h3><p>内核的<code>module_layout</code>的CRC值，我们可以通过内核编译的<code>Module.symvers</code>文件进行查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat Module.symvers | grep module_layout<br></code></pre></td></tr></table></figure><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402194808674.png" alt="image-20230402194808674" style="zoom:100%;"><p>外部模块<code>module_layout</code>的CRC值，我们可以通过modprode查看编译出的ko文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">modprobe --dump-versions xxx.ko | grep module_layout<br></code></pre></td></tr></table></figure><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402194909699.png" alt="image-20230402194909699" style="zoom:100%;"><blockquote><p>可以看到内核与外部模块的module_layout值是一样的，所以我们可以通过<strong>insmod或者modprobe加载chrdevbase.ko</strong></p></blockquote><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/8d71df88-4caa-436c-b5eb-72d2a53f2b31.png"><h3 id="1-2-Linux对于模块的两层检验"><a href="#1-2-Linux对于模块的两层检验" class="headerlink" title="1.2 Linux对于模块的两层检验"></a>1.2 Linux对于模块的两层检验</h3><p>inux 对可装载模块采取了两层验证：<strong>模块的 CRC 值校验</strong>和 <strong>vermagic 的检查</strong>。</p><p>其中模块 CRC 值校验针对模块（内核）导出符号，是一种简单的 ABI（即 Application Binary Interface）一致性检查，第一节开头的 hello.ko 加载失败的根本原因就是没有通过 CRC 值校验（即 module_layout 的 CRC 值与当前内核中的不符）。</p><p>而模块 vermagic（即 Version Magic String）则保存了模块编译时的内核版本以及 SMP 等配置信息，当模块 vermagic 与主机信息不相符时亦将终止模块的加载。</p><h2 id="2-模块的CRC值校验"><a href="#2-模块的CRC值校验" class="headerlink" title="2.模块的CRC值校验"></a>2.模块的CRC值校验</h2><p>首先我们了解一下CTC值校验在哪里添加，又是如何进行校验的</p><h3 id="2-1-添加模块的CRC值"><a href="#2-1-添加模块的CRC值" class="headerlink" title="2.1 添加模块的CRC值"></a>2.1 添加模块的CRC值</h3><p>当我们在编译内核模块时，会生成许多的中间文件：</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402205606535.png" alt="image-20230402205606535" style="zoom:80%;"><p>其中<strong>chrdevbase.mod.c</strong>是在模块源文件chrdevbase.c基础上进行的扩展，其内容如下：</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402205711705.png" alt="image-20230402205711705" style="zoom:67%;"><blockquote><p>🤺 <strong>注意</strong>：这里红色圈出来的就是各个符号，前面的16进制数字就是每个符号对应的CRC值。可以看到，module_layout对应的CRC值就是0xfa985410，与1.1节看到的是一样的！</p></blockquote><p>那么chrdevbase.mod.c在生成的过程中， 会调用modpost添加各种信息，其中有一步就是添加版本值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// scripts\mod\modpost.h</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">for</span> (mod = modules; mod; mod = mod-&gt;next) &#123;<br>err |= add_versions(&amp;buf, mod);<br>&#125;<br><br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add_versions</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buffer *b, <span class="hljs-keyword">struct</span> module *mod)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> *<span class="hljs-title">s</span>, *<span class="hljs-title">exp</span>;</span><br><span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (s = mod-&gt;unres; s; s = s-&gt;next) &#123;<br><span class="hljs-built_in">exp</span> = find_symbol(s-&gt;name);<br>s-&gt;module = <span class="hljs-built_in">exp</span>-&gt;module;<br>s-&gt;crc_valid = <span class="hljs-built_in">exp</span>-&gt;crc_valid;<br>s-&gt;crc = <span class="hljs-built_in">exp</span>-&gt;crc;<br>&#125;<br><br>buf_printf(b, <span class="hljs-string">&quot;\n&quot;</span>);<br>buf_printf(b, <span class="hljs-string">&quot;static const struct modversion_info ____versions[]\n&quot;</span>);<br>buf_printf(b, <span class="hljs-string">&quot;__used\n&quot;</span>);<br>buf_printf(b, <span class="hljs-string">&quot;__attribute__((section(\&quot;__versions\&quot;))) = &#123;\n&quot;</span>);<br><br><span class="hljs-keyword">for</span> (s = mod-&gt;unres; s; s = s-&gt;next) &#123;<br><span class="hljs-keyword">if</span> (!s-&gt;module)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (!s-&gt;crc_valid) &#123;<br>warn(<span class="hljs-string">&quot;\&quot;%s\&quot; [%s.ko] has no CRC!\n&quot;</span>,<br>s-&gt;name, mod-&gt;name);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>        <span class="hljs-comment">// 添加各个符号SYSBOL对应的CRC值</span><br>buf_printf(b, <span class="hljs-string">&quot;\t&#123; %#8x, __VMLINUX_SYMBOL_STR(%s) &#125;,\n&quot;</span>, s-&gt;crc, s-&gt;name);<br>&#125;<br><br>buf_printf(b, <span class="hljs-string">&quot;&#125;;\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>哇哦，从这里可以清晰的看到，最终生成的chrdevbase.mod.c【或chrdevbase.ko】是通过add_version添加的。</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402210324480.png" alt="image-20230402210324480" style="zoom:80%;"><h3 id="2-2-通过objdump反汇编后查看versions的值"><a href="#2-2-通过objdump反汇编后查看versions的值" class="headerlink" title="2.2 通过objdump反汇编后查看versions的值"></a>2.2 通过objdump反汇编后查看versions的值</h3><p>我们在上述<code>cat chrdevbase.mod.c</code>中可以看到几个section，如 .modinfo、.gnu.linkonce.this_module 和 __versions。<u>Linux 使用 GCC 中的声明函数属性 <code>__attribute__ </code>完成对模块的版本信息附加</u>。</p><p>通过<code>objdump --section=__versions -s chrdevbase.ko</code>的值查看当前模块的版本version值</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402211313240.png" alt="image-20230402211313240" style="zoom:50%;"><p>可以看到当前模块的module_layout也匹配上了，另外的几个值，如<code>__unregister_chrdev</code>也对应了上述的CRC值</p><h3 id="2-3-加载模块的过程中何时检验CRC"><a href="#2-3-加载模块的过程中何时检验CRC" class="headerlink" title="2.3 加载模块的过程中何时检验CRC"></a>2.3 加载模块的过程中何时检验CRC</h3><p>🥇🥈🥉 <strong>模块 CRC 值校验查看的是就是模块 __versions 小节的内容，模块的 CRC 校验过程在函数 setup_load_info 中完成</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel\module.c</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> module *<span class="hljs-title function_">setup_load_info</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> load_info *info, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-comment">/* Check module struct version now, before we try to use module. */</span><br><span class="hljs-keyword">if</span> (!check_modstruct_version(info-&gt;sechdrs, info-&gt;index.vers, mod))<br><span class="hljs-keyword">return</span> ERR_PTR(-ENOEXEC);<br><br><span class="hljs-keyword">return</span> mod;<br>&#125;<br><br><span class="hljs-comment">//--------------------------------------------------------</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_modstruct_version</span><span class="hljs-params">(Elf_Shdr *sechdrs, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> versindex, <span class="hljs-keyword">struct</span> module *mod)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *crc;<br><br><span class="hljs-keyword">if</span> (!find_symbol(VMLINUX_SYMBOL_STR(module_layout), <span class="hljs-literal">NULL</span>,&amp;crc, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>))<br>        BUG();<br><span class="hljs-keyword">return</span> check_version(sechdrs, versindex, VMLINUX_SYMBOL_STR(module_layout), mod, crc, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">//--------------------------------------------------------</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_version</span><span class="hljs-params">(Elf_Shdr *sechdrs, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> versindex, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *symname, <span class="hljs-keyword">struct</span> module *mod, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *crc, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> module *crc_owner)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i, num_versions;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">modversion_info</span> *<span class="hljs-title">versions</span>;</span><br><br><br>versions = (<span class="hljs-type">void</span> *) sechdrs[versindex].sh_addr;<br>num_versions = sechdrs[versindex].sh_size / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> modversion_info);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_versions; i++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(versions[i].name, symname) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-keyword">if</span> (versions[i].crc == maybe_relocated(*crc, crc_owner))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>pr_debug(<span class="hljs-string">&quot;Found checksum %lX vs module %lX\n&quot;</span>,<br>       maybe_relocated(*crc, crc_owner), versions[i].crc);<br><span class="hljs-keyword">goto</span> bad_version;<br>&#125;<br><br>pr_warn(<span class="hljs-string">&quot;%s: no symbol version for %s\n&quot;</span>, mod-&gt;name, symname);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>bad_version:<br>pr_warn(<span class="hljs-string">&quot;%s: disagrees about version of symbol %s\n&quot;</span>,<br>       mod-&gt;name, symname);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我的天，终于看到了第1节报错的报错的来源啦！</strong></p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402213008474.png" alt="image-20230402213008474" style="zoom:80%;"><h3 id="2-4-为什么module-layout导出的符号会发生变化"><a href="#2-4-为什么module-layout导出的符号会发生变化" class="headerlink" title="2.4 为什么module_layout导出的符号会发生变化"></a>2.4 为什么module_layout导出的符号会发生变化</h3><p>根据附录2，我们知道了导出的符号如果是函数时，如果CRC值发生了改变，可能是<strong>参数变化</strong>或者<strong>返回值变化</strong>。</p><p>因此，我们将<strong>module_layout</strong>的参数进行变化，编译后查看其CRC值</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230405235046404.png" alt="image-20230405235046404" style="zoom: 50%;"><blockquote><p>我们在参数中添加了<code>int num</code>，发现值变化成了<code>0x5d01a2ac</code></p></blockquote><p>将<strong>module_layout</strong>的参数恢复成原样，重新编译</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230405235204648.png" alt="image-20230405235204648" style="zoom:50%;"><blockquote><p>可以看到又恢复成了原来的1.1节中的值</p></blockquote><h3 id="2-5-module-layout-完全一样的两份kernel代码，生成CRC值不一样？"><a href="#2-5-module-layout-完全一样的两份kernel代码，生成CRC值不一样？" class="headerlink" title="2.5 module_layout 完全一样的两份kernel代码，生成CRC值不一样？"></a>2.5 module_layout 完全一样的两份kernel代码，生成CRC值不一样？</h3><p>当我们在module.c中<code>EXPORT_SYMBOL(module_layout)</code>之后，在编译阶段，宏会被替换成下面的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include\linux\export.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __CRC_SYMBOL(sym, sec)\</span><br><span class="hljs-meta">extern __visible void *__crc_##sym __attribute__((weak));\</span><br><span class="hljs-meta">static const unsigned long __kcrctab_##sym\</span><br><span class="hljs-meta">__used\</span><br><span class="hljs-meta">__attribute__((section(<span class="hljs-string">&quot;___kcrctab&quot;</span> sec <span class="hljs-string">&quot;+&quot;</span> #sym), unused))\</span><br><span class="hljs-meta">= (unsigned long) &amp;__crc_##sym;</span><br><br><span class="hljs-comment">/* For every exported symbol, place a struct in the __ksymtab section */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __EXPORT_SYMBOL(sym, sec)\</span><br><span class="hljs-meta">extern typeof(sym) sym;\</span><br><span class="hljs-meta">__CRC_SYMBOL(sym, sec)\</span><br><span class="hljs-meta">static const char __kstrtab_##sym[]\</span><br><span class="hljs-meta">__attribute__((section(<span class="hljs-string">&quot;__ksymtab_strings&quot;</span>), aligned(1))) \</span><br><span class="hljs-meta">= VMLINUX_SYMBOL_STR(sym);\</span><br><span class="hljs-meta">extern const struct kernel_symbol __ksymtab_##sym;\</span><br><span class="hljs-meta">__visible const struct kernel_symbol __ksymtab_##sym\</span><br><span class="hljs-meta">__used\</span><br><span class="hljs-meta">__attribute__((section(<span class="hljs-string">&quot;___ksymtab&quot;</span> sec <span class="hljs-string">&quot;+&quot;</span> #sym), unused))\</span><br><span class="hljs-meta">= &#123; (unsigned long)&amp;sym, __kstrtab_##sym &#125;</span><br></code></pre></td></tr></table></figure><p>EXPORT_SYMBOL(sym)的这一段代码，其实就是针对模块版本校验机制，生成了某个符号相应的3个段的值。段<code>__ksymtab</code>保存了符号的地址和名字，段<code>__ksymtab_strings</code>是段名字的实际存储位置，段<code>__kcrctab</code>保存了符号crc值的地址。</p><p>可见EXPORT_SYMBOL(sym)宏声明以后，符号的地址名字和CRC值都有了，已经符合版本校验的需要了。可还有一个疑问，符号实际的crc值是怎么生成的呢？宏中引用了一个外部变量<code>extern void *__crc_##sym attribute((weak));</code>，<code>__crc##sym</code>是怎么来的？</p><p>__crc##sym是在编译.o时候做的，查看内核的makefile，makefile.build文件定义了.o的生成规则：<br><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230406225635425.png" alt="image-20230405235204648" style="zoom: 67%;"></p><p>而当CONFIG_MODVERSIONS&#x3D;y 时， cmd_cc_o_c 会将file.c 编译成.tmp_file.o而不是file.o 。cmd_modversions 会检查.tmp_file.o 是否包含<code>__ksymtab</code> ，也就是说file.c 是否包含EXPORT_SYMBOL(xxx)；如果没有__ksymtab ， cmd_modversions 会将.tmp_file.o 直接更名为file.o 。如果确实包含__ksymtab ， cmd_modversions 会通过genksyms 产生xxxx ( export symbol )的符号签名( checksum )，然后调用linker 重新把这些符号以及这些符号的checksum链接进file.o。</p><p>可见符号的CRC值_crc##sym，是在编译.o时，由genksyms脚本生成的。</p><p>通过readelf命令可以，查看内核中关于版本检查的三个段<code>__ksymtab</code>、<code>__ksymtab_strings</code>、<code>__kcrctab</code>：</p><p><img src="/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230406231443917.png" alt="image-20230406231443917"></p><p>如果module_layout在符号表中地址不同，则编译生成后期对应的CRC值是不同的！！</p><p>🤖 <strong>如果两份完全一样的module_layout代码，但是生成的CRC值不同</strong>  -&gt; 那么，必定是module_layout在符号表中的位置不同，也就是在module_layout之前肯定EXPORT_SYMBOL了其他的符号，导致module_layout在对应的符号表中位置不同</p><h2 id="3-模块的vermagic检验"><a href="#3-模块的vermagic检验" class="headerlink" title="3.模块的vermagic检验"></a>3.模块的vermagic检验</h2><h3 id="3-1-内核版本是如何生成的"><a href="#3-1-内核版本是如何生成的" class="headerlink" title="3.1 内核版本是如何生成的"></a>3.1 内核版本是如何生成的</h3><p>inux版本：在<code>include/generated/utsrelease.h</code>中定义，文件中的内容如下：**#define UTS_RELEASE “4.1.15”**，utsrelease.h是kernel编译后自动生成的，用户更改里面的内容不会有效果。</p><h3 id="3-2-模块的vermagic是如何生成的"><a href="#3-2-模块的vermagic是如何生成的" class="headerlink" title="3.2 模块的vermagic是如何生成的"></a>3.2 模块的vermagic是如何生成的</h3><p>在<code>include/linux/vermagic.h</code>中定义有VERMAGIC_STRING，VERMAGIC_STRING不仅包含内核版本号，还包含有 内核使用的gcc版本，SMP与PREEMPT等配置信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> VERMAGIC_STRING \</span><br><span class="hljs-meta">UTS_RELEASE <span class="hljs-string">&quot; &quot;</span>\</span><br><span class="hljs-meta">MODULE_VERMAGIC_SMP MODULE_VERMAGIC_PREEMPT \</span><br><span class="hljs-meta">MODULE_VERMAGIC_MODULE_UNLOAD MODULE_VERMAGIC_MODVERSIONS\</span><br><span class="hljs-meta">MODULE_ARCH_VERMAGIC</span><br></code></pre></td></tr></table></figure><p>模块在编译时，我们可以看到屏幕上会显示”MODPOST”。在此阶段，VERMAGIC_STRING会添加到模块的modinfo段。在内核源码目录下scripts\mod\modpost.c文件中可以看到模块后续处理部分的代码。</p><p>模块编译生成后，通过<code>modinfo xxx.ko</code>命令可以查看此模块的vermagic等信息。</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230406233259580.png" alt="image-20230406233259580" style="zoom: 80%;"><h3 id="3-3-如何校验模块的vermagic"><a href="#3-3-如何校验模块的vermagic" class="headerlink" title="3.3 如何校验模块的vermagic"></a>3.3 如何校验模块的vermagic</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* kernel/module.c */</span> <br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_modinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> module *mod,<span class="hljs-keyword">struct</span> load_info *info)</span> <br>&#123; <br> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *modmagic = get_modinfo(info,<span class="hljs-string">&quot;vermagic&quot;</span>); <br> ... <br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!same_magic(modmagic,vermagic,info-&gt;index.vers)) &#123; <br>   ... <br> &#125; <br> ... <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="附录1：module-symvers-文件的内容"><a href="#附录1：module-symvers-文件的内容" class="headerlink" title="附录1：module.symvers 文件的内容"></a>附录1：module.symvers 文件的内容</h2><p>如果打开该文件后看到的符号CRC值都是0x00000000，那是因为你在配置的时并没有设置 <code>CONFIG_MODVERSIONS</code>。一旦设置过这个配置选项，就意味着打开了内核的 <strong>Module versioning</strong>功能。Module versioning 功能应用在我们使用模块的场合。</p><p>如果Module versioning功能被打开的话，它会以每个导出符号的C原型声明作为输入，计算出对应的CRC校验值，保存在文件 Module.symvers 中。如此一来，内核在后面要加载使用模块的时候，会两相比较模块中的CRC值和保存下来的CRC值，如果发现不相等，内核就拒绝加载这个模块。</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230403230704333.png" alt="image-20230403230704333" style="zoom:100%;"><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230403231013373.png" alt="image-20230403231013373" style="zoom:100%;"><h2 id="附录2：CRC机制"><a href="#附录2：CRC机制" class="headerlink" title="附录2：CRC机制"></a>附录2：CRC机制</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/414290127?utm_id=0">https://zhuanlan.zhihu.com/p/414290127?utm_id=0</a></p></blockquote><p>内核模块符号CRC生成相关代码在scripts&#x2F;genksyms&#x2F;目录下面，注意其中除了c代码会进行解析之外，lex.l和parse.y也会进行初步的解析。CRC即cyclic redundancy check，用于错误检查。只有当内容保持不变的时候，CRC才会保持不变。内核模块主要对导出的符号（EXPORT_SYMBOL）做检查，要求保持两个一致性：</p><ol><li>接口一致：变量、函数参数、函数返回值类型名没有变化，若是结构体，其内部所有成员也没有变化；</li><li>语义一致：结构体成员变量名不能发生变化，函数参数名无需保持一致。</li></ol><h3 id="CRC基本函数"><a href="#CRC基本函数" class="headerlink" title="CRC基本函数"></a>CRC基本函数</h3><p>linux预先定义了256个（0xff）crctab，即用于异或操作的基，并以32位为单位来做CRC操作，相关内核源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">partial_crc32_one</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> crc)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> crctab32[(crc ^ c) &amp; <span class="hljs-number">0xff</span>] ^ (crc &gt;&gt; <span class="hljs-number">8</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">partial_crc32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> crc)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (*s)<br>        crc = partial_crc32_one(*s++, crc);<br>    <span class="hljs-keyword">return</span> crc;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">crc32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> partial_crc32(s, <span class="hljs-number">0xffffffff</span>) ^ <span class="hljs-number">0xffffffff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大致流程是从初始字符开始到最后一个字符，每个字符串都用相同的操作计算crc值，直到字符串结束，得到最终的CRC值。</p><p>对EXPORT_SYMBOL的符号进行crc调用并不由scripts&#x2F;genksyms&#x2F;中的c代码直接发起，而是在编译期的语法生成时由bison的semantic actions发起，相关生成规则如下（在scripts&#x2F;genksyms&#x2F;parse.y）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">export_definition:<br>    EXPORT_SYMBOL_KEYW <span class="hljs-string">&#x27;(&#x27;</span> IDENT <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span><br>        &#123; export_symbol((*$<span class="hljs-number">3</span>)-&gt;<span class="hljs-built_in">string</span>); $$ = $<span class="hljs-number">5</span>; &#125;<br>    ;<br></code></pre></td></tr></table></figure><p>即碰到EXPROT_SYMBOL关键词时，调用genksyms.c里的export_symbol，生成crc值。</p><h3 id="CRC计算举例"><a href="#CRC计算举例" class="headerlink" title="CRC计算举例"></a>CRC计算举例</h3><p><strong>基本类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> abcde;<br>EXPORT_SYMBOL(abcde);<br></code></pre></td></tr></table></figure><p>对于符号abcde，计算过程是：</p><ol><li>partial_crc32(“unsigned”, 0xffffffff) ⇒ 0xa9df1ba</li><li>partial_crc32_one(“ “, 0xa9df1ba) ⇒ 0x10d0e7ab</li><li>partial_crc32(“int”, 0x10d0e7ab) ⇒ 0xa9d106cd</li><li>partial_crc32_one(“ “, 0xa9d106cd) ⇒ 0xde124fc3</li><li>partial_crc32(“abcde”, 0xde124fc3) ⇒ 0x2e7e6a97</li><li>partial_crc32_one(“ “, 0x2e7e6a97) ⇒ 0x552b5845</li><li>0x552b5845 ^ 0xffffffff ⇒ 0xaad4a7ba</li></ol><p>最终，abcde的crc值即为0xaad4a7ba，可以通过Module.symvers查看得到。</p><p>可以发现，以上每步相当于把变量声明的每个符号依次计算了一遍crc32值，且每个符号计算后，都会与空格的crc哈希值做异或，最后将结果的值取0xffffffff的异或，即是最终符号的crc值，即如下过程：</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230405234653884.png" alt="image-20230405234653884" style="zoom:80%;"><p>如果变量是个数组或者指针，则对于分号前的所有符号进行如上计算，包括数组大小等。</p><p>对于导出的基本类型，会产生CRC值不同的原因有：</p><ul><li>变量的类型发生改变</li><li>数组变量的大小发生改变</li></ul><p><strong>函数</strong></p><p>若定义如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">test_fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> b)</span>;<br>EXPORT_SYMBOL(test_fun);<br></code></pre></td></tr></table></figure><p>那么CRC计算如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> -&gt; test_fun -&gt; ( -&gt;<br>    <span class="hljs-type">int</span> -&gt; , -&gt;<br>    <span class="hljs-type">char</span> -&gt; , -&gt;<br>)<br></code></pre></td></tr></table></figure><p>此处变量类型使用基础变量以便理解，如果是符合变量，则需要按照需求展开。</p><p>对于导出的函数，会产生CRC值不同的原因有：</p><ul><li>函数的返回值类型发生变化；</li><li>参数的类型发生变化；</li><li>参数名字发生变化不影响CRC值。</li></ul><p><strong>结构体</strong></p><p>若定义如下复合结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_struct</span> &#123;</span><br>        <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> my_int;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_struct</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_struct</span> <span class="hljs-title">bb</span>;</span><br>        my_int cc;<br>&#125;;<br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_struct</span> *<span class="hljs-title">abcde</span>;</span><br></code></pre></td></tr></table></figure><p>对于abcde，其类型struct test_struct包含另一个结构体struct my_struct和typedef后的变量，则计算的时候，需要依次对如下变量进行计算：\</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> → <span class="hljs-title">test_struct</span> → &#123;</span> → <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> → <span class="hljs-title">my_struct</span> → &#123;</span> → <br>        <span class="hljs-type">int</span> → a → ; → <br>    &#125; → bb → ; → <br>        <span class="hljs-keyword">typedef</span> → <span class="hljs-type">int</span> → my_int → cc → ; → <br>&#125; → * → abcde<br></code></pre></td></tr></table></figure><p>也就是关于struct或者typedef后的类型，其不直接利用类型名来进行计算，而是递归展开该类型的定义，对定义中的所有元素进行再次计算，最后得出计算的结果。</p><p>需要注意的是，typedef计算与基本类型类似，但是struct计算时，其中的每个变量后的分号都纳入计算范围。</p><p>对于导出的结构体，会产生CRC值不同的原因有：</p><ul><li>结构体内变量发生变化，包括变量类型、变量名字；</li><li>结构体内成员的顺序发生改变</li><li>若有typedef，其对应的名字或者类型发生变化。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile中的include关键字</title>
    <link href="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile中的include关键字"><a href="#Makefile中的include关键字" class="headerlink" title="Makefile中的include关键字"></a>Makefile中的include关键字</h1><blockquote><p>🪶 <strong>摘录自</strong>：<a href="https://juejin.cn/post/7150700142817968158#heading-2">https://juejin.cn/post/7150700142817968158#heading-2</a></p></blockquote><h2 id="include-的概念"><a href="#include-的概念" class="headerlink" title="include 的概念"></a>include 的概念</h2><p>makefile 中可以使用 <code>include</code> 指令来包含另一个文件。 当 <code>make</code> 识别到 <code>include</code> 指令时，<u>会暂停读入当前的 makefile 文件</u>，并转而读入 <code>include</code> 指定的文件，之后再继续读取本文件的剩余内容。</p><h2 id="include的使用"><a href="#include的使用" class="headerlink" title="include的使用"></a>include的使用</h2><p>本小节实验涉及到的文件包括：</p><ul><li>inc_a</li><li>inc_b</li><li>makefile</li></ul><p><code>inc_a</code> 的内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#this is a include file for makefile</span><br><br>vari_c=<span class="hljs-string">&quot;vari_c from inc_a&quot;</span><br></code></pre></td></tr></table></figure><p><code>makefile</code> 文件的内容如下：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Make"><span class="hljs-comment"># this is a basic makefile</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:all clean</span><br><br>vari_a=<span class="hljs-string">&quot;original vari a&quot;</span><br>vari_b=<span class="hljs-string">&quot;original vari b&quot;</span><br><br><span class="hljs-keyword">include</span> inc_a<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(vari_a)</span><br>    @echo <span class="hljs-variable">$(vari_b)</span><br>    @echo <span class="hljs-variable">$(vari_c)</span><br><br><span class="hljs-section">clean:</span><br></code></pre></td></tr></table></figure><p>在 Terminal 中执行 <code>make</code> 命令并观察输出结果。</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330234842191.png" alt="image-20230330234842191" style="zoom:80%;"><p>从输出结果可以看出来 makefile 已经成功包含了 <code>inc_a</code> 文件，并且正确获取到了 <code>vari_c</code> 变量。 值得一提的是 <code>include</code> 指示符所指示的文件名可以是任何 shell 能够识别的文件名，这表明 <code>include</code> 还可以支持包含通配符的文件名。我们将在下面的实验中进行验证。</p><p><code>inc_b</code>，文件内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#this is a include file for makefile</span><br><br>vari_d=<span class="hljs-string">&quot;vari_d from inc_b&quot;</span><br></code></pre></td></tr></table></figure><p>修改 makefile，使用通配符同时包含 <code>inc_a</code> 和 <code>inc_b</code> 文件。 修改后的 makefile 内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># this is a basic makefile</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:all clean</span><br><br>vari_a=<span class="hljs-string">&quot;original vari a&quot;</span><br>vari_b=<span class="hljs-string">&quot;original vari b&quot;</span><br><br><span class="hljs-keyword">include</span> inc_*<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(vari_a)</span><br>    @echo <span class="hljs-variable">$(vari_b)</span><br>    @echo <span class="hljs-variable">$(vari_c)</span><br>    @echo <span class="hljs-variable">$(vari_d)</span><br><br><span class="hljs-section">clean:</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：makefile 中修改了两处，第一处是 <code>inc_a</code> 修改为了 <code>inc_*</code>，第二处是在 <code>all</code> 中新增了 <code>@echo $(vari_d)</code> 。因为在 <code>inc_b</code> 中我们定义了变量 <code>vari_d</code>，在 makefile 中我们需要对其值进行输出。</p></blockquote><p>执行 <code>make</code> 命令,输出结果如图：</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235057222.png" alt="image-20230330235057222" style="zoom:80%;"><p>由此说明 <code>inc_a</code> 与 <code>inc_b</code> 都被包含进了 makefile 文件中。</p><h2 id="include-文件的查找路径"><a href="#include-文件的查找路径" class="headerlink" title="include 文件的查找路径"></a>include 文件的查找路径</h2><p>当 include 指示符包含的文件不包含绝对路径，且在当前路径下也无法寻找到时，make 会按以下优先级寻找文件：</p><ol><li><code>-I</code> 指定的目录</li><li><code>/usr/gnu/include</code></li><li><code>/usr/local/include</code></li><li><code>/usr/include</code></li><li>指定 makefile 的 include 路径</li></ol><p>修改 <code>makefile</code>，不再指定 <code>inc_a</code> 和 <code>inc_b</code> 的相对路径，此时 makefile 文件的内容是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># this is a basic makefile</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:all clean</span><br><br>vari_a=<span class="hljs-string">&quot;original vari a&quot;</span><br>vari_b=<span class="hljs-string">&quot;original vari b&quot;</span><br><br><span class="hljs-keyword">include</span> inc_*<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(vari_a)</span><br>    @echo <span class="hljs-variable">$(vari_b)</span><br>    @echo <span class="hljs-variable">$(vari_c)</span><br>    @echo <span class="hljs-variable">$(vari_d)</span><br><span class="hljs-section">clean:</span><br></code></pre></td></tr></table></figure><p>当前目录结构为：</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235800533.png" alt="image-20230330235800533" style="zoom:80%;"><p>执行 <code>make</code> 命令，观察输出结果，如果发现有错误产生。</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235517959.png" alt="image-20230330235517959" style="zoom:80%;"><p>可以看到 makefile 无法找到 <code>inc_a</code> 和 <code>inc_b</code> 文件。</p><p>接下来使用 <code>make -I</code> 命令来指定搜寻路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -I ./include_demo/<br></code></pre></td></tr></table></figure><p>Terminal 输出结果如下图：</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235727451.png" alt="image-20230330235727451" style="zoom:80%;"><p>发现输出结果依然是错误的。因为从输出结果可以看出 <code>make</code> 是在查找名为 <code>inc_*</code> 的文件。现在我们修改 makefile 文件中的 <code>include</code> 行。</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs M">include inc_a inc_b<br></code></pre></td></tr></table></figure><p>Terminal 的输出结果如图所示：</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235905294.png" alt="image-20230330235905294" style="zoom:80%;"><p>说明程序得到了正确的执行。</p><blockquote><p>可见不使用通配符的情况下<code>include</code>配合<code>-I</code>选项才能得到预期效果。</p></blockquote><h2 id="include的处理细节"><a href="#include的处理细节" class="headerlink" title="include的处理细节"></a>include的处理细节</h2><p>前面提到 <code>make</code> 读入 makefile 时遇见 <code>include</code> 指示符会暂停读入当前文件，转而读入 <code>include</code> 指定的文件，之后才继续读入当前文件。</p><p>makefile 文件的内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#this makefile is test for include process</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:all clean</span><br><br>vari_a=<span class="hljs-string">&quot;vari_a @ 1st&quot;</span><br><br><span class="hljs-keyword">include</span> ./include_demo/c_inc<br><br>vari_a += <span class="hljs-string">&quot; @2nd ...&quot;</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(vari_a)</span><br><br><span class="hljs-section">clean:</span><br></code></pre></td></tr></table></figure><p>从 makefile 内容上可以看出 makefile 规则的执行过程是先定义变量 <code>vari_a</code>，然后再引入文件 <code>c_inc</code>，最后修改变量 <code>vari_a</code>。</p><p><code>c_inc</code> 文件的内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#this is a include file for include process</span><br><br>vari_a=<span class="hljs-string">&quot;vari_a from c_inc&quot;</span><br></code></pre></td></tr></table></figure><p>从中可以看出在 <code>c_inc</code> 文件中也对 <code>vari_a</code> 变量进行了定义。</p><p>执行 <code>make</code> 命令观察输出结果。</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230331000240966.png" alt="image-20230331000240966" style="zoom:80%;"><p>这说明 <code>vari_a</code> 在 <code>include</code> 过程中被修改了，并且在其后添加了字符串 <code>@2nd ...</code>，结果与预期中 <code>make</code> 处理 <code>include</code> 指示符的行为一致</p>]]></content>
    
    
    <categories>
      
      <category>Makefile学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile的执行顺序</title>
    <link href="/2023/03/30/Makefile%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2023/03/30/Makefile%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile的执行顺序"><a href="#Makefile的执行顺序" class="headerlink" title="Makefile的执行顺序"></a>Makefile的执行顺序</h1><blockquote><p>🪶 摘录自：<a href="https://blog.csdn.net/qq_35524916/article/details/77131555?spm=1001.2014.3001.5506">https://blog.csdn.net/qq_35524916/article/details/77131555?spm=1001.2014.3001.5506</a></p></blockquote><p><strong>在linux下，makefile的执行实际上分为两个阶段进行</strong></p><ul><li>第一阶段：读取所有的makefile文件（包括“MAKEFILES”变量指定的、指示符“include”指定的、以及命令行选项“-f（–file）”指定的makefile文件），内建的变量、明确规则和隐含规则，并建立所有目标和依赖之间的依赖关系结构链表。</li><li>第二阶段：根据第一阶段已经建立的依赖关系结构链表决定哪些目标需要更新，并使用对应的规则来重建这些目标。</li></ul><p><strong>make的执行过程如下：</strong></p><ol><li>依次读取变量“MAKEFILES”定义的makefile文件列表</li><li>读取工作目录下的makefile文件（缺省的是根据命名的查找顺序“GNUmakefile”，“makefile”，“Makefile”，首先找到那个就读取那个）</li><li>依次读取工作目录makefile文件中使用指示符“include”包含的文件</li><li>查找重建所有已读取的makefile文件的规则（如果存在一个目标是当前读取的某一个makefile文件，则执行此规则重建此makefile文件，完成以后从第一步开始重新执行）</li><li>初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支</li><li>根据“终极目标”以及其他目标的依赖关系建立依赖关系链表</li><li>执行除“终极目标”以外的所有的目标的规则（规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件）</li><li>执行“终极目标”所在的规则</li></ol>]]></content>
    
    
    <categories>
      
      <category>Makefile学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile中的shell函数</title>
    <link href="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/"/>
    <url>/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile中的shell函数"><a href="#Makefile中的shell函数" class="headerlink" title="Makefile中的shell函数"></a>Makefile中的shell函数</h1><p>shell函数不同于除“wildcard”函数之外的其它函数。make可以使用它来和外部通信。</p><p>函数功能：函数“shell”所实现的功能和shell中的引用（&#96;&#96;）相同，实现对命令的扩展。这就意味着需要一个shell 命令作为此函数的参数，函数的返回结果是此命令在shell中的执行结果。make仅仅对它的返回结果进行处理；make将函数返回结果中的所有换行符（“\n”）或者一对“\n\r”替换为单空格；并去掉末尾的回车符号（“\n”）或者“\n\r”。进行函数展开式时，它所调用的命令（它的参数）得到执行。除对它的引用出现在规则的命令行和递归变量的定义中以外，其它决大多数情况下，make是在读取解析Makefile时完成对函数shell的展开。</p><p>🤺 <strong>返回值</strong>：函数“shell”的参数（一个shell命令）在<strong>shell环境中的执行结果</strong>。</p><p>函数说明：注意，这个函数会新生成一个 Shell 程序来执行命令，所以你要注意其运行性能，如果你的 Makefile 中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是 Makefile 的隐晦的规则可能会让你的 shell 函数执行的次数比你想像的多得多。</p><p>🐼 <strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">contents := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> cat foo.txt)</span><br><span class="hljs-variable">$(info <span class="hljs-variable">$(contents)</span>)</span><br><span class="hljs-section">all:</span><br>@echo <span class="hljs-string">&quot;make all&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">foo.txt</span><br>hello amx!<br>I love codiing.<br></code></pre></td></tr></table></figure><img src="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/image-20230329222716788.png" alt="image-20230329222716788" style="zoom:80%;"><blockquote><p>将换行符当做空格进行连接</p></blockquote><p>🐼 <strong>示例2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">contents := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> echo *.c)</span><br><span class="hljs-variable">$(info <span class="hljs-variable">$(contents)</span>)</span><br><span class="hljs-section">all:</span><br>@echo <span class="hljs-string">&quot;make all&quot;</span><br></code></pre></td></tr></table></figure><img src="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/image-20230329222846872.png" alt="image-20230329222846872" style="zoom:90%;"><img src="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/image-20230329222921766.png" alt="image-20230329222921766" style="zoom:80%;"><p>🐼 <strong>示例3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">contents := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> sh test.sh hello)</span><br><span class="hljs-variable">$(info <span class="hljs-variable">$(contents)</span>)</span><br><span class="hljs-section">all:</span><br>@echo <span class="hljs-string">&quot;make all&quot;</span><br></code></pre></td></tr></table></figure><p>其中<code>test.sh</code>如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>name=&quot;amx&quot;<br>echo $&#123;name&#125;<br>echo $0<br>echo $1<br>echo &quot;ChatGpt4.0&quot;<br></code></pre></td></tr></table></figure><img src="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/image-20230329224038930.png" alt="image-20230329224038930" style="zoom:90%;">]]></content>
    
    
    <categories>
      
      <category>Makefile学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kernel中__attribute__属性</title>
    <link href="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/"/>
    <url>/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="kernel中-attribute-属性"><a href="#kernel中-attribute-属性" class="headerlink" title="kernel中__attribute__属性"></a>kernel中__attribute__属性</h1><blockquote><p>🐧 <strong>参考</strong>：<a href="https://www.eet-china.com/mp/a192020.html">https://www.eet-china.com/mp/a192020.html</a></p></blockquote><h2 id="1-实验程序"><a href="#1-实验程序" class="headerlink" title="1.实验程序"></a>1.实验程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __attribute__ ((constructor)) beforeMain(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before main...\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Main!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：<code>gcc test.c -o test</code></p><p>输出结果：</p><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328225545088.png" alt="image-20230328225545088" style="zoom:80%;"><blockquote><p>为什么最开始执行的不是main函数？怎么和我们刚开始学习C程序时说的不一样呢？从运行结果中，我们可以看出来beforeMain是在进入main函数之前被调用的，这对于C语言的初学者来说似乎有点难以理解。究竟是谁调用的beforeMain呢？怎么还没有进入main就可以有代码被执行呢？</p></blockquote><p>带着以上问题，我们先用-v参数来显示编译过程输出结果<code>gcc test.c -o test -v</code>：，其中输出部分如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/8/:/usr/lib/gcc/x86_64-linux-gnu/8/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/8/:/usr/lib/gcc/x86_64-linux-gnu/<br>LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/8/:/usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/8/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/8/../../../:/lib/:/usr/lib/<br>COLLECT_GCC_OPTIONS=&#x27;-o&#x27; &#x27;test&#x27; &#x27;-v&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=x86-64&#x27;<br> /usr/lib/gcc/x86_64-linux-gnu/8/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/8/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/8/lto-wrapper -plugin-opt=-fresolution=/tmp/ccxW7QBR.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o test /usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/8 -L/usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/8/../../.. /tmp/ccboZUZT.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/crtn.o<br>COLLECT_GCC_OPTIONS=&#x27;-o&#x27; &#x27;test&#x27; &#x27;-v&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=x86-64&#x27;<br></code></pre></td></tr></table></figure><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328225732402.png" alt="image-20230328225732402" style="zoom:100%;"><p>从输出结果可以看出，在链接生成最后的可执行文件时，有很多的C库二进制文件参与进来。而最终的可执行文件除了我们编写的这个简单的C代码以外，还有大量的C库文件参与了链接，并包含在了最终的可执行文件中。这个链接的过程，是由链接器ld的链接脚本来决定的。如果我们没有指定链接脚本，会默认使用ld的默认脚本。</p><p>通过<strong>ld -verbose</strong>命令来查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">using internal linker script:<br>==================================================<br>/* Script for -z combreloc -z separate-code: combine and sort reloc sections with separate code segment */<br>/* Copyright (C) 2014-2018 Free Software Foundation, Inc.<br>   Copying and distribution of this script, with or without modification,<br>   are permitted in any medium without royalty provided the copyright<br>   notice and this notice are preserved.  */<br>OUTPUT_FORMAT(&quot;elf64-x86-64&quot;, &quot;elf64-x86-64&quot;,<br>              &quot;elf64-x86-64&quot;)<br>OUTPUT_ARCH(i386:x86-64)<br>ENTRY(_start)<br>SEARCH_DIR(&quot;=/usr/local/lib/x86_64-linux-gnu&quot;); SEARCH_DIR(&quot;=/lib/x86_64-linux-gnu&quot;); SEARCH_DIR(&quot;=/usr/lib/x86_64-linux-gnu&quot;); SEARCH_DIR(&quot;=/usr/lib/x86_64-linux-gnu64&quot;); SEARCH_DIR(&quot;=/usr/local/lib64&quot;); SEARCH_DIR(&quot;=/lib64&quot;); SEARCH_DIR(&quot;=/usr/lib64&quot;); SEARCH_DIR(&quot;=/usr/local/lib&quot;); SEARCH_DIR(&quot;=/lib&quot;); SEARCH_DIR(&quot;=/usr/lib&quot;); SEARCH_DIR(&quot;=/usr/x86_64-linux-gnu/lib64&quot;); SEARCH_DIR(&quot;=/usr/x86_64-linux-gnu/lib&quot;);<br></code></pre></td></tr></table></figure><p>从上面输出可以看出这里定义了输出的文件格式、目标机器的类型，以及重要的信息和程序的入口ENTRY（_start）。</p><blockquote><p>我们的例子中beforeMain函数使用的gcc扩展属性<code>__attribute__（（constructor））</code>就是将函数对应的指令归属于.ctors section部分。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">.ctors          :<br>&#123;<br>  /* gcc uses crtbegin.o to find the start of<br>     the constructors, so we make sure it is<br>     first.  Because this is a wildcard, it<br>     doesn&#x27;t matter if the user does not<br>     actually link against crtbegin.o; the<br>     linker won&#x27;t look for a file to match a<br>     wildcard.  The wildcard also means that it<br>     doesn&#x27;t matter which directory crtbegin.o<br>     is in.  */<br>  KEEP (*crtbegin.o(.ctors))<br>  KEEP (*crtbegin?.o(.ctors))<br>  /* We don&#x27;t want to include the .ctor section from<br>     the crtend.o file until after the sorted ctors.<br>     The .ctor section from the crtend file contains the<br>     end of ctors marker and it must be last */<br>  KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))<br>  KEEP (*(SORT(.ctors.*)))<br>  KEEP (*(.ctors))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-attribute-constructor-属性"><a href="#2-attribute-constructor-属性" class="headerlink" title="2._attribute_((constructor))属性"></a>2._<em>attribute</em>_((constructor))属性</h2><blockquote><p>The constructor attribute causes the function to be called automatically before execution enters main (). 构造函数属性使函数在执行进入main（）之前自动被调用</p></blockquote><p>GNU C的一大特色就是<code>__attribute__</code>机制。<code>__attribute__</code>可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute ）。<code>__attribute__</code>写法是<code>__attribute__</code>前后都有两个下划线，并且后面会紧跟一对原括弧，括弧里面是相应的<code>__attribute__</code>参数。<code>__attribute__</code>格式为<code>__attribute__((attribute-list))</code></p><p>就是指在函数上方加上<code>__attribute__((constructor))</code>可以让这个函数在main函数执行前运行</p><p><strong>作用：<code>__attribute__((constructor))</code>可以提前初始化一些在main函数中用到的东西，便于我们做一些准备工作。</strong></p><p><strong>带有优先级的参数</strong></p><p>我们还可以给属性设置优先级，看下面示例代码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span><br><br>static void __attribute__ ((constructor(101))) beforeMain1(void)<br>&#123;<br>    printf(&quot;Before main...1\n&quot;);<br>&#125;<br>static void __attribute__ ((constructor(102))) beforeMain2(void)<br>&#123;<br>    printf(&quot;Before main...2\n&quot;);<br>&#125;<br>static void __attribute__ ((constructor(103))) beforeMain3(void)<br>&#123;<br>    printf(&quot;Before main...3\n&quot;);<br>&#125;<br><br>int main(void)<br>&#123;<br>    printf(&quot;Main!\n&quot;);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328230224517.png" alt="image-20230328230224517" style="zoom:100%;"><h2 id="3-attribute-destructor-属性"><a href="#3-attribute-destructor-属性" class="headerlink" title="3._attribute_((destructor))属性"></a>3._<em>attribute</em>_((destructor))属性</h2><p>查阅了GNU的文档你还会发现有提及这么一个写法<code>__attribute__((destructor))</code>，文档中关于这两个用法的说明如下:</p><blockquote><p>The constructor attribute causes the function to be called automatically before execution enters main (). Similarly, the destructor attribute causes the function to be called automatically after main () completes or exit () is called. Functions with these attributes are useful for initializing data that is used implicitly during the execution of the program.</p></blockquote><blockquote><p>同理, destructor让系统在main()函数退出或者调用了exit()之后,调用我们的函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __attribute__ ((constructor)) beforeMain(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before main...\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __attribute__ ((destructor)) afterMain(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After main...\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Main!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328230504826.png" alt="image-20230328230504826" style="zoom:100%;"><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>C程序中<code>__attribute__ ((constructor))</code>和<code>__attribute__ ((destructor))</code>类似于C++类中构造函数和析构函数。在main函数之前，执行一个函数，便于我们做一些准备工作；在main()函数退出或者调用了exit()之后调用。多个函数时，GCC为我们提供了一个参数叫优先级，constructor按从小到大，destructor函数相反<code> void __attribute__((constructor(5)) initFunction1(void); void __attribute__((constructor(10)) initFunction2(void);</code></p><h2 id="5-attribute用于加载动态库"><a href="#5-attribute用于加载动态库" class="headerlink" title="5.attribute用于加载动态库"></a>5.attribute用于加载动态库</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">Shared objects may <span class="hljs-keyword">export</span> functions using the<br><br>__attribute__((constructor)) and __attribute__((destructor))<br>function attributes.  Constructor functions are executed before<br>dlopen() returns, and destructor functions are executed before<br>dlclose() returns.  A shared object may <span class="hljs-keyword">export</span> multiple<br>constructors and destructors, and priorities can be associated<br>with each function to determine the order in which they are<br>executed.  See the gcc info pages (under <span class="hljs-string">&quot;Function attributes&quot;</span>)<br>for further information.<br></code></pre></td></tr></table></figure><p>函数设置__attribute__((constructor))属性，在dlopen时，会先调用该方法。</p><p>设置__attribute__((destructor))属性，在dlclose时会调用该方法。</p><p>实验程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br>__attribute__((constructor)) <span class="hljs-type">void</span> <span class="hljs-title function_">test_init</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>&#125;<br><br>__attribute__((destructor)) <span class="hljs-type">void</span> <span class="hljs-title function_">test_fini</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bye world\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -fPIC -shared test.c -o  libtest.so<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span><span class="hljs-params">(*testFunc)</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">void</span> *handle = dlopen(<span class="hljs-string">&quot;./libtest.so&quot;</span>, RTLD_LAZY);<br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;handle is null, %s\n&quot;</span>, dlerror());<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------\n&quot;</span>);<br>    testFunc f = (testFunc)dlsym(handle, <span class="hljs-string">&quot;test&quot;</span>);<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;f is null\n&quot;</span>);<br>    &#125;<br><br>    f();<br>    dlclose(handle);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc main.c -ldl -O0 -g -o main<br></code></pre></td></tr></table></figure><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328234128499.png" alt="image-20230328234128499" style="zoom:100%;">]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓init进程系列(1)ctl.interface_start</title>
    <link href="/2023/03/24/%E5%AE%89%E5%8D%93init%E8%BF%9B%E7%A8%8B%E7%B3%BB%E5%88%97-1-ctl-interface-start/"/>
    <url>/2023/03/24/%E5%AE%89%E5%8D%93init%E8%BF%9B%E7%A8%8B%E7%B3%BB%E5%88%97-1-ctl-interface-start/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓init进程系列-1-ctl-interface-start"><a href="#安卓init进程系列-1-ctl-interface-start" class="headerlink" title="安卓init进程系列(1)ctl.interface_start"></a>安卓init进程系列(1)ctl.interface_start</h1><blockquote><p>🤖 <strong>背景</strong>：为什么会有ctl.interface_start这个属性，因为安卓有了动态HAL的概念，具体可以参见我的另外一篇<a href="https://anmuxixixi.github.io/2023/03/24/%E5%8A%A8%E6%80%81%E5%8F%AF%E7%94%A8%E7%9A%84-HAL/">博客</a></p></blockquote><h2 id="1-哪里会去调用ctl-interface-start"><a href="#1-哪里会去调用ctl-interface-start" class="headerlink" title="1.哪里会去调用ctl.interface_start"></a>1.哪里会去调用ctl.interface_start</h2><p>为什么一直强调背景的重要性，如果脱离的背景，看代码的实现是痛苦的，是梦游的，是无用功🐖</p><p>就好比这里，如果不知道ctl.interface_start出现的背景，就不知道哪里调用了<code>ctl.interface_start</code>，也不知道为什么在某一个Android版本里面突然出现了它。</p><p>好了，从背景来看是为了实现HAL的动态启动，比如WIFI我们不用的时候，WIFI相应的HAL需要自动关闭，这样就实现了一个HAL的动态启动，用的时候开，最大程度的节省系统资源。</p><blockquote><p>🎨 <strong>声明</strong>：那我们以CameraHAL为例，进行分析！【本人不是专业搞Camera的，故参考<a href="https://blog.csdn.net/liujun3512159/article/details/124702217%E3%80%91">https://blog.csdn.net/liujun3512159/article/details/124702217】</a></p><p>另外，关于HAL的启动流程，我也会写一篇详尽的博客供自己复习和大家参考！</p></blockquote><p>client需要获取hal服务，一般都会调用servicemanager去getservice</p><img src="/2023/03/24/%E5%AE%89%E5%8D%93init%E8%BF%9B%E7%A8%8B%E7%B3%BB%E5%88%97-1-ctl-interface-start/image-20230324225335198-1679669618537-1-1679669619970-3.png" alt="image-20230324225335198" style="zoom:80%;"><p>当client向hwservicemanager获取服务的时候，发现找不到该服务，那么会去调用<strong>tryStartService</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\hwservicemanager\ServiceManager.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">tryStartService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; fqName, <span class="hljs-type">const</span> std::string&amp; name)</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> ::android::base::SetProperty;<br><br>    <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Since &quot;</span> &lt;&lt; fqName &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; name<br>              &lt;&lt; <span class="hljs-string">&quot; is not registered, trying to start it as a lazy HAL.&quot;</span>;<br><br>    std::<span class="hljs-built_in">thread</span>([=] &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetProperty</span>(<span class="hljs-string">&quot;ctl.interface_start&quot;</span>, fqName + <span class="hljs-string">&quot;/&quot;</span> + name)) &#123;<br>            <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Tried to start &quot;</span> &lt;&lt; fqName &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; name<br>                      &lt;&lt; <span class="hljs-string">&quot; as a lazy service, but was unable to. Usually this happens when a &quot;</span><br>                         <span class="hljs-string">&quot;service is not installed, but if the service is intended to be used as a &quot;</span><br>                         <span class="hljs-string">&quot;lazy service, then it may be configured incorrectly.&quot;</span>;<br>        &#125;<br>    &#125;).<span class="hljs-built_in">detach</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>设置属性值，key为<code>ctl.interface_start</code>，value为<code>fqName + &quot;/&quot; + name</code>，我们都知道init进行捕获到系统属性值变化以后会调用<strong>HandlePropertySet</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">HandlePropertySet</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> std::string&amp; value,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-type">const</span> std::string&amp; source_context, <span class="hljs-type">const</span> ucred&amp; cr,</span></span><br><span class="hljs-params"><span class="hljs-function">                           SocketConnection* socket, std::string* error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">StartsWith</span>(name, <span class="hljs-string">&quot;ctl.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SendControlMessage</span>(name.<span class="hljs-built_in">c_str</span>() + <span class="hljs-number">4</span>, value, cr.pid, socket, error);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当属性值以ctl.开头，调用SendControlMessage</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\property_service.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">SendControlMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg, <span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">pid_t</span> pid,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   SocketConnection* socket, std::string* error)</span> </span>&#123;<br>    <span class="hljs-comment">// 调用QueueControlMessage</span><br>    <span class="hljs-type">bool</span> queue_success = <span class="hljs-built_in">QueueControlMessage</span>(msg, name, pid, fd);<br><br>    <span class="hljs-keyword">return</span> PROP_SUCCESS;<br>&#125;<br><br><span class="hljs-comment">// system\core\init\init.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QueueControlMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message, <span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    pending_control_messages.<span class="hljs-built_in">push</span>(&#123;message, name, pid, fd&#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里往<code>pending_control_messages</code>放了<code>message, name, pid, fd</code>这些重要的信息！！！</p><p>按照init的设计思想，类似于rc文件中service的处理方式！既然向pending_control_messages放了一条信息待处理，那么必然有一个地方专门消费pending_control_messages中的信息，我理解这里运用了<strong>生产者-消费者</strong>设计模式，🐧答案在第3节！</p><h2 id="2-init进程启动后续"><a href="#2-init进程启动后续" class="headerlink" title="2.init进程启动后续"></a>2.init进程启动后续</h2><p>Android S从宏观来看，init进程总共分为3个阶段，最后一个阶段也就是<strong>SecondStageMain</strong>，当SecondStageMain所有代码执行结束，init进程基本就结束了，但不代表init进程啥也不干了，里面有一个关键的<u><strong>while循环</strong></u>，会一直监听是否收到ctlMsg信息！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\init.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SecondStageMain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsShuttingDown</span>()) &#123;<br>            <span class="hljs-built_in">HandleControlMessages</span>();<br>            <span class="hljs-built_in">SetUsbController</span>();<br>        &#125;<br>    &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们看看怎么处理CtlMsg信息的，这里我们暂时不用理会与ctl.interface_start的联系.</p><h2 id="3-HandleControlMessages-怎么处理CtlMsg"><a href="#3-HandleControlMessages-怎么处理CtlMsg" class="headerlink" title="3.HandleControlMessages:怎么处理CtlMsg"></a>3.HandleControlMessages:怎么处理CtlMsg</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\init.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleControlMessages</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 当pending_control_messages不为空的时候</span><br>    <span class="hljs-keyword">if</span> (!pending_control_messages.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> control_message = pending_control_messages.<span class="hljs-built_in">front</span>();<br>        pending_control_messages.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 关键看这里，这里回去调用HandleControlMessage处理相关的信息</span><br>        <span class="hljs-type">bool</span> success = <span class="hljs-built_in">HandleControlMessage</span>(control_message.message, control_message.name,<br>                                            control_message.pid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最为关键的是HandleControlMessage，它负责处理每一条具体的CtlMsg</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">HandleControlMessage</span><span class="hljs-params">(std::string_view message, <span class="hljs-type">const</span> std::string&amp; name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">pid_t</span> from_pid)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取进程的的cmdline_path，这里camerahal传进来的应该是hwservicemanager对应的pid</span><br>    <span class="hljs-comment">// 同时获取的cmdline_path就是hwservicemanger这个字符串</span><br>    std::string cmdline_path = <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;proc/%d/cmdline&quot;</span>, from_pid);<br>    std::string process_cmdline;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ReadFileToString</span>(cmdline_path, &amp;process_cmdline)) &#123;<br>        std::<span class="hljs-built_in">replace</span>(process_cmdline.<span class="hljs-built_in">begin</span>(), process_cmdline.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>);<br>        process_cmdline = <span class="hljs-built_in">Trim</span>(process_cmdline);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        process_cmdline = <span class="hljs-string">&quot;unknown process&quot;</span>;<br>    &#125;<br><br>    Service* service = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> action = message;<br>    <span class="hljs-comment">// 如果action以interface_开头，就去ServiceList中寻找</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ConsumePrefix</span>(&amp;action, <span class="hljs-string">&quot;interface_&quot;</span>)) &#123;<br>        service = ServiceList::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">FindInterface</span>(name);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        service = ServiceList::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">FindService</span>(name);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取我们要执行sigstop_on,oneshot_on,....,start,stop,...中的一种</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; map = <span class="hljs-built_in">GetControlMessageMap</span>();<br>    <span class="hljs-comment">// 显然这里找到的是start</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">find</span>(action);<br><span class="hljs-comment">// start对应的处理函数为DoControlStart</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; function = it-&gt;second;<br><br>    <span class="hljs-comment">// 调用DoControlStart执行这个服务</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">function</span>(service); !result.<span class="hljs-built_in">ok</span>()) &#123;<br>        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Control message: Could not ctl.&quot;</span> &lt;&lt; message &lt;&lt; <span class="hljs-string">&quot; for &#x27;&quot;</span> &lt;&lt; name<br>                   &lt;&lt; <span class="hljs-string">&quot;&#x27; from pid: &quot;</span> &lt;&lt; from_pid &lt;&lt; <span class="hljs-string">&quot; (&quot;</span> &lt;&lt; process_cmdline<br>                   &lt;&lt; <span class="hljs-string">&quot;): &quot;</span> &lt;&lt; result.<span class="hljs-built_in">error</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Control message: Processed ctl.&quot;</span> &lt;&lt; message &lt;&lt; <span class="hljs-string">&quot; for &#x27;&quot;</span> &lt;&lt; name<br>              &lt;&lt; <span class="hljs-string">&quot;&#x27; from pid: &quot;</span> &lt;&lt; from_pid &lt;&lt; <span class="hljs-string">&quot; (&quot;</span> &lt;&lt; process_cmdline &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> std::map&lt;std::string, ControlMessageFunction, std::less&lt;&gt;&gt;&amp; <span class="hljs-built_in">GetControlMessageMap</span>() &#123;<br>    <span class="hljs-comment">// clang-format off</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::map&lt;std::string, ControlMessageFunction, std::less&lt;&gt;&gt; control_message_functions = &#123;<br>        &#123;<span class="hljs-string">&quot;sigstop_on&quot;</span>,        [](<span class="hljs-keyword">auto</span>* service) &#123; service-&gt;<span class="hljs-built_in">set_sigstop</span>(<span class="hljs-literal">true</span>); <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-type">void</span>&gt;&#123;&#125;; &#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;sigstop_off&quot;</span>,       [](<span class="hljs-keyword">auto</span>* service) &#123; service-&gt;<span class="hljs-built_in">set_sigstop</span>(<span class="hljs-literal">false</span>); <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-type">void</span>&gt;&#123;&#125;; &#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;oneshot_on&quot;</span>,        [](<span class="hljs-keyword">auto</span>* service) &#123; service-&gt;<span class="hljs-built_in">set_oneshot</span>(<span class="hljs-literal">true</span>); <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-type">void</span>&gt;&#123;&#125;; &#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;oneshot_off&quot;</span>,       [](<span class="hljs-keyword">auto</span>* service) &#123; service-&gt;<span class="hljs-built_in">set_oneshot</span>(<span class="hljs-literal">false</span>); <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-type">void</span>&gt;&#123;&#125;; &#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;start&quot;</span>,             DoControlStart&#125;,<br>        &#123;<span class="hljs-string">&quot;stop&quot;</span>,              DoControlStop&#125;,<br>        &#123;<span class="hljs-string">&quot;restart&quot;</span>,           DoControlRestart&#125;,<br>    &#125;;<br>    <span class="hljs-comment">// clang-format on</span><br><br>    <span class="hljs-keyword">return</span> control_message_functions;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态可用的 HAL</title>
    <link href="/2023/03/24/%E5%8A%A8%E6%80%81%E5%8F%AF%E7%94%A8%E7%9A%84-HAL/"/>
    <url>/2023/03/24/%E5%8A%A8%E6%80%81%E5%8F%AF%E7%94%A8%E7%9A%84-HAL/</url>
    
    <content type="html"><![CDATA[<h1 id="动态可用的-HAL"><a href="#动态可用的-HAL" class="headerlink" title="动态可用的 HAL"></a>动态可用的 HAL</h1><blockquote><p>🤖 全部来自<a href="https://source.android.com/docs/core/architecture/hal/dynamic-lifecycle?hl=zh-cn">安卓官网</a></p></blockquote><p>Android 9 支持在不使用或不需要 Android 硬件子系统时动态关停这些子系统。例如，如果用户未使用 Wi-Fi，Wi-Fi 子系统就不应占用内存、耗用电量或使用其他系统资源。早期版本的 Android 中，在 Android 手机启动的整个期间，Android 设备上的 HAL&#x2F;驱动程序都会保持开启状态。</p><p>实现动态关停涉及连接数据流以及执行动态进程，下文对此进行了详细介绍。</p><h2 id="对-HAL-定义所做的更改"><a href="#对-HAL-定义所做的更改" class="headerlink" title="对 HAL 定义所做的更改"></a>对 HAL 定义所做的更改</h2><p>要实现动态关停，不仅需要有关于哪些进程为哪些 HAL 接口提供服务的信息（此类信息之后在其他情况中也可能很有用），还需要确保设备启动时不启动进程，而且在进程退出后，直到系统再次请求启动它们之前，都不重新启动它们。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># some init.rc script associated with the HAL</span><br>service vendor.some-service-name /vendor/bin/hw/some-binary-service<br>    <span class="hljs-comment"># init language extension, provides information of what service is served</span><br>    <span class="hljs-comment"># if multiple interfaces are served, they can be specified one on each line</span><br>    interface android.hardware.light@2.0::ILight default<br>    <span class="hljs-comment"># restarted if hwservicemanager dies</span><br>    <span class="hljs-comment"># would also cause the hal to start early during boot if disabled wasn&#x27;t set</span><br>    class hal<br>    <span class="hljs-comment"># will not be restarted if it exits until it is requested to be restarted</span><br>    oneshot<br>    <span class="hljs-comment"># will only be started when requested</span><br>    disabled<br>    <span class="hljs-comment"># ... other properties</span><br></code></pre></td></tr></table></figure><h2 id="对-init-和-hwservicemanager-所做的更改"><a href="#对-init-和-hwservicemanager-所做的更改" class="headerlink" title="对 init 和 hwservicemanager 所做的更改"></a>对 init 和 hwservicemanager 所做的更改</h2><p>为了实现动态关停，还需要让 <code>hwservicemanager</code> 告知 <code>init</code> 启动所请求的服务。在 Android 9 中，<code>init</code> 包含三个额外的控制消息（例如，<code>ctl.start</code>）：<code>ctl.interface_start</code>、<code>ctl.interface_stop</code> 和 <code>ctl.interface_restart</code>。这些消息可用于指示 <code>init</code> 打开或关闭特定硬件接口。如果系统请求使用某个服务但该服务未注册，<code>hwservicemanager</code> 会请求启动该服务。不过，动态 HAL 不需要使用以上任何消息。</p><h2 id="确定-HAL-退出"><a href="#确定-HAL-退出" class="headerlink" title="确定 HAL 退出"></a>确定 HAL 退出</h2><p>在 Android 9 中，必须手动确定 HAL 退出。对于 Android 10 及更高版本，还可以使用自动生命周期确定 HAL 退出。</p><p>为了实现动态关停，需要多个策略来决定何时启动和关停 HAL。如果 HAL 出于任何原因决定退出，当系统再次需要用到它时，它将使用以下信息和基础架构自动重新启动：HAL 定义中提供的信息，以及更改后的 <code>init</code> 和 <code>hwservicemanager</code> 提供的基础架构。这可能会涉及多个不同的策略，包括：</p><ul><li>如果有人对 HAL 调用关闭命令或类似的 API，则 HAL 可能会选择自行调用退出命令。此行为必须在相应的 HAL 接口中指定。</li><li>HAL 可在任务完成后关停（记录在 HAL 文件中）。</li></ul><h2 id="自动生命周期"><a href="#自动生命周期" class="headerlink" title="自动生命周期"></a>自动生命周期</h2><p>Android 10 为内核和 hwservicemanager 添加了更多支持，可让 HAL 在没有任何客户端时自动关停。如需使用此功能，请根据“对 HAL 定义所做的更改”这一部分完成其中所有步骤，并执行以下操作：</p><ul><li>使用 <code>LazyServiceRegistrar</code> 而不是成员函数 <code>registerAsService</code> 通过 C++ 注册服务，例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// only one instance of LazyServiceRegistrar per process</span><br>LazyServiceRegistrar registrar;<br>registrar.<span class="hljs-built_in">registerAsService</span>(myHidlService <span class="hljs-comment">/* , &quot;default&quot; */</span>);<br></code></pre></td></tr></table></figure><ul><li>验证 HAL 客户端是否仅在使用时保留对顶级 HAL（通过 <code>hwservicemanager</code> 注册的接口）的引用。为了避免出现延迟，如果该引用在继续执行的 hwbinder 线程上被丢弃，客户端还应该在丢弃引用后调用 <code>IPCThreadState::self()-&gt;flushCommands()</code>，以确保 binder 驱动程序在相关引用计数发生变化时收到通知。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习笔记</title>
    <link href="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="git学习笔记"><a href="#git学习笔记" class="headerlink" title="git学习笔记"></a>git学习笔记</h1><h2 id="git下载安装"><a href="#git下载安装" class="headerlink" title="git下载安装"></a>git下载安装</h2><p>下载地址：<a href="https://git-scm.com/download">Git - Downloads</a></p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1679585116661-4.png" alt="img"><p>以得到如下安装文件：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1679585140689-7.png" alt="img"><p>双击下载的安装文件来安装Git。安装完成后在电脑桌面（也可以是其他目录）点击右键，如果能够看</p><p>到如下两个菜单则说明Git安装成功</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230323232638131.png" alt="image-20230323232638131" style="zoom: 70%;"><p>备注：</p><ul><li>Git GUI：Git提供的图形界面工具</li><li>Git Bash：Git提供的命令行工具</li></ul><p>当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><h2 id="git三个区"><a href="#git三个区" class="headerlink" title="git三个区"></a>git三个区</h2><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/e38fd405-7e6a-4cc7-b576-a991af1d9cd5.png" alt="在这里插入图片描述"><ul><li><code>Workspace</code>：工作区，就是你平时存放项目代码的地方</li><li><code>Index / Stage</code>：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息,一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）</li><li><code>Repository</code>：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li><code>Remote</code>：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><hr><p><strong>命令如下：</strong></p><ol><li>clone（克隆）: 从远程仓库中克隆代码到本地仓库</li><li>checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订</li><li>add（添加）: 在提交前先将代码提交到暂存区</li><li>commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本</li><li>fetch (抓取) ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li><li>pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge</li><li>push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</li></ol><h2 id="git-config配置作者信息"><a href="#git-config配置作者信息" class="headerlink" title="git config配置作者信息"></a>git config配置作者信息</h2><blockquote><p>后盾人：<a href="https://www.bilibili.com/video/BV1WW4y1b78T">https://www.bilibili.com/video/BV1WW4y1b78T</a></p></blockquote><p>配置文件为<code>~/.gitconfig</code>，执行任何Git配置命令后文件将自动创建。</p><p>第一个要配置的是你个人的用户名称和电子邮件地址，这两条配置很重要，每次Git提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name “OneAmxixixi”<br>git config --global user.email “842629356@qq.com&quot;<br></code></pre></td></tr></table></figure><ul><li>如果我们要在特定的项目仓中修改提交人信息：</li></ul><p>当我们git init初始化本地仓库后，会出现.git文件，我们进入里面的配置文件<code>config</code>。</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325224813424.png" alt="image-20230325224813424" style="zoom:70%;"><p>此时config文件如下：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325224941049.png" alt="image-20230325224941049" style="zoom: 67%;"><p>修改当前仓库提交人信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">Administrator@WBX-20220621BRZ MINGW64 /g/git强化学习/android12 (master)<br>$ git config user.name <span class="hljs-string">&quot;baitaowulong&quot;</span><br></code></pre></td></tr></table></figure><p>此时当前仓库的<code>.git/config</code>就出现了新的提交人</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325225038843.png" alt="image-20230325225038843" style="zoom:67%;"><h2 id="gitignore添加文件至忽略列表"><a href="#gitignore添加文件至忽略列表" class="headerlink" title=".gitignore添加文件至忽略列表"></a>.gitignore添加文件至忽略列表</h2><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为<code>.gitignore</code> 的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略所有以.a结尾的文件</span><br>*.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略所有以.a结尾的文件，除了lib.a</span><br>!lib.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅仅忽略当前目录下的TODO文件夹，但不忽略当前路径子文件的TODO文件夹，例如./subdir/TODO</span><br>/TODO<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略build/目录下所有文件</span><br>build/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略doc目录下以.txt结尾的文件，但不忽略doc子目录下以txt文件的文件，比如doc/server/arch.txt不会忽略</span><br>doc/*.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略doc文件下所有以pdf结尾的文件，包括子目录</span><br>doc/**/*.pdf<br></code></pre></td></tr></table></figure><ol><li>我们创建了两个文件，一个以<code>.java</code>结尾，一个以<code>.c</code>结尾</li></ol><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325231753957.png" alt="image-20230325231753957" style="zoom:80%;"><ol start="2"><li>在<code>.gitignore</code>中设置被忽略的规则</li></ol><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325231903931.png" alt="image-20230325231903931" style="zoom:80%;"><ol start="3"><li>此时本地仓库就不会跟踪<code>.gitignore</code>中的内容</li></ol><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325231922326.png" alt="image-20230325231922326" style="zoom: 80%;"><h2 id="git-rm删除文件"><a href="#git-rm删除文件" class="headerlink" title="git rm删除文件"></a>git rm删除文件</h2><h3 id="git-rm基本用法"><a href="#git-rm基本用法" class="headerlink" title="git rm基本用法"></a>git rm基本用法</h3><p><strong>作用：</strong>  <strong>同时从工作区和索引中删除文件</strong>。即本地的文件也被删除了。</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326104602205.png" alt="image-20230326104602205" style="zoom:80%;"><h3 id="git-rm-–cache后悔药"><a href="#git-rm-–cache后悔药" class="headerlink" title="git rm –cache后悔药"></a>git rm –cache后悔药</h3><blockquote><p>场景：假设我们手快了，将一些文件添加到了本地版本库里面，现在想删除它，但是又不希望本地的文件丢失。</p></blockquote><p><strong>作用：</strong> <strong>从索引中删除文件。但是本地文件还存在</strong>， 只是不希望这个文件被版本控制</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326105155871.png" alt="image-20230326105155871" style="zoom:80%;"><h2 id="git-mv修改文件名"><a href="#git-mv修改文件名" class="headerlink" title="git mv修改文件名"></a>git mv修改文件名</h2><blockquote><p>场景：发现版本库里面的文件需要修改，例如我们要将版本库里面的binder.c改成bind.c</p></blockquote><p><strong>作用：</strong></p><ul><li><p>git mv 命令用于移动或重命名一个文件、目录或软连接。</p></li><li><p>它会将内容从工作区和暂存区中重命名，手动重命名需要执行两步操作，git mv 一步即可</p></li></ul><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326110457377.png" alt="image-20230326110457377" style="zoom:80%;"><p>如果不采取git mv，需要两步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv led_t286.c led_q385.c<br>git add led_t286.c led_t286<br></code></pre></td></tr></table></figure><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326111013402.png" alt="image-20230326111013402" style="zoom:80%;"><h2 id="git-log查看版本变动信息"><a href="#git-log查看版本变动信息" class="headerlink" title="git log查看版本变动信息"></a>git log查看版本变动信息</h2><p><strong>作用：</strong>查看版本变动信息</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326112521485.png" alt="image-20230326112521485" style="zoom:80%;"><p>如果想看查看更加详细一点的信息可以使用<code>git log -p</code></p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326112631990.png" alt="image-20230326112631990" style="zoom:80%;"><p>如果想要日志以某种格式输出可以使用<code>git log --pretty=format</code></p><blockquote><p>详细可参考：<a href="https://blog.csdn.net/u011106915/article/details/105836289/">https://blog.csdn.net/u011106915/article/details/105836289/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --pretty=format:&quot;SHA-1:%h - 创建人:%an 时间:%ad 提交信息:%s&quot; --date=format:&quot;%y-%m-%d %H:%M:%S&quot; --shortstat --since=2.weeks &gt; log.txt<br></code></pre></td></tr></table></figure><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326112833997.png" alt="image-20230326112833997" style="zoom:67%;"><h2 id="git-amend修改最近一次提交"><a href="#git-amend修改最近一次提交" class="headerlink" title="git amend修改最近一次提交"></a>git amend修改最近一次提交</h2><blockquote><p>场景：假如刚刚有一笔提交，需要重新修改后提交，但是我们又不想生成新的commitId重新提交</p></blockquote><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326113641189.png" alt="image-20230326113641189" style="zoom:80%;"><h2 id="git命令创建别名"><a href="#git命令创建别名" class="headerlink" title="git命令创建别名"></a>git命令创建别名</h2><p>Linux：在home目录下，编辑<code>.gitconfig</code>文件</p><p>WIndow：在 <code>$HOME</code> 目录下（一般情况下是 <code>C:\Users\$USER</code> ）的 <code>.gitconfig</code> 文件</p><p>添加以下内容：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326210601688.png" alt="image-20230326210601688" style="zoom:80%;"><p>接下来我们就可以使用简短的命令表示以前繁琐的命令</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326210430079.png" alt="image-20230326210430079" style="zoom: 80%;"><p>如果我们想更简短一点，在Linux下，编辑<code>~/.bashrc</code>【Window编辑<code>C:\Users\$USER\.bash_profile</code>】，添加以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias gs=&#x27;git status&#x27;<br>alias gss=&#x27;git status |grep modified&#x27;<br>alias gd=&#x27;git diff &#x27;<br>alias gds=&#x27;git diff --staged&#x27;<br>alias gsh=&#x27;git show &#x27;<br>alias ga=&#x27;git add .&#x27;<br>alias gcm=&#x27;git commit .&#x27;<br>alias gc=&#x27;git checkout -- &#x27;<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">alias</span> gl=<span class="hljs-string">&#x27;git log --pretty=oneline  --abbrev-commit&#x27;</span></span><br>alias gl=&#x27;git lg&#x27;<br>alias glh=&#x27;git lg --graph&#x27;<br>alias gls=&#x27;git lg --author=panfei&#x27;<br>alias gb=&#x27;git branch -v&#x27;<br></code></pre></td></tr></table></figure><p>就可以使用<code>gs</code>表示<code>git status</code>…</p><h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><blockquote><p>🐌 <strong>参考</strong>：<a href="https://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html">阮一峰博客</a></p></blockquote><p>对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。</p><p>这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（<code>git merge</code>）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>git cherry-pick</code>命令的作用，就是将指定的提交（commit）应用于其他分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick &lt;commitHash&gt;<br></code></pre></td></tr></table></figure><p>上面命令就会将指定的提交<code>commitHash</code>，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。</p><p>举例来说，代码仓库有<code>master</code>和<code>feature</code>两个分支。</p><blockquote><p>a - b - c - d   Master<br>     <br>       e - f - g Feature</p></blockquote><p>现在将提交<code>f</code>应用到<code>master</code>分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到 master 分支</span><br>$ git checkout master<br><br><span class="hljs-comment"># Cherry pick 操作</span><br>$ git cherry-pick f<br></code></pre></td></tr></table></figure><p>上面的操作完成以后，代码库就变成了下面的样子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">a - b - c - d - f   Master<br>     \<br>       e - f - g Feature<br></code></pre></td></tr></table></figure><p>从上面可以看到，<code>master</code>分支的末尾增加了一个提交<code>f</code>。</p><p><code>git cherry-pick</code>命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bas">$ git cherry-pick feature<br></code></pre></td></tr></table></figure><p>上面代码表示将<code>feature</code>分支的最近一次提交，转移到当前分支。</p><h3 id="转移多个提交"><a href="#转移多个提交" class="headerlink" title="转移多个提交"></a>转移多个提交</h3><p>Cherry pick 支持一次转移多个提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;<br></code></pre></td></tr></table></figure><p>上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。</p><p>如果想要转移一系列的连续提交，可以使用下面的简便语法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick A..B <br></code></pre></td></tr></table></figure><p>上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。</p><p>注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick A^..B <br></code></pre></td></tr></table></figure><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><p><code>git cherry-pick</code>命令的常用配置项如下。</p><p><strong>（1）<code>-e</code>，<code>--edit</code></strong></p><p>打开外部编辑器，编辑提交信息。</p><p><strong>（2）<code>-n</code>，<code>--no-commit</code></strong></p><p>只更新工作区和暂存区，不产生新的提交。</p><p><strong>（3）<code>-x</code></strong></p><p>在提交信息的末尾追加一行<code>(cherry picked from commit ...)</code>，方便以后查到这个提交是如何产生的。</p><p><strong>（4）<code>-s</code>，<code>--signoff</code></strong></p><p>在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</p><p><strong>（5）<code>-m parent-number</code>，<code>--mainline parent-number</code></strong></p><p>如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。</p><p><code>-m</code>配置项告诉 Git，应该采用哪个分支的变动。它的参数<code>parent-number</code>是一个从<code>1</code>开始的整数，代表原始提交的父分支编号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick -m 1 &lt;commitHash&gt;<br></code></pre></td></tr></table></figure><p>上面命令表示，Cherry pick 采用提交<code>commitHash</code>来自编号1的父分支的变动。</p><p>一般来说，1号父分支是接受变动的分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from）。</p><h3 id="代码冲突"><a href="#代码冲突" class="headerlink" title="代码冲突"></a>代码冲突</h3><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p><p><strong>（1）<code>--continue</code></strong></p><p>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（<code>git add .</code>），第二步使用下面的命令，让 Cherry pick 过程继续执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure><p><strong>（2）<code>--abort</code></strong></p><p>发生代码冲突后，放弃合并，回到操作前的样子。</p><p><strong>（3）<code>--quit</code></strong></p><p>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。</p><h3 id="转移到另一个代码库"><a href="#转移到另一个代码库" class="headerlink" title="转移到另一个代码库"></a>转移到另一个代码库</h3><p>Cherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add target git://gitUrl<br></code></pre></td></tr></table></figure><p>上面命令添加了一个远程仓库<code>target</code>。</p><p>然后，将远程代码抓取到本地。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bas">$ git fetch target<br></code></pre></td></tr></table></figure><p>上面命令将远程代码仓库抓取到本地。</p><p>接着，检查一下要从远程仓库转移的提交，获取它的哈希值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> target/master<br></code></pre></td></tr></table></figure><p>最后，使用<code>git cherry-pick</code>命令转移提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick &lt;commitHash&gt;<br></code></pre></td></tr></table></figure><h2 id="Git-中-HEAD、工作树和索引之间的区别"><a href="#Git-中-HEAD、工作树和索引之间的区别" class="headerlink" title="Git 中 HEAD、工作树和索引之间的区别"></a>Git 中 HEAD、工作树和索引之间的区别</h2><blockquote><p>参考：<a href="http://fanyouf.gitee.io/interview/git/02.html#%E7%AE%80%E7%89%88">http://fanyouf.gitee.io/interview/git/02.html#%E7%AE%80%E7%89%88</a></p></blockquote><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2de056a0-fa40-11eb-991d-334fd31f0201.png" alt="img" style="zoom:80%;"><p>在<code>git</code>中，可以存在很多分支，其本质上是一个指向<code>commit</code>对象的可变指针，而<code>Head</code>是一个特别的指针，是一个指向你正在工作中的本地分支的指针</p><p>简单来讲，就是你现在在哪儿，HEAD 就指向哪儿</p><p>例如当前我们处于<code>master</code>分支，所以<code>HEAD</code>这个指针指向了<code>master</code>分支指针</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/36cb0da0-fa40-11eb-991d-334fd31f0201.png" alt="img" style="zoom:80%;"><p>然后通过调用<code>git checkout test</code>切换到<code>test</code>分支，那么<code>HEAD</code>则指向<code>test</code>分支，如下图：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3e86ba80-fa40-11eb-991d-334fd31f0201.png" alt="img" style="zoom:80%;"><p>但我们在<code>test</code>分支再一次<code>commit</code>信息的时候，<code>HEAD</code>指针仍然指向了<code>test</code>分支指针，而<code>test</code>分支指针已经指向了最新创建的提交，如下图：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/439839b0-fa66-11eb-991d-334fd31f0201.png" alt="img" style="zoom: 50%;"><p>这个<code>HEAD</code>存储的位置就在<code>.git/HEAD</code>目录中，查看信息可以看到<code>HEAD</code>指向了另一个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> .git/HEAD</span><br>ref: refs/heads/master<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> .git/refs/heads/master</span><br>7406a10efcc169bbab17827aeda189aa20376f7f<br></code></pre></td></tr></table></figure><p>这个文件的内容是一串哈希码，而这个哈希码正是<code>master</code>分支上最新的提交所对应的哈希码</p><p>所以，当我们切换分支的时候，<code>HEAD</code>指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</p><p>所以，HEAD 指针 ——–&gt; 分支指针 ——–&gt; 最新提交</p><h3 id="工作树和索引"><a href="#工作树和索引" class="headerlink" title="工作树和索引"></a>工作树和索引</h3><p>在<code>Git</code>管理下，大家实际操作的目录被称为<strong>工作树</strong>，也就是<strong>工作区域</strong></p><p>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域</p><p><code>Git</code>在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库</p><p>因此，要提交文件，首先需要把文件加入到索引区域中。</p><p>所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交</p><blockquote><p>工作树就是工作区，索引就是暂存区，数据库就是本地仓库</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>从所在的位置来看：</p><ul><li>HEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</li><li>工作树是查看和编辑的（源）文件的实际内容</li><li>索引是放置你想要提交给 git 仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过 git commit 则将索引区域的文件提交到 git 仓库中</li></ul><h2 id="如何理解git-checkout-–-file和git-reset-HEAD-–-file"><a href="#如何理解git-checkout-–-file和git-reset-HEAD-–-file" class="headerlink" title="如何理解git checkout – file和git reset HEAD – file"></a>如何理解git checkout – file和git reset HEAD – file</h2><blockquote><p>参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897889638509536">https://www.liaoxuefeng.com/wiki/896043488029600/897889638509536</a></p></blockquote><p>git checkout – file：撤销对工作区修改；这个命令是以最新的存储时间节点（add和commit）为参照，覆盖工作区对应文件file；这个命令改变的是<strong>工作区</strong>【使用场景：当需要撤回工作区的内容到上一个版本，<strong>但是还没有</strong>git add添加到暂存区】</p><p>git reset HEAD – file：清空add命令向暂存区提交的关于file文件的修改（Ustage）；这个命令仅改变<strong>暂存区</strong>，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何改变【使用场景：当需要撤回工作区的内容到上一个版本，<strong>但是已经</strong>git add添加到暂存区】</p><p>🍭 <strong>总结：</strong></p><blockquote><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Git学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核编译</title>
    <link href="/2023/03/22/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"/>
    <url>/2023/03/22/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux内核编译"><a href="#Linux内核编译" class="headerlink" title="Linux内核编译"></a>Linux内核编译</h1><h2 id="1-linux内核中Makefile、Kconfig、-config的关系"><a href="#1-linux内核中Makefile、Kconfig、-config的关系" class="headerlink" title="1.linux内核中Makefile、Kconfig、.config的关系"></a>1.linux内核中Makefile、Kconfig、.config的关系</h2><p><strong>三者的作用：</strong></p><ul><li>Makefile：一个文本形式的文件，编译源文件的方法。</li><li>Kconfig：一个文本形式的文件，内核的配置菜单。</li><li>.config：编译所依据的配置</li></ul><p><strong>三者的关系：</strong></p><p>简单来说就是去饭店点菜：Kconfig是菜单，Makefile是做法，.config就是你点的菜。在运行make menuconfig后在配置界面中出现的就是Kconfig中的选项，在界面中看到的已经配置好的选项就是从.config中读取出来的，当配置完成后就会将配置重新保存到.config中，编译时makefile会读取.config中配置来对内核进行编译。</p><blockquote><ol><li>如果.config不存在，运行make config&#x2F;menuconfig时的缺省设置由固化在各个Kconfig文件中各项目的缺省值决定。</li><li>如果.config存在，运行make config&#x2F;menuconfig时的缺省设置即是当前.config的设置，若对设置进行了修改，<code>.config</code>将被更新。</li><li>arch&#x2F;arm&#x2F;defconfig是一个缺省的配置文件，make defconfig时会根据这个文件生成当前的.config。</li><li>arch&#x2F;arm&#x2F;configs文件夹中有许多命名为xxx_defconfig的配置文件，如果运行make xxx_defconfig，当前.config文件会由xxx_defconfig文件生成。</li></ol></blockquote><p>🐼 <strong>总结一下</strong></p><p>执行<code>make xxx_defconfig</code>生成.config文件</p><p>执行<code>make menuconfig</code>可以修改.config文件。</p><h2 id="2-模块编译时obj-y和obj-m的区别"><a href="#2-模块编译时obj-y和obj-m的区别" class="headerlink" title="2.模块编译时obj-y和obj-m的区别"></a>2.模块编译时obj-y和obj-m的区别</h2><p>在进行模块编译时，主要有两个选项，obj-m和obj-y，而与内核密切相关的是obj-y选项，下面对两者之间的区别简单总结一下。</p><p>以test.c文件为例：</p><p>obj-m +&#x3D; test.o</p><p>obj-y  +&#x3D; test.o</p><p>其中:</p><ul><li><p>obj-m表示把文件test.o作为”模块”进行编译，不会编译到内核，但是会生成一个独立的 “test.ko” 文件。</p></li><li><p>obj-y表示把test.o文件编译进内核</p></li></ul><h2 id="3-Kernel中Makefile的语法"><a href="#3-Kernel中Makefile的语法" class="headerlink" title="3.Kernel中Makefile的语法"></a>3.Kernel中Makefile的语法</h2><p>1）直接编译</p><p>obj-y &#x3D; led.o</p><p>2）条件编译</p><p>obj-$(CONFIG_RAPIDIO) +&#x3D; rapidio.o</p><p>3）编译目录：</p><p>obj-$(CONFIG_ISCSI_TARGET)  +&#x3D; iscsi&#x2F;</p><h2 id="4-Kernel中Kconfig的语法"><a href="#4-Kernel中Kconfig的语法" class="headerlink" title="4.Kernel中Kconfig的语法"></a>4.Kernel中Kconfig的语法</h2><blockquote><p> 参考：<a href="https://mp.weixin.qq.com/s/crXt-6EvKtWg9QX7SM90Sw">https://mp.weixin.qq.com/s/crXt-6EvKtWg9QX7SM90Sw</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android S创建逻辑分区</title>
    <link href="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/"/>
    <url>/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-S创建逻辑分区"><a href="#Android-S创建逻辑分区" class="headerlink" title="Android S创建逻辑分区"></a>Android S创建逻辑分区</h1><p>从安卓模拟器看来，super设备对应的真实块设备为<code>/dev/block/vda2</code></p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230318233940020.png" alt="image-20230318233940020" style="zoom:80%;"><p>从真实模拟器运行环境来看，super总共分为了四个分区system、vendor、product、system_ext【其中<strong>system</strong>分区由于<strong>system as root</strong>机制作为了rootfs进行挂载】</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230318234134317.png" alt="image-20230318234134317" style="zoom: 80%;"><p>另外从网上找到一份真实Android S启动日志：</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230322203850415.png" alt="image-20230322203850415" style="zoom:80%;"><p>🤖从真实启动日志来看，那么<strong>为什么这个dm设备怎么来的？为什么dm-0是system_a而不是vendor_a呢？</strong></p><p>我们要带着这些问题去思考，一步步阅读源码，解决自己的疑惑……</p><h2 id="1-整体认知——LpMetadata"><a href="#1-整体认知——LpMetadata" class="headerlink" title="1.整体认知——LpMetadata"></a>1.整体认知——LpMetadata</h2><blockquote><p>这里引用<strong>洛奇看世界</strong>大哥画的精美示意图：<a href="https://blog.csdn.net/guyongqiangx/article/details/123899602">https://blog.csdn.net/guyongqiangx/article/details/123899602</a></p></blockquote><ul><li>super整体分区布局示意图如下：</li></ul><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/086bef9593e0494a90d27eef2e071bae.png" alt="image-20230318234134317" style="zoom: 80%;"><ul><li>super分区中的metadata如下：</li></ul><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/4ff675e237df41ed9c7d4809bed4d758.png" alt="image-20230318234134317" style="zoom: 67%;"><p>metadata对应的数据结构为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\liblp\include\liblp\liblp.h</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadata</span> &#123;<br>    LpMetadataGeometry geometry;<br>    LpMetadataHeader header;<br>    std::vector&lt;LpMetadataPartition&gt; partitions;<br>    std::vector&lt;LpMetadataExtent&gt; extents;<br>    std::vector&lt;LpMetadataPartitionGroup&gt; groups;<br>    std::vector&lt;LpMetadataBlockDevice&gt; block_devices;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面配合具体从super分区中抓取的数据解析。</p><p>命令：<code>dd if=/dev/block/platform/soc/7824900.sdhci/by-name/super bs=4096 count=1048576 of=/data/super.data</code></p><blockquote><p>下面引用：<a href="https://blog.csdn.net/weixin_43899302/article/details/119343835?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_43899302/article/details/119343835?spm=1001.2014.3001.5506</a></p></blockquote><h3 id="1-1-LpMetadataGeometry"><a href="#1-1-LpMetadataGeometry" class="headerlink" title="1.1 LpMetadataGeometry"></a>1.1 LpMetadataGeometry</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\liblp\include\liblp\metadata_format.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataGeometry</span> &#123;<br>    <span class="hljs-type">uint32_t</span> magic;<br>    <span class="hljs-type">uint32_t</span> struct_size;<br>    <span class="hljs-type">uint8_t</span> checksum[<span class="hljs-number">32</span>];<br>    <span class="hljs-type">uint32_t</span> metadata_max_size;<br>    <span class="hljs-type">uint32_t</span> metadata_slot_count;<br>    <span class="hljs-type">uint32_t</span> logical_block_size;<br>&#125; __attribute__((packed)) LpMetadataGeometry;<br></code></pre></td></tr></table></figure><p>因为metadata.img前面预留了4KB（4096Byte），所以偏移位置为<strong>0x1000h</strong></p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/28872ef9b62844a5b49c0caa07658ff6.png" alt="在这里插入图片描述" style="zoom:100%;"><blockquote><p>前32位（4字节）为MetadataGeometry的Magic，在代码中会进行校验魔术字LP_METADATA_GEOMETRY_MAGIC</p><p>☃️<strong>一定注意：看镜像的16进制都是小端模式</strong></p><p>依次类推，后面0x0000034表示32位的变量struct_size</p><p>所以最终这些<strong>metadata.img</strong>中的数据都会一一按位读取到结构体LpMetadataGeometry</p></blockquote><p>在创建super分区的时候，会调用<strong>ParseGeometry</strong>去进行解析<strong>LpMetadataGeometry</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\liblp\include\liblp\metadata_format.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LP_METADATA_GEOMETRY_MAGIC 0x616c4467</span><br><br><span class="hljs-comment">// system\core\fs_mgr\liblp\reader.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParseGeometry</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* buffer, LpMetadataGeometry* geometry)</span> </span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(*geometry) &lt;= LP_METADATA_GEOMETRY_SIZE);<br>    <span class="hljs-built_in">memcpy</span>(geometry, buffer, <span class="hljs-built_in">sizeof</span>(*geometry));<br><br>    <span class="hljs-keyword">if</span> (geometry-&gt;magic != LP_METADATA_GEOMETRY_MAGIC) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has invalid geometry magic signature.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (geometry-&gt;struct_size &gt; <span class="hljs-built_in">sizeof</span>(LpMetadataGeometry)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has unrecognized fields.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    &#123;<br>        LpMetadataGeometry temp = *geometry;<br>        <span class="hljs-built_in">memset</span>(&amp;temp.checksum, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(temp.checksum));<br>        <span class="hljs-built_in">SHA256</span>(&amp;temp, temp.struct_size, temp.checksum);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(temp.checksum, geometry-&gt;checksum, <span class="hljs-built_in">sizeof</span>(temp.checksum)) != <span class="hljs-number">0</span>) &#123;<br>            LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has invalid geometry checksum.&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (geometry-&gt;struct_size != <span class="hljs-built_in">sizeof</span>(LpMetadataGeometry)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has invalid struct size.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (geometry-&gt;metadata_slot_count == <span class="hljs-number">0</span>) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has invalid slot count.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (geometry-&gt;metadata_max_size % LP_SECTOR_SIZE != <span class="hljs-number">0</span>) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Metadata max size is not sector-aligned.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-LpMetadataHeader"><a href="#1-2-LpMetadataHeader" class="headerlink" title="1.2 LpMetadataHeader"></a>1.2 LpMetadataHeader</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\liblp\include\liblp\metadata_format.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataHeader</span> &#123;<br>    <span class="hljs-type">uint32_t</span> magic;<br>    <span class="hljs-type">uint16_t</span> major_version;<br>    <span class="hljs-type">uint16_t</span> minor_version;<br>    <span class="hljs-type">uint32_t</span> header_size;<br>    <span class="hljs-type">uint8_t</span> header_checksum[<span class="hljs-number">32</span>];<br>    <span class="hljs-type">uint32_t</span> tables_size;<br>    <span class="hljs-type">uint8_t</span> tables_checksum[<span class="hljs-number">32</span>];<br>    LpMetadataTableDescriptor partitions;<br>    LpMetadataTableDescriptor extents;<br>    LpMetadataTableDescriptor groups;<br>    LpMetadataTableDescriptor block_devices;<br>&#125; __attribute__((packed)) LpMetadataHeader;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataTableDescriptor</span> &#123;<br>    <span class="hljs-type">uint32_t</span> offset;<br>    <span class="hljs-type">uint32_t</span> num_entries;<br>    <span class="hljs-type">uint32_t</span> entry_size;<br>&#125; __attribute__((packed)) LpMetadataTableDescriptor;<br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/fc1dd4f8828e4e279906e52bd4417f7a.png" alt="在这里插入图片描述" style="zoom:100%;"><h3 id="1-3-LpMetadataPartition"><a href="#1-3-LpMetadataPartition" class="headerlink" title="1.3 LpMetadataPartition"></a>1.3 LpMetadataPartition</h3><p>这个就是表示super中的一个个逻辑分区所有的字段，比如说name表示逻辑分区名，attributes表示逻辑分区属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataPartition</span> &#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">36</span>];<br>    <span class="hljs-type">uint32_t</span> attributes;<br>    <span class="hljs-type">uint32_t</span> first_extent_index;<br>    <span class="hljs-type">uint32_t</span> num_extents;<br>    <span class="hljs-type">uint32_t</span> group_index;<br>&#125; __attribute__((packed)) LpMetadataPartition;<br><br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/e3b51aa1d6f94b66a78618b135853e75.png" alt="在这里插入图片描述" style="zoom:100%;"><p>我们来看一下前面的36字节表示的逻辑分区名，可以看到这里表示的是<strong>system</strong></p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230320234029590.png" alt="image-20230320234029590" style="zoom:80%;"><h3 id="1-4-LpMetadataExtent"><a href="#1-4-LpMetadataExtent" class="headerlink" title="1.4 LpMetadataExtent"></a>1.4 LpMetadataExtent</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataExtent</span> &#123;<br>    <span class="hljs-type">uint64_t</span> num_sectors;<br>    <span class="hljs-type">uint32_t</span> target_type;<br>    <span class="hljs-type">uint64_t</span> target_data;<br>    <span class="hljs-type">uint32_t</span> target_source;<br>&#125; __attribute__((packed)) LpMetadataExtent;<br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/02bdee1d427e444ab4e2d8b2416591fe.png" alt="在这里插入图片描述" style="zoom:100%;"><h3 id="1-5-LpMetadataPartitionGroup"><a href="#1-5-LpMetadataPartitionGroup" class="headerlink" title="1.5 LpMetadataPartitionGroup"></a>1.5 LpMetadataPartitionGroup</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataPartitionGroup</span> &#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">36</span>];<br>    <span class="hljs-type">uint32_t</span> flags;<br>    <span class="hljs-type">uint64_t</span> maximum_size;<br>&#125; __attribute__((packed)) LpMetadataPartitionGroup;<br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/0ea2cc17e450475396458ff4843f7a78.png" alt="在这里插入图片描述" style="zoom:100%;"><h3 id="1-6-LpMetadataBlockDevice"><a href="#1-6-LpMetadataBlockDevice" class="headerlink" title="1.6 LpMetadataBlockDevice"></a>1.6 LpMetadataBlockDevice</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataBlockDevice</span> &#123;<br>    <span class="hljs-type">uint64_t</span> first_logical_sector;<br>    <span class="hljs-type">uint32_t</span> alignment;<br>    <span class="hljs-type">uint32_t</span> alignment_offset;<br>    <span class="hljs-type">uint64_t</span> size;<br>    <span class="hljs-type">char</span> partition_name[<span class="hljs-number">36</span>];<br>    <span class="hljs-type">uint32_t</span> flags;<br>&#125; __attribute__((packed)) LpMetadataBlockDevice;<br><br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/9d54d69d1fe943458fe819d4edfa5bb8.png" alt="在这里插入图片描述" style="zoom100%;"><h2 id="2-Device-Mapper机制简介"><a href="#2-Device-Mapper机制简介" class="headerlink" title="2.Device Mapper机制简介"></a>2.Device Mapper机制简介</h2><blockquote><p>参考<strong>内核工匠</strong>的<a href="https://blog.csdn.net/feelabclihu/article/details/106581248?spm=1001.2014.3001.5506">DeviceMapper架构及在android上的应用</a></p></blockquote><p>Device Mapper是Linux2.6 内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构。</p><p>Device Mapper将所有与策略相关的工作放到用户空间完成，内核中主要提供完成这些策略所需要的机制。用户空间部分责配置具体的策略和控制逻辑，比如逻辑设备和哪些物理设备建立映射，怎么建立这些映射关系等，而具体重定向 IO 请求的工作由内核中相关代码完成。</p><p>内核中相关代码在内核源码的 kernel&#x2F;driver&#x2F;md&#x2F; 目录中，其代码文件可以划分为实现device mapper 内核中基本架构的文件(例如：dm.c dm_table.c等)和实现具体映射工作的 target driver 插件文件(例如：dm-bow.c dm-crypt.c dm-linear.c等)两部分。</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/format.png" style="zoom:80%;"><p>它包含三个重要的对象概念，Mapped Device、Mapping Table、Target device。</p><ul><li><strong>Mapped Device</strong>：是一个抽象的逻辑设备，通过MappingTable描述的映射关系（Mapped Device 逻辑的起始地址、范围、和表示在 Target Device 所在物理设备的地址偏移量以及Target 类型等信息）和Target Device建立映射关系。</li><li><strong>Target Device</strong>：是Mapped Device所映射的物理空间段。</li><li><strong>Mapping Table</strong>：DeviceMapper在内核中通过一个一个模块化的 Target Driver 插件实现对 IO 请求的过滤或者重新定向等工作，当前已经实现的插件包括：dm-crypt、dm-linear、dm-verity、dm-bow、dm-raid等。</li></ul><p>Device mapper 中这三个对象和 target driver 插件一起构成了一个可迭代的设备树。该层次在理论上可以在 device mapper 架构下无限迭代下去。</p><h3 id="2-1-核心数据结构"><a href="#2-1-核心数据结构" class="headerlink" title="2.1 核心数据结构"></a>2.1 核心数据结构</h3><ul><li><strong>mapped_device</strong> ：在dm.c 文件中定义，该结构用于表示 mapped device，它主要包括该 mapped device 相关的锁，注册的请求队列和一些内存池以及指向它所对应映射表的指针等域。</li><li><strong>dm_table</strong>：在文件dm_table.c 文件中定义，该结构中包含一个 dm_target结构数组，dm_target 结构具体描述了 mapped_device 到它某个 target device 的映射关系。而在 dm_table 结构中将这些 dm_target 按照 B 树的方式组织起来方便 IO 请求映射时的查找操作。dm_target 结构具体记录该结构对应 target device 所映射的 mapped device 逻辑区域的开始地址和范围，同时还包含指向具体 target device 相关操作的 target_type 结构的指针。</li><li><strong>target_type</strong>：该结构主要包含了 target device 对应的 target driver 插件的名字、定义的构建和删除该类型target device的方法、该类target device对应的IO请求重映射和结束IO的方法等。而表示具体的target device的域是dm_target中的private域，该指针指向mapped device所映射的具体target device对应的结构。表示target device的具体结构由于不同的target 类型而不同。</li></ul><p>开发者可以定制device target部分，以实现自己所需要的需求功能。</p><h3 id="2-2-三步建立dm设备的过程"><a href="#2-2-三步建立dm设备的过程" class="headerlink" title="2.2 三步建立dm设备的过程"></a>2.2 <strong>三步建立dm设备的过程</strong></h3><p>通过下述的三个主要步骤，device mapper在内核中就建立一个可以提供给用户使用的mapped device逻辑块设备。</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/device-mapper.png"><h2 id="3-挂载阶段创建逻辑分区"><a href="#3-挂载阶段创建逻辑分区" class="headerlink" title="3.挂载阶段创建逻辑分区"></a>3.挂载阶段创建逻辑分区</h2><h3 id="3-1-开始挂载"><a href="#3-1-开始挂载" class="headerlink" title="3.1 开始挂载"></a>3.1 开始挂载</h3><p>🐼 关于第一阶段挂载的流程可以参考我之前写的<a href="https://blog.csdn.net/stephen_curry300/article/details/126110983?spm=1001.2014.3001.5501">CSDN博客</a></p><p>挂载的入口如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 路径: /system/core/init/first_stage_mount.cpp</span><br><span class="hljs-comment">// 在设备树中挂载由fstab文件指定的分区</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DoFirstStageMount</span><span class="hljs-params">(<span class="hljs-type">bool</span> create_devices)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> fsm = FirstStageMount::<span class="hljs-built_in">Create</span>();<br>    <span class="hljs-keyword">return</span> (*fsm)-&gt;<span class="hljs-built_in">DoFirstStageMount</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FirstStageMount::DoFirstStageMount</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">MountPartitions</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用MountPartitions去挂载分区</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\first_stage_mount.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FirstStageMount::CreateLogicalPartitions</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 遍历读取到的fstab中flag中是否含有logical</span><br>    <span class="hljs-comment">// 如果有，则支持DmLinear</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsDmLinearEnabled</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 对应3.2 读取元数据</span><br>    <span class="hljs-keyword">auto</span> metadata = android::fs_mgr::<span class="hljs-built_in">ReadCurrentMetadata</span>(super_path_);<br><br>    <span class="hljs-comment">// TODO...</span><br>    <span class="hljs-keyword">return</span> android::fs_mgr::<span class="hljs-built_in">CreateLogicalPartitions</span>(*metadata.<span class="hljs-built_in">get</span>(), super_path_);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-读取元数据"><a href="#3-2-读取元数据" class="headerlink" title="3.2 读取元数据"></a>3.2 读取元数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\fs_mgr_dm_linear.cpp</span><br><span class="hljs-comment">// 传进来的block_device是super分区对应的真实的块设备（假设为/dev/block/mmcblk0p5）</span><br><span class="hljs-function">std::unique_ptr&lt;LpMetadata&gt; <span class="hljs-title">ReadCurrentMetadata</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; block_device)</span> </span>&#123;<br>    <span class="hljs-comment">// fs_mgr_get_slot_suffix获取环境变量ro.boot.slot_suffix</span><br>    <span class="hljs-comment">// 如果当前启动分区为_a，则slot=0</span><br>    <span class="hljs-comment">// 如果当前启动分区为_b，则slot=1</span><br>    <span class="hljs-type">uint32_t</span> slot = <span class="hljs-built_in">SlotNumberForSlotSuffix</span>(<span class="hljs-built_in">fs_mgr_get_slot_suffix</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReadMetadata</span>(block_device.<span class="hljs-built_in">c_str</span>(), slot);<br>&#125;<br><br><span class="hljs-comment">// 传进来的super_partition是/dev/block/mmcblk0p5</span><br><span class="hljs-comment">// 假设启动分区为_a，slot_number为0</span><br><span class="hljs-function">std::unique_ptr&lt;LpMetadata&gt; <span class="hljs-title">ReadMetadata</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; super_partition, <span class="hljs-type">uint32_t</span> slot_number)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReadMetadata</span>(<span class="hljs-built_in">PartitionOpener</span>(), super_partition, slot_number);<br>&#125;<br><br><span class="hljs-comment">// --------------------------------------------------------------</span><br><br><span class="hljs-comment">// system\core\fs_mgr\liblp\reader.cpp</span><br><span class="hljs-function">std::unique_ptr&lt;LpMetadata&gt; <span class="hljs-title">ReadMetadata</span><span class="hljs-params">(<span class="hljs-type">const</span> IPartitionOpener&amp; opener,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         <span class="hljs-type">const</span> std::string&amp; super_partition, <span class="hljs-type">uint32_t</span> slot_number)</span> </span>&#123;<br>    android::base::unique_fd fd = opener.<span class="hljs-built_in">Open</span>(super_partition, O_RDONLY);<br><br>    LpMetadataGeometry geometry;<br>    <span class="hljs-comment">// 读取/dev/block/mmcblk0p5中的元数据</span><br>    <span class="hljs-comment">// 读的是1.1节中的LpMetadataGeometry数据结构，将其保存到geometry</span><br>    <span class="hljs-comment">// 目的是直接赋值给下面即将创建的变量meta的成员变量geometry</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ReadLogicalPartitionGeometry</span>(fd, &amp;geometry)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    std::unique_ptr&lt;LpMetadata&gt; metadata;<br><br>    <span class="hljs-comment">// 读取/dev/block/mmcblk0p5中的所有的元数据</span><br>    <span class="hljs-comment">// 将其保存到metadata变量中，最后返回3.1中最初调用ReadCurrentMetadata的地方</span><br>    <span class="hljs-comment">// 所有的metadata结构都是按照1.整体认知——LpMetadata分布的</span><br>    metadata = <span class="hljs-built_in">ParseMetadata</span>(geometry, fd)<br>    <br>    <span class="hljs-keyword">return</span> metadata;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-创建逻辑分区"><a href="#3-3-创建逻辑分区" class="headerlink" title="3.3 创建逻辑分区"></a>3.3 创建逻辑分区</h3><p><strong>3.2节和3.3节是独立的，两节都是3.1的子篇，不要线性阅读</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateLogicalPartitions</span><span class="hljs-params">(<span class="hljs-type">const</span> LpMetadata&amp; metadata, <span class="hljs-type">const</span> std::string&amp; super_device)</span> </span>&#123;<br>    CreateLogicalPartitionParams params = &#123;<br>            .block_device = super_device,<br>            .metadata = &amp;metadata,<br>    &#125;;<br>    <span class="hljs-comment">// 这里的metadata.partitions是1.3节的LpMetadataPartition</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; partition : metadata.partitions) &#123;<br>        params.partition = &amp;partition;<br><br>        std::string ignore_path;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateLogicalPartition</span>(params, &amp;ignore_path)) &#123;<br>            LERROR &lt;&lt; <span class="hljs-string">&quot;Could not create logical partition: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetPartitionName</span>(partition);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会遍历metadata中存储的partitions成员变量，也就是metadata.img中存放的一个个逻辑分区信息，例如如果我们第一个存储的LpMetadataPartition是system的信息，那么首先调用CreateLogicalPartition去创建逻辑分区，第二个存储的LpMetadataPartition是vendor的信息，相应的调用CreateLogicalPartition去创建逻辑分。</p><p>🎈<strong>到这里解释了开头我们提到的为什么dm-1、dm-2创建的先后顺序，其与metadata.img中的分区顺序有关，换句话说，就是与生成super.img时指明的顺序有关。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateLogicalPartition</span><span class="hljs-params">(CreateLogicalPartitionParams params, std::string* path)</span> </span>&#123;<br>    CreateLogicalPartitionParams::OwnedData owned_data;<br>    <span class="hljs-keyword">if</span> (!params.<span class="hljs-built_in">InitDefaults</span>(&amp;owned_data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    DmTable table;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateDmTableInternal</span>(params, &amp;table)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    DeviceMapper&amp; dm = DeviceMapper::<span class="hljs-built_in">Instance</span>();<br>    <span class="hljs-keyword">if</span> (!dm.<span class="hljs-built_in">CreateDevice</span>(params.device_name, table, path, params.timeout_ms)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 文章开头的启动日志打印就是在这里</span><br>    LINFO &lt;&lt; <span class="hljs-string">&quot;Created logical partition &quot;</span> &lt;&lt; params.device_name &lt;&lt; <span class="hljs-string">&quot; on device &quot;</span> &lt;&lt; *path;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-1-InitDefaults初始化CreateLogicalPartitionParams"><a href="#3-3-1-InitDefaults初始化CreateLogicalPartitionParams" class="headerlink" title="3.3.1 InitDefaults初始化CreateLogicalPartitionParams"></a>3.3.1 InitDefaults初始化CreateLogicalPartitionParams</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateLogicalPartitionParams::InitDefaults</span><span class="hljs-params">(CreateLogicalPartitionParams::OwnedData* owned)</span> </span>&#123;<br>    <span class="hljs-comment">// 3.3节开头的CreateLogicalPartitionParams params的参数中还没有初始化partition_name</span><br>    <span class="hljs-keyword">if</span> (partition_name.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// partition_name为system</span><br>        partition_name = android::fs_mgr::<span class="hljs-built_in">GetPartitionName</span>(*partition);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (partition_name != android::fs_mgr::<span class="hljs-built_in">GetPartitionName</span>(*partition)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Inconsistent partition_name &quot;</span> &lt;&lt; partition_name &lt;&lt; <span class="hljs-string">&quot; with partition &quot;</span><br>               &lt;&lt; android::fs_mgr::<span class="hljs-built_in">GetPartitionName</span>(*partition);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (device_name.<span class="hljs-built_in">empty</span>()) &#123;<br>        device_name = partition_name;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// --------------------------------------------------------------</span><br><br><span class="hljs-comment">// system\core\fs_mgr\liblp\reader.cpp</span><br><span class="hljs-function">std::string <span class="hljs-title">GetPartitionName</span><span class="hljs-params">(<span class="hljs-type">const</span> LpMetadataPartition&amp; partition)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">NameFromFixedArray</span>(partition.name, <span class="hljs-built_in">sizeof</span>(partition.name));<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="3-3-2-CreateDmTableInternal创建dm-linear设备table"><a href="#3-3-2-CreateDmTableInternal创建dm-linear设备table" class="headerlink" title="3.3.2 CreateDmTableInternal创建dm-linear设备table"></a>3.3.2 CreateDmTableInternal创建dm-linear设备table</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateDmTableInternal</span><span class="hljs-params">(<span class="hljs-type">const</span> CreateLogicalPartitionParams&amp; params, DmTable* table)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; super_device = params.block_device;<br><br>    <span class="hljs-type">uint64_t</span> sector = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; params.partition-&gt;num_extents; i++) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; extent = params.metadata-&gt;extents[params.partition-&gt;first_extent_index + i];<br>        std::unique_ptr&lt;DmTarget&gt; target;<br>        <span class="hljs-keyword">switch</span> (extent.target_type) &#123;<br>            <span class="hljs-keyword">case</span> LP_TARGET_TYPE_ZERO:<br>                target = std::<span class="hljs-built_in">make_unique</span>&lt;DmTargetZero&gt;(sector, extent.num_sectors);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> LP_TARGET_TYPE_LINEAR: &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; block_device = params.metadata-&gt;block_devices[extent.target_source];<br>                std::string dev_string;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetPhysicalPartitionDevicePath</span>(params, block_device, super_device,<br>                                                    &amp;dev_string)) &#123;<br>                    <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Unable to complete device-mapper table, unknown block device&quot;</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                target = std::<span class="hljs-built_in">make_unique</span>&lt;DmTargetLinear&gt;(sector, extent.num_sectors, dev_string,<br>                                                          extent.target_data);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Unknown target type in metadata: &quot;</span> &lt;&lt; extent.target_type;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!table-&gt;<span class="hljs-built_in">AddTarget</span>(std::<span class="hljs-built_in">move</span>(target))) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        sector += extent.num_sectors;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (params.partition-&gt;attributes &amp; LP_PARTITION_ATTR_READONLY) &#123;<br>        table-&gt;<span class="hljs-built_in">set_readonly</span>(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (params.force_writable) &#123;<br>        table-&gt;<span class="hljs-built_in">set_readonly</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-3-CreateDevice"><a href="#2-3-3-CreateDevice" class="headerlink" title="2.3.3 CreateDevice"></a>2.3.3 CreateDevice</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\libdm\dm.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeviceMapper::CreateDevice</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> DmTable&amp; table, std::string* path,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">const</span> std::chrono::milliseconds&amp; timeout_ms)</span> </span>&#123;<br>    std::string uuid = <span class="hljs-built_in">GenerateUuid</span>();<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateDevice</span>(name, uuid)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    std::string unique_path;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">LoadTableAndActivate</span>(name, table) || !<span class="hljs-built_in">GetDeviceUniquePath</span>(name, &amp;unique_path) ||<br>        !<span class="hljs-built_in">GetDmDevicePathByName</span>(name, path)) &#123;<br>        <span class="hljs-built_in">DeleteDevice</span>(name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WaitForFile</span>(unique_path, timeout_ms)) &#123;<br>        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed waiting for device path: &quot;</span> &lt;&lt; unique_path;<br>        <span class="hljs-built_in">DeleteDevice</span>(name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeviceMapper::CreateDevice</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> std::string&amp; uuid)</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dm_ioctl</span> io;<br>    <span class="hljs-built_in">InitIo</span>(&amp;io, name);<br>    <span class="hljs-keyword">if</span> (!uuid.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-built_in">snprintf</span>(io.uuid, <span class="hljs-built_in">sizeof</span>(io.uuid), <span class="hljs-string">&quot;%s&quot;</span>, uuid.<span class="hljs-built_in">c_str</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ioctl</span>(fd_, DM_DEV_CREATE, &amp;io)) &#123;<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;DM_DEV_CREATE failed for [&quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>展讯Android P System_as_root规范说明</title>
    <link href="/2023/03/16/%E5%B1%95%E8%AE%AFAndroid-P-System-as-root%E8%A7%84%E8%8C%83%E8%AF%B4%E6%98%8E/"/>
    <url>/2023/03/16/%E5%B1%95%E8%AE%AFAndroid-P-System-as-root%E8%A7%84%E8%8C%83%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="展讯Android-P-System-as-root规范说明"><a href="#展讯Android-P-System-as-root规范说明" class="headerlink" title="展讯Android P System_as_root规范说明"></a>展讯Android P System_as_root规范说明</h1><blockquote><p>作为个人学习笔记使用，<a href="https://bbs.16rd.com/thread-584995-1-1.html">https://bbs.16rd.com/thread-584995-1-1.html</a></p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Android 从 8.0 开始引入了 Treble 架构，目的是让 Android 设备制造商能够更快，更容易，更低成本的去升级 Android 版本。为实现这一目的，Google 设定了很多规则，设备商只有实现了这些规 则，才能满足 Treble 架构的要求。本文介绍的 system as root 就是 Google 在 AndroidP 上提出的一 项改动规则。</p><p>所谓 system as root，指的是 system 分区被挂载为 rootfs，android 可以通过 OTA 直接升级 rootfs，避免出现 system 升级之后，存储在 ramdisk（rootfs）中的 init&#x2F;init.rc 与新的 android 版本不匹配导致系统出问题。 在 A&#x2F;B 系统的 device 上，ramdisk 已经打包到 system.img 了，所以无需做什么适配。搭载Android 9.x 的所有新设备都必须使用 system-as-root（BOARD_BUILD_SYSTEM_ROOT_IMAGE必须为 true），它可以将 ramdisk.img 合并到 system.img，而后者会反过来再作为 rootfs 进行装载。对于要升级到 Android 9 的设备，使用 system-as-root 并非强制要求。</p><p>System as root 的改动部分可如下图所示：</p><img src="/2023/03/16/%E5%B1%95%E8%AE%AFAndroid-P-System-as-root%E8%A7%84%E8%8C%83%E8%AF%B4%E6%98%8E/173632rimzt33h8mi4ntif.jpg" alt="173632rimzt33h8mi4ntif" style="zoom:80%;"><h2 id="2-System-as-root-规范"><a href="#2-System-as-root-规范" class="headerlink" title="2.System as root 规范"></a>2.System as root 规范</h2><p>System as root 的核心在于 ramdisk 会被打包到 system.img，基于这种状况，设备厂商自行添加到 ramdisk 中的改动，必须转移到其它位置，否则 system.img 一更换（例如 GSI 版本），ramdisk中添加的内容就丢失了，导致系统启动可能出现问题。根据 Google 发布的 system as root 文档的要求，总结了下面这些需要调整的部分：</p><table><thead><tr><th>ID</th><th>修改内容</th><th>规范</th></tr></thead><tbody><tr><td>1</td><td>rc文件的调整</td><td>原来放置在device&#x2F;{board}&#x2F;路径中的rc文件，需要编译 到vendor&#x2F;etc&#x2F;init;另一方面如果修改了 &#x2F;system&#x2F;core&#x2F;rootdir&#x2F;T init.*.rc ,最好将修改移动到设备厂 商自行添加的rc文件中；rc文件中import的路径需要修改， 避免import路径错误导致rc文件没有被解析。</td></tr><tr><td>2</td><td>内核模块移岀ramdisk</td><td>内核模块驱动已经移到vendor分区。</td></tr><tr><td>3</td><td>fstab文件路径调整</td><td>fstab文件需要从ramdisk移动到vendor&#x2F;etc</td></tr><tr><td>4</td><td>ramdisk打包调整</td><td>ramdisk.img 需要打包到 system.img 中</td></tr><tr><td>5</td><td>dm-verify实现方案调整</td><td>AndroidP ± dm-verify必须开启,UNISOC版本已默认 开启 dm-verify</td></tr></tbody></table><h3 id="2-1-rc文件的调整"><a href="#2-1-rc文件的调整" class="headerlink" title="2.1 rc文件的调整"></a>2.1 rc文件的调整</h3><p>在 device&#x2F;{board}仓库中存在很多设备相关的 rc 文件，在 AndroidP 之前，这些 rc 文件是被编译到 ramdisk 的根路径的，但是按照 system as root 的要求，这些文件必须调整到其它路径，且文件 中 import rc 等语句所对应的路径需要做调整。具体改动如下：</p><ul><li>device&#x2F;{board} 路径的 rc 文件 copy 到 vendor 分区，例如： device&#x2F;{board}&#x2F;common&#x2F;DeviceCommon.mk</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">product_COPY_FILES += \<br><span class="hljs-variable">$(LOCAL_PATH)</span>/rootdir/root/init.common.rc:<span class="hljs-variable">$(TARGET_COPY_OUT_VENDOR)</span>/etc/init/hw/init.common .rc \<br><span class="hljs-variable">$(LOCAL_PATH)</span>/rootdir/root/init.ram.rc:<span class="hljs-variable">$(TARGET_COPY_OUT_VENDOR)</span>/etc/init/hw/init.ram.rc \<br></code></pre></td></tr></table></figure><ul><li>device&#x2F;{board} 路径的 rc 文件 import 路径需要做相应调整：例如 device&#x2F;{board}&#x2F;common&#x2F;rootdir&#x2F;root&#x2F;init.common.rc 文件原本 import 的都是根路径的 rc 文件，现在需要根据实际归档路径来调整。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">import /vendor/etc/init/hw/init.$&#123;ro.hardware&#125;.usb.rc<br>import /vendor/etc/init/hw/init.ram.rc<br>import /vendor/etc/init/hw/init.storage.rc<br></code></pre></td></tr></table></figure><h3 id="2-2-内核模块移出ramdisk"><a href="#2-2-内核模块移出ramdisk" class="headerlink" title="2.2  内核模块移出ramdisk"></a>2.2  内核模块移出ramdisk</h3><p>在 UNISOC 平台，部分 kernel modules 放到 ramdisk 的 lib 路径下，在开启了 <strong>system as root</strong>之后，遵循 Google 的建议，需要统一调整到&#x2F;vendor&#x2F;lib&#x2F;modules 中：</p><ul><li>在模块的 Android.mk(bp)中，将模块 bin 文件归档路径设定为&#x2F;vendor&#x2F;lib&#x2F;modules：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs make\">vendor/sprd/modules/wcn/fm/driver/Android.mk<br>1. LOCAL_MODULE := sprd_fm.ko<br>2. LOCAL_MODULE_CLASS := SHARED_LIBRARIES<br>3. LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/etc/modules<br></code></pre></td></tr></table></figure><h3 id="2-3-fstab-文件路径调整"><a href="#2-3-fstab-文件路径调整" class="headerlink" title="2.3 fstab 文件路径调整"></a>2.3 fstab 文件路径调整</h3><p>fstab 是用于定义文件系统 mount 信息的，这个文件与设备的存储强相关，所以也需要从 ramdisk移出，将 fstab 放在 vendor&#x2F;etc&#x2F;路径下。需要注意的是，recovery 模式所用的 ramdisk 与正常开机的不是一个， 所以 recovery 模式所用的 fstab 文件，路径不用修改。</p>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>User Data Checkpoint机制</title>
    <link href="/2023/03/15/User-Data-Checkpoint%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/03/15/User-Data-Checkpoint%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="User-Data-Checkpoint机制-UDC"><a href="#User-Data-Checkpoint机制-UDC" class="headerlink" title="User Data Checkpoint机制(UDC)"></a>User Data Checkpoint机制(UDC)</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>由于AB升级的回滚机制只支持到early_boot阶段，如果OTA升级的过程中，data分区被修改了，并且OTA升级失败了，则data分区是无法回滚到之前的状态的。UDC功能是为了解决OTA升级失败后，当data分区被修改后，不支持回滚data分区的问题。UDC同时支持绑定key版本以及防止key回滚的功能。</p><h2 id="2-实现UDC"><a href="#2-实现UDC" class="headerlink" title="2.实现UDC"></a>2.实现UDC</h2><blockquote><p>一定要参考安卓官网：<a href="https://source.android.com/docs/core/ota/user-data-checkpoint?hl=zh-cn">https://source.android.com/docs/core/ota/user-data-checkpoint?hl=zh-cn</a></p></blockquote><h3 id="2-1-设置"><a href="#2-1-设置" class="headerlink" title="2.1 设置"></a>2.1 设置</h3><p>在 <code>init.hardware.rc</code> 文件的 <code>on fs</code> 中，确保您具有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount_all /vendor/etc/fstab.$&#123;ro.boot.hardware.platform&#125; --early<br></code></pre></td></tr></table></figure><p>在 <code>init.hardware.rc</code> 文件的 <code>on late-fs</code> 中，确保您具有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount_all /vendor/etc/fstab.$&#123;ro.boot.hardware.platform&#125; --late<br></code></pre></td></tr></table></figure><p>在 <code>fstab.hardware</code> 文件中，确保将 <code>/data</code> 标记为 <code>latemount</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/dev/block/bootdevice/by-name/userdata              /data              f2fs<br>noatime,nosuid,nodev,discard,reserve_root=32768,resgid=1065,fsync_mode=nobarrier<br>latemount,wait,check,fileencryption=ice,keydirectory=/metadata/vold/metadata_encryption,quota,formattable,sysfs_path=/sys/devices/platform/soc/1d84000.ufshc,reservedsize=128M,checkpoint=fs<br></code></pre></td></tr></table></figure><h3 id="2-2-添加metadata分区"><a href="#2-2-添加metadata分区" class="headerlink" title="2.2 添加metadata分区"></a>2.2 添加metadata分区</h3><p>UDC 需要使用 metadata 分区来存储非引导加载程序重试计数和密钥。设置 metadata 分区并提前将其装载在 <code>/metadata</code> 中。</p><p>在 <code>fstab.hardware</code> 文件中，确保将 <code>/metadata</code> 标记为 <code>earlymount</code> 或 <code>first_stage_mount</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/dev/block/by-name/metadata           /metadata           ext4<br>noatime,nosuid,nodev,discard,sync<br>wait,formattable,first_stage_mount<br></code></pre></td></tr></table></figure><p>将分区初始化为全零。</p><p>将以下行添加到 <code>BoardConfig.mk</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">BOARD_USES_METADATA_PARTITION := true<br>BOARD_ROOT_EXTRA_FOLDERS := existing_folders metadata<br></code></pre></td></tr></table></figure><h3 id="2-3-更新系统"><a href="#2-3-更新系统" class="headerlink" title="2.3 更新系统"></a>2.3 更新系统</h3><p><strong>F2FS 系统</strong></p><ul><li><p>对于使用 F2FS 来格式化数据的系统，请确保您的 F2FS 版本支持检查点。</p></li><li><p>对于在 <code>/data</code> 装载的设备，请将 <code>checkpoint=fs</code> 标志添加到 fstab 的 <code>&lt;fs_mgr_flags&gt;</code> 部分。</p></li></ul><p><strong>非 F2FS 系统</strong></p><ul><li>对于非 F2FS 系统，必须在内核配置中启用 <code>dm-bow</code>。</li><li>对于在 <code>/data</code> 装载的设备，请将 <code>checkpoint=block</code> 标志添加到 fstab 的 <code>&lt;fs_mgr_flags&gt;</code> 部分。</li></ul><h2 id="3-f2fs挂载流程"><a href="#3-f2fs挂载流程" class="headerlink" title="3.f2fs挂载流程"></a>3.f2fs挂载流程</h2><p>既然上面提到了f2fs天然支持checkpoint，那我们分析一下它的挂载流程</p><h3 id="3-1开始挂载所有"><a href="#3-1开始挂载所有" class="headerlink" title="3.1开始挂载所有"></a>3.1开始挂载所有</h3><p>在rc中会调用mount_all来挂载所有fstab中的entry</p><p>在<code>device/softwinner/ceres-common/init.sun50iw10p1.rc</code>文件的on fs中有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount_all /vendor/etc/fstab.sun50iw10p1 --early<br></code></pre></td></tr></table></figure><p>在<code>device/softwinner/ceres-b3/fstab.sun50iw10p1.rc</code>文件的<code>data</code>分区中添加<code>latemount</code>和<code>checkpoint=fs</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/dev/block/by-name/UDISK      /data        f2fs     noatime,nosuid,nodev,discard wait,check,formattable,quota,reservedsize=33554432,fileencryption=aes-256-xts:aes-256-cts,latemount,checkpoint=fs<br></code></pre></td></tr></table></figure><p>此时会去解析mount_all对应的动作，然后将<code>/vendor/etc/fstab.sun50iw10p1</code>作为arg[0]，<code>--early</code>作为arg[1]传给mount_all对应的处理函数<code>do_mount_all</code></p><img src="/2023/03/15/User-Data-Checkpoint%E6%9C%BA%E5%88%B6/image-20230315202320251.png" alt="image-20230315202320251"><p>在<code>do_mount_all</code>中会调用fs_mgr_mount_all挂载所有<code>/vendor/etc/fstab.sun50iw10p1</code>中的项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\builtins.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> Result&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">do_mount_all</span><span class="hljs-params">(<span class="hljs-type">const</span> BuiltinArguments&amp; args)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    Fstab fstab;<br>    <span class="hljs-keyword">if</span> (mount_all-&gt;fstab_path.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ReadDefaultFstab</span>(&amp;fstab)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Error</span>() &lt;&lt; <span class="hljs-string">&quot;Could not read default fstab&quot;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 会将/vendor/etc/fstab.sun50iw10p1中的每一项解析好放在fstab数组中</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ReadFstabFromFile</span>(mount_all-&gt;fstab_path, &amp;fstab)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Error</span>() &lt;&lt; <span class="hljs-string">&quot;Could not read fstab&quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 调用fs_mgr_mount_all挂载所有解析出来的entry</span><br>    <span class="hljs-keyword">auto</span> mount_fstab_result = <span class="hljs-built_in">fs_mgr_mount_all</span>(&amp;fstab, mount_all-&gt;mode);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-fs-mgr-mount-all做好准备工作"><a href="#3-2-fs-mgr-mount-all做好准备工作" class="headerlink" title="3.2 fs_mgr_mount_all做好准备工作"></a>3.2 fs_mgr_mount_all做好准备工作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">MountAllResult <span class="hljs-title">fs_mgr_mount_all</span><span class="hljs-params">(Fstab* fstab, <span class="hljs-type">int</span> mount_mode)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(fstab-&gt;<span class="hljs-built_in">size</span>()); i++) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; current_entry = (*fstab)[i];<br>        <span class="hljs-comment">// 调用checkpoint_manager的Update方法</span><br>        <span class="hljs-keyword">if</span> (!checkpoint_manager.<span class="hljs-built_in">Update</span>(&amp;current_entry)) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// system\core\fs_mgr\fs_mgr.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(FstabEntry* entry, <span class="hljs-type">const</span> std::string&amp; block_device = std::string())</span> </span>&#123;<br>    <span class="hljs-comment">// fs_mgr_flags是否包含checkpoint=fs或checkpoint=blk</span><br>    <span class="hljs-comment">// 显然包含</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SupportsCheckpoint</span>(entry)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ***********************这里是最重要的***********************</span><br>    <span class="hljs-comment">// ***********************这里是最重要的***********************</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NeedsCheckpoint</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">UpdateCheckpointPartition</span>(entry, block_device)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Could not set up checkpoint partition, skipping!&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-1-NeedsCheckpoint判断是否需要检查Checkpoint"><a href="#3-2-1-NeedsCheckpoint判断是否需要检查Checkpoint" class="headerlink" title="3.2.1 NeedsCheckpoint判断是否需要检查Checkpoint"></a>3.2.1 NeedsCheckpoint判断是否需要检查Checkpoint</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\fs_mgr.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NeedsCheckpoint</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用vdc二进制，传入第一个参数checkpoint,第二个参数needsCheckpoint，最终回调的结果是needs_checkpoint_</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">call_vdc</span>(&#123;<span class="hljs-string">&quot;checkpoint&quot;</span>, <span class="hljs-string">&quot;needsCheckpoint&quot;</span>&#125;, &amp;needs_checkpoint_)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Failed to find if checkpointing is needed. Assuming no.&quot;</span>;<br>        needs_checkpoint_ = NO;<br>    &#125;<br>    <span class="hljs-keyword">return</span> needs_checkpoint_ == YES;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>vdc</strong>二进制编译完以后位于<code>out/target/product/[productName]</code>中</p><img src="/2023/03/15/User-Data-Checkpoint%E6%9C%BA%E5%88%B6/image-20230315204223717.png" alt="image-20230315204223717" style="zoom:50%;"><p>下面看一下它的main入口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\vold\vdc.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (xxx) &#123;<br>        <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;checkpoint&quot;</span> &amp;&amp; args[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;needsCheckpoint&quot;</span> &amp;&amp; args.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">bool</span> enabled = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 调用needsCheckpoint方法</span><br>        <span class="hljs-built_in">checkStatus</span>(args, vold-&gt;<span class="hljs-built_in">needsCheckpoint</span>(&amp;enabled));<br>        <span class="hljs-keyword">return</span> enabled ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">binder::Status <span class="hljs-title">VoldNativeService::needsCheckpoint</span><span class="hljs-params">(<span class="hljs-type">bool</span>* _aidl_return)</span> </span>&#123;<br>    *_aidl_return = <span class="hljs-built_in">cp_needsCheckpoint</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Ok</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cp_needsCheckpoint</span><span class="hljs-params">()</span> </span>&#123;<br><br>    sp&lt;IBootControl&gt; <span class="hljs-keyword">module</span> = IBootControl::<span class="hljs-built_in">getService</span>();<br><br>    <span class="hljs-keyword">if</span> (isCheckpointing) <span class="hljs-keyword">return</span> isCheckpointing;<br><br>    <span class="hljs-comment">// 调用bootctl的isSlotMarkedSuccessful方法</span><br>    <span class="hljs-comment">// 如果是第一次启动，那必然boot分区没有succ标记</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">module</span> &amp;&amp; <span class="hljs-keyword">module</span>-&gt;<span class="hljs-built_in">isSlotMarkedSuccessful</span>(<span class="hljs-keyword">module</span>-&gt;<span class="hljs-built_in">getCurrentSlot</span>()) == BoolResult::FALSE) &#123;<br>        isCheckpointing = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>如果是OTA升级阶段或者是第一次刷固件的时候（调用boot_ctrl判断当前slot是否已经Marked Successful了，如果没有，表明此时处于OTA升级阶段或者是第一次刷固件的时候，需要进行checkpoint），则返回true；正常情况就是false；</strong></p><h4 id="3-2-2-UpdateCheckpointPartition更新挂载opt选项"><a href="#3-2-2-UpdateCheckpointPartition更新挂载opt选项" class="headerlink" title="3.2.2 UpdateCheckpointPartition更新挂载opt选项"></a>3.2.2 UpdateCheckpointPartition更新挂载opt选项</h4><p>如果NeedsCheckpoint为True，调用UpdateCheckpointPartition</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UpdateCheckpointPartition</span><span class="hljs-params">(FstabEntry* entry, <span class="hljs-type">const</span> std::string&amp; block_device)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (entry-&gt;fs_mgr_flags.checkpoint_fs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_f2fs</span>(entry-&gt;fs_type)) &#123;<br>            <span class="hljs-comment">// 会在这里添加checkpoint=disable</span><br>            entry-&gt;fs_checkpoint_opts = <span class="hljs-string">&quot;,checkpoint=disable&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-mount-with-alternatives执行真正的挂载"><a href="#3-3-mount-with-alternatives执行真正的挂载" class="headerlink" title="3.3 mount_with_alternatives执行真正的挂载"></a>3.3 mount_with_alternatives执行真正的挂载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">mount_with_alternatives</span><span class="hljs-params">(<span class="hljs-type">const</span> Fstab&amp; fstab, <span class="hljs-type">int</span> start_idx, <span class="hljs-type">int</span>* end_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">int</span>* attempted_idx)</span> </span>&#123;<br>    <span class="hljs-comment">// 总共尝试2次</span><br> <span class="hljs-type">int</span> retry_count = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (retry_count-- &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 调用__mount开始真正的挂载</span><br>        <span class="hljs-keyword">if</span> (!__mount(fstab[i].blk_device, fstab[i].mount_point, fstab[i])) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><blockquote><p> 🍭 参考大神pyjeston：<a href="https://www.cnblogs.com/pyjetson/p/14682457.html">https://www.cnblogs.com/pyjetson/p/14682457.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手写一个简单的文件系统</title>
    <link href="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="动手写一个简单的文件系统"><a href="#动手写一个简单的文件系统" class="headerlink" title="动手写一个简单的文件系统"></a>动手写一个简单的文件系统</h1><blockquote><p>🍉 <strong>参考博客</strong>：<a href="https://www.jianshu.com/p/8966d121263b">https://www.jianshu.com/p/8966d121263b</a></p><p>🍒 <strong>项目地址</strong>：<a href="https://github.com/ZhangShurong/HUST_OS_fs_experiment">https://github.com/ZhangShurong/HUST_OS_fs_experiment</a></p><p>🍐 <strong>文件系统前置知识：</strong><a href="https://blog.csdn.net/u012489236/article/details/123834123?spm=1001.2014.3001.5506">https://blog.csdn.net/u012489236/article/details/123834123?spm=1001.2014.3001.5506</a></p></blockquote><h2 id="0-下载运行"><a href="#0-下载运行" class="headerlink" title="0.下载运行"></a>0.下载运行</h2><p>按照<code>Readme.md</code>执行以后，可以看到具有了一个基础文件系统的功能：</p><img src="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230311221220446.png" alt="image-20230311221220446" style="zoom: 67%;"><p>如果有编译报错，有关于timepesc类型转换的；解决方案如下：</p><img src="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230311224039035.png" alt="image-20230311224039035" style="zoom: 55%;"><h2 id="1-总体设计"><a href="#1-总体设计" class="headerlink" title="1.总体设计"></a>1.总体设计</h2><p>本文件系统的磁盘结构参考minix的文件系统实现。但是自举块（或称引导块）中没有数据。且不采用二级或者多级索引，其结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">|Dummy Block|Super Block|IMap|BMap|Inode Table|Data blocks|<br></code></pre></td></tr></table></figure><img src="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230312230337246.png" alt="image-20230312230337246" style="zoom:67%;"><p>其中每个块的大小定义为4096bytes，每个Inode含有10个块所以单个文件最大为40KB，支持的最小磁盘大小为24K。以下详细阐述文件系统中所需要的三个基本数据结构。</p><h3 id="1-1-超级块结构"><a href="#1-1-超级块结构" class="headerlink" title="1.1 超级块结构"></a>1.1 超级块结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_fs_super_block</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> version;<br>    <span class="hljs-type">uint64_t</span> magic;<br>    <span class="hljs-type">uint64_t</span> block_size;<br>    <span class="hljs-type">uint64_t</span> inodes_count;<br>    <span class="hljs-type">uint64_t</span> free_blocks;<br>    <span class="hljs-type">uint64_t</span> blocks_count;<br>    <span class="hljs-type">uint64_t</span> bmap_block;<br>    <span class="hljs-type">uint64_t</span> imap_block;<br>    <span class="hljs-type">uint64_t</span> inode_table_block;<br>    <span class="hljs-type">uint64_t</span> data_block_number;<br>    <span class="hljs-type">char</span> padding[<span class="hljs-number">4016</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>超级块中的padding数组，是为了使超级块的大小为4096bytes，以简化后期的工作；“Magic”为1314522；indoe_count记录文件系统所支持的inode个数，这个值在格式化时就已经计算并写入超级块了。Bmap_block记录着bmap开始的数据块索引,imap_block，inode_table_block和data_block_number同理，记录索引是为了简化文件块的定位操作。</p><h3 id="1-2-HUST-inode结构"><a href="#1-2-HUST-inode结构" class="headerlink" title="1.2 HUST_inode结构"></a>1.2 HUST_inode结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> &#123;</span>  <br>    <span class="hljs-type">mode_t</span> mode; <span class="hljs-comment">//sizeof(mode_t) is 4  </span><br>    <span class="hljs-type">uint64_t</span> inode_no;  <br>    <span class="hljs-type">uint64_t</span> blocks;  <br>    <span class="hljs-type">uint64_t</span> block[HUST_N_BLOCKS];  <br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>  <br>        <span class="hljs-type">uint64_t</span> file_size;  <br>        <span class="hljs-type">uint64_t</span> dir_children_count;  <br>    &#125;;  <br>    <span class="hljs-type">int32_t</span> i_uid;   <br>    <span class="hljs-type">int32_t</span> i_gid;  <br>    <span class="hljs-type">int32_t</span> i_nlink;  <br>    <span class="hljs-type">int64_t</span> i_atime;  <br>    <span class="hljs-type">int64_t</span> i_mtime;  <br>    <span class="hljs-type">int64_t</span> i_ctime;  <br>    <span class="hljs-type">char</span> padding[<span class="hljs-number">112</span>];  <br>&#125;;  <br></code></pre></td></tr></table></figure><p>HUST_inode对应着磁盘上的inode结构，在后文会描述它是如何转换为VFS中的inode的。在上述结构体中，mode代表该inode是文件还是目录，blocks代表该inode的大小（所占块的数目），i_uid和i_gid用于后面的多用户管理。Padding数组是为了让HUST_inode结构体能够被4096整除；宏HUST_N_BLOCK被定义为10，意味着每个文件（目录）最大的大小为10个块；block数组存储着每个块的索引，用于定位文件。</p><h3 id="1-3-文件系统的目录结构"><a href="#1-3-文件系统的目录结构" class="headerlink" title="1.3 文件系统的目录结构"></a>1.3 文件系统的目录结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_dir_record</span> &#123;</span>  <br>    <span class="hljs-type">char</span> filename[HUST_FILENAME_MAX_LEN];  <br>    <span class="hljs-type">uint64_t</span> inode_no;  <br>&#125;;<br></code></pre></td></tr></table></figure><p>文件记录是为了储存目录项，其中HUST_FILENAME_MAX_LEN定义为256也就是说，文件名最大长度256。<br> 编写文件系统除了设计文件系统的磁盘结构，定义文件系统支持的操作也是十分重要的，这个直接影响了文件系统的功能。本文件系统支持基本的文件的增删改查，多用户等功能，但是不支持文件的移动，软硬链接等操作。</p><h2 id="2-mkfs的实现"><a href="#2-mkfs的实现" class="headerlink" title="2.mkfs的实现"></a>2.mkfs的实现</h2><p>要使用这个文件系统，必须首先创建一个符合磁盘布局的映像文件，所以我们需要实现一个格式化程序，这个程序按照惯例叫做mkfs。本节详细描述mkfs的实现。</p><p>mkfs的作用是将一个文件改写成对应于我们文件系统的结构，其主要功能点为<strong>写入超级块，写入imap,bmap，写入inode table</strong>，以及创建一个根目录和测试文件。</p><p>超级块包含了文件系统的基本信息，其信息在上文中有详细描述。写入超级块信息，需要计算整个磁盘的大小，然后计算imap，bmap以及inode table的大小，这样才能确定各个区域在磁盘中的位置。这些工作都是在init_disk这个函数中完成的。基本逻辑为读取需要格式化的文件大小，计算出整个磁盘中的块的个数，简单的将块的个数与inode的个数等同起来；然后通过块数以及inode个数计算imap和bmap的大小。其中bmap的大小如下（imap大小计算公式与bmap一致）：<br>$$<br>bmapsize &#x3D; blockcount&#x2F; HUST_BLOCKSIZE * 8<br>$$<br>关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">init_disk</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span>  <br>&#123;  <br>    <span class="hljs-comment">//获取基本信息  </span><br>    <span class="hljs-comment">//... ...  </span><br>    <span class="hljs-comment">//计算bmap  </span><br>    bmap_size = super_block.blocks_count/(<span class="hljs-number">8</span>*HUST_BLOCKSIZE);  <br>    super_block.bmap_block = RESERVE_BLOCKS;  <br>  <br>    <span class="hljs-keyword">if</span> (super_block.blocks_count%(<span class="hljs-number">8</span>*HUST_BLOCKSIZE) != <span class="hljs-number">0</span>) &#123;  <br>        bmap_size += <span class="hljs-number">1</span>;  <br>    &#125;  <br>    bmap = (<span class="hljs-type">uint8_t</span> *)<span class="hljs-built_in">malloc</span>(bmap_size*HUST_BLOCKSIZE);  <span class="hljs-comment">// 单位是块</span><br>    <span class="hljs-built_in">memset</span>(bmap,<span class="hljs-number">0</span>,bmap_size*HUST_BLOCKSIZE);  <br>  <br>    <span class="hljs-comment">//计算imap  </span><br>    imap_size = super_block.inodes_count/(<span class="hljs-number">8</span>*HUST_BLOCKSIZE);  <span class="hljs-comment">// 单位是块</span><br>    super_block.imap_block = super_block.bmap_block + bmap_size;  <br> <br>    <span class="hljs-keyword">if</span>(super_block.inodes_count%(<span class="hljs-number">8</span>*HUST_BLOCKSIZE) != <span class="hljs-number">0</span>) &#123;  <br>        imap_size += <span class="hljs-number">1</span>;  <br>    &#125;  <br>    imap = (<span class="hljs-type">uint8_t</span> *)<span class="hljs-built_in">malloc</span>(imap_size*HUST_BLOCKSIZE);  <br>    <span class="hljs-built_in">memset</span>(imap,<span class="hljs-number">0</span>,imap_size*HUST_BLOCKSIZE);  <br>  <br>    <span class="hljs-comment">//计算inode_table  </span><br>    inode_table_size = super_block.inodes_count/(HUST_BLOCKSIZE/HUST_INODE_SIZE);  <br>    super_block.inode_table_block = super_block.imap_block + imap_size;  <br>    super_block.data_block_number = RESERVE_BLOCKS + bmap_size + imap_size + inode_table_size;  <br>    super_block.free_blocks = super_block.blocks_count - super_block.data_block_number - <span class="hljs-number">1</span>;  <br><br>    <span class="hljs-comment">// 设置bmap以及imap  </span><br>    <span class="hljs-comment">// ... ...  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，imap和bmap为uint8_t的全局数组。</p><p>计算完基本信息之后，我们需要将其写入文件并创建根目录和测试文件。文件创建的基本步骤如下：</p><ol><li>检测（获取）磁盘（文件）大小，确认是否有足够的空间</li><li>找的空闲的inode和block，并标记imap和bmap。</li><li>生成相应的数据，并写入对应的块中。对于根目录来讲，写入的数据为三个目录项，目录项的内容为文件（目录）名以及对应的inode编号。第一个目录项为当前目录和对应的inode编号0，第二个目录项为上一级目录和对应的inode编号0，第三个目录项为欢迎文件，内容为文件名“file”和对应的inode编号1。</li><li>设置对应的inode信息，如是文件还是目录（mode信息），创建时间修改时间(i_ctime和i_mtime)，用户id和组id信息（i_uid和i_gid）等。</li><li>更新超级块信息。</li></ol><p>在我们的文件系统写完之前，我们可以新建一个文件来测试我们的mkfs是否能正常运行，通过16进制编辑器来查看是否功能正常。具体步骤如下：</p><ul><li>运行下列命令创建文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">dd bs=4096 count=100 if=/dev/zero of=image <br><br>- if=文件名：输入文件名，默认为标准输入。即指定源文件。<br>- of=文件名：输出文件名，默认为标准输出。即指定目的文件。<br>- bs=bytes：同时设置读入/输出的块大小为bytes个字节。<br>- count=blocks：仅拷贝blocks个块，块大小等于bs指定的字节数。<br></code></pre></td></tr></table></figure><ul><li>编译mkfs.c</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc mkfs.c -o mkfs <br></code></pre></td></tr></table></figure><ul><li>格式化image文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./mkfs ./image<br></code></pre></td></tr></table></figure><ul><li>通过hexdump来查看文件的结构，结果如下图。通过检查，我们发现，image文件结构写入正确无误。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">amx@amxxxx:~/Desktop/simple_fs$ hexdump ./image <br><span class="hljs-number">0000000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0001000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0</span>eda <span class="hljs-number">0014</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>  <span class="hljs-comment">/* HUST_fs文件系统的magic为1314522 */</span><br><span class="hljs-number">0001010</span> <span class="hljs-number">1000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0064</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0001020</span> <span class="hljs-number">0059</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0064</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0001030</span> <span class="hljs-number">0002</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0003</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0001040</span> <span class="hljs-number">0004</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">000</span>a <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0001050</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0002000</span> <span class="hljs-number">07f</span>f <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0002010</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0003000</span> <span class="hljs-number">0003</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0003010</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0004000</span> <span class="hljs-number">4000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0004010</span> <span class="hljs-number">0001</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">000</span>a <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0004020</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0004040</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">24</span>ed <span class="hljs-number">4</span>c27 <span class="hljs-number">7f</span>f3 <span class="hljs-number">0000</span><br><span class="hljs-number">0004050</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">3760</span> <span class="hljs-number">4</span>c3b <span class="hljs-number">7f</span>f3 <span class="hljs-number">0000</span><br><span class="hljs-number">0004060</span> <span class="hljs-number">0</span>d68 <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0003</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0004070</span> <span class="hljs-number">03e8</span> <span class="hljs-number">0000</span> <span class="hljs-number">03e8</span> <span class="hljs-number">0000</span> <span class="hljs-number">0002</span> <span class="hljs-number">0000</span> <span class="hljs-number">7f</span>f3 <span class="hljs-number">0000</span><br><span class="hljs-number">0004080</span> <span class="hljs-number">8f</span>e7 <span class="hljs-number">640</span>c <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">8f</span>e7 <span class="hljs-number">640</span>c <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0004090</span> <span class="hljs-number">8f</span>e7 <span class="hljs-number">640</span>c <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">3848</span> <span class="hljs-number">4</span>c3b <span class="hljs-number">7f</span>f3 <span class="hljs-number">0000</span><br>...............................................<br>amx@amxxxx:~/Desktop/simple_fs$ <br></code></pre></td></tr></table></figure><h2 id="3-文件系统的实现"><a href="#3-文件系统的实现" class="headerlink" title="3.文件系统的实现"></a>3.文件系统的实现</h2><p>一个通常意义上的文件系统驱动可以单独被编译成模块动态加载，也可以被直接编译到内核中，为了调试的方便，本文中的文件系统采用动态加载的方式实现。实现一个文件系统必须遵照内核的一些“规则”，以下我将以递进的顺序阐述文件系统的实现过程。</p><h3 id="3-1-文件系统的加载与卸载"><a href="#3-1-文件系统的加载与卸载" class="headerlink" title="3.1 文件系统的加载与卸载"></a>3.1 文件系统的加载与卸载</h3><p>首先为了能够成功加载文件系统，文件系统需要提供文件系统的名字，超级块的加载和删除方法。这些东西反应在<code>file_system_type</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> <span class="hljs-title">HUST_fs_type</span> =</span> &#123;  <br>    .owner = THIS_MODULE,  <br>    .name = <span class="hljs-string">&quot;HUST_fs&quot;</span>,  <br>    .mount = HUST_fs_mount,  <br>    .kill_sb = HUST_fs_kill_superblock, <span class="hljs-comment">/* unmount */</span>  <br>&#125;;  <br></code></pre></td></tr></table></figure><p>文件系统作为一种块设备驱动，自然也需要实现module_init以及mocule_exit。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Called when the module is loaded. */</span>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_fs_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>    <span class="hljs-type">int</span> ret;  <br>    ret = register_filesystem(&amp;HUST_fs_type);  <br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)  <br>        printk(KERN_INFO <span class="hljs-string">&quot;Sucessfully registered HUST_fs\n&quot;</span>);  <br>    <span class="hljs-keyword">else</span>  <br>        printk(KERN_ERR <span class="hljs-string">&quot;Failed to register HUST_fs. Error: [%d]\n&quot;</span>, ret);  <br>    <span class="hljs-keyword">return</span> ret;  <br>&#125;  <br>  <br><span class="hljs-comment">/* Called when the module is unloaded. */</span>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">HUST_fs_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br><br>    <span class="hljs-type">int</span> ret;  <br>    ret = unregister_filesystem(&amp;HUST_fs_type);  <br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)  <br>        printk(KERN_INFO <span class="hljs-string">&quot;Sucessfully unregistered HUST_fs\n&quot;</span>);  <br>    <span class="hljs-keyword">else</span>  <br>        printk(KERN_ERR <span class="hljs-string">&quot;Failed to unregister HUST_fs. Error: [%d]\n&quot;</span>, ret);  <br>&#125;  <br>module_init(HUST_fs_init);  <br>module_exit(HUST_fs_exit);  <br>  <br>MODULE_LICENSE(<span class="hljs-string">&quot;MIT&quot;</span>);  <br>MODULE_AUTHOR(<span class="hljs-string">&quot;cv&quot;</span>); <br></code></pre></td></tr></table></figure><p>我们可以看到，设备驱动加载的时候，驱动向内核注册了文件系统，而驱动卸载的时候，文件系统的信息也被删除。文件系统加载时调用的函数为HUST_fs_mount，实际上，这个函数向内核注册了一个回调：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_fs_fill_super</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">void</span> *data, <span class="hljs-type">int</span> silent)</span>  <br></code></pre></td></tr></table></figure><p>这个函数是用来与VFS交互从而生成VFS超级块的。在HUST fs中，超级块在磁盘的第二个4096字节上，即块号为1。这个函数执行时会从磁盘中读取信息，填充到VFS提供的超级块结构体中，下列为部分关键代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_fs_fill_super</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">void</span> *data, <span class="hljs-type">int</span> silent)</span>  &#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> *<span class="hljs-title">bh</span>;</span>  <br>    bh = sb_bread(sb, <span class="hljs-number">1</span>);  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_fs_super_block</span> *<span class="hljs-title">sb_disk</span>;</span>  <br>    sb_disk = (<span class="hljs-keyword">struct</span> HUST_fs_super_block *)bh-&gt;b_data;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">root_inode</span>;</span>  <br>    <span class="hljs-keyword">if</span> (sb_disk-&gt;block_size != <span class="hljs-number">4096</span>) &#123;  <br>        printk(KERN_ERR <span class="hljs-string">&quot;HUST_fs expects a blocksize of %d\n&quot;</span>, <span class="hljs-number">4096</span>);  <br>        ret = -EFAULT;  <br>        <span class="hljs-keyword">goto</span> release;  <br>   &#125;  <br>   <span class="hljs-comment">//fill vfs super block  </span><br>    sb-&gt;s_magic = sb_disk-&gt;magic;  <br>    sb-&gt;s_fs_info = sb_disk;  <br>    sb-&gt;s_maxbytes = HUST_BLOCKSIZE * HUST_N_BLOCKS; <span class="hljs-comment">/* Max file size */</span>  <br>    sb-&gt;s_op = &amp;HUST_fs_super_ops;  <br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码可以看出，我们用sb_read来读取磁盘上的内容，然后填充super_block结构体。值得注意的是，有关超级块的操作函数即superblock_operations也是在此处赋值的。由于super_block* sb在文件系统卸载之前是一直存在于内存中的，所以我们可以使用s_fs_info来存储原始的超级块信息，避免后期交互时 再次读取磁盘。</p><p>文件系统卸载的时候超级块信息需要被删除，所以HUST_fs_kill_superblock的作用时释放该超级块，通知VFS该挂载点已经卸载。</p><p>实现基本函数后，可以对文件系统进行挂载操作，挂载操作的脚本内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">sudo umount ./test  <br>sudo rmmod HUST_fs  <br>dd bs=<span class="hljs-number">4096</span> count=<span class="hljs-number">100</span> <span class="hljs-keyword">if</span>=/dev/zero of=image  <br>./mkfs image  <br>insmod HUST_fs.ko  <br>mount -o loop -t HUST_fs image ./test  <br>dmesg<br></code></pre></td></tr></table></figure><p>我们从第0节可以看到挂载成功</p><h3 id="3-2-ls命令的实现"><a href="#3-2-ls命令的实现" class="headerlink" title="3.2  ls命令的实现"></a>3.2  ls命令的实现</h3><p>加载文件系统之后第一个要实现的功能是读取文件系统中的数据，所以选择实现文件夹读取操作，这一操作在2.x内核中是<code>.readdir</code>函数指针，在最新版本中是<code>.iterate</code>函数指针。这个指针在保存在file_operation中，如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">HUST_fs_dir_ops</span> =</span> &#123;  <br>    .owner = THIS_MODULE,  <br>    .iterate = HUST_fs_iterate,  <br>&#125;; <br></code></pre></td></tr></table></figure><p>HUST_fs_iterate函数主要功能逻辑是读取inode的块数据，并且将块数据中的inode和文件名通过dir_emit函数传输到VFS层。以根目录为例，根目录的包含三个数据项，分别是父目录，当前目录和欢迎文件，所以该函数会执行以下三个语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//参数分别表示上下文，文件/目录名，文件/目录名长度，inode号，文件类型  </span><br>dir_emit(ctx, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>, DT_DIR);  <br>dir_emit(ctx, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-number">2</span>,<span class="hljs-number">0</span>, DT_DIR);  <br>dir_emit(ctx, <span class="hljs-string">&quot;file&quot;</span>, <span class="hljs-number">4</span>,<span class="hljs-number">1</span>, DT_REG);<br></code></pre></td></tr></table></figure><p>完成该函数后，在填充根目录inode时将HUST_fs_dir_ops指针赋值，即可在挂在文件系统后执行ls命令。</p><img src="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230311223941193.png" alt="image-20230311223941193" style="zoom: 80%;"><p>如上图所示，我们成功看到了欢迎文件。但是此时我们不能对文件进行任何操作，因为还没有实现其他的接口。</p><h3 id="3-3-磁盘管理相关逻辑的实现"><a href="#3-3-磁盘管理相关逻辑的实现" class="headerlink" title="3.3 磁盘管理相关逻辑的实现"></a>3.3 磁盘管理相关逻辑的实现</h3><p>这个磁盘管理的内涵包括向磁盘写入和从磁盘取出读取inode，更新inode信息，维护imap，bmap，inode table等操作。为了使磁盘上的内容有序的组合起来，磁盘空间的管理十分的重要，后续的文件读写操作都与此相关。</p><p>写入和删除inode的操作存放在super_operations这个结构体中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_operations</span> <span class="hljs-title">HUST_fs_super_ops</span> =</span> &#123;  <br>    .evict_inode = HUST_evict_inode,  <br>    .write_inode = HUST_write_inode,  <br>&#125;;<br></code></pre></td></tr></table></figure><p>HUST_fs_super_ops需要在填充超级块时赋值到super_block的s_ops字段中。HUST_write_inode函数的功能是将内存中的inode保存在磁盘上。关键代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_write_inode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> writeback_control *wbc)</span>  <br>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">bh</span>;</span>  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> * <span class="hljs-title">raw_inode</span> =</span> <span class="hljs-literal">NULL</span>;  <br>    HUST_fs_get_inode(inode-&gt;i_sb, inode-&gt;i_ino, raw_inode);  <br>    <span class="hljs-keyword">if</span> (!raw_inode)  <br>        <span class="hljs-keyword">return</span> -EFAULT;  <br>    raw_inode-&gt;mode = inode-&gt;i_mode;  <br>    raw_inode-&gt;i_uid = fs_high2lowuid(i_uid_read(inode));  <br>    raw_inode-&gt;i_gid = fs_high2lowgid(i_gid_read(inode));  <br>    raw_inode-&gt;i_nlink = inode-&gt;i_nlink;  <br>    raw_inode-&gt;file_size = inode-&gt;i_size;      <br>    raw_inode-&gt;i_atime = (inode-&gt;i_atime.tv_sec);  <br>    raw_inode-&gt;i_mtime = (inode-&gt;i_mtime.tv_sec);  <br>    raw_inode-&gt;i_ctime = (inode-&gt;i_ctime.tv_sec);  <br>    mark_buffer_dirty(bh);  <br>    brelse(bh);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>可以看到，该函数的将vfs inode中的相关信息存储到HUST_inode结构体中，然后写入磁盘。这个是单独的写入磁盘操作，事实上，当我们申请inode时，imap也是需要检查刷新的，需要把相应位置标记为1。同理，evict_inode函数的作用时删除inode，删除成功后，我们需要刷新imap的值，把相应位置标记为0。</p><p>设置和写入map的操作都在map.c中，以下以imap为例。对于imap来讲，申请inode的时候需要检查第一个空闲的inode编号，当inode被释放的时候也要及时清零对应的imap。与此相关的函数如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从磁盘中读取数据并存在imap数组中  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_imap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block* sb, <span class="hljs-type">uint8_t</span>* imap, <span class="hljs-type">ssize_t</span> imap_size)</span>;  <br><span class="hljs-comment">//在vaddr数组中找到第一个为0的bit，这个函数用于定位空inode或者block  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_find_first_zero_bit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *vaddr, <span class="hljs-type">unsigned</span> size)</span>;  <br><span class="hljs-comment">//将imap的某一位置0或者1，并保存在磁盘上  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">set_and_save_imap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block* sb, <span class="hljs-type">uint64_t</span> inode_num, <span class="hljs-type">uint8_t</span> value)</span>;  <br><span class="hljs-comment">//定义的位操作宏如下  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> setbit(number,x) number |= 1UL &lt;&lt; x  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clearbit(number, x) number &amp;= ~(1UL &lt;&lt; x)  </span><br></code></pre></td></tr></table></figure><p>由于本文件系统并不是为了实际使用，所以上述的操作都没有考虑性能以及准确性问题。事实上，能够加上校验或者冗余备份是最好的。</p><h3 id="3-4-读写文件内容"><a href="#3-4-读写文件内容" class="headerlink" title="3.4 读写文件内容"></a>3.4 读写文件内容</h3><p>为了能够快速看到文件系统在正常工作，所以接下来需要实现文件的读写操作。文件读写操作按照一般处理，应该是实现在struct file_operations这个结构体中的。事实上，最开始我是实现在这个结构体中的read_iter函数指针中的。但是比较有趣的一点是，如果我们实现了struct address_space_operations结构体中的函数，那么struct file_operations结构体中的函数则可以交由VFS实现。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">HUST_fs_file_ops</span> =</span> &#123;  <br>    .owner = THIS_MODULE,  <br>    .llseek = generic_file_llseek,  <br>    .mmap = generic_file_mmap,  <br>    .fsync = generic_file_fsync,  <br>    .read_iter = generic_file_read_iter,  <br>    .write_iter = generic_file_write_iter,  <br>&#125;;  <br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>   <span class="hljs-title">address_space_operations</span> <span class="hljs-title">HUST_fs_aops</span> =</span> &#123;  <br>    .readpage = HUST_fs_readpage,  <br>    .writepage = HUST_fs_writepage,  <br>    .write_begin = HUST_fs_write_begin,  <br>    .write_end = generic_write_end,  <br>&#125;;<br></code></pre></td></tr></table></figure><p>上述的generic开头的函数是不需要我们手动实现的。上述的address_space_operations操作其实是实现了页高速缓存的一些操作。页高速缓存是linux内核实现的一种主要磁盘缓存，它主要用来减少对磁盘的IO操作，具体地讲，是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。这些接口一旦实现，那么对文件的操作就可以转移到内存中，这就是为什么可以使用generic开头的这些函数来代替手写。</p><p>HUST_fs_readpage, HUST_fs_writepage以及HUST_fs_write_begin都被注册回调到同一个函数HUST_fs_get_block。HUST_fs_get_block主要返回内核请求长度的数据。至于读写操作，内核调用__bwrite函数最终调用块设备驱动执行。因为在我没有采用二级或者多级索引，故而HUST_fs_get_block函数逻辑比较简单，部分代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_fs_get_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-type">sector_t</span> block,  </span><br><span class="hljs-params">              <span class="hljs-keyword">struct</span> buffer_head *bh, <span class="hljs-type">int</span> create)</span>  <br>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> inode-&gt;i_sb;  <br>    <span class="hljs-keyword">if</span> (block &gt; HUST_N_BLOCKS) <br>        <span class="hljs-keyword">return</span> -ENOSPC;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> <span class="hljs-title">H_inode</span>;</span>  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == HUST_fs_get_inode(sb, inode-&gt;i_ino, &amp;H_inode))  <br>        <span class="hljs-keyword">return</span> -EFAULT;  <br>    <span class="hljs-keyword">if</span> (H_inode.blocks == <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">if</span>(alloc_block_for_inode(sb, &amp;H_inode, <span class="hljs-number">1</span>)) <br>            <span class="hljs-keyword">return</span> -EFAULT;  <br>    map_bh(bh, sb, H_inode.block[block]);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，该函数判断传入的block的大小，并将磁盘内容映射到bh中。后续的读写操作将有VFS帮我们完成。</p><h3 id="3-5-inode操作"><a href="#3-5-inode操作" class="headerlink" title="3.5 inode操作"></a>3.5 inode操作</h3><p>Inode操作涉及文件(夹)的创建删除，将HUST_inode映射到VFS中的inode等操作。具体实现的函数如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span> <span class="hljs-title">HUST_fs_inode_ops</span> =</span> &#123;  <br>    .lookup = HUST_fs_lookup,  <br>    .mkdir = HUST_fs_mkdir,  <br>    .create = HUST_fs_create,  <br>    .unlink = HUST_fs_unlink,  <br>&#125;; <br></code></pre></td></tr></table></figure><p>HUST_fs_lookup是其中比较复杂的一个函数，它负责将一个目录下的inode信息交由VFS管理。首先，HUST_fs_lookup读取文件夹的内容，然后遍历文件夹下面的HUST_inode，找到我们想要的HUST_inode，根据不同的文件属性，申请vfs_inode；并对不同的vfs_inode设置不同的操作。假设vfs_inode对应的是一个文件，那么就设置vfs_inode-&gt;mapping-&gt;a_ops，如果vfs_inode对应的是文件夹，那么就设置vfs_inode-&gt;f_ops &#x3D; &amp;HUST_fs_dir_ops;最后将vfs_inode注册到VFS中。这部分的关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> dentry *<span class="hljs-title function_">HUST_fs_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *parent_inode,  </span><br><span class="hljs-params">                  <span class="hljs-keyword">struct</span> dentry *child_dentry, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span>  <br>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> parent_inode-&gt;i_sb;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> <span class="hljs-title">H_inode</span>;</span>  <br><span class="hljs-comment">//省略代码  </span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; H_inode.dir_children_count; i++) &#123;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>  <br>            (child_dentry-&gt;d_name.name, dtptr[i].filename,  <br>             HUST_FILENAME_MAX_LEN) == <span class="hljs-number">0</span>)&#123;  <br>            inode = iget_locked(sb, dtptr[i].inode_no);  <br>            <span class="hljs-keyword">if</span> (inode-&gt;i_state &amp; I_NEW) &#123;  <br>                inode_init_owner(inode, parent_inode, <span class="hljs-number">0</span>);  <br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> <span class="hljs-title">H_child_inode</span>;</span>  <br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == HUST_fs_get_inode(sb, dtptr[i].inode_no, &amp;H_child_inode))  <br>                    <span class="hljs-keyword">return</span> ERR_PTR(-EFAULT);  <br>                HUST_fs_convert_inode(&amp;H_child_inode, inode);  <br>                inode-&gt;i_op = &amp;HUST_fs_inode_ops;  <br>                <span class="hljs-keyword">if</span> (S_ISDIR(H_child_inode.mode)) &#123;  <br>                    inode-&gt;i_fop = &amp;HUST_fs_dir_ops;  <br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISREG(H_child_inode.mode)) &#123;  <br>                    inode-&gt;i_fop = &amp;HUST_fs_file_ops;;  <br>                    inode-&gt;i_mapping-&gt;a_ops = &amp;HUST_fs_aops;  <br>                &#125;  <br>                inode-&gt;i_mode = H_child_inode.mode;  <br>                inode-&gt;i_size = H_child_inode.file_size;  <br>                insert_inode_hash(inode);  <br>                unlock_new_inode(inode);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br><span class="hljs-comment">//省略代码  </span><br>&#125; <br></code></pre></td></tr></table></figure><p>只有在这里注册了相关函数，系统调用才能正常执行。不然就会出现不支持的操作这种报错信息。</p><p>.create与.mkdir都是对应了inode的创建，只是inode的属性不能而已。.create创建普通文件而.mkdir创建文件夹。所以这两个函数的功能被函数HUST_fs_create_obj所处理。这个函数接受新建文件（夹）的请求，检查磁盘的大小，检查是否有空余的indoe，并且分配inode号，然后更新imap信息，最后更新超级块信息。由于该函数逻辑简单但是代码量比较大，故而不在此展示其具体实现。</p><p>在完成上述工作之后，我们的文件系统基本已经完成了，这个系统采用线性（区别于minixi二级索引用树来管理）的方式管理磁盘空间，支持基本的增删改查文件操作，支持文件权限，支持多用户。</p>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android HIDL服务实现</title>
    <link href="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-HIDL服务实现"><a href="#Android-HIDL服务实现" class="headerlink" title="Android HIDL服务实现"></a>Android HIDL服务实现</h1><blockquote><p><a href="https://www.jianshu.com/p/b75c4321ae0a">https://www.jianshu.com/p/b75c4321ae0a</a></p></blockquote><p><strong>Android O(8.0)</strong> 版本之后，底层实现有了比较大的变化，最显著的一个方面就是 <strong>HIDL</strong> 机制的全面实施。本文将从 <strong>HIDL的基本概念</strong>、<strong>HIDL服务模拟</strong>、<strong>framework层aidl服务</strong>、<strong>应用层程序</strong> 这四个方面来全面的阐述 <strong>HIDL</strong> 工作全过程，这对于理解系统源码中 <strong>Gnss</strong>、<strong>Usb</strong>、<strong>Camera</strong> 等模块的工作原理有极大帮助。</p><h2 id="1-HIDL设计目的"><a href="#1-HIDL设计目的" class="headerlink" title="1. HIDL设计目的"></a>1. HIDL设计目的</h2><p>在 <strong>Android O(8.0)</strong> 之前系统的升级牵扯多方协作，极为麻烦，<strong>HIDL</strong>机制的推出就是将 <strong>framework</strong> 与 <strong>hal</strong> 层分开，使得框架部分可以直接被覆盖、更新，而不需要重新对 HAL 进行编译，这样在系统升级时，<strong>OEM</strong> 厂商 跳过 <strong>SoC</strong> 厂商，先对 <strong>framework</strong> 进行升级。</p><h3 id="1-1-Android-8-0之前"><a href="#1-1-Android-8-0之前" class="headerlink" title="1.1 Android 8.0之前"></a>1.1 Android 8.0之前</h3><p><strong>framework</strong> 与 <strong>hal</strong> 紧紧耦合存在于 <strong>system.img</strong> 中，因此在版本升级时需要: <strong>OEM</strong> 厂商适配 <strong>framework</strong> ，<strong>SoC厂商</strong> 适配 <strong>hal</strong>， 之后将修改打包到 <strong>system.img</strong>，生成 OTA 升级包，推送到手机进行 OTA 升级</p><h3 id="1-2-Android-8-0之后"><a href="#1-2-Android-8-0之后" class="headerlink" title="1.2 Android 8.0之后"></a>1.2 Android 8.0之后</h3><p><strong>framework</strong> 与 <strong>hal</strong> 进行了解耦， <strong>framework</strong> 存在于 <strong>system.img</strong>，<strong>hal</strong> 存在于<strong>vendor.img</strong>，进行版本升级时，分为两次升级:</p><ul><li><strong>framework升级</strong> ： OEM 厂商适配 framework，将修改打包到 system.img， 生成OTA 升级包，推送到手机进行 OTA 升级(framework 发生改变，hal 层未变)。</li><li><strong>hal升级</strong> ：SoC 厂商适配 hal， 将修改打包到 vendor.img, 生成OTA 升级包，推送到手机进行OTA升级(framework发生改变，hal 层发生改变)。</li></ul><h2 id="2-HIDL机制演进"><a href="#2-HIDL机制演进" class="headerlink" title="2.HIDL机制演进"></a>2.HIDL机制演进</h2><h3 id="2-1-老版本-Framework-与-HAL-的通信框架"><a href="#2-1-老版本-Framework-与-HAL-的通信框架" class="headerlink" title="2.1 老版本 Framework 与 HAL 的通信框架"></a>2.1 老版本 Framework 与 HAL 的通信框架</h3><p>正如上述所言，旧版的系统架构中， Android Framework 层与 Hal 层是打包成一个 <strong>system.img</strong> 的，且 Framework 与 hal 层之间是紧密耦合的，通过链接的方式使用相应的硬件 <strong>so</strong> 库。它们之间的架构一般有如下两种方式：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-0fed2e7f185e551d.png" style="zoom:80%;"><h3 id="2-2-HIDL-类型介绍"><a href="#2-2-HIDL-类型介绍" class="headerlink" title="2.2  HIDL 类型介绍"></a>2.2  HIDL 类型介绍</h3><p>为了解决两者之间这种紧耦合所带来的弊端，google 引入 HIDL 来定义 Framework 与 HAL 之间的接口，可以用下图来描述：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-ea297e84897f8686.webp" style="zoom:80%;"><p>事实上虽然 google 推出了这种机制，但是很多厂商没有很快的跟上节奏，因此为了向前兼容， google 定义了三种类型：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-5b8123370101b01f.png" style="zoom: 67%;"><p>① 是 Treble Project 之前使用的实现架构，使用的是传统 HAL 和旧版 HAL</p><p>② 直通模式，passthrough mode。如图所示，Framework 和 HAL 层工作在同一个进程当中，下面的 HAL 是使用 HIDL 封装后的库，是直通式 HAL。这些库文件也可用于 ③ 绑定模式</p><p>③ 绑定模式，binderized mode。是直通式 HAL binder 化，变为绑定式 HAL。Framework 和 HAL 层工作在不同的进程，之间通过 Binder 进行 IPC</p><p>④ 纯绑定式。相对于 ③ 来说，绑定式 HAL 中并不包含直通式 HAL，因此称为纯绑定式</p><p><strong>上述可总结为</strong>：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-619180c0c7f8afc5.png" style="zoom: 67%;"><h2 id="3-Binderized-Mode（绑定式）简介"><a href="#3-Binderized-Mode（绑定式）简介" class="headerlink" title="3.Binderized Mode（绑定式）简介"></a>3.Binderized Mode（绑定式）简介</h2><p>们知道 <strong>绑定模式</strong> 是 google 为了向前兼容而定义的一种类型，且 Android 8.0 及后续版本的设备都必须只支持这种模式。这种模式下 Framework 与 Hal 分别位于不同的进程中，其实从具体实现来讲这种模式也更应该被称为 <strong>Binder 化的直通式</strong>。本文将通过这种方式实现一个 <strong>HIDL</strong> 服务。</p><h2 id="4-环境-x2F-工具准备"><a href="#4-环境-x2F-工具准备" class="headerlink" title="4.环境&#x2F;工具准备"></a>4.环境&#x2F;工具准备</h2><ul><li>Ubuntu 20.04 TLS</li><li>Android 源码：Android 9.0，编译烧录详见 <a href="https://www.jianshu.com/p/848414148272">Android源码编译烧录</a></li><li>hidl-gen 工具：Android 系统自带，需要配置一下环境变量</li></ul><h2 id="5-HIDL实现"><a href="#5-HIDL实现" class="headerlink" title="5.HIDL实现"></a>5.HIDL实现</h2><p>本文目的是实现一个具有 <strong>加减乘除</strong> 运算的 HIDL 服务,命名为 <strong>银河一号(GalaxyOne)<strong>。HIDL用起来非常简单，在系统源码中的 <strong>hardware&#x2F;interfaces</strong> 目录下有很多的 HIDL，我们仿照其他 HIDL 来创建自己的目录：</strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0</strong></p><h3 id="5-1-创建IGalaxyOne-hal-文件"><a href="#5-1-创建IGalaxyOne-hal-文件" class="headerlink" title="5.1 创建IGalaxyOne.hal 文件"></a>5.1 创建IGalaxyOne.hal 文件</h3><p><strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0&#x2F;IGalaxyOne.hal</strong></p><p>这里定义了四种基本的运算：加、减、乘、除，这是上层调用 HAL 的入口，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">package android.hardware.galaxy_one@<span class="hljs-number">1.0</span>;<br><br>interface IGalaxyOne&#123;<br><br>    <span class="hljs-comment">//加法</span><br>    add(<span class="hljs-type">uint32_t</span> a,<span class="hljs-type">uint32_t</span> b) generates (<span class="hljs-type">uint32_t</span> result);<br>    <span class="hljs-comment">//减法</span><br>    sub(<span class="hljs-type">uint32_t</span> a,<span class="hljs-type">uint32_t</span> b) generates (<span class="hljs-type">uint32_t</span> result);<br>    <span class="hljs-comment">//乘法</span><br>    mul(<span class="hljs-type">uint32_t</span> a,<span class="hljs-type">uint32_t</span> b) generates (<span class="hljs-type">uint32_t</span> result);<br>    <span class="hljs-comment">//除法</span><br>    div(<span class="hljs-type">uint32_t</span> a,<span class="hljs-type">uint32_t</span> b) generates (<span class="hljs-type">uint32_t</span> result);<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-2-hidl-gen生成HIDL框架"><a href="#5-2-hidl-gen生成HIDL框架" class="headerlink" title="5.2 hidl-gen生成HIDL框架"></a>5.2 hidl-gen生成HIDL框架</h3><p>在使用 hidl-gen 之前需要先做两件事：<br>1、hidl-gen 由 Android 提供，使用之前需要先配置一下系统路径，如我这里所做的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># vim ~/.bashrc</span><br>export PATH=/home/zsk/AOSP/out/soong/host/linux-x86/bin:$PATH<br></code></pre></td></tr></table></figure><p>2、Ubuntu 新的终端窗口必须先设定一些 Android 环境变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">source build/envsetup.sh<br>lunch aosp_sailfish-userdebug  <span class="hljs-comment">// lunch mode 根据需求修改</span><br>make hidl-gen<br></code></pre></td></tr></table></figure><p>配置完成之后在 <strong>源码根目录</strong> 下执行如下命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">PACKAGE=android.hardware.galaxy_one@<span class="hljs-number">1.0</span><br>LOC=hardware/interfaces/galaxy_one/<span class="hljs-number">1.0</span>/<span class="hljs-keyword">default</span>/<br>    <br>hidl-gen -o $LOC -Lc++-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE<br><br>hidl-gen -o $LOC -Landroidbp-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE<br></code></pre></td></tr></table></figure><p>命令执行成功之后会发现在 <strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0</strong> 目录下多了一个 <strong>default</strong> 目录，进入之后发现有如下文件：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-0096f7494b4dbff9.png" style="zoom: 80%;"><p>之后执行 <strong>update-makefiles.sh</strong> 脚本来为 HIDL 生成对应的 <strong>Android.bp</strong> 文件，此脚本位于 <strong>hardware&#x2F;interfaces</strong> 目录下，同样可在源码根目录下执行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">./hardware/interfaces/update-makefiles.sh<br></code></pre></td></tr></table></figure><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-5ea845283e2c2d58.png" style="zoom: 80%;"><p>接下来我们需要添加两个空文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">touch hardware/interfaces/galaxy_one/<span class="hljs-number">1.0</span>/<span class="hljs-keyword">default</span>/android.hardware.galaxy_one@<span class="hljs-number">1.0</span>-service.rc<br>touch hardware/interfaces/galaxy_one/<span class="hljs-number">1.0</span>/<span class="hljs-keyword">default</span>/service.cpp<br></code></pre></td></tr></table></figure><p>完成之后，整个工程结构如下所示：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-118902147dc61749.png" style="zoom: 80%;"><h3 id="5-3-调用流程"><a href="#5-3-调用流程" class="headerlink" title="5.3 调用流程"></a>5.3 调用流程</h3><p>上述过程已经将 HIDL 服务所需要的全本文件配置完成，虽然其中很多文件是空的，或者没有具体实现，我们现在先放在一边，先来对整体的调用流程及各个文件的功效略作说明。</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-865d0cf346cee965.png" style="zoom: 80%;"><ul><li>Application：指上层应用</li><li>JNI：指 framework 层，getService 获取 hal 层 service</li><li><a href="mailto:&#97;&#110;&#100;&#x72;&#111;&#105;&#100;&#46;&#104;&#x61;&#x72;&#x64;&#x77;&#x61;&#114;&#101;&#x2e;&#103;&#97;&#x6c;&#97;&#120;&#x79;&#x5f;&#111;&#110;&#101;&#x40;&#49;&#46;&#48;&#46;&#x73;&#111;">&#97;&#110;&#100;&#x72;&#111;&#105;&#100;&#46;&#104;&#x61;&#x72;&#x64;&#x77;&#x61;&#114;&#101;&#x2e;&#103;&#97;&#x6c;&#97;&#120;&#x79;&#x5f;&#111;&#110;&#101;&#x40;&#49;&#46;&#48;&#46;&#x73;&#111;</a>：由 IGalaxyOne.hal 生成的接口库，由 <strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0&#x2F;Android.bp</strong> 通过 <strong>IGalaxyOne.hal</strong> 生成，这样只要这个接口库不变，那么 framework 的更新和 hal 层就隔绝开了</li><li><a href="mailto:&#x61;&#x6e;&#100;&#x72;&#x6f;&#105;&#x64;&#46;&#104;&#x61;&#x72;&#100;&#x77;&#x61;&#x72;&#101;&#x2e;&#x67;&#97;&#x6c;&#97;&#x78;&#121;&#x5f;&#x6f;&#x6e;&#101;&#x40;&#x31;&#46;&#48;&#45;&#115;&#101;&#x72;&#118;&#105;&#99;&#x65;&#46;&#x72;&#x63;">&#x61;&#x6e;&#100;&#x72;&#x6f;&#105;&#x64;&#46;&#104;&#x61;&#x72;&#100;&#x77;&#x61;&#x72;&#101;&#x2e;&#x67;&#97;&#x6c;&#97;&#x78;&#121;&#x5f;&#x6f;&#x6e;&#101;&#x40;&#x31;&#46;&#48;&#45;&#115;&#101;&#x72;&#118;&#105;&#99;&#x65;&#46;&#x72;&#x63;</a>：设备开机时通过 <strong>rc</strong> 文件启动此服务</li><li>galaxy_hal_service：service的名，可通过 <strong>start galaxy_hal_service</strong> 启动服务，由service.cpp编译生成</li><li><a href="mailto:&#x61;&#110;&#x64;&#114;&#111;&#105;&#100;&#x2e;&#x68;&#x61;&#114;&#100;&#119;&#97;&#x72;&#x65;&#46;&#103;&#x61;&#108;&#97;&#120;&#x79;&#95;&#x6f;&#110;&#x65;&#64;&#x31;&#46;&#x30;&#45;&#x69;&#109;&#112;&#x6c;&#x2e;&#115;&#111;">&#x61;&#110;&#x64;&#114;&#111;&#105;&#100;&#x2e;&#x68;&#x61;&#114;&#100;&#119;&#97;&#x72;&#x65;&#46;&#103;&#x61;&#108;&#97;&#120;&#x79;&#95;&#x6f;&#110;&#x65;&#64;&#x31;&#46;&#x30;&#45;&#x69;&#109;&#112;&#x6c;&#x2e;&#115;&#111;</a>：实现库，上层应用的最终调用，由GalaxyOne.cpp编译生成</li></ul><p>关于 <strong>Application、JNI</strong> 这两层内容会在稍后用两个篇幅去分析，此处暂不理会。现在我们就着这个调用过程将需要的内容补充完成。明出处。</p><h4 id="5-3-1-接口库生成"><a href="#5-3-1-接口库生成" class="headerlink" title="5.3.1 接口库生成"></a>5.3.1 接口库生成</h4><p><a href="mailto:&#97;&#110;&#100;&#114;&#111;&#x69;&#100;&#x2e;&#104;&#x61;&#114;&#100;&#119;&#97;&#x72;&#x65;&#x2e;&#103;&#x61;&#x6c;&#x61;&#120;&#x79;&#95;&#111;&#x6e;&#101;&#64;&#x31;&#x2e;&#x30;&#x2e;&#115;&#x6f;">&#97;&#110;&#100;&#114;&#111;&#x69;&#100;&#x2e;&#104;&#x61;&#114;&#100;&#119;&#97;&#x72;&#x65;&#x2e;&#103;&#x61;&#x6c;&#x61;&#120;&#x79;&#95;&#111;&#x6e;&#101;&#64;&#x31;&#x2e;&#x30;&#x2e;&#115;&#x6f;</a>，由 <strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0&#x2F;Android.bp</strong> 通过 <strong>IGalaxyOne.hal</strong> 生成，Android.bp 文件是在上面一些列命令执行之后生成，而接口库是当我们最终执行编译模块时生成，可以说这个过程不需要我们手动参与，Android.bp 内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile">// This file is autogenerated by hidl-gen -Landroidbp.<br><br>hidl_interface &#123;<br>    name: <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0&quot;</span>,   //此处设置接口库的名字<br>    root: <span class="hljs-string">&quot;android.hardware&quot;</span>,<br>    vndk: &#123;<br>        enabled: true,<br>    &#125;,<br>    srcs: [<br>        <span class="hljs-string">&quot;IGalaxyOne.hal&quot;</span>,<br>    ],<br>    interfaces: [<br>        <span class="hljs-string">&quot;android.hidl.base@1.0&quot;</span>,<br>    ],<br>    gen_java: true,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-2-实现库生成"><a href="#5-3-2-实现库生成" class="headerlink" title="5.3.2 实现库生成"></a>5.3.2 实现库生成</h4><p><a href="mailto:&#97;&#x6e;&#x64;&#114;&#x6f;&#105;&#100;&#46;&#x68;&#97;&#x72;&#100;&#119;&#x61;&#114;&#101;&#x2e;&#103;&#x61;&#108;&#x61;&#x78;&#x79;&#x5f;&#x6f;&#x6e;&#x65;&#64;&#x31;&#46;&#48;&#x2d;&#105;&#109;&#112;&#x6c;&#x2e;&#x73;&#x6f;">&#97;&#x6e;&#x64;&#114;&#x6f;&#105;&#100;&#46;&#x68;&#97;&#x72;&#100;&#119;&#x61;&#114;&#101;&#x2e;&#103;&#x61;&#108;&#x61;&#x78;&#x79;&#x5f;&#x6f;&#x6e;&#x65;&#64;&#x31;&#46;&#48;&#x2d;&#105;&#109;&#112;&#x6c;&#x2e;&#x73;&#x6f;</a>，由 <strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0&#x2F;default&#x2F;Android.bp</strong> 通过 <strong>GalaxyOne.cpp</strong> 生成，注意这个 Android.bp 文件是位于 <strong>default</strong> 目录下，同样的在最后模块编译时生成，原始内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cc_library_shared &#123;<br>    name: <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0-impl&quot;</span>,<br>    relative_install_path: <span class="hljs-string">&quot;hw&quot;</span>,<br>    proprietary: true,<br>    srcs: [<br>        <span class="hljs-string">&quot;GalaxyOne.cpp&quot;</span>,<br>    ],<br>    shared_libs: [    //这里可以添加我们需要的库<br>        <span class="hljs-string">&quot;liblog&quot;</span>,     <br>        <span class="hljs-string">&quot;libhidlbase&quot;</span>,<br>        <span class="hljs-string">&quot;libhidltransport&quot;</span>,<br>        <span class="hljs-string">&quot;libhwbinder&quot;</span>,<br>        <span class="hljs-string">&quot;libutils&quot;</span>,<br>        <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0&quot;</span>,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-3-GalaxyOne-cpp实现"><a href="#5-3-3-GalaxyOne-cpp实现" class="headerlink" title="5.3.3 GalaxyOne.cpp实现"></a>5.3.3 GalaxyOne.cpp实现</h4><p>在 <strong>5.3.2</strong> 中，实现库是由 <strong>GalaxyOne.cpp</strong> 编译而成，现在我们来将此文件补充完成：</p><p><strong>GalaxyOne.h:</strong><br> Binder化直通式，同样需要将 HIDL_FETCH_XXX 打开，至于原因我们在后面会提及</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ANDROID_HARDWARE_GALAXY_ONE_V1_0_GALAXYONE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANDROID_HARDWARE_GALAXY_ONE_V1_0_GALAXYONE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hardware/galaxy_one/1.0/IGalaxyOne.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/MQDescriptor.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/Status.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;log/log.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> android &#123;<br><span class="hljs-keyword">namespace</span> hardware &#123;<br><span class="hljs-keyword">namespace</span> galaxy_one &#123;<br><span class="hljs-keyword">namespace</span> V1_0 &#123;<br><span class="hljs-keyword">namespace</span> implementation &#123;<br><br><span class="hljs-keyword">using</span> ::android::hardware::hidl_array;<br><span class="hljs-keyword">using</span> ::android::hardware::hidl_memory;<br><span class="hljs-keyword">using</span> ::android::hardware::hidl_string;<br><span class="hljs-keyword">using</span> ::android::hardware::hidl_vec;<br><span class="hljs-keyword">using</span> ::android::hardware::Return;<br><span class="hljs-keyword">using</span> ::android::hardware::Void;<br><span class="hljs-keyword">using</span> ::android::sp;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GalaxyOne</span> : <span class="hljs-keyword">public</span> IGalaxyOne &#123;<br>    <span class="hljs-comment">// Methods from ::android::hardware::galaxy_one::V1_0::IGalaxyOne follow.</span><br>    <span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> <span class="hljs-keyword">override</span></span>;<br><br>    <span class="hljs-comment">// Methods from ::android::hidl::base::V1_0::IBase follow.</span><br><br>&#125;;<br><br><span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> most likely delete, this is only for passthrough implementations</span><br> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">IGalaxyOne* <span class="hljs-title">HIDL_FETCH_IGalaxyOne</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span></span>;<br><br>&#125;  <span class="hljs-comment">// namespace implementation</span><br>&#125;  <span class="hljs-comment">// namespace V1_0</span><br>&#125;  <span class="hljs-comment">// namespace galaxy_one</span><br>&#125;  <span class="hljs-comment">// namespace hardware</span><br>&#125;  <span class="hljs-comment">// namespace android</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// ANDROID_HARDWARE_GALAXY_ONE_V1_0_GALAXYONE_H</span></span><br><br></code></pre></td></tr></table></figure><p><strong>GalaxyOne.cpp:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GalaxyOne.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> android &#123;<br><span class="hljs-keyword">namespace</span> hardware &#123;<br><span class="hljs-keyword">namespace</span> galaxy_one &#123;<br><span class="hljs-keyword">namespace</span> V1_0 &#123;<br><span class="hljs-keyword">namespace</span> implementation &#123;<br><br><span class="hljs-comment">// Methods from ::android::hardware::galaxy_one::V1_0::IGalaxyOne follow.</span><br><span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">GalaxyOne::add</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> result = a + b;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;GalaxyOne::add  a = %d,b = %d,result = %d&quot;</span>,a,b,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">GalaxyOne::sub</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> result = a - b;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;GalaxyOne::sub  a = %d,b = %d,result = %d&quot;</span>,a,b,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">GalaxyOne::mul</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> result = a * b;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;GalaxyOne::mul  a = %d,b = %d,result = %d&quot;</span>,a,b,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">GalaxyOne::div</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> result = a / b;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;GalaxyOne::div  a = %d,b = %d,result = %d&quot;</span>,a,b,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// Methods from ::android::hidl::base::V1_0::IBase follow.</span><br><span class="hljs-function">IGalaxyOne* <span class="hljs-title">HIDL_FETCH_IGalaxyOne</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-comment">/* name */</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">ALOG</span>(<span class="hljs-string">&quot;galaxy_one service init success....&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">GalaxyOne</span>();<br>&#125;<br><br>&#125;  <span class="hljs-comment">// namespace implementation</span><br>&#125;  <span class="hljs-comment">// namespace V1_0</span><br>&#125;  <span class="hljs-comment">// namespace galaxy_one</span><br>&#125;  <span class="hljs-comment">// namespace hardware</span><br>&#125;  <span class="hljs-comment">// namespace android</span><br></code></pre></td></tr></table></figure><h4 id="5-3-4-模块编译"><a href="#5-3-4-模块编译" class="headerlink" title="5.3.4 模块编译"></a>5.3.4 模块编译</h4><p>现在除了需要的 <strong>rc</strong> 文件没有补充、<strong>galaxy-hal-service</strong> 服务没有生成外其余均已配置好了，现在进行编译生成对应的库。进入根目录下执行如下命令：(注意是在刚刚执行过的 <strong>source build&#x2F;envsetup.sh</strong> 和 <strong>lunch</strong> 的窗口下编译，若是新窗口则需要重新执行这两条命令)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mmm  hardware/interfaces/galaxy_one/1.0<br></code></pre></td></tr></table></figure><p>此时应该可以在 <strong>out&#x2F;tartget&#x2F;product&#x2F;XXX&#x2F;vendor&#x2F;lib64&#x2F;hw</strong> 和 <strong>out&#x2F;tartget&#x2F;product&#x2F;XXX&#x2F;system&#x2F;lib64&#x2F;hw</strong> 目录下找到 <strong><a href="mailto:&#97;&#x6e;&#100;&#114;&#111;&#x69;&#x64;&#46;&#x68;&#x61;&#114;&#100;&#x77;&#x61;&#x72;&#x65;&#46;&#103;&#97;&#x6c;&#x61;&#120;&#121;&#x5f;&#x6f;&#110;&#101;&#64;&#x31;&#x2e;&#48;&#45;&#x69;&#x6d;&#112;&#108;&#x2e;&#x73;&#x6f;">&#97;&#x6e;&#100;&#114;&#111;&#x69;&#x64;&#46;&#x68;&#x61;&#114;&#100;&#x77;&#x61;&#x72;&#x65;&#46;&#103;&#97;&#x6c;&#x61;&#120;&#121;&#x5f;&#x6f;&#110;&#101;&#64;&#x31;&#x2e;&#48;&#45;&#x69;&#x6d;&#112;&#108;&#x2e;&#x73;&#x6f;</a></strong> 和 <strong><a href="mailto:&#x61;&#110;&#x64;&#x72;&#x6f;&#105;&#100;&#x2e;&#x68;&#97;&#114;&#100;&#x77;&#97;&#x72;&#101;&#x2e;&#103;&#97;&#108;&#x61;&#x78;&#x79;&#x5f;&#111;&#110;&#x65;&#64;&#49;&#x2e;&#48;&#x2e;&#115;&#111;">&#x61;&#110;&#x64;&#x72;&#x6f;&#105;&#100;&#x2e;&#x68;&#97;&#114;&#100;&#x77;&#97;&#x72;&#101;&#x2e;&#103;&#97;&#108;&#x61;&#x78;&#x79;&#x5f;&#111;&#110;&#x65;&#64;&#49;&#x2e;&#48;&#x2e;&#115;&#111;</a></strong> 两个动态库</p><h4 id="5-3-5-service生成"><a href="#5-3-5-service生成" class="headerlink" title="5.3.5 service生成"></a>5.3.5 service生成</h4><p>上面过程将需要的动态库生成完毕，接下来我们需要生成对应的 service 可执行文件，这个过程一共分为三步：</p><p><strong>1、向&#x2F;default下的Android.bp 文件添加以下内容</strong></p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs make">cc_library &#123;<br>    name: <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0-service&quot;</span>,<br>    defaults: [<span class="hljs-string">&quot;hidl_defaults&quot;</span>],<br>    relative_install_path: <span class="hljs-string">&quot;hw&quot;</span>,<br>    vendor: true,<br>    srcs: [<br>        <span class="hljs-string">&quot;service.cpp&quot;</span><br>    ],<br>    init_rc: [<span class="hljs-string">&quot;android.hardware.galaxy_one@1.0-service.rc&quot;</span>],<br>    shared_libs: [<br>        <span class="hljs-string">&quot;liblog&quot;</span>,<br>        <span class="hljs-string">&quot;libhidlbase&quot;</span>,<br>        <span class="hljs-string">&quot;libhidltransport&quot;</span>,<br>        <span class="hljs-string">&quot;libhwbinder&quot;</span>,<br>        <span class="hljs-string">&quot;libutils&quot;</span>,<br>        <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0&quot;</span>,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、补充 service.cpp 内容</strong></p><p>内容很简单，<strong>defaultPassthroughServiceImplementation</strong> 帮我们自动注册服务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_TAG <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0-service&quot;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hardware/galaxy_one/1.0/IGalaxyOne.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/LegacySupport.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GalaxyOne.h&quot;</span></span><br> <br><span class="hljs-comment">// Generated HIDL files</span><br><span class="hljs-keyword">using</span> android::hardware::galaxy_one::V1_0::IGalaxyOne;<br><span class="hljs-keyword">using</span> android::hardware::galaxy_one::V1_0::implementation::GalaxyOne;<br> <br><span class="hljs-keyword">using</span> android::hardware::defaultPassthroughServiceImplementation;<br><span class="hljs-keyword">using</span> android::hardware::configureRpcThreadpool;<br><span class="hljs-keyword">using</span> android::hardware::joinRpcThreadpool;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">defaultPassthroughServiceImplementation</span>&lt;IGalaxyOne&gt;();<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>3、补充 rc 文件</strong></p><p>注意这里的 <strong>galaxy-hal-service</strong> 相当于这个服务的别名，系统就是根据这个文件在启动的同时也将这个 service 启动，因此在下面我们手动启动测试时没有什么作用，不过这里先补充完整。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">service galaxy-hal-service /vendor/bin/hw/android.hardware.galaxy_one@1.0-service<br>    class hal<br>    user system<br>    group system<br></code></pre></td></tr></table></figure><p>同样执行 <strong>mmm hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0</strong> 命令，完成之后就会得到如下二进制可执行文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ba">out/target/product/sailfish/vendor/bin/hw/android.hardware.galaxy_one@1.0-service<br></code></pre></td></tr></table></figure><h3 id="5-4-client端"><a href="#5-4-client端" class="headerlink" title="5.4 client端"></a>5.4 client端</h3><p>经过一系列过程之后，我们得到了三个产物<br>1、<strong><a href="mailto:&#x61;&#110;&#100;&#x72;&#111;&#105;&#100;&#46;&#x68;&#x61;&#114;&#x64;&#x77;&#x61;&#x72;&#x65;&#x2e;&#x67;&#97;&#x6c;&#x61;&#120;&#121;&#95;&#111;&#x6e;&#101;&#x40;&#x31;&#46;&#48;&#46;&#115;&#x6f;">&#x61;&#110;&#100;&#x72;&#111;&#105;&#100;&#46;&#x68;&#x61;&#114;&#x64;&#x77;&#x61;&#x72;&#x65;&#x2e;&#x67;&#97;&#x6c;&#x61;&#120;&#121;&#95;&#111;&#x6e;&#101;&#x40;&#x31;&#46;&#48;&#46;&#115;&#x6f;</a></strong><br>2、<strong><a href="mailto:&#97;&#110;&#x64;&#114;&#111;&#x69;&#100;&#46;&#104;&#97;&#x72;&#x64;&#119;&#x61;&#114;&#101;&#46;&#103;&#97;&#108;&#97;&#x78;&#121;&#x5f;&#x6f;&#x6e;&#101;&#x40;&#x31;&#x2e;&#x30;&#45;&#x69;&#109;&#112;&#x6c;&#x2e;&#x73;&#x6f;">&#97;&#110;&#x64;&#114;&#111;&#x69;&#100;&#46;&#104;&#97;&#x72;&#x64;&#119;&#x61;&#114;&#101;&#46;&#103;&#97;&#108;&#97;&#x78;&#121;&#x5f;&#x6f;&#x6e;&#101;&#x40;&#x31;&#x2e;&#x30;&#45;&#x69;&#109;&#112;&#x6c;&#x2e;&#x73;&#x6f;</a></strong><br>3、<strong><a href="mailto:&#97;&#110;&#x64;&#114;&#111;&#105;&#x64;&#46;&#104;&#x61;&#x72;&#100;&#119;&#97;&#x72;&#x65;&#x2e;&#x67;&#x61;&#x6c;&#x61;&#x78;&#x79;&#95;&#111;&#110;&#101;&#x40;&#x31;&#x2e;&#x30;&#x2d;&#115;&#x65;&#114;&#118;&#105;&#x63;&#x65;">&#97;&#110;&#x64;&#114;&#111;&#105;&#x64;&#46;&#104;&#x61;&#x72;&#100;&#119;&#97;&#x72;&#x65;&#x2e;&#x67;&#x61;&#x6c;&#x61;&#x78;&#x79;&#95;&#111;&#110;&#101;&#x40;&#x31;&#x2e;&#x30;&#x2d;&#115;&#x65;&#114;&#118;&#105;&#x63;&#x65;</a></strong></p><p>现在需要模拟一个客户端来测试调用，因此在 <strong>default</strong> 目录下新建 <strong>test</strong> 目录，并新建 <strong>client.cpp、Android.bp</strong> 文件，具体结构如下：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-cfccd9a1dea02880.png" style="zoom: 67%;"><p><strong>client.cpp 内容如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hardware/galaxy_one/1.0/IGalaxyOne.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/Status.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;log/log.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> android::sp;<br><span class="hljs-keyword">using</span> android::hardware::galaxy_one::V1_0::IGalaxyOne;<br><span class="hljs-keyword">using</span> android::hardware::Return;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    android::sp&lt;IGalaxyOne&gt; service = IGalaxyOne::<span class="hljs-built_in">getService</span>();<br>    <span class="hljs-keyword">if</span> (service == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;faile to get galaxy_one service......&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;success to get galaxy_one service.....&quot;</span>);<br><br>    <span class="hljs-type">uint32_t</span> addResult = service-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;galaxy_one service add: result = %d&quot;</span>,(<span class="hljs-type">int</span>)addResult);<br><br>    <span class="hljs-type">uint32_t</span> subResult = service-&gt;<span class="hljs-built_in">sub</span>(<span class="hljs-number">8</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;galaxy_one service sub: result = %d&quot;</span>,(<span class="hljs-type">int</span>)subResult);<br><br>    <span class="hljs-type">uint32_t</span> mulResult = service-&gt;<span class="hljs-built_in">mul</span>(<span class="hljs-number">3</span>,<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;galaxy_one service mul: result = %d&quot;</span>,(<span class="hljs-type">int</span>)mulResult);<br><br>    <span class="hljs-type">uint32_t</span> divResult = service-&gt;<span class="hljs-built_in">div</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;galaxy_one service div: result = %d&quot;</span>,(<span class="hljs-type">int</span>)divResult);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Android.bp 内容如下：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cc_binary &#123;<br>    name: <span class="hljs-string">&quot;galaxy_test&quot;</span>,    //表示生成的 client 名称<br>    srcs: [<br>        <span class="hljs-string">&quot;client.cpp&quot;</span><br>    ],<br>    shared_libs: [<br>        <span class="hljs-string">&quot;liblog&quot;</span>,<br>        <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0&quot;</span>,<br>        <span class="hljs-string">&quot;libhidlbase&quot;</span>,<br>        <span class="hljs-string">&quot;libhidltransport&quot;</span>,<br>        <span class="hljs-string">&quot;libhwbinder&quot;</span>,<br>        <span class="hljs-string">&quot;libutils&quot;</span>,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>mmm hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0</strong> 命令编译之后，可以在 <strong>out&#x2F;target&#x2F;product&#x2F;XXX&#x2F;system&#x2F;bin</strong> 目录下找到 <strong>galaxy_test</strong> 。</p><h3 id="5-5-声明使得Framework可以识别"><a href="#5-5-声明使得Framework可以识别" class="headerlink" title="5.5 声明使得Framework可以识别"></a>5.5 声明使得Framework可以识别</h3><p><strong>HIDL</strong> 想要被 <strong>framework</strong> 获取使用还需要在 <strong>manifest.xml</strong> 中注册，此文件位于 <code>device/[companyName]/[productName]/manifest.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">hal</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;hidl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>android.hardware.galaxy_one<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transport</span>&gt;</span>hwbinder<span class="hljs-tag">&lt;/<span class="hljs-name">transport</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">interface</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>IGalaxyOne<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">instance</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">instance</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">interface</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fqname</span>&gt;</span>@1.0::IGalaxyOne/default<span class="hljs-tag">&lt;/<span class="hljs-name">fqname</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">hal</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-6-添加sepolicy策略"><a href="#5-6-添加sepolicy策略" class="headerlink" title="5.6 添加sepolicy策略"></a>5.6 添加sepolicy策略</h3><p>本文暂时关闭selinux</p><h2 id="6-验证服务"><a href="#6-验证服务" class="headerlink" title="6.验证服务"></a>6.验证服务</h2><h3 id="6-1-push设备"><a href="#6-1-push设备" class="headerlink" title="6.1 push设备"></a>6.1 push设备</h3><p>现在我们一共得到 4 个产物，使用 <strong>adb</strong> 命令将其 <strong>push</strong> 到手机对应目录下：</p><p>1、<a href="mailto:&#97;&#110;&#x64;&#114;&#111;&#x69;&#100;&#x2e;&#104;&#x61;&#x72;&#100;&#x77;&#x61;&#x72;&#101;&#x2e;&#x67;&#97;&#108;&#x61;&#120;&#121;&#95;&#111;&#110;&#101;&#64;&#x31;&#46;&#x30;&#45;&#x69;&#x6d;&#x70;&#108;&#46;&#115;&#111;">&#97;&#110;&#x64;&#114;&#111;&#x69;&#100;&#x2e;&#104;&#x61;&#x72;&#100;&#x77;&#x61;&#x72;&#101;&#x2e;&#x67;&#97;&#108;&#x61;&#120;&#121;&#95;&#111;&#110;&#101;&#64;&#x31;&#46;&#x30;&#45;&#x69;&#x6d;&#x70;&#108;&#46;&#115;&#111;</a> &#x3D;&#x3D;&#x3D;&gt; &#x2F;vendor&#x2F;lib64&#x2F;hw<br>2、<a href="mailto:&#97;&#x6e;&#x64;&#114;&#x6f;&#105;&#x64;&#46;&#104;&#x61;&#x72;&#100;&#119;&#97;&#x72;&#101;&#x2e;&#x67;&#97;&#x6c;&#97;&#x78;&#121;&#x5f;&#x6f;&#110;&#101;&#64;&#49;&#46;&#48;&#x2e;&#115;&#111;">&#97;&#x6e;&#x64;&#114;&#x6f;&#105;&#x64;&#46;&#104;&#x61;&#x72;&#100;&#119;&#97;&#x72;&#101;&#x2e;&#x67;&#97;&#x6c;&#97;&#x78;&#121;&#x5f;&#x6f;&#110;&#101;&#64;&#49;&#46;&#48;&#x2e;&#115;&#111;</a> &#x3D;&#x3D;&#x3D;&gt; vendor&#x2F;lib64<br>3、<a href="mailto:&#97;&#x6e;&#x64;&#x72;&#x6f;&#x69;&#x64;&#46;&#104;&#97;&#x72;&#100;&#x77;&#x61;&#114;&#101;&#46;&#x67;&#x61;&#x6c;&#x61;&#x78;&#x79;&#x5f;&#x6f;&#x6e;&#101;&#x40;&#x31;&#x2e;&#48;&#45;&#x73;&#101;&#114;&#x76;&#x69;&#x63;&#101;">&#97;&#x6e;&#x64;&#x72;&#x6f;&#x69;&#x64;&#46;&#104;&#97;&#x72;&#100;&#x77;&#x61;&#114;&#101;&#46;&#x67;&#x61;&#x6c;&#x61;&#x78;&#x79;&#x5f;&#x6f;&#x6e;&#101;&#x40;&#x31;&#x2e;&#48;&#45;&#x73;&#101;&#114;&#x76;&#x69;&#x63;&#101;</a> &#x3D;&#x3D;&#x3D;&gt; &#x2F;vendor&#x2F;bin&#x2F;hw<br>4、galaxy_test &#x3D;&#x3D;&#x3D;&gt; &#x2F;system&#x2F;bin</p><h3 id="6-2-运行service"><a href="#6-2-运行service" class="headerlink" title="6.2 运行service"></a>6.2 运行service</h3><p>这里我们手动启动，用于测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./vendor/bin/hw/android.hardware.galaxy_one@1.0-service<br></code></pre></td></tr></table></figure><h3 id="6-3-运行client"><a href="#6-3-运行client" class="headerlink" title="6.3 运行client"></a>6.3 运行client</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./system/bin/galaxy_test<br></code></pre></td></tr></table></figure><p>运行成功之后可查看日志，有如下内容则表示服务建立成功：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-a17a33c648493e73.png" style="zoom: 75%;">]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件系统mount过程</title>
    <link href="/2023/03/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fmount%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/03/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fmount%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统mount过程"><a href="#文件系统mount过程" class="headerlink" title="文件系统mount过程"></a>文件系统mount过程</h1><blockquote><p>🍒 <strong>环境</strong>：内核版本4.5</p><p>🍉 <strong>说明</strong>：参考<a href="https://blog.csdn.net/zr_lang/article/details/39963253%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2%EF%BC%8C%E6%94%B6%E8%8E%B7%E9%A2%87%E4%B8%B0">https://blog.csdn.net/zr_lang/article/details/39963253，非常感谢，收获颇丰</a></p></blockquote><p>从用户下发mount指令到具体的文件系统进行挂载，大致经历了下面的步骤【以<code>f2fs</code>文件系统为例】。</p><img src="/2023/03/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fmount%E8%BF%87%E7%A8%8B/image-20230309225903725.png" alt="image-20230309225903725" style="zoom: 67%;"><h2 id="1-每个人该有的样子file-system-type"><a href="#1-每个人该有的样子file-system-type" class="headerlink" title="1.每个人该有的样子file_system_type"></a>1.每个人该有的样子file_system_type</h2><p>每个人在冲浪的都有自己的昵称，自己的个性标签，这仿佛是每个人共同的样子，不妨将所有的文件系统也抽象成同一个样子表示<code>file_system_type</code>，每一个文件系统肯定有</p><ul><li>name: 文件系统的名字，如xfs, ext2等</li><li>fs_flags: 说明文件系统的类型</li><li>mount: 代替早期的get_sb()，用户挂载此文件系统时使用的回调函数。</li><li>kill_sb: 删除内存中的super block，在卸载文件系统时使用。</li><li>owner: 指向实现这个文件系统的模块，通常为THIS_MODULE宏。</li><li>next: 指向文件系统类型链表的下一个文件系统类型。</li><li>fs_supers: 具有同样此文件系统类型的超级块结构，都串连在这个表头下。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include\linux\fs.h</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> &#123;</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>        <span class="hljs-type">int</span> fs_flags;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_REQUIRES_DEV         1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_BINARY_MOUNTDATA     2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_HAS_SUBTYPE          4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_USERNS_MOUNT         8       <span class="hljs-comment">/* Can be mounted by userns root */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_USERNS_DEV_MOUNT     16 <span class="hljs-comment">/* A userns mount does not imply MNT_NODEV */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_RENAME_DOES_D_MOVE   32768   <span class="hljs-comment">/* FS will handle d_move() during rename() internally. */</span></span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *(*<span class="hljs-title">mount</span>) (<span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> *, <span class="hljs-title">int</span>, <span class="hljs-title">const</span> <span class="hljs-title">char</span> *, <span class="hljs-title">void</span> *);</span><br>        <span class="hljs-type">void</span> (*kill_sb) (<span class="hljs-keyword">struct</span> super_block *);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> * <span class="hljs-title">next</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span> <span class="hljs-title">fs_supers</span>;</span><br>       <span class="hljs-comment">// ....</span><br>        <span class="hljs-comment">//为了说明方便，此处省略若干锁相关变量。</span><br>        <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在kernel的<code>/fs</code>有各种各样的文件系统，file_system_type结构一般被定义在super.c。下面以<strong>f2fs</strong>文件系统为例介绍一下他的<code>file_system_type</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs\f2fs\super.c</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> <span class="hljs-title">f2fs_fs_type</span> =</span> &#123;<br>.owner= THIS_MODULE,<br>.name= <span class="hljs-string">&quot;f2fs&quot;</span>,<br>.mount= f2fs_mount,<br>.kill_sb= kill_f2fs_super,<br>.fs_flags= FS_REQUIRES_DEV,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>owner说明f2fs模块本身拥有这个file_system_type。</p></li><li><p>name是f2fs。</p></li><li><p>fs_flags是FS_REQUIRES_DEV，表明f2fs一定要被使用在物理设备上。</p></li><li><p>mount是f2fs_mount，说明 f2fs_mount这个函数实现了f2fs的具体mount操作。在第3节阐述</p></li></ul><h2 id="2-注册账号register-filesystem"><a href="#2-注册账号register-filesystem" class="headerlink" title="2.注册账号register_filesystem"></a>2.注册账号register_filesystem</h2><p>当然，你自己想象好了自己的昵称，自己的个性表型，自己的能力，还有自己的一份简历【superblock】，不注册账号怎么冲浪嘛🏄</p><p>同理当初始化好了一个具体的文件系统，我们也要向内核进行注册<code>register_filesystem</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">register_filesystem</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file_system_type * fs)</span><br>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> ** <span class="hljs-title">p</span>;</span><br> <br>        BUG_ON(<span class="hljs-built_in">strchr</span>(fs-&gt;name, <span class="hljs-string">&#x27;.&#x27;</span>));<br>        <span class="hljs-keyword">if</span> (fs-&gt;next)<br>                <span class="hljs-keyword">return</span> -EBUSY;<br>        write_lock(&amp;file_systems_lock);<br>       <br>        <span class="hljs-comment">// 遍历全局file_systems链表，尝试查找本次要注册文件系统名。</span><br>        p = find_filesystem(fs-&gt;name, <span class="hljs-built_in">strlen</span>(fs-&gt;name));<br>        <span class="hljs-keyword">if</span> (*p) <span class="hljs-comment">// 如果不为NULL，则说明找到了重名的文件系统。注册失败。</span><br>                res = -EBUSY;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果返回NULL，说明已经到链表结尾，可以注册此文件系统。</span><br>                *p = fs; <span class="hljs-comment">// 将此文件系统链接到链表结尾。</span><br>        write_unlock(&amp;file_systems_lock);<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>file_system_type的基本操作都在fs&#x2F;filesystems.c文件里，文件不长，可以简短的浏览一下都有那些操作函数。最主要的变量莫过于此文件内的全局变量：</p><p>&#x2F;&#x2F; 此变量是文件系统类型单链表的头指针<code>static struct file_system_type *file_systems</code></p></blockquote><p>那么f2fs在哪里注册的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">init_f2fs_fs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    err = register_filesystem(&amp;f2fs_fs_type);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-开始属于f2fs的mount"><a href="#3-开始属于f2fs的mount" class="headerlink" title="3.开始属于f2fs的mount"></a>3.开始属于f2fs的mount</h2><p>在文章的开头我们可以看到，如果在用户空间执行<code>mount -t f2fs /dev/xxx /mntdir/xxx</code>，那么最终会去调用f2fs的mount函数，在第1节的f2fs_fs_type指明了f2fs文件系统的mount函数为<code>f2fs_mount</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dentry *<span class="hljs-title function_">f2fs_mount</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file_system_type *fs_type, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *dev_name, <span class="hljs-type">void</span> *data)</span><br>&#123;<br><span class="hljs-keyword">return</span> mount_bdev(fs_type, flags, dev_name, data, f2fs_fill_super);<br>&#125;<br></code></pre></td></tr></table></figure><p>看起来就是一个mount_bdev()函数，但是看参数可以看到一些重要的东西</p><ul><li>fs_type不用多说，携带file_system_type的信息，这里传递它主要是因为它携带了super block的链表和很多锁变量。</li><li>flags文件系统的通用挂载选项。</li><li>dev_name是mount操作时的设备名，如&#x2F;dev&#x2F;sda1。后面会用到这个设备名找到对应的设备信息，从而从中获得super block。</li><li>data是挂载时指定的挂载选项信息。</li><li>f2fs_fill_super是一个由f2fs特定实现的fill_super方法，用来根据f2fs文件系统的特性解析mount data并继续填充super block的字段，并且初始化挂载点的根索引节点对象和目录项对象。</li></ul><h2 id="4-挂载选项flag和data"><a href="#4-挂载选项flag和data" class="headerlink" title="4.挂载选项flag和data"></a>4.挂载选项flag和data</h2><p>在第3节中我们可以看到f2fs挂载的时候有flags和data，但是我们平常挂载的只有一个<code>- o</code>参数啊，例如<code>mount -t f2fs -o ro /dev/xxx /mntdir/xxx</code>。那么我们如何区分具体的flag和data呢？</p><p>先来看一下flags都有哪些可选值(取自<code>include/uapi/linux/fs.h</code>)，我们来尽量把它们和mount命令里的选项对应一下(man 2 mount)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * These are the fs-independent mount-flags: up to 32 flags are supported</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RDONLY        1         <span class="hljs-comment">/* 对应-o ro/rw */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSUID        2         <span class="hljs-comment">/* 对应-o suid/nosuid */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODEV         4         <span class="hljs-comment">/*  对应-o suid/nosuid */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOEXEC        8         <span class="hljs-comment">/* 对应-o exec/noexec */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SYNCHRONOUS  16         <span class="hljs-comment">/* 对应-o sync/async */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REMOUNT      32         <span class="hljs-comment">/* 对应-o remount，告诉mount这是一次remount操作 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MANDLOCK     64         <span class="hljs-comment">/* 对应-o mand/nomand */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_DIRSYNC      128        <span class="hljs-comment">/* 对应-o dirsync */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOATIME      1024       <span class="hljs-comment">/* 对应-o atime/noatime */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODIRATIME   2048       <span class="hljs-comment">/* 对应-o diratime/nodiratime */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BIND         4096       <span class="hljs-comment">/* 对应-B/--bind选项，告诉mount这是一次bind操作 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MOVE         8192       <span class="hljs-comment">/* 对应-M/--move，告诉mount这是一次move操作 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REC          16384      <span class="hljs-comment">/* rec是recursive的意思，这个flag一般不单独出现，都是伴随这其它flag，表示递归的进行操作 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_VERBOSE      32768      <span class="hljs-comment">/* 对应-v/--verbose */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SILENT       32768      <span class="hljs-comment">/* 对应-o silent/loud */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_POSIXACL     (1&lt;&lt;16)    <span class="hljs-comment">/* 让VFS不应用umask，如NFS */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_UNBINDABLE   (1&lt;&lt;17)    <span class="hljs-comment">/* 对应--make-unbindable */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_PRIVATE      (1&lt;&lt;18)    <span class="hljs-comment">/* 对应--make-private */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SLAVE        (1&lt;&lt;19)    <span class="hljs-comment">/* 对应--make-slave */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SHARED       (1&lt;&lt;20)    <span class="hljs-comment">/* 对应--make-shared */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RELATIME     (1&lt;&lt;21)    <span class="hljs-comment">/* 对应-o relatime/norelatime */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_KERNMOUNT    (1&lt;&lt;22)    <span class="hljs-comment">/* 这个一般不在应用层使用，一般内核挂载的文件系统如sysfs使用，表示使用kern_mount()进行挂载 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_I_VERSION    (1&lt;&lt;23)    <span class="hljs-comment">/* 对应-o iversion/noiversion */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_STRICTATIME  (1&lt;&lt;24)    <span class="hljs-comment">/* 对应-o strictatime/nostrictatime */</span></span><br> <br><span class="hljs-comment">/* 下面这几个flags都是内核内部使用的，它们的含义我只是通过简单的查看代码逻辑暂时猜测的 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSEC        (1&lt;&lt;28)    <span class="hljs-comment">/* 有些文件系统不支持suid，security xattr等安全标记 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BORN         (1&lt;&lt;29)    <span class="hljs-comment">/* 表示内存superblock已经创建完成 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_ACTIVE       (1&lt;&lt;30)    <span class="hljs-comment">/* 表示内存superblock正处于活动状态 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOUSER       (1&lt;&lt;31)    <span class="hljs-comment">/* 表示文件系统不能被应用层挂载使用，只能被内核使用，如rootfs */</span></span><br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Superblock flags that can be altered by MS_REMOUNT</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RMT_MASK     (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION)  <span class="hljs-comment">// 可以在remount是改变的flags</span></span><br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Old magic mount flag and mask</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_VAL 0xC0ED0000      <span class="hljs-comment">/* 过去使用的magic，现在基本被忽略了 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_MSK 0xffff0000      <span class="hljs-comment">/* 过去使用的flag的的mask */</span></span><br></code></pre></td></tr></table></figure><p>从上面可以看出，flags基本上是options中通用的那些，也就是说基本是<strong>面向所有文件系统通用的</strong>，当然还有一些是内核使用的。这些flags大部分都在VFS层被解析使用。</p><p>而data呢，把options中通用的去掉，<strong>剩下的就是每个文件系统各自支持的挂载选项</strong>。</p><p>🎈让我们来看个例子：我们选取一个与flags对应的option，如nodev。在从xfs【也是一种文件系统】中选取一个特定的option，如noquota。然后用strace跟踪一下mount的过程，执行</p><p><code>strace mount /dev/loop0 /mnt/test -o noquota,nodev</code></p><p>在接近最后的位置我们可以看到mount系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mount(<span class="hljs-string">&quot;/dev/loop0&quot;</span>, <span class="hljs-string">&quot;/mnt/test&quot;</span>, <span class="hljs-string">&quot;xfs&quot;</span>, MS_MGC_VAL|MS_NODEV, <span class="hljs-string">&quot;noquota&quot;</span>) = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>果然，nodev被解释为flag，noquota被当作了mount data。</p><h2 id="5-mount系统调用的实现（sys-mount）"><a href="#5-mount系统调用的实现（sys-mount）" class="headerlink" title="5.mount系统调用的实现（sys_mount）"></a>5.mount系统调用的实现（sys_mount）</h2><p>如果要研究mount的执行过程先要找到mount的发起位置，有些mount是内核发起的，由内核自主挂载。而绝大部分的mount都是用户通过mount系统调用发起的，我们就以后者为起点开始分析。<strong>mount系统调用</strong>（sys_mount）定义在fs&#x2F;namespace.c中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs\namespace.c</span><br><br>SYSCALL_DEFINE5(mount, <span class="hljs-type">char</span> __user *, dev_name, <span class="hljs-type">char</span> __user *, dir_name,<br>                <span class="hljs-type">char</span> __user *, type, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, flags, <span class="hljs-type">void</span> __user *, data)<br>&#123;<br>        <span class="hljs-type">int</span> ret;<br>        <span class="hljs-type">char</span> *kernel_type;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filename</span> *<span class="hljs-title">kernel_dir</span>;</span><br>        <span class="hljs-type">char</span> *kernel_dev;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data_page;<br> <br>        <span class="hljs-comment">/* 拷贝得到文件系统类型名 */</span><br>        ret = copy_mount_string(type, &amp;kernel_type);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">goto</span> out_type;<br> <br>        <span class="hljs-comment">/* 得到文件系统挂载点名 */</span><br>        kernel_dir = getname(dir_name);<br>        <span class="hljs-keyword">if</span> (IS_ERR(kernel_dir)) &#123;<br>                ret = PTR_ERR(kernel_dir);<br>                <span class="hljs-keyword">goto</span> out_dir;<br>        &#125;<br> <br>        <span class="hljs-comment">/* 拷贝得到文件系统所在的设备名 */</span><br>        ret = copy_mount_string(dev_name, &amp;kernel_dev);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">goto</span> out_dev;<br> <br>        <span class="hljs-comment">/* 拷贝得到文件系统定制的mount data */</span><br>        ret = copy_mount_options(data, &amp;data_page);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">goto</span> out_data;<br> <br>        <span class="hljs-comment">/* 到此mount所需要的fstype, dev_name, mountpoint, flags和data这几个参数都拷贝到内核空间了 */</span><br>        <span class="hljs-comment">/* 调用do_mount函数继续下面的操作 */</span><br>        ret = do_mount(kernel_dev, kernel_dir-&gt;name, kernel_type, flags,<br>                (<span class="hljs-type">void</span> *) data_page);<br> <br>        free_page(data_page);<br>out_data:<br>        kfree(kernel_dev);<br>out_dev:<br>        putname(kernel_dir);<br>out_dir:<br>        kfree(kernel_type);<br>out_type:<br>        <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-do-mount调用"><a href="#6-do-mount调用" class="headerlink" title="6.do_mount调用"></a>6.do_mount调用</h2><p>系统调用sys_mount后，会继续执行do_mount函数，该函数在VFS层。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">do_mount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *dev_name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dir_name,</span><br><span class="hljs-params">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type_page, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-type">void</span> *data_page)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">path</span> <span class="hljs-title">path</span>;</span><br>        <span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> mnt_flags = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">/* Discard magic */</span><br>        <span class="hljs-keyword">if</span> ((flags &amp; MS_MGC_MSK) == MS_MGC_VAL)<br>                flags &amp;= ~MS_MGC_MSK;<br>        <span class="hljs-comment">/* Basic sanity checks */</span><br>        <span class="hljs-keyword">if</span> (!dir_name || !*dir_name || !<span class="hljs-built_in">memchr</span>(dir_name, <span class="hljs-number">0</span>, PAGE_SIZE))<br>                <span class="hljs-keyword">return</span> -EINVAL;<br>        <span class="hljs-keyword">if</span> (data_page)<br>                ((<span class="hljs-type">char</span> *)data_page)[PAGE_SIZE - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 把mountpoint解释成path内核结构，这里是路径名解析的过程</span><br>        <span class="hljs-comment">// 调用do_path_lookup。关于路径名解析我们后面再说</span><br>        <span class="hljs-comment">/* ... and get the mountpoint */</span><br>        retval = kern_path(dir_name, LOOKUP_FOLLOW, &amp;path);<br>        <span class="hljs-keyword">if</span> (retval)<br>                <span class="hljs-keyword">return</span> retval;<br>        retval = security_sb_mount(dev_name, &amp;path,<br>                                   type_page, flags, data_page);<br>        <span class="hljs-keyword">if</span> (!retval &amp;&amp; !may_mount())<br>                retval = -EPERM;<br>        <span class="hljs-keyword">if</span> (retval)<br>                <span class="hljs-keyword">goto</span> dput_out;<br>        <span class="hljs-comment">// 从这里开始就是一系列的对flags的解析，把通用option提出来</span><br>        <span class="hljs-comment">// 并且找出我们要mount做哪种操作，如bind, remount, newmount等</span><br>        <span class="hljs-comment">/* Default to relatime unless overriden */</span><br>        <span class="hljs-keyword">if</span> (!(flags &amp; MS_NOATIME))<br>                mnt_flags |= MNT_RELATIME;<br>        <span class="hljs-comment">/* Separate the per-mountpoint flags */</span><br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NOSUID)<br>                mnt_flags |= MNT_NOSUID;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NODEV)<br>                mnt_flags |= MNT_NODEV;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NOEXEC)<br>                mnt_flags |= MNT_NOEXEC;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NOATIME)<br>                mnt_flags |= MNT_NOATIME;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NODIRATIME)<br>                mnt_flags |= MNT_NODIRATIME;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_STRICTATIME)<br>                mnt_flags &amp;= ~(MNT_RELATIME | MNT_NOATIME);<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_RDONLY)<br>                mnt_flags |= MNT_READONLY;<br>        <span class="hljs-comment">/* The default atime for remount is preservation */</span><br>        <span class="hljs-keyword">if</span> ((flags &amp; MS_REMOUNT) &amp;&amp;<br>            ((flags &amp; (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |<br>                       MS_STRICTATIME)) == <span class="hljs-number">0</span>)) &#123;<br>                mnt_flags &amp;= ~MNT_ATIME_MASK;<br>                mnt_flags |= path.mnt-&gt;mnt_flags &amp; MNT_ATIME_MASK;<br>        &#125;<br>        flags &amp;= ~(MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_ACTIVE | MS_BORN |<br>                   MS_NOATIME | MS_NODIRATIME | MS_RELATIME| MS_KERNMOUNT |<br>                   MS_STRICTATIME);<br>        <span class="hljs-comment">// 根据flags的指示，决定做哪种mount操作</span><br>        <span class="hljs-keyword">if</span> (flags &amp; MS_REMOUNT)<br>                retval = do_remount(&amp;path, flags &amp; ~MS_REMOUNT, mnt_flags,<br>                                    data_page);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flags &amp; MS_BIND)<br>                retval = do_loopback(&amp;path, dev_name, flags &amp; MS_REC);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flags &amp; (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))<br>                retval = do_change_type(&amp;path, flags);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flags &amp; MS_MOVE)<br>                retval = do_move_mount(&amp;path, dev_name);<br>        <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 我们这里以new mount为入手点，继续向下分析</span><br>                retval = do_new_mount(&amp;path, type_page, flags, mnt_flags,<br>                                      dev_name, data_page);<br>dput_out:<br>        path_put(&amp;path);<br>        <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上所述，我们得出do_mount主要干这么几个事：</p><ol><li><p>解析mountpoint路径名，把字符串路径名变成内核dentry或者说path结构</p></li><li><p>解析flags，把通用option分出来。</p></li><li><p>根据flags中指明mount操作的标志，决定做哪一种mount操作。</p></li><li><p>执行remount&#x2F;bind&#x2F;shared&#x2F;move&#x2F;new mount操作。</p></li></ol><p>到此mount就可能做5种mount操作（remount, bind, chang type, move和new mount）之一。我们以do_new_mount为例继续分析，do_new_mount属于最常见的情况，挂载一个新的文件系统。</p><h2 id="7-do-new-mount调用"><a href="#7-do-new-mount调用" class="headerlink" title="7.do_new_mount调用"></a>7.do_new_mount调用</h2><p>do_new_mount函数也在namespace.c里可以找到，它主要做三件事：</p><ol><li>根据fstype从全局文件系统类型(file_system_type)链表中找到对应的文件系统类型结构</li><li>用上一步得到的特定文件系统类型结构中的mount回调函数执行下面的挂载操作，最终构建一个mount结构体，其中包含vfsmount信息。</li><li>将得到的mount结构体加入全局文件系统树中</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_new_mount</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> path *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fstype, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">                        <span class="hljs-type">int</span> mnt_flags, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> *<span class="hljs-title">type</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span> *<span class="hljs-title">user_ns</span> =</span> current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vfsmount</span> *<span class="hljs-title">mnt</span>;</span><br>        <span class="hljs-type">int</span> err;<br> <br>        <span class="hljs-keyword">if</span> (!fstype)<br>                <span class="hljs-keyword">return</span> -EINVAL;<br> <br>        <span class="hljs-comment">// 根据fs类型名（如xfs）在全局文件系统类型链表上找到其对应的file_system_type结构</span><br>        type = get_fs_type(fstype);<br>        <span class="hljs-keyword">if</span> (!type)<br>                <span class="hljs-keyword">return</span> -ENODEV;<br> <br>        <span class="hljs-comment">// 调用此函数准备进入每个文件系统的个别处理函数，构建一个vfsmnt结构</span><br>        <span class="hljs-comment">// 注意这里以文件系统类型、挂载标记、设备名和挂载选项信息为参数，并没有mountpoint参数。这里只是想用type中的mount回调函数读取设备的superblock信息，填充mnt结构，然后把flag和data解析后填充到mnt结构中。</span><br>        mnt = vfs_kern_mount(type, flags, name, data);<br>        <span class="hljs-keyword">if</span> (!IS_ERR(mnt) &amp;&amp; (type-&gt;fs_flags &amp; FS_HAS_SUBTYPE) &amp;&amp;<br>            !mnt-&gt;mnt_sb-&gt;s_subtype)<br>                mnt = fs_set_subtype(mnt, fstype);<br> <br>        put_filesystem(type);<br>        <span class="hljs-keyword">if</span> (IS_ERR(mnt))<br>                <span class="hljs-keyword">return</span> PTR_ERR(mnt);<br> <br>        <span class="hljs-comment">// 准备将得到的mnt结构加入全局文件系统树</span><br>        <span class="hljs-comment">// 注意path变量，也就是mountpoint在这里</span><br>        err = do_add_mount(real_mount(mnt), path, mnt_flags);<br>        <span class="hljs-keyword">if</span> (err)<br>                mntput(mnt);<br>        <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="99-向驱动大哥学习，走进file-operations"><a href="#99-向驱动大哥学习，走进file-operations" class="headerlink" title="99.向驱动大哥学习，走进file_operations"></a>99.向驱动大哥学习，走进file_operations</h2><p>我们按照学习驱动的方式，学习整个文件系统的挂载。在学习驱动的时候，最关键的就是字符设备操作集<code>file_operations </code>，我们写驱动的时候会初始化每一个驱动对应的操作集，例如我们编写一个led驱动，我们常常写成下面的样子，每一个file_operation的操作，如open、write都在自己的驱动中指明对应的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">led_fops</span> =</span> &#123;<br>    .owner = THIS_MODULE,<br>    .open = led_open,<br>    .write = led_write,<br>    .release = led_release,<br>&#125;;<br></code></pre></td></tr></table></figure><p>那么文件系统也是通用的道理，也有文件系统自己的操作集<code>file_operations</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include\linux\fs.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-type">loff_t</span> (*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<br><span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br><span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br><span class="hljs-type">ssize_t</span> (*read_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br><span class="hljs-type">ssize_t</span> (*write_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br><span class="hljs-type">int</span> (*iterate) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);<br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *)</span>;<br><span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br><span class="hljs-type">int</span> (*mremap)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br><span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br><span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);<br><span class="hljs-type">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br><span class="hljs-type">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span> datasync);<br><span class="hljs-type">int</span> (*aio_fsync) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-type">int</span> datasync);<br><span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);<br><span class="hljs-type">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br><span class="hljs-type">ssize_t</span> (*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">int</span>);<br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<br><span class="hljs-type">int</span> (*check_flags)(<span class="hljs-type">int</span>);<br><span class="hljs-type">int</span> (*flock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br><span class="hljs-type">ssize_t</span> (*splice_write)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><span class="hljs-type">ssize_t</span> (*splice_read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><span class="hljs-type">int</span> (*setlease)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">long</span>, <span class="hljs-keyword">struct</span> file_lock **, <span class="hljs-type">void</span> **);<br><span class="hljs-type">long</span> (*fallocate)(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> mode, <span class="hljs-type">loff_t</span> offset,<br>  <span class="hljs-type">loff_t</span> len);<br><span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">struct</span> file *f);<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><br><span class="hljs-type">unsigned</span> (*mmap_capabilities)(<span class="hljs-keyword">struct</span> file *);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>对于一个具体的文件系统ext4、f2fs等，都会指明自己的file_operations，以f2fs为例</p><img src="/2023/03/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fmount%E8%BF%87%E7%A8%8B/image-20230309230859994.png" alt="image-20230309230859994" style="zoom: 67%;"><p>加入我们在用户态执行ioctl操作，那么对应的<code>f2fs_ioct</code>l就会执行。</p>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>懂得了Android I/O调优对你的应用帮助很大（上篇）</title>
    <link href="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/"/>
    <url>/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="懂得了Android-I-x2F-O调优对你的应用帮助很大（上篇）"><a href="#懂得了Android-I-x2F-O调优对你的应用帮助很大（上篇）" class="headerlink" title="懂得了Android I&#x2F;O调优对你的应用帮助很大（上篇）"></a>懂得了Android I&#x2F;O调优对你的应用帮助很大（上篇）</h1><blockquote><p>🍀转载自：<a href="https://www.cnblogs.com/mysweetAngleBaby/articles/16066846.html">https://www.cnblogs.com/mysweetAngleBaby/articles/16066846.html</a></p></blockquote><h2 id="1-I-x2F-O的基本知识"><a href="#1-I-x2F-O的基本知识" class="headerlink" title="1.I&#x2F;O的基本知识"></a>1.I&#x2F;O的基本知识</h2><p>在工作中，我发现很多工程师对I&#x2F;O的认识其实比较模糊，认为I&#x2F;O就是应用程序执行read()、write()这样的一些操作，并不清楚这些操作背后的整个流程是怎样的。</p><img src="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/26731569-b807a907e68b8792.png" style="zoom: 67%;"><p>我画了一张简图，你可以看到整个文件I&#x2F;O操作由应用程序、文件系统和磁盘共同完成。首先应用程序将I&#x2F;O命令发送给文件系统，然后文件系统会在合适的时机把I&#x2F;O操作发给磁盘。<br>这就好比CPU、内存、磁盘三个小伙伴一起完成接力跑，最终跑完的时间很大程度上取决于最慢的小伙伴。我们知道，CPU和内存相比磁盘是高速设备，整个流程的瓶颈在于磁盘I&#x2F;O的性能。所以很多时候，文件系统性能比磁盘性能更加重要，为了降低磁盘对应用程序的影响，文件系统需要通过各种各样的手段进行优化。那么接下来，我们首先来看文件系统。</p><h3 id="1-1-文件系统"><a href="#1-1-文件系统" class="headerlink" title="1.1 文件系统"></a>1.1 文件系统</h3><p>文件系统，简单来说就是存储和组织数据的方式。比如在iOS 10.3系统以后，苹果使用APFS（Apple File System）替代之前旧的文件系统HFS+。对于Android来说，现在普遍使用的是Linux常用的ext4文件系统。</p><p>关于文件系统还需要多说两句，华为在EMUI 5.0以后就使用F2FS取代ext4，Google也在最新的旗舰手机Pixel 3使用了F2FS文件系统。Flash-Friendly File System是三星是专门为NAND闪存芯片开发的文件系统，也做了大量针对闪存的优化。根据华为的测试数据，F2FS文件系统在小文件的随机读写方面比ext4更快，例如随机写可以优化60%，不足之处在于可靠性方面出现过一些问题。我想说的是，随着Google、华为的投入和规模化使用，F2FS系统应该是未来Android的主流文件系统。</p><p>还是回到文件系统的I&#x2F;O。应用程序调用read()方法，系统会通过中断从用户空间进入内核处理流程，然后经过VFS（Virtual File System，虚拟文件系统）、具体文件系统、页缓存Page Cache。下面是Linux一个通用的I&#x2F;O架构模型。</p><img src="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/26731569-a7586fb52f51be3a.png" style="zoom: 67%;"><ul><li>虚拟文件系统（VFS）。它主要用于实现屏蔽具体的文件系统，为应用程序的操作提供一个统一的接口。这样保证就算厂商把文件系统从ext4切换到F2FS，应用程序也不用做任何修改。</li><li>文件系统（File System）。ext4、F2FS都是具体文件系统实现，文件元数据如何组织、目录和索引结构如何设计、怎么分配和清理数据，这些都是设计一个文件系统必须要考虑的。<strong>每个文件系统都有适合自己的应用场景，我们不能说F2FS就一定比ext4要好。</strong>F2FS在连续读取大文件上并没有优势，而且会占用更大的空间。只是对一般应用程序来说，随机I&#x2F;O会更加频繁，特别是在启动的场景。你可以在&#x2F;proc&#x2F;filesystems看到系统可以识别的所有文件系统的列表。</li><li>页缓存（Page Cache）。在启动优化中我已经讲过Page Cache这个概念了，在读文件的时候会，先看它是不是已经在Page Cache中，如果命中就不会去读取磁盘。在Linux 2.4.10之前还有一个单独的Buffer Cache，后来它也合并到Page Cache中的Buffer Page了。</li></ul><p>具体来说，Page Cache就像是我们经常使用的数据缓存，是文件系统对数据的缓存，目的是提升内存命中率。Buffer Cache就像我们经常使用的BufferInputStream，是磁盘对数据的缓存，目的是合并部分文件系统的I&#x2F;O请求、降低磁盘I&#x2F;O的次数。需要注意的是，它们既会用在读请求中，也会用到写请求中。<br>通过&#x2F;proc&#x2F;meminfo文件可以查看缓存的内存占用情况，当手机内存不足的时候，系统会回收它们的内存，这样整体I&#x2F;O的性能就会有所降低。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">MemTotal:    2866492 kB<br>MemFree:      72192 kB<br>Buffers:      62708 kB      // Buffer Cache<br>Cached:      652904 kB      // Page Cache<br></code></pre></td></tr></table></figure><h3 id="1-2-磁盘"><a href="#1-2-磁盘" class="headerlink" title="1.2 磁盘"></a>1.2 磁盘</h3><p>磁盘指的是系统的存储设备，就像小时候我们常听的CD或者电脑使用的机械硬盘，当然还有现在比较流行的SSD固态硬盘。<br>正如我上面所说，如果发现应用程序要read()的数据没有在页缓存中，这时候就需要真正向磁盘发起I&#x2F;O请求。这个过程要先经过内核的通用块层、I&#x2F;O调度层、设备驱动层，最后才会交给具体的硬件设备处理。</p><img src="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/26731569-5a8d09f33aacf7fd.png" style="zoom: 67%;"><ul><li>通用块层。系统中能够随机访问固定大小数据块（block）的设备称为块设备，CD、硬盘和SSD这些都属于块设备。通用块层主要作用是接收上层发出的磁盘请求，并最终发出I&#x2F;O请求。它跟VFS的作用类似，让上层不需要关心底层硬件设备的具体实现。</li><li>I&#x2F;O调度层。磁盘I&#x2F;O那么慢，为了降低真正的磁盘I&#x2F;O，我们不能接收到磁盘请求就立刻交给驱动层处理。所以我们增加了I&#x2F;O调度层，它会根据设置的调度算法对请求合并和排序。这里比较关键的参数有两个，一个是队列长度，一个是具体的调度算法。我们可以通过下面的文件可以查看对应块设备的队列长度和使用的调度算法。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">/sys/block/[disk]/queue/nr_requests      // 队列长度，一般是 128。<br>/sys/block/[disk]/queue/scheduler        // 调度算法<br></code></pre></td></tr></table></figure><ul><li>块设备驱动层。块设备驱动层根据具体的物理设备，选择对应的驱动程序通过操控硬件设备完成最终的I&#x2F;O请求。例如光盘是靠激光在表面烧录存储、闪存是靠电子擦写存储数据</li></ul><h2 id="2-I-x2F-O的性能评估"><a href="#2-I-x2F-O的性能评估" class="headerlink" title="2.I&#x2F;O的性能评估"></a>2.I&#x2F;O的性能评估</h2><p>正如下图你所看到的，整个I&#x2F;O的流程涉及的链路非常长。我们在应用程序中通过打点，发现一个文件读取需要300ms。但是下面每一层可能都有自己的策略和调度算法，因此很难真正的得到每一层的耗时。</p><img src="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/26731569-ee5db940a613d188.png" style="zoom: 67%;"><p>在前面的启动优化内容中，我讲过Facebook和支付宝采用编译单独ROM的方法来评估I&#x2F;O性能。这是一个比较复杂但是有效的做法，我们可以通过定制源码，选择打开感兴趣的日志来追踪I&#x2F;O的性能。</p><ol><li>I&#x2F;O性能指标<br>I&#x2F;O性能评估中最为核心的指标是吞吐量和IOPS。今天文章开头所说的，“连续读取不超过550MB&#x2F;s，连续写入不超过520MB&#x2F;s”，就指的是I&#x2F;O吞吐量。<br>还有一个比较重要的指标是IOPS，它指的是每秒可以读写的次数。对于随机读写频繁的应用，例如大量的小文件存储，IOPS是关键的衡量指标。</li><li>I&#x2F;O测量<br>如果不采用定制源码的方式，还有哪些方法可以用来测量I&#x2F;O的性能呢？\</li></ol><p><strong>第一种方法：使用proc。</strong><br>总的来说，I&#x2F;O性能会跟很多因素有关，是读还是写、是否是连续、I&#x2F;O大小等。另外一个对I&#x2F;O性能影响比较大的因素是负载，I&#x2F;O性能会随着负载的增加而降低，我们可以通过I&#x2F;O的等待时间和次数来衡量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">proc/self/schedstat:<br>  se.statistics.iowait_count：IO 等待的次数<br>  se.statistics.iowait_sum：  IO 等待的时间<br></code></pre></td></tr></table></figure><p>如果是root的机器，我们可以开启内核的I&#x2F;O监控，将所有block读写dump到日志文件中，这样可以通过dmesg命令来查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 1 &amp;gt; /proc/sys/vm/block_dump<br>dmesg -c grep pid<br>.sample.io.test(7540): READ block 29262592 on dm-1 (256 sectors)<br>.sample.io.test(7540): READ block 29262848 on dm-1 (256 sectors)<br></code></pre></td></tr></table></figure><p><strong>第二种方法：使用strace。</strong><br>Linux提供了iostat、iotop等一些相关的命令，不过大部分Anroid设备都不支持。我们可以通过 strace来跟踪I&#x2F;O相关的系统调用次数和耗时。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">strace -ttT -f -p [pid]<br>read(53, &amp;quot;*****************&amp;quot;\.\.\., 1024) = 1024       &amp;lt;0.000447&amp;gt;<br>read(53, &amp;quot;*****************&amp;quot;\.\.\., 1024) = 1024       &amp;lt;0.000084&amp;gt;<br>read(53, &amp;quot;*****************&amp;quot;\.\.\., 1024) = 1024       &amp;lt;0.000059&amp;gt;<br></code></pre></td></tr></table></figure><p>通过上面的日志，你可以看到应用程序在读取文件操作符为53的文件，每次读取1024个字节。第一次读取花了447us，后面两次都使用了100us不到。这跟启动优化提到的“数据重排”是一个原因，文件系统每次读取以block为单位，而block的大小一般是4KB，后面两次的读取是从页缓存得到。<br>我们也可以通过strace统计一段时间内所有系统调用的耗时概况。不过strace本身也会消耗不少资源，对执行时间也会产生影响。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">strace -c -f -p [pid]<br><span class="hljs-meta prompt_">% </span><span class="language-bash">time     seconds  usecs/call     calls    errors  syscall</span><br>------ ----------- ----------- --------- --------- ————————<br> 97.56    0.041002          21      1987             read<br>  1.44    0.000605          55        11             write<br></code></pre></td></tr></table></figure><p>从上面的信息你可以看到，读占了97.56%的时间，一共调用了1987次，耗时0.04s，平均每次系统调用21us。同样的道理，我们也可以计算应用程序某个任务I&#x2F;O耗时的百分比。假设一个任务执行了10s，I&#x2F;O花了9s，那么I&#x2F;O耗时百分比就是90%。这种情况下，I&#x2F;O就是我们任务很大的瓶颈，需要去做进一步的优化。</p><p><strong>第三种方法：使用vmstat。</strong><br>vmstat的各个字段说明可以参考《vmstat监视内存使用情况》，其中Memory中的buff和cache，I&#x2F;O中的bi和bo，System中的cs，以及CPU中的sy和wa，这些字段的数值都与I&#x2F;O行为有关。</p><p>我们可以配合dd命令来配合测试，观察vmstat的输出数据变化。不过需要注意的是Android里面的dd命令似乎并不支持conv和flag参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">//清除Buffer和Cache内存缓存<br>echo 3 &amp;gt; /proc/sys/vm/drop_caches<br>//每隔1秒输出1组vmstat数据<br>vmstat 1<br>//测试写入速度，写入文件/data/data/test，buffer大小为4K，次数为1000次<br>dd if=/dev/zero of=/data/data/test bs=4k count=1000<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言字符串处理函数</title>
    <link href="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"/>
    <url>/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言字符串处理函数"><a href="#C语言字符串处理函数" class="headerlink" title="C语言字符串处理函数"></a>C语言字符串处理函数</h1><p>写代码时对字符和字符串的处理很频繁，但是C语言中本身没有字符串类型，字符串通常存储在<strong>常量字符串（const char* str）</strong>中或者<strong>字符数组（char str[] &#x3D; “amx”）</strong>中。<strong>常量字符串</strong>适用于那些对它不做修改的字符串函数。</p><p>首先，我们要确定在C语言中，字符串都是以\0结尾的，只不过我们创建的时候不用自己添加，是编译的时候由编译器添加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-keyword">if</span> (str[<span class="hljs-number">3</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;末尾是\\0\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/截屏2022-05-21 16.32.40.png"><h2 id="1-字符串的长度"><a href="#1-字符串的长度" class="headerlink" title="1.字符串的长度"></a>1.字符串的长度</h2><h3 id="1-1-strlen"><a href="#1-1-strlen" class="headerlink" title="1.1 strlen"></a>1.1 strlen</h3><p>作用：求字符串的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strlen</span>(str)); <span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-长度不受限制的字符串函数"><a href="#2-长度不受限制的字符串函数" class="headerlink" title="2.长度不受限制的字符串函数"></a>2.长度不受限制的字符串函数</h2><h3 id="2-1-strcpy"><a href="#2-1-strcpy" class="headerlink" title="2.1  strcpy"></a>2.1  strcpy</h3><p>作用：复制字符串</p><p>将<strong>源</strong>所指向的 C 字符串复制到<strong>目标</strong>所指向的数组中，包括终止空字符（并在该点停止）。</p><blockquote><p>为避免溢出，目标所指向的数组的大小应足够长，以包含与源相同的 C 字符串（包括终止空字符），并且不应在内存中与 source 重叠。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">20</span>];<br>    <br>    <span class="hljs-built_in">strcpy</span>(str2,str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str2);  <span class="hljs-comment">// amx</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-strcat"><a href="#2-2-strcat" class="headerlink" title="2.2 strcat"></a>2.2 strcat</h3><p>作用：连接字符串</p><p>将‎‎<strong>源</strong>‎‎字符串的副本追加到‎‎<strong>目标</strong>‎‎字符串。‎<em>‎</em>目标‎‎中的终止空字符被‎<em>‎</em>源<em>‎</em>‎的第一个字符覆盖，并且在‎<em>‎</em>目标<em>‎</em>‎中由两者串联形成的新字符串的末尾包含一个空字符。‎</p><blockquote><p>注：目的地‎‎和‎‎来源‎‎不得重叠。<strong>自己不能给自己追加。</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;hello &quot;</span>;<br>    <br>    <span class="hljs-built_in">strcat</span>(str2,str1);  <span class="hljs-comment">// 将str1添加到str2后面去</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str2);  <span class="hljs-comment">// hello amx</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-strcmp"><a href="#2-3-strcmp" class="headerlink" title="2.3 strcmp"></a>2.3 strcmp</h3><p>作用：比较两个字符串</p><img src="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/d04949f8-1e4a-482b-be1c-b1de518ec939.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;hello &quot;</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strcmp</span>(str1,str2));  <span class="hljs-comment">// -7</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-长度受限制的字符串函数"><a href="#3-长度受限制的字符串函数" class="headerlink" title="3.长度受限制的字符串函数"></a>3.长度受限制的字符串函数</h2><h3 id="3-1-strncpy"><a href="#3-1-strncpy" class="headerlink" title="3.1 strncpy"></a>3.1 strncpy</h3><p>作用：<strong>Copy characters from string</strong>从字符串中复制字符</p><p>将<strong>源</strong>的前<strong>num</strong>字符复制到<strong>目标</strong>。如果在复制<strong>num</strong>个字符之前找到<strong>源</strong>C 字符串（由空字符指示）的末尾，则<strong>目标</strong>将填充零，直到向其写入总共<strong>num</strong>个字符。</p><blockquote><p>如果源的长度超过 num，则不会在目标末尾隐式追加空字符。</p><p>因此，在这种情况下，<strong>目标</strong>不应被视为以空值结尾的 C 字符串（这样读取它会溢出）。</p><p>目的地和来源不得重叠（重叠时，请参阅 memmove 以了解更安全的替代方案）。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">20</span>];<br>    <br>    <span class="hljs-built_in">strncpy</span>(str2,str1,<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str2);  <span class="hljs-comment">// hello</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-strncat"><a href="#3-2-strncat" class="headerlink" title="3.2 strncat"></a>3.2 strncat</h3><p>作用：将<strong>源</strong>的前<strong>num</strong>个字符追加到<strong>目标</strong>，加上一个终止空字符。</p><blockquote><p>如果源中 C 字符串的长度小于<strong>num</strong>，则仅复制直到终止空字符的内容。</p><p>如果source拷贝进去之后desination还有原本存在的字符会主动追加一个’\0’。</p><p>如果追加长度num大于strlen(source),则只追加source原本的字符串和一个’\0’</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;HI!&quot;</span>;<br>    <br>    <span class="hljs-built_in">strncat</span>(str2,str1,<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str2);  <span class="hljs-comment">// HI!hello</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-strncmp"><a href="#3-3-strncmp" class="headerlink" title="3.3 strncmp"></a>3.3 strncmp</h3><p>作用：将 C 字符串<strong>str1</strong>的<strong>最多 num</strong>个字符与 C 字符串<strong>str2</strong>的字符数进行比较。</p><blockquote><p>此函数开始比较每个字符串的第一个字符。如果它们彼此相等，则继续向后比较，直到字符不同，直到达到终止空字符，或者直到两个字符串中的<strong>num</strong>字符匹配，以先发生的情况为准。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;hellaaaa&quot;</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strncmp</span>(str1,str2,<span class="hljs-number">4</span>));  <span class="hljs-comment">// 0</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strncmp</span>(str1,str2,<span class="hljs-number">5</span>));  <span class="hljs-comment">// 14</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-安全的字符串函数"><a href="#4-安全的字符串函数" class="headerlink" title="4.安全的字符串函数"></a>4.安全的字符串函数</h2><blockquote><p>为了减轻程序员添加结束符和处理字符串截断的负担，可以使用strlcpy和strlcat函数。</p><p>🍭文档：<a href="https://gratisoft.us/todd/papers/strlcpy.html">https://gratisoft.us/todd/papers/strlcpy.html</a></p></blockquote><h3 id="4-1-strlcpy"><a href="#4-1-strlcpy" class="headerlink" title="4.1 strlcpy"></a>4.1 strlcpy</h3><p>作用：</p><p><strong>strlcpy源代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">strlcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">size_t</span> dsize)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *osrc = src;<br>    <span class="hljs-type">size_t</span> nleft = dsize;<br>    <span class="hljs-comment">/* Copy as many bytes as will fit. */</span><br>    <span class="hljs-keyword">if</span> (nleft != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (--nleft != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((*dst++ = *src++) == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* Not enough room in dst, add NUL and traverse rest of src. */</span><br>    <span class="hljs-keyword">if</span> (nleft == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (dsize != <span class="hljs-number">0</span>)<br>            *dst = <span class="hljs-string">&#x27;\0&#x27;</span>;        <span class="hljs-comment">/* NUL-terminate dst */</span><br>        <span class="hljs-keyword">while</span> (*src++);<br>    &#125;<br>    <span class="hljs-keyword">return</span>(src - osrc - <span class="hljs-number">1</span>);    <span class="hljs-comment">/* count does not include NUL */</span><br>&#125;<br></code></pre></td></tr></table></figure><p> <code>strlcpy</code>将 <code>src</code> 按字符拷贝到 <code>dst</code>中，最多拷贝<code>dszie-1</code>个字符，拷贝结束后在 <code>dst</code> 末尾添加 <code>0x00</code>结束符，返回值是 <code>src</code>的长度。一般将 <code>dsize</code>置为<code>dst</code>的大小。相较于strncpy，<strong>strlcpy有两个优点</strong>：</p><ul><li>当<code>strlen(src)</code>大于等于<code>dsize</code>时自动在<code>dst</code>末尾添加结束符；</li><li>返回值大于等于<code>dsize</code>时确定发生字符串截断。以上两点帮助程序员进行判断，方便后续处理。</li></ul><h3 id="4-2-strlcat"><a href="#4-2-strlcat" class="headerlink" title="4.2 strlcat"></a>4.2 strlcat</h3><p>作用：</p><p><strong>strlcat源代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">strlcat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">size_t</span> dsize)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *odst = dst;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *osrc = src;<br>    <span class="hljs-type">size_t</span> n = dsize;<br>    <span class="hljs-type">size_t</span> dlen;<br>    <span class="hljs-comment">/* Find the end of dst and adjust bytes left but don&#x27;t go past end. */</span><br>    <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span> &amp;&amp; *dst != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        dst++;<br>    dlen = dst - odst;<br>    n = dsize - dlen;<br><br>    <span class="hljs-keyword">if</span> (n-- == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>(dlen + <span class="hljs-built_in">strlen</span>(src));<br>    <span class="hljs-keyword">while</span> (*src != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n != <span class="hljs-number">0</span>) &#123;<br>            *dst++ = *src;<br>            n--;<br>        &#125;<br>        src++;<br>    &#125;<br>    *dst = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span>(dlen + (src - osrc));    <span class="hljs-comment">/* count does not include NUL */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>dlen</code>是 <code>dst</code>中原有字符串的长度（不包含<code>0x00</code>结束符）；<code>dsize</code>是 <code>dst</code>缓冲区的总大小（包含结束符）。 它首先找到 <code>dst</code>中源字符串的结束符，然后计算剩余空间大小，如果为0，则返回。如果有剩余空间，就依次往其中添加<code>src</code>字符串，直至<code>dst</code>缓冲区填满，返回值是<code>dst</code>原字符串长度与<code>src</code>长度之和。相比较strncat，<strong>strlcat的优点是</strong>：</p><ul><li>第三个参数大小直接带入<code>dst</code>的大小，不需要计算剩余空间；</li><li>返回值可以用来判断是否发生字符串截断。</li></ul><h2 id="5-字符串查找"><a href="#5-字符串查找" class="headerlink" title="5.字符串查找"></a>5.字符串查找</h2><h3 id="5-1-strstr"><a href="#5-1-strstr" class="headerlink" title="5.1 strstr"></a>5.1 strstr</h3><p>作用：返回一个指向<strong>str1</strong>中第一次出现的<strong>str2</strong>的指针，如果<strong>str2</strong> 不是 <strong>str1</strong>的一部分，则返回空指针</p><blockquote><p>匹配过程不包括终止空字符，但碰到它就此停止。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] =<span class="hljs-string">&quot;This is a simple string&quot;</span>;  <br>    <span class="hljs-type">char</span>* pch;<br>    pch = <span class="hljs-built_in">strstr</span>(str,<span class="hljs-string">&quot;is&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p&quot;</span>,*pch);  <span class="hljs-comment">// 0X69</span><br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-strtok"><a href="#5-2-strtok" class="headerlink" title="5.2 strtok"></a>5.2 strtok</h3><p>作用：将字符串拆分为标记</p><p>对该函数的一系列调用将str拆分为标记，这些标记是由分隔符中的任何字符分隔的连续字符序列。</p><h2 id="6-错误信息报告"><a href="#6-错误信息报告" class="headerlink" title="6.错误信息报告"></a>6.错误信息报告</h2><h3 id="6-1-strerror"><a href="#6-1-strerror" class="headerlink" title="6.1 strerror"></a>6.1 strerror</h3><p>作用：<strong>string</strong>获取指向错误消息字符串的指针</p><p>错误码是程序员知道的，但是要转化为用户能看懂的错误信息，就需要使用函数将其转化为错误信息。</p><p>解释<strong>errnum</strong>的值，生成一个字符串，其中包含一条描述错误条件的消息，就好像被库的函数设置为<strong>errno</strong>一样。</p><blockquote><p>errno在头文件&lt;errno.h&gt;中</p><p>errno是一个全局的错误码变量</p><p>当C语言的库函数在执行过程中，发生错误，就会把对应的错误码，赋值到errno中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE * pFile;<br>    <span class="hljs-comment">//打开文件</span><br>    pFile = fopen (<span class="hljs-string">&quot;unexist.ent&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error opening file unexist.ent: %s\n&quot;</span>,strerror(errno));<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Win opening file!&quot;</span>);<br>    &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/4b271827-30e6-493f-a1b7-59db778d01d7.png"><h2 id="7-字符分类函数"><a href="#7-字符分类函数" class="headerlink" title="7.字符分类函数"></a>7.字符分类函数</h2><p>函数使用需要的头文件<code>#include &lt;ctype.h&gt;</code></p><img src="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/df04e811-541d-4e15-9bfe-3525a4827235.png"><p><strong>字符转换</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">tolower</span>(c);<span class="hljs-comment">//转小写字母</span><br><span class="hljs-built_in">toupper</span>(c);<span class="hljs-comment">//转大写字母</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;I Am A Good Student&quot;</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(str[i])&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isupper</span>(str[i]))&#123;<br>            str[i] = <span class="hljs-built_in">tolower</span>(str[i]);<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str);  <span class="hljs-comment">// i am a good student</span><br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Binder系统学习笔记</title>
    <link href="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Binder系统学习笔记"><a href="#Binder系统学习笔记" class="headerlink" title="Binder系统学习笔记"></a>Binder系统学习笔记</h1><h2 id="1-Binder系统的两大核心"><a href="#1-Binder系统的两大核心" class="headerlink" title="1.Binder系统的两大核心"></a>1.Binder系统的两大核心</h2><h3 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h3><p>A进程想要把数据传递给B进程，这就涉及到了<strong>IPC</strong>（Inter Process Communication 跨进程通信），如下图所示：</p><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230305230100824.png" alt="image-20230305230100824" style="zoom:80%;"><p>例如A进程想要通过<code>led_open</code> 或者 <code>led_ctl</code> 打开led，但是当前A进程没有权限，那么会通过RPC进程通信：</p><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230305230747468.png" alt="image-20230305230747468" style="zoom:80%;"><p>从这个图来看，从底下来看仿佛是A进程调用了一个本地的方法led_open&#x2F;led_ctl，然后把数据发给B，由B进程来操作硬件！【整个过程就是RPC】</p><blockquote><p><strong>RPC</strong>:(Reomote Procedure Call 远程过程调用) ：客户端将调用一个本地方法，而这个本地方法则是负责透明的与远程服务端进行过程间通信。这个本地方法会将相关参数顺序打包到一个消息中，然后把这个消息发送给服务端提供的方法，服务端的方法会从消息中解出序列化发出来的参数，然后执行，最后仍以同样的方式将方法的返回值发送给客户端。</p></blockquote><h3 id="1-2-binder系统中的IPC和RPC"><a href="#1-2-binder系统中的IPC和RPC" class="headerlink" title="1.2 binder系统中的IPC和RPC"></a>1.2 binder系统中的IPC和RPC</h3><p>binder系统中IPC需要具备下面三个要素：</p><ul><li><strong>源</strong>：在上面的例子中，源就是进程A</li><li><strong>目的</strong>：1）B 向 servicemanager 注册led服务；2）A 向 servicemanager 查询led服务，得到一个handle</li><li><strong>数据</strong>：就是一个char buf，用来存放通信的数据</li></ul><p><strong>实际的RPC过程中我们需要思考下面的问题</strong>：</p><ol><li>A进程需要调用B进程的什么函数</li><li>A进程需要传递什么参数给B进程</li><li>A进程会得到B进程的什么返回值</li></ol><blockquote><p>第2步A进程通过IPC将buf传输数据给B；</p><p>第3步同样B进程处理完以后通过IPC将数据返回给A</p></blockquote><h2 id="2-Binder机制分析"><a href="#2-Binder机制分析" class="headerlink" title="2 Binder机制分析"></a>2 Binder机制分析</h2><h3 id="2-1-servicemanager的作用"><a href="#2-1-servicemanager的作用" class="headerlink" title="2.1 servicemanager的作用"></a>2.1 servicemanager的作用</h3><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d12a5c80-9140-4483-bbf4-3ac05cd8a5f9.png" style="zoom: 67%;"><p>代码路径：frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">bs</span>;</span><br><br>    bs = binder_open(<span class="hljs-number">128</span>*<span class="hljs-number">1024</span>);  <span class="hljs-comment">// 打开binder驱动【bs是描述binder驱动的结构体】</span><br>    <span class="hljs-keyword">if</span> (!bs) &#123;<br>        ALOGE(<span class="hljs-string">&quot;failed to open binder driver\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 告诉binder驱动我就是servicemanager</span><br>    <span class="hljs-keyword">if</span> (binder_become_context_manager(bs)) &#123;<br>        ALOGE(<span class="hljs-string">&quot;cannot become context manager (%s)\n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    svcmgr_handle = BINDER_SERVICE_MANAGER;<br>    binder_loop(bs, svcmgr_handler);  <span class="hljs-comment">// 循环监听binder驱动，完成相应服务的函数调用</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个疑惑：svcmgr_handle是什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">svcmgr_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_transaction_data *txn,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_io *msg,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_io *reply)</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">switch</span>(txn-&gt;code) &#123;<br>    <span class="hljs-keyword">case</span> SVC_MGR_GET_SERVICE:<br>    <span class="hljs-keyword">case</span> SVC_MGR_CHECK_SERVICE:<br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">case</span> SVC_MGR_ADD_SERVICE:<br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">case</span> SVC_MGR_LIST_SERVICES: &#123;<br>       <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    bio_put_uint32(reply, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到svcmgr_handler实际上是一个函数【这个函数里面会根据传进来的txn结构体中的code来决定，到底是去注册服务还是调用服务】</p><ul><li>如果是<code>SVC_MGR_ADD_SERVICE</code>，就是注册服务</li><li>如果是<code>SVC_MGR_CHECK_SERVICE</code>，就是检查服务是否存在</li><li>如果是<code>SVC_MGR_GET_SERVICE</code>，就是获取服务</li></ul><blockquote><p>这里正好对应上了开头思维导图上的最后一项servicemanager的作用</p></blockquote><h3 id="1-3-2-server端作用"><a href="#1-3-2-server端作用" class="headerlink" title="1.3.2 server端作用"></a>1.3.2 server端作用</h3><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1a4196fb-da3b-4125-99f4-a1a9516218fd.png" style="zoom: 50%;"><p>我们先看一下注册服务的流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">svcmgr_publish</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs, <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *ptr)</span><br>&#123;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);<br>    bio_put_string16_x(&amp;msg, name);<br>    bio_put_obj(&amp;msg, ptr);<br><br>    <span class="hljs-keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    status = bio_get_uint32(&amp;reply);<br><br>    binder_done(bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端注册服务时会调用<code>svcmgr_publish</code>函数，这个函数里面最主要的是去调用<code>binder_call</code>函数</p><p><strong>binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE)</strong></p><ul><li>bs：描述binder驱动的结构体</li><li>msg：表示要注册服务的相关信息的binder_io结构体</li><li>reply：表示servicemanager回复的数据</li><li>target：注册时target传的是BINDER_SERVICE_MANAGER，该值表示的就是servicemanager</li><li>SVC_MGR_ADD_SERVICE：表示调用目标的函数，该函数的CODE值为SVC_MGR_ADD_SERVICE【在注册时相当于调用servicemanager的addservice服务】</li></ul><h3 id="1-3-3-client端作用"><a href="#1-3-3-client端作用" class="headerlink" title="1.3.3 client端作用"></a>1.3.3 client端作用</h3><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f955b7ac-25ac-4cd8-82b1-af135a447d3b.png" style="zoom: 50%;"><p>client端首先会去获取服务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">svcmgr_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs, <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);<br>    bio_put_string16_x(&amp;msg, name);<br><br>    <span class="hljs-keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_CHECK_SERVICE))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    handle = bio_get_ref(&amp;reply);<br><br>    <span class="hljs-keyword">if</span> (handle)<br>        binder_acquire(bs, handle);<br><br>    binder_done(bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> handle;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里同样也会去调用binder_call函数</p><p><strong>binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE)</strong></p><ul><li>bs：描述binder驱动的结构体</li><li>msg：表示即将查询服务的相关信息的binder_io结构体</li><li>reply：表示servicemanager回复的数据，数据里面会包含刚刚想要查询服务的进程</li><li>target：注册时target传的是BINDER_SERVICE_MANAGER，该值表示的就是servicemanager</li><li>SVC_MGR_CHECK_SERVICE：表示调用目标的函数，该函数的CODE值为SVC_MGR_CHECK_SERVICE【在注册时相当于调用servicemanager的getservice服务】</li></ul><h3 id="1-3-4-理解binder-call函数"><a href="#1-3-4-理解binder-call函数" class="headerlink" title="1.3.4 理解binder_call函数"></a>1.3.4 理解binder_call函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">binder_call</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs,</span><br><span class="hljs-params">                <span class="hljs-keyword">struct</span> binder_io *msg, <span class="hljs-keyword">struct</span> binder_io *reply,</span><br><span class="hljs-params">                <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">uint32_t</span> code)</span><br>&#123;<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_write_read</span> <span class="hljs-title">bwr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-type">uint32_t</span> cmd;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_transaction_data</span> <span class="hljs-title">txn</span>;</span><br>    &#125; __attribute__((packed)) writebuf;<br>    <span class="hljs-type">unsigned</span> readbuf[<span class="hljs-number">32</span>];<br><br>    <span class="hljs-keyword">if</span> (msg-&gt;flags &amp; BIO_F_OVERFLOW) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;binder: txn buffer overflow\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> fail;<br>    &#125;<br><br>    writebuf.cmd = BC_TRANSACTION;<br>    writebuf.txn.target.handle = target;<br>    writebuf.txn.code = code;<br>    writebuf.txn.flags = <span class="hljs-number">0</span>;<br>    writebuf.txn.data_size = msg-&gt;data - msg-&gt;data0;<br>    writebuf.txn.offsets_size = ((<span class="hljs-type">char</span>*) msg-&gt;offs) - ((<span class="hljs-type">char</span>*) msg-&gt;offs0);<br>    writebuf.txn.data.ptr.buffer = (<span class="hljs-type">uintptr_t</span>)msg-&gt;data0;<br>    writebuf.txn.data.ptr.offsets = (<span class="hljs-type">uintptr_t</span>)msg-&gt;offs0;<br><br>    bwr.write_size = <span class="hljs-keyword">sizeof</span>(writebuf);<br>    bwr.write_consumed = <span class="hljs-number">0</span>;<br>    bwr.write_buffer = (<span class="hljs-type">uintptr_t</span>) &amp;writebuf;<br><br>    hexdump(msg-&gt;data0, msg-&gt;data - msg-&gt;data0);<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        bwr.read_size = <span class="hljs-keyword">sizeof</span>(readbuf);<br>        bwr.read_consumed = <span class="hljs-number">0</span>;<br>        bwr.read_buffer = (<span class="hljs-type">uintptr_t</span>) readbuf;<br><br>        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);<br><br>        <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;binder: ioctl failed (%s)\n&quot;</span>, strerror(errno));<br>            <span class="hljs-keyword">goto</span> fail;<br>        &#125;<br><br>        res = binder_parse(bs, reply, (<span class="hljs-type">uintptr_t</span>) readbuf, bwr.read_consumed, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> fail;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>binder_call就是rpc中的远程调用函数</strong></p><p>在注册服务，获取服务，调用服务中的接口函数都是使用了binder_call函数，我们来分析一下binder_call函数具体在干嘛：</p><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3bdaac93-c274-45df-b04b-2a106eb4a42c.png" style="zoom: 67%;"><p><strong>binder_call内部实现：</strong></p><ol><li>构造参数msg，该值是一个binder_io类型的数据</li><li>将binder_io数据转化为<code>binder_write_read</code>类型的数据，因为binder驱动的ioctl中传递的是<code>binder_write_read</code>类型的数据</li></ol><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9b6e2287-0653-4646-8533-7cf9bdaf8b79.png" style="zoom: 67%;"><ol start="3"><li>客户端会调用ioctl发送数据</li></ol><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4f6deea3-edd7-44e5-9d8a-01d697da89d2.png" style="zoom: 67%;"><ol start="4"><li>服务端会调用ioctl接收数据</li></ol><h2 id="3-C程序实现Hello服务"><a href="#3-C程序实现Hello服务" class="headerlink" title="3.C程序实现Hello服务"></a>3.C程序实现Hello服务</h2><h3 id="3-1-server端和client端编写思路"><a href="#3-1-server端和client端编写思路" class="headerlink" title="3.1 server端和client端编写思路"></a>3.1 server端和client端编写思路</h3><p><strong>client端：</strong></p><ul><li>打开驱动，binder_open</li><li>获取服务的handle【服务以进程的形式存在，就是获得服务对应进程的handle】</li><li>构造参数binder_io</li><li>调用函数binder_call进行远程服务访问</li><li>返回binder_io，取出返回值</li><li>释放获得的handle</li></ul><p><strong>server端：</strong></p><ul><li>打开驱动，binder_open</li><li>调用svcmgr_publish注册服务</li><li>ioctl去读取binder驱动的数据</li><li>解析数据，将binder_write_read类型的数据转换为binder_io类型的数据</li><li>根据解析出的数据中的CODE值，去调用当前服务的对应函数</li><li>把返回值转换为binder_io</li></ul><h3 id="3-2-hello服务的server端"><a href="#3-2-hello服务的server端" class="headerlink" title="3.2 hello服务的server端"></a>3.2 hello服务的server端</h3><ul><li>test_server.h</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义hello服务的CODE编码，来表示当前应该调用服务的哪一个函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _TEST_SERVER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _TEST_SERVER_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO_SVR_CMD_SAYHELLO     1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO_SVR_CMD_SAYHELLO_TO  2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GOODBYE_SVR_CMD_SAYGOODBYE     1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GOODBYE_SVR_CMD_SAYGOODBYE_TO  2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// _TEST_SERVER_H</span></span><br></code></pre></td></tr></table></figure><ul><li>test_server.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/* Copyright 2008 The Android Open Source Project</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;private/android_filesystem_config.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;binder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test_server.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">svcmgr_publish</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs, <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *ptr)</span><br>&#123;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);<br>    bio_put_string16_x(&amp;msg, name);<br>    bio_put_obj(&amp;msg, ptr);<br><br>    <span class="hljs-keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    status = bio_get_uint32(&amp;reply);<br><br>    binder_done(bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sayhello</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;say hello : %d\n&quot;</span>, ++cnt);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sayhello_to</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;say hello to %s : %d\n&quot;</span>, name, ++cnt);<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">hello_service_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_transaction_data *txn,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_io *msg,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_io *reply)</span><br>&#123;<br>    <span class="hljs-comment">/* 根据txn-&gt;code知道要调用哪一个函数</span><br><span class="hljs-comment">     * 如果需要参数, 可以从msg取出</span><br><span class="hljs-comment">     * 如果要返回结果, 可以把结果放入reply</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/* sayhello</span><br><span class="hljs-comment">     * sayhello_to</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-type">uint16_t</span> *s;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">512</span>];<br>    <span class="hljs-type">size_t</span> len;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">uint32_t</span> strict_policy;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-comment">// Equivalent to Parcel::enforceInterface(), reading the RPC</span><br>    <span class="hljs-comment">// header with the strict mode policy mask and the interface name.</span><br>    <span class="hljs-comment">// Note that we ignore the strict_policy and don&#x27;t propagate it</span><br>    <span class="hljs-comment">// further (since we do no outbound RPCs anyway).</span><br>    strict_policy = bio_get_uint32(msg);<br><br>    <span class="hljs-keyword">switch</span>(txn-&gt;code) &#123;<br>    <span class="hljs-keyword">case</span> HELLO_SVR_CMD_SAYHELLO:<br>        sayhello();<br>        bio_put_uint32(reply, <span class="hljs-number">0</span>); <span class="hljs-comment">/* no exception */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">case</span> HELLO_SVR_CMD_SAYHELLO_TO:<br>        <span class="hljs-comment">/* 从msg里取出字符串 */</span><br>        s = bio_get_string16(msg, &amp;len);  <span class="hljs-comment">//&quot;IHelloService&quot;</span><br>        s = bio_get_string16(msg, &amp;len);  <span class="hljs-comment">// name</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            name[i] = s[i];<br>        name[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        <span class="hljs-comment">/* 处理 */</span><br>        i = sayhello_to(name);<br><br>        <span class="hljs-comment">/* 把结果放入reply */</span><br>        bio_put_uint32(reply, <span class="hljs-number">0</span>); <span class="hljs-comment">/* no exception */</span><br>        bio_put_uint32(reply, i);<br>        <br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;unknown code %d\n&quot;</span>, txn-&gt;code);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">bs</span>;</span><br>    <span class="hljs-type">uint32_t</span> svcmgr = BINDER_SERVICE_MANAGER;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">int</span> ret;<br><br>    bs = binder_open(<span class="hljs-number">128</span>*<span class="hljs-number">1024</span>);<br>    <span class="hljs-keyword">if</span> (!bs) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to open binder driver\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* add service */</span><br>    ret = svcmgr_publish(bs, svcmgr, <span class="hljs-string">&quot;hello&quot;</span>, hello_service_handler);<br>    <span class="hljs-keyword">if</span> (ret) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to publish hello service\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* read data */</span><br>        <span class="hljs-comment">/* parse data, and process */</span><br>        <span class="hljs-comment">/* reply */</span><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    binder_set_maxthreads(bs, <span class="hljs-number">10</span>);<br><br>    binder_loop(bs, hello_service_handler);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-hello服务的client端"><a href="#3-3-hello服务的client端" class="headerlink" title="3.3 hello服务的client端"></a>3.3 hello服务的client端</h3><ul><li>test_client.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c">&lt;&gt;<span class="hljs-comment">/* Copyright 2008 The Android Open Source Project</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;private/android_filesystem_config.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;binder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test_server.h&quot;</span></span><br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">svcmgr_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs, <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);<br>    bio_put_string16_x(&amp;msg, name);<br><br>    <span class="hljs-keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_CHECK_SERVICE))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    handle = bio_get_ref(&amp;reply);<br><br>    <span class="hljs-keyword">if</span> (handle)<br>        binder_acquire(bs, handle);<br><br>    binder_done(bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> handle;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">g_bs</span>;</span><br><span class="hljs-type">uint32_t</span> g_hello_handle;<br><span class="hljs-type">uint32_t</span> g_goodbye_handle;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sayhello</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    <span class="hljs-comment">/* 构造binder_io */</span><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, <span class="hljs-string">&quot;IHelloService&quot;</span>);<br><br>    <span class="hljs-comment">/* 放入参数 */</span><br><br>    <span class="hljs-comment">/* 调用binder_call */</span><br>    <span class="hljs-keyword">if</span> (binder_call(g_bs, &amp;msg, &amp;reply, g_hello_handle, HELLO_SVR_CMD_SAYHELLO))<br>        <span class="hljs-keyword">return</span> ;<br>    <br>    <span class="hljs-comment">/* 从reply中解析出返回值 */</span><br><br>    binder_done(g_bs, &amp;msg, &amp;reply);<br>    <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sayhello_to</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">int</span> exception;<br><br>    <span class="hljs-comment">/* 构造binder_io */</span><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, <span class="hljs-string">&quot;IHelloService&quot;</span>);<br><br>    <span class="hljs-comment">/* 放入参数 */</span><br>    bio_put_string16_x(&amp;msg, name);<br><br>    <span class="hljs-comment">/* 调用binder_call */</span><br>    <span class="hljs-keyword">if</span> (binder_call(g_bs, &amp;msg, &amp;reply, g_hello_handle, HELLO_SVR_CMD_SAYHELLO_TO))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">/* 从reply中解析出返回值 */</span><br>    exception = bio_get_uint32(&amp;reply);<br>    <span class="hljs-keyword">if</span> (exception)<br>        ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>        ret = bio_get_uint32(&amp;reply);<br><br>    binder_done(g_bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> ret;<br>    <br>&#125;<br><br><br><span class="hljs-comment">/* ./test_client hello</span><br><span class="hljs-comment"> * ./test_client hello &lt;name&gt;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">bs</span>;</span><br>    <span class="hljs-type">uint32_t</span> svcmgr = BINDER_SERVICE_MANAGER;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">int</span> ret;<br><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage:\n&quot;</span>);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s &lt;hello&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s &lt;hello&gt; &lt;name&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    bs = binder_open(<span class="hljs-number">128</span>*<span class="hljs-number">1024</span>);<br>    <span class="hljs-keyword">if</span> (!bs) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to open binder driver\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    g_bs = bs;<br><br>    <span class="hljs-comment">/* get service */</span><br>    handle = svcmgr_lookup(bs, svcmgr, <span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!handle) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to get hello service\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    g_hello_handle = handle;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Handle for hello service = %d\n&quot;</span>, g_hello_handle);<br><br>    <span class="hljs-comment">/* send data to server */</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello&quot;</span>))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>) &#123;<br>            sayhello();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span>) &#123;<br>            ret = sayhello_to(argv[<span class="hljs-number">2</span>]);<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;get ret of sayhello_to = %d\n&quot;</span>, ret);      <br>        &#125;<br>    &#125;<br><br>    binder_release(bs, handle);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3f3601eb-c63d-46bb-9692-1dfdc4d24690.png"><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/b20537c9-9aff-4da7-84ae-dd1dbcb30baf.png">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 8.1从零开始写HAL</title>
    <link href="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/"/>
    <url>/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-8-1从零开始写HAL"><a href="#Android-8-1从零开始写HAL" class="headerlink" title="Android 8.1从零开始写HAL"></a>Android 8.1从零开始写HAL</h1><blockquote><p>🍛版权声明：本文为CSDN博主「Qidi_Huang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>🍜原文链接：<a href="https://blog.csdn.net/Qidi_Huang/article/details/107426961">https://blog.csdn.net/Qidi_Huang/article/details/107426961</a></p></blockquote><h2 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1.定义接口"></a>1.定义接口</h2><p>【前言】<br>我们都知道从 <code>Android 8.0</code> 开始， Google 启动了 <code>Treble 项目</code>，自此开始推行 Binder 化的 HAL 实现。除少数类型 HAL 外，在 Android 9.0 及其之后的版本，Google 甚至要求大部分<strong>外设</strong>(peripherals) 必须支持使用 Binder 化的 HAL，否则都不再视为合规。因此，本文中的 HAL 指的是用 HIDL 语言描述、使用 Binder 方式实现的 HAL。</p><p>在阅读本系列文章前，如果你已经大致了解 <code>Android SELinux</code> 概念（比如 <code>*.te</code> 文件和 <code>file_contexts</code>），以及 Binder 的基本调用方法（比如知道序列化的概念、 transact()&#x2F;onTransact()的调用时机），对于理解本文的内容会很有帮助。</p><p>根据项目不同，有的时候我们也许希望在设备上使用一种新的外设，比如某种传感器；或者有的时候，我们可能需要在 Android native 层运行一个特定进程，用来辅助处理来自 Android Frameworks 的数据，或者用于和其它 native 层的进程进行交互。对于前一种场景，我们需要为外设编写全新的 HAL；对于后一种场景，我们不需要编写 HAL，但需要实现一个很类似的 vendor service。这二者的实现方式极其类似，区别只在于他们使用的设备节点不同（一个使用<code>/dev/hwbinder</code>，另一个使用 <code>/dev/vndbinder</code>），还有各自申请的 sepolicy 权限有别。</p><p>以下正文以实现一个全新的 HAL 为例进行说明，但并不涉及对设备节点的操作。</p><h3 id="1-1-明确HAL接口"><a href="#1-1-明确HAL接口" class="headerlink" title="1.1 明确HAL接口"></a>1.1 明确HAL接口</h3><p>Android 大量采用面向接口编程的理念，HAL 也不例外。常用的 HAL 模块接口已经由 Google 和业界充分讨论并预定义，比如 Audio 和 Camera，这些模块需要支持的功能也已经明确，其接口描述可以在 <code>/hardware/interfaces/</code> 目录下找到。</p><p>同理，我们实现自己的 HAL 时，也应该先明确新 HAL 要支持的功能，再根据需求需要设计要暴露给给其它进程的接口。</p><p><strong>为了说明方便，我们不以真实的外设 HAL 来描述，而是做一系列假设，自己给自己设计需求。虽然这样的 HAL 不对应具体的使用场景，但道理是相通的，完全可以照猫画虎、举一反三。</strong></p><p>我们假设新 HAL 需要支持 3 个功能：</p><ul><li>允许其它进程主动设置状态</li><li>允许其它进程注册回调函数</li><li>允许其它进程注销回调函数</li></ul><p>给 <strong>新外设</strong>取名为 <code>demoComponent</code>，给<strong>新 HAL 的进程</strong>取名为 <code>demoService</code>。给支持上述 3 项功能的接口分别取名为 <code>setStatus() </code>、 <code>registerCallback()</code> 和 <code>unregisterCallback()</code>。假设其它进程所设置的“状态”是一个 <code>DemoData</code> 结构体，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-built_in">string</span>  name;<br>    <span class="hljs-type">int</span>     value;<br>&#125; DemoData;<br></code></pre></td></tr></table></figure><p>假设回调函数方法为 <code>onCallbackEvent()</code>， 参数同样为 <code>DemoData</code> 结构。</p><h3 id="1-2-编写接口描述文件"><a href="#1-2-编写接口描述文件" class="headerlink" title="1.2 编写接口描述文件"></a>1.2 编写接口描述文件</h3><p>通常，经过前述步骤明确接口之后，我们就可以写出完整的头文件来了，继而对应实现各接口。但是在 HAL 实现过程中，我们首先要写的不是头文件，而是创作出用 HIDL 语言编写的 <code>*.hal</code> 接口描述文件。（<strong>不过，在 Android R 上将支持用 AIDL 语言来编写接口描述文件，以后可能逐步废弃 HIDL 语言</strong>）</p><p>按照目前的开发规范，我们的自定义接口描述文件通常放在 <code>/vendor/&lt;CompanyName&gt;/hardware/interfaces/&lt;ComponentName&gt;/&lt;SubComponentName&gt;/&lt;VersionCode&gt;/</code> 目录下。 根据我们前文的假设，这里的<code>&lt;ComponentName&gt;</code>就是 demoComponent。<code>&lt;SubComponentName&gt;</code> 可有可无，在这个例子中对应的是 demoService。VersionCode 表示 HAL 接口的版本号，因为我们编写的是一个全新的 HAL，所以版本号是 1.0。</p><p>因为我们的实现涉及 <strong>HAL 进程、回调函数、参数数据</strong> 3 个部分，所以对应的 hal 文件也有 3 个，分别是：</p><ul><li><strong>IDemoServiceDef.hal</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">package vendor.harman.hardware.demoComponent.demoService@<span class="hljs-number">1.0</span>;<br><br>import IDemoCallback;<br><br>interface IDemoServiceDef &#123;<br><br>    setStatus(DemoData data) generates (<span class="hljs-type">int32_t</span> status);<br>    registerCallback(IDemoCallback cb) generates (<span class="hljs-type">int32_t</span> status);<br>    unregisterCallback(IDemoCallback cb) generates (<span class="hljs-type">int32_t</span> status);<br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li><strong>IDemoCallback.hal</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">package vendor.harman.hardware.demoComponent.demoService@<span class="hljs-number">1.0</span>;<br><br>interface IDemoCallback &#123;<br><br>   onCallbackEvent(DemoData payload) generates (<span class="hljs-type">int32_t</span> status);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>types.hal</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">package vendor.harman.hardware.demoComponent.demoService@<span class="hljs-number">1.0</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DemoData</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-built_in">string</span>  name;<br>    <span class="hljs-type">int32_t</span> value;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里有四个基本点需要注意。</p><ol><li><p><strong>数据类型描述文件的文件名是个固定名称</strong> <code>types.hal</code>；接口描述文件的文件名要以<strong>大写字母 I</strong> 开头写作 <code>IXxxx.hal</code>，并且相应地以<code>interface IXxxx &#123;&#125; </code>进行描述；<strong>generates</strong> 后加数据类型表示接口的返回值类型。</p></li><li><p>每个<code> *.hal</code> 文件都需要在文件头声明它所属的包。这里的包名为<code> package vendor.harman.hardware.demoComponent.demoService@1.0;</code>。</p></li><li><p>HIDL 语言所使用的数据类型和 C&#x2F;C++&#x2F;Java 的数据类型稍有区别。举个简单例子，对比 DemoData 结构体的原始写法与 HIDL 写法，可以看到 int32 被替换成了 int32_t。 再比如说，HIDL 数据类型也不支持 C&#x2F;C++ 的原始指针。关于 HIDL 数据类型的详细介绍可以参考《HIDL 数据类型》。</p></li><li><p>另外，<code>*.hal</code> 文件之间相互引用时，使用 <code>import</code> 关键字进行声明。</p></li></ol><p>这些固定形式是由 HIDL 框架决定的，我们必须遵从。</p><p>编写完成后用 <code>ls</code> 命令查看，就是下图中 3 个绿色文件的样子（<code>Android.*</code> 是自动生成的，1.3节就要讲到。<code>default/</code> 的含义和作用留待第2章进行介绍）：</p><img src="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/20200717231917282.png"><h3 id="1-3-生成-Makefile"><a href="#1-3-生成-Makefile" class="headerlink" title="1.3 生成 Makefile"></a>1.3 生成 Makefile</h3><p>编写好接口描述文件后，我们需要执行脚本 <code>/vendor/&lt;CompanyName&gt;/hardware/interfaces/update-makefiles.sh</code> 为接口描述文件自动生成 2 个 Makefile —— <code>Android.bp</code> 和 <code>Android.mk</code>。</p><p>有了这 2 个 Makefile，在编译阶段就可以自动从接口描述文件生成 Binder 框架的源文件、头文件以和对应的库，而无需我们手动敲一遍，十分方便。</p><h2 id="2-实现-HAL-主体"><a href="#2-实现-HAL-主体" class="headerlink" title="2.实现 HAL 主体"></a>2.实现 HAL 主体</h2><h3 id="2-1-配置HAL"><a href="#2-1-配置HAL" class="headerlink" title="2.1 配置HAL"></a>2.1 配置HAL</h3><p>因为不同的产品可能使用不同的外设，所以每个产品都有自己的资源清单 <code>manifest.xml</code>，位于目录 <code>/device/&lt;CompanyName&gt;/&lt;PlatformName&gt;/&lt;ProductName&gt;/</code> 下。清单中会列出该款产品支持的所有外设、服务和它们的 HAL 类型。</p><p>我们也应该把正在创建的 demoComponent HAL 添加进这个清单里。以我用的 Intel 平台为例，产品代号就不说了，<code>manifest.xml</code> 位于 <code>/device/harman/broxton/XXXX/</code> 目录下。添加完成后看起来类似下面这个样子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;device&quot;</span>&gt;</span><br><br>    ......<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hal</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;hidl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>vendor.harman.hardware.demoComponent.demoService<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transport</span>&gt;</span>hwbinder<span class="hljs-tag">&lt;/<span class="hljs-name">transport</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">interface</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>IDemoServiceDef<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">instance</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">instance</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">interface</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">hal</span>&gt;</span><br><br>    ......<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sepolicy</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>27.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sepolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 <code>&lt;hal format=&quot;hidl&quot;&gt;</code> 表示 HAL 使用 HIDL 描述； <code>&lt;name&gt;</code> 的值可以看出来就是接口描述文件所在的位置，但中间少了个 <strong>“.interfaces”</strong> ；<code>&lt;transport&gt;</code> 表示 HAL 实现所依赖的 binder 类型；<code>&lt;version&gt;</code> 表示 HAL 版本，回忆上一节，我们在编写接口描述文件时，文件存放路径里也有个 HAL 版本号，这两个版本号要一致； <code>&lt;interface&gt;</code> 节点用来标明 HAL 接口，下属的<code> &lt;name&gt;</code> 指定了 HAL 的接口描述文件为 <code>IDemoServiceDef.hal</code>， <code>&lt;instance&gt;</code> 指定了 HAL 的实现位于 <code>default/</code> 目录下。</p><p>default&#x2F; <strong>目录需要我们自己创建，位于</strong> <code>/vendor/&lt;CompanyName&gt;/hardware/interfaces/&lt;ComponentName&gt;/&lt;SubComponentName&gt;/&lt;VersionCode&gt;/</code>。 还是以我用的平台为例，完整路径为 <code>/vendor/harman/hardware/interfaces/demoComponent/demoService/1.0/default</code>。</p><h3 id="2-2-实现HAL主体"><a href="#2-2-实现HAL主体" class="headerlink" title="2.2 实现HAL主体"></a>2.2 实现HAL主体</h3><p>接下来我们要实现 demoComponent HAL 的主体。 因为 <strong>Binder 化后的 HAL 是以服务进程的形式运行在 Android native 层</strong>的，所以我给这个主体取名为 demoService。在 <code>default/</code> 目录下新建 <code>DemoServiceImpl.h</code> 和<code>DemoServiceImpl.cpp</code>。</p><p>这之后要做的事大家就很熟悉了 —— 在 <code>DemoServiceImpl.h</code> 里引用必要的头文件、声明类和方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hardware/hardware.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/IServiceManager.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/IPCThreadState.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/IDemoServiceDef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/IDemoCallback.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> android;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoServiceImpl</span> : <span class="hljs-keyword">public</span> IDemoServiceDef &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DemoServiceImpl</span>();<br>    ~<span class="hljs-built_in">DemoServiceImpl</span>() &#123;&#125;<br><br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> <span class="hljs-keyword">override</span></span>;<br><br><br><span class="hljs-keyword">private</span>:<br>    android::sp&lt;IDemoCallback&gt; callback = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong><code>DemoServiceImpl</code> 类继承自 <code>IDemoServiceDef</code> 类，并对接口进行覆写，同时声明了一个 <code>IDemoCallback</code> 指针用来保存回调函数。</strong></p><p>大家可能会困惑<strong>IDemoServiceDef</strong> 类和接口声明是哪里来的？我们可以通过名字推测它是由 <strong>IDemoServiceDef.hal</strong> 生成的。实际上和推测一样，编译阶段自动生成的文件会被放在 <code>/out/soong/.intermediates/vendor/harman/hardware/interfaces/demoComponent/demoService/1.0/</code> 目录，头文件和源文件可以分别在 <code>vendor.harman.hardware.demoComponent.demoService@1.0_genc++_headers</code> 和 <code>vendor.harman.hardware.demoComponent.demoService@1.0_genc++ </code>中找到。 <strong>在 <code>DemoServiceImpl.h</code> 里需要 <code>#include</code> 引用这些自动生成的头文件。</strong></p><p>下方展示的是自动生成的头文件 <code>IDemoServiceDef.h</code> 的部分代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HIDL_GENERATED_VENDOR_HARMAN_HARDWARE_DEMOCOMPONENT_DEMOSERVICE_V1_0_IDEMOSERVICEDEF_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HIDL_GENERATED_VENDOR_HARMAN_HARDWARE_DEMOCOMPONENT_DEMOSERVICE_V1_0_IDEMOSERVICEDEF_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hidl/base/1.0/IBase.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/IDemoCallback.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/types.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hidl/manager/1.0/IServiceNotification.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/HidlSupport.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/MQDescriptor.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/Status.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/NativeHandle.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/misc.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> vendor &#123;<br><span class="hljs-keyword">namespace</span> harman &#123;<br><span class="hljs-keyword">namespace</span> hardware &#123;<br><span class="hljs-keyword">namespace</span> demoComponent &#123;<br><span class="hljs-keyword">namespace</span> demoService &#123;<br><span class="hljs-keyword">namespace</span> V1_0 &#123;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IDemoServiceDef</span> : <span class="hljs-keyword">public</span> ::android::hidl::base::V1_0::IBase &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isRemote</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><br><br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// ....省略</span><br>&#125;;<br><br><span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoServiceDef&gt;&amp;)</span></span>;<br><br>&#125;  <span class="hljs-comment">// namespace V1_0</span><br>&#125;  <span class="hljs-comment">// namespace demoService</span><br>&#125;  <span class="hljs-comment">// namespace demoComponent</span><br>&#125;  <span class="hljs-comment">// namespace hardware</span><br>&#125;  <span class="hljs-comment">// namespace harman</span><br>&#125;  <span class="hljs-comment">// namespace vendor</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// HIDL_GENERATED_VENDOR_HARMAN_HARDWARE_DEMOCOMPONENT_DEMOSERVICE_V1_0_IDEMOSERVICEDEF_H</span></span><br></code></pre></td></tr></table></figure><p>然后在 <code>DemoServiceImpl.cpp</code> 中实现各方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceImpl.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><br>DemoServiceImpl::<span class="hljs-built_in">DemoServiceImpl</span>() &#123;<br><br>&#125;<br><br>::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">DemoServiceImpl::setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoServiceImpl setStatus&quot;</span>);<br>    <span class="hljs-comment">// 省略设置状态的代码</span><br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService invokes callback&quot;</span>);<br>    <span class="hljs-comment">// 在最后执行回调函数发送通知</span><br>    callback-&gt;<span class="hljs-built_in">onCallbackEvent</span>(sta);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">DemoServiceImpl::registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoServiceImpl registerCallback&quot;</span>);<br>    <span class="hljs-comment">// 保存回调函数</span><br>    callback = cb;<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService callback function saved&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">DemoServiceImpl::unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoServiceImpl unregisterCallback&quot;</span>);<br>    <span class="hljs-keyword">if</span> (callback == cb) &#123;<br>        <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService callback function cleared.&quot;</span>);<br>        <span class="hljs-comment">// 清空回调函数</span><br>        callback = <span class="hljs-literal">nullptr</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService callback function mismatch, uncleared.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这 3 个接口的实现写得很简单，直接看代码注释就可以，无需赘言。</p><h3 id="2-3-将-HAL-注册为-Binder-服务"><a href="#2-3-将-HAL-注册为-Binder-服务" class="headerlink" title="2.3 将 HAL 注册为 Binder 服务"></a>2.3 将 HAL 注册为 Binder 服务</h3><p><strong>因为 Binder 化的 HAL 以独立本地进程的形式运行</strong>，<strong>所以必定需要 main() 函数作为进程启动入口</strong>。我们当然可以把 main() 写在 DemoServiceImpl.cpp 中，但为了与接口实现进行区分，我在<code>default/ </code>目录下新建源文件 <code>DemoService.cpp</code>，在该文件中实现且仅实现 main() 函数。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_TAG <span class="hljs-string">&quot;vendor.harman.demoComponent.demoService@1.0-service&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/log.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/ProcessState.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/LegacySupport.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceImpl.h&quot;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-comment">/* argc */</span>, <span class="hljs-type">char</span>* <span class="hljs-comment">/* argv */</span> [])</span> </span>&#123;<br>    android::ProcessState::<span class="hljs-built_in">initWithDriver</span>(<span class="hljs-string">&quot;/dev/hwbinder&quot;</span>);  <span class="hljs-comment">// 初始化 Binder 驱动</span><br>    <span class="hljs-keyword">auto</span> service = std::<span class="hljs-built_in">make_unique</span>&lt;DemoServiceImpl&gt;();      <span class="hljs-comment">// 构造 DemoServiceImpl 实例</span><br>    android::hardware::<span class="hljs-built_in">configureRpcThreadpool</span>(<span class="hljs-number">4</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/* callerWillJoin */</span>);<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService registerAsService&quot;</span>);<br>    android::<span class="hljs-type">status_t</span> status = service-&gt;<span class="hljs-built_in">registerAsService</span>();  <span class="hljs-comment">// 注册为 Binder 服务</span><br>    <span class="hljs-keyword">if</span> (status != android::OK) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Unable to register DemoService (%d)&quot;</span>, status);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    android::hardware::<span class="hljs-built_in">joinRpcThreadpool</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在 <strong>main()</strong> 函数中主要干了些事：使用设备节点 <code>/dev/hwbinder</code> 初始化 Binder 驱动，并以单例（Singleton）的方式将 <code>DemoServiceImpl</code> 类的一个实例注册为 Binder 服务。</p><p><strong>如果你希望 HAL 进程也能与其它本地进程交互，那么在初始化驱动的时候应该使用</strong> <code>/dev/vndbinder</code>。</p><h2 id="3-实现-Bp、Bn-端"><a href="#3-实现-Bp、Bn-端" class="headerlink" title="3.实现 Bp、Bn 端"></a>3.实现 Bp、Bn 端</h2><p><strong>【前言】</strong></p><p>既然 Binder 化的 HAL 依赖于 Binder 机制进行实现，那么我们自然必须按照 Binder 框架，相应编写 <strong>demoComponent HAL</strong> 的 <strong>Bp</strong> 端和 <strong>Bn</strong> 端。只有这样，才能打通客户端进程调用到服务端进程 —— 我们的 demoService —— 的通路。</p><h3 id="3-1-定义demoService接口类"><a href="#3-1-定义demoService接口类" class="headerlink" title="3.1 定义demoService接口类"></a>3.1 定义demoService接口类</h3><p>要将 demoService 接入 Binder，就必须定义一个我们自己的接口类，继承 Binder 的接口基类 <code>IInterface</code>，并实现所有 Binder 通信过程中要用到的方法。不过我们并不需要事无巨细地完成这项繁杂的工作，因为 Binder 框架提供了数个模板类和宏，大大方便了我们实现。</p><p>还记得在上一节《实现 HAL 主体》里我们创建了 <code>default/</code> 目录。在该目录下新建头文件 <code>DemoServiceBinderInterface.h</code>，并在这个头文件里定义接口类 <code>IDemoService</code>。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/IInterface.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/IDemoCallback.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEMOSERVICE_NAME <span class="hljs-string">&quot;com.qidi.demoService&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><span class="hljs-keyword">using</span> ::vendor::harman::hardware::demoComponent::demoService::V1_0::IDemoCallback;<br><span class="hljs-keyword">using</span> ::vendor::harman::hardware::demoComponent::demoService::V1_0::DemoData;<br><br><span class="hljs-keyword">namespace</span> android &#123;<br><br>    <span class="hljs-comment">// command codes for binder transactions</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">eDemoServiceTransactionID</span><br>    &#123;<br>        SET_STATUS = android::IBinder::FIRST_CALL_TRANSACTION,<br>        REGISTER_CALLBACK,<br>        UNREGISTER_CALLBACK<br>    &#125;;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">IDemoService</span>: <span class="hljs-keyword">public</span> IInterface &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">DECLARE_META_INTERFACE</span>(DemoService);<br><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>= <span class="hljs-number">0</span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了定义类 <code>IDemoService</code>，我们还在头文件 <code>DemoServiceBinderInterface.h</code> 里以<strong>枚举数据的形式</strong>定义了和 demoService Binder 调用相关的 Command code。 三个 Command code <code>SET_STATUS</code>、<code>REGISTER_CALLBACK</code> 和 <code>UNREGISTER_CALLBACK</code> 分别对应 demoService 的三个接口。<strong>第一个 Command code 必须赋值为</strong> <code>android::IBinder::FIRST_CALL_TRANSACTION</code>。</p><p>宏 <code>DECLARE_META_INTERFACE()</code> 主要用来声明用于 Binder 通信的成员变量 <code>descriptor</code> 和通用接口 <code>asInterface()</code> 、 <code>getInterfaceDescriptor()</code>。 相关代码位于 <code>IInterface.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span><br><span class="hljs-meta">    static const ::android::String16 descriptor;                        \</span><br><span class="hljs-meta">    static ::android::sp<span class="hljs-string">&lt;I##INTERFACE&gt;</span> asInterface(                     \</span><br><span class="hljs-meta">            const ::android::sp<span class="hljs-string">&lt;::android::IBinder&gt;</span>&amp; obj);              \</span><br><span class="hljs-meta">    virtual const ::android::String16&amp; getInterfaceDescriptor() const;  \</span><br><span class="hljs-meta">    I##INTERFACE();                                                     \</span><br><span class="hljs-meta">    virtual ~I##INTERFACE();                                            \</span><br></code></pre></td></tr></table></figure><p>至此，demoService 的接口类就定义好了。</p><h3 id="3-2-声明-Bp、Bn-端"><a href="#3-2-声明-Bp、Bn-端" class="headerlink" title="3.2 声明 Bp、Bn 端"></a>3.2 声明 Bp、Bn 端</h3><p>有了接口类之后，就可以正式着手 Bp、Bn 端的工作了。依照先声明后实现的顺序，我们继续在 <code>default/</code> 目录下新建头文件 <code>BpDemoService.h</code> 和 <code>BnDemoService.h</code>。<strong>Binder 框架提供了模板类<code>BpInterface&lt;&gt;</code>和 <code>BnInterface&lt;&gt;</code> 来简化这一过程</strong>。</p><ul><li><strong><code>BpDemoService.h</code> 代码如下：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><br><span class="hljs-keyword">namespace</span> android &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">BpDemoService</span>: <span class="hljs-keyword">public</span> BpInterface&lt;android::IDemoService&gt; &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">BpDemoService</span>(<span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; impl);<br><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span></span>;<br>    &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Bp 端头文件中将 <code>IDemoService</code> 作为参数传入 <code>BpInterface&lt;&gt;</code> 模板，所以需要引用 <code>DemoServiceBinderInterface.h</code>。由于模板类的设计，文件中声明的 demoService 的 3 个接口将被整合到 Binder 框架代码中。我们即便不去关注其中的细节也没关系，只要负责填入接口类和接口声明，剩下的交给 Binder 框架就好。当然，如果你充满好奇且时间充裕，也可以一头扎进去理一理思路。 <code>BpInterface&lt;&gt;</code> 模板类的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> INTERFACE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BpInterface</span> : <span class="hljs-keyword">public</span> INTERFACE, <span class="hljs-keyword">public</span> BpRefBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span>                    <span class="hljs-title">BpInterface</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; remote)</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IBinder*            <span class="hljs-title">onAsBinder</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong><code>BnDemoService.h</code> 代码如下：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> android &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">BnDemoService</span>: <span class="hljs-keyword">public</span> BnInterface&lt;IDemoService&gt; &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">status_t</span> <span class="hljs-title">onTransact</span><span class="hljs-params">( <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                Parcel* reply, <span class="hljs-type">uint32_t</span> flags = <span class="hljs-number">0</span>)</span></span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Bn 端头文件的内容与 Bp 端类似，但需要注意，由于 Binder 框架的设计原因，这里的方法名 <code>onTransact()</code> 及参数都是固定的，我们不能写成其它形式。</strong> <code>BnInterface&lt;&gt;</code> 模板类在 <code>IInterface.h</code> 中的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> INTERFACE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BnInterface</span> : <span class="hljs-keyword">public</span> INTERFACE, <span class="hljs-keyword">public</span> BBinder<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> sp&lt;IInterface&gt;      <span class="hljs-title">queryLocalInterface</span><span class="hljs-params">(<span class="hljs-type">const</span> String16&amp; _descriptor)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> String16&amp;     <span class="hljs-title">getInterfaceDescriptor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IBinder*            <span class="hljs-title">onAsBinder</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-3-实现-Bp、Bn-端"><a href="#3-3-实现-Bp、Bn-端" class="headerlink" title="3.3 实现 Bp、Bn 端"></a>3.3 实现 Bp、Bn 端</h3><p>声明之后，该进行实现了。继续在 <code>default/</code> 目录下新建源文件 <code>BpDemoService.cpp</code> 和 <code>BnDemoService.cpp</code>。</p><p>实现过程只是顺水推舟而已，直接看代码吧。</p><ul><li><strong>BpDemoService.cpp:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/Log.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/IServiceManager.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/Parcel.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;BpDemoService.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_D ALOGD</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_E ALOGE</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> android;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><br><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">BpDemoService::setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span> </span>&#123;<br>    Parcel data, reply;<br><br>    data.<span class="hljs-built_in">writeInterfaceToken</span>(IDemoService::<span class="hljs-built_in">getInterfaceDescriptor</span>());<br>    data.<span class="hljs-built_in">write</span>(&amp;sta, <span class="hljs-built_in">sizeof</span>(DemoData));<br><br>    <span class="hljs-type">status_t</span> status = <span class="hljs-built_in">remote</span>()-&gt;<span class="hljs-built_in">transact</span>(SET_STATUS, data, &amp;reply);<br>    <span class="hljs-keyword">if</span> (status != NO_ERROR) &#123;<br>        <span class="hljs-built_in">LOG_E</span>(<span class="hljs-string">&quot;BpDemoService::setStatus transact failed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> reply.<span class="hljs-built_in">readInt32</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">BpDemoService::registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>&#123;<br>    Parcel data, reply;<br><br>    data.<span class="hljs-built_in">writeInterfaceToken</span>(IDemoService::<span class="hljs-built_in">getInterfaceDescriptor</span>());<br>    data.<span class="hljs-built_in">write</span>(&amp;cb, <span class="hljs-built_in">sizeof</span>(::android::sp&lt;IDemoCallback&gt;));<br><br>    <span class="hljs-type">status_t</span> status = <span class="hljs-built_in">remote</span>()-&gt;<span class="hljs-built_in">transact</span>(REGISTER_CALLBACK, data, &amp;reply);<br>    <span class="hljs-keyword">if</span> (status != NO_ERROR) &#123;<br>        <span class="hljs-built_in">LOG_E</span>(<span class="hljs-string">&quot;BpDemoService::registerCallback transact failed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> reply.<span class="hljs-built_in">readInt32</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">BpDemoService::unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>&#123;<br>    Parcel data, reply;<br><br>    data.<span class="hljs-built_in">writeInterfaceToken</span>(IDemoService::<span class="hljs-built_in">getInterfaceDescriptor</span>());<br>    data.<span class="hljs-built_in">write</span>(&amp;cb, <span class="hljs-built_in">sizeof</span>(::android::sp&lt;IDemoCallback&gt;));<br><br>    <span class="hljs-type">status_t</span> status = <span class="hljs-built_in">remote</span>()-&gt;<span class="hljs-built_in">transact</span>(UNREGISTER_CALLBACK, data, &amp;reply);<br>    <span class="hljs-keyword">if</span> (status == NO_ERROR) &#123;<br>        <span class="hljs-built_in">LOG_E</span>(<span class="hljs-string">&quot;BpDemoService::unregisterCallback transact failed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> reply.<span class="hljs-built_in">readInt32</span>();<br>&#125;<br><br>BpDemoService::<span class="hljs-built_in">BpDemoService</span>(<span class="hljs-type">const</span> sp&lt;IBinder&gt; &amp;impl) : <span class="hljs-built_in">BpInterface</span>&lt;IDemoService&gt;(impl) &#123;&#125;<br><span class="hljs-built_in">IMPLEMENT_META_INTERFACE</span>(DemoService, DEMOSERVICE_NAME);<br><br></code></pre></td></tr></table></figure><p>Bp 端的源文件里使用了宏 <code>IMPLEMENT_META_INTERFACE()</code>，扩展之后即是宏 <code>DECLARE_META_INTERFACE()</code> 所声明的接口的实现。</p><p>这个宏同样定义在 <code>IInterface.h</code> 中，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span><br><span class="hljs-meta">    const ::android::String16 I##INTERFACE::descriptor(NAME);           \</span><br><span class="hljs-meta">    const ::android::String16&amp;                                          \</span><br><span class="hljs-meta">            I##INTERFACE::getInterfaceDescriptor() const &#123;              \</span><br><span class="hljs-meta">        return I##INTERFACE::descriptor;                                \</span><br><span class="hljs-meta">    &#125;                                                                   \</span><br><span class="hljs-meta">    ::android::sp<span class="hljs-string">&lt;I##INTERFACE&gt;</span> I##INTERFACE::asInterface(              \</span><br><span class="hljs-meta">            const ::android::sp<span class="hljs-string">&lt;::android::IBinder&gt;</span>&amp; obj)               \</span><br><span class="hljs-meta">    &#123;                                                                   \</span><br><span class="hljs-meta">        ::android::sp<span class="hljs-string">&lt;I##INTERFACE&gt;</span> intr;                               \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (obj != NULL) &#123;                                              \</span><br><span class="hljs-meta">            intr = static_cast<span class="hljs-string">&lt;I##INTERFACE*&gt;</span>(                          \</span><br><span class="hljs-meta">                obj-&gt;queryLocalInterface(                               \</span><br><span class="hljs-meta">                        I##INTERFACE::descriptor).get());               \</span><br><span class="hljs-meta">            <span class="hljs-keyword">if</span> (intr == NULL) &#123;                                         \</span><br><span class="hljs-meta">                intr = new Bp##INTERFACE(obj);                          \</span><br><span class="hljs-meta">            &#125;                                                           \</span><br><span class="hljs-meta">        &#125;                                                               \</span><br><span class="hljs-meta">        return intr;                                                    \</span><br><span class="hljs-meta">    &#125;                                                                   \</span><br><span class="hljs-meta">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span><br><span class="hljs-meta">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span><br></code></pre></td></tr></table></figure><ul><li><strong>BnDemoService.cpp:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/Log.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/Errors.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/Parcel.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;BnDemoService.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_D ALOGD</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_E ALOGE</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> android;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><span class="hljs-keyword">using</span> ::vendor::harman::hardware::demoComponent::demoService::V1_0::DemoData;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BnDemoService::onTransact</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel &amp;data, Parcel *reply, <span class="hljs-type">uint32_t</span> flags)</span> </span>&#123;<br>    <span class="hljs-type">status_t</span> retCode = NO_ERROR;<br>    <span class="hljs-keyword">switch</span> (code) &#123;<br>        <span class="hljs-keyword">case</span> SET_STATUS:&#123;<br>            <span class="hljs-built_in">LOG_D</span>(<span class="hljs-string">&quot;BnDemoService SET_STATUS()&quot;</span>);<br>            <span class="hljs-built_in">CHECK_INTERFACE</span>(IDemoService, data, reply);<br>            DemoData sta;<br>            data.<span class="hljs-built_in">read</span>(&amp;sta, <span class="hljs-built_in">sizeof</span>(DemoData));<br>            reply-&gt;<span class="hljs-built_in">writeInt32</span>(<span class="hljs-built_in">setStatus</span>(sta));<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> REGISTER_CALLBACK:&#123;<br>            <span class="hljs-built_in">LOG_D</span>(<span class="hljs-string">&quot;BnDemoService REGISTER_CALLBACK()&quot;</span>);<br>            <span class="hljs-built_in">CHECK_INTERFACE</span>(IDemoService, data, reply);<br>            ::android::sp&lt;IDemoCallback&gt; rcb;<br>            data.<span class="hljs-built_in">read</span>(&amp;rcb, <span class="hljs-built_in">sizeof</span>(::android::sp&lt;IDemoCallback&gt;));<br>            reply-&gt;<span class="hljs-built_in">writeInt32</span>(<span class="hljs-built_in">registerCallback</span>(rcb));<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> UNREGISTER_CALLBACK: &#123;<br>            <span class="hljs-built_in">LOG_D</span>(<span class="hljs-string">&quot;BnDemoService UNREGISTER_CALLBACK()&quot;</span>);<br>            <span class="hljs-built_in">CHECK_INTERFACE</span>(IDemoService, data, reply);<br>            sp&lt;IDemoCallback&gt; urcb;<br>            data.<span class="hljs-built_in">read</span>(&amp;urcb, <span class="hljs-built_in">sizeof</span>(::android::sp&lt;IDemoCallback&gt;));<br>            reply-&gt;<span class="hljs-built_in">writeInt32</span>(<span class="hljs-built_in">unregisterCallback</span>(urcb));<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>: &#123;<br>            <span class="hljs-built_in">LOG_E</span>(<span class="hljs-string">&quot;BnDemoService::onTransact(0x%x,0x%x)&quot;</span>, code, flags);<br>            retCode = BBinder::<span class="hljs-built_in">onTransact</span>(code, data, reply, flags);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> retCode;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Bn 端的源文件里对 <code>onTransact()</code> 进行实现，使用 <code>switch...case...</code> 对 Command code 进行处理。<strong>在每个 case 的末尾可以看到对 demoService 里各个方法的调用</strong>，并将调用的返回值写入 reply。</p><h2 id="4-编译与打包"><a href="#4-编译与打包" class="headerlink" title="4.编译与打包"></a>4.编译与打包</h2><h3 id="4-1-编写Makefile"><a href="#4-1-编写Makefile" class="headerlink" title="4.1 编写Makefile"></a>4.1 编写Makefile</h3><p><strong>这里说的 Makefile 是指 <code>Android.bp</code>（当然也可以使用 <code>Android.mk</code>，语法稍有区别）</strong>。</p><p>在 <code>default/</code> 目录下新建文件 <code>Android.bp</code>，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cc_defaults &#123;<br>    name: <span class="hljs-string">&quot;demoSvc_v1_0_default&quot;</span>,<br>    shared_libs: [<br>        <span class="hljs-string">&quot;libhidlbase&quot;</span>,<br>        <span class="hljs-string">&quot;libhidltransport&quot;</span>,<br>        <span class="hljs-string">&quot;liblog&quot;</span>,<br>        <span class="hljs-string">&quot;libutils&quot;</span>,<br>        <span class="hljs-string">&quot;libhardware&quot;</span>,<br>        <span class="hljs-string">&quot;libbinder&quot;</span>,<br>        <span class="hljs-string">&quot;vendor.harman.hardware.demoComponent.demoService@1.0_vendor&quot;</span>,<br>    ],<br>    cflags: [<br>        <span class="hljs-string">&quot;-Wall&quot;</span>,<br>        <span class="hljs-string">&quot;-Wextra&quot;</span>,<br>        <span class="hljs-string">&quot;-Werror&quot;</span>,<br>    ],<br>&#125;<br><br>cc_binary &#123;<br>    name: <span class="hljs-string">&quot;vendor.harman.demoComponent.demoService@1.0-service&quot;</span>,<br>    defaults: [<span class="hljs-string">&quot;demoSvc_v1_0_default&quot;</span>],<br>    init_rc: [<span class="hljs-string">&quot;vendor.harman.demoComponent.demoService@1.0-service.rc&quot;</span>],<br>    vendor: <span class="hljs-literal">true</span>,<br>    relative_install_path: <span class="hljs-string">&quot;hw&quot;</span>,<br><br>    include_dirs:[<span class="hljs-string">&quot;vendor/harman/hardware/interfaces/demoComponent/demoService/1.0/default&quot;</span>],<br>    srcs: [<br>        <span class="hljs-string">&quot;DemoService.cpp&quot;</span>,<br>        <span class="hljs-string">&quot;DemoServiceImpl.cpp&quot;</span>,<br>        <span class="hljs-string">&quot;BpDemoService.cpp&quot;</span>,<br>        <span class="hljs-string">&quot;BnDemoService.cpp&quot;</span><br>    ],<br>    shared_libs: [<br>        <span class="hljs-string">&quot;libbase&quot;</span>,<br>        <span class="hljs-string">&quot;libprotobuf-cpp-lite&quot;</span>,<br>        <span class="hljs-string">&quot;vendor.harman.hardware.demoComponent.demoService@1.0_vendor&quot;</span><br>    ],<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>目标 demoSvc_v1_0_default 可以理解成是将和 Binder 框架相关的库打包而成的一个总的库文件，<a href="mailto:&#118;&#101;&#110;&#x64;&#111;&#x72;&#x2e;&#104;&#97;&#x72;&#109;&#97;&#110;&#x2e;&#104;&#97;&#114;&#100;&#x77;&#x61;&#x72;&#101;&#x2e;&#100;&#x65;&#109;&#x6f;&#x43;&#111;&#x6d;&#x70;&#111;&#x6e;&#x65;&#110;&#116;&#x2e;&#100;&#101;&#x6d;&#x6f;&#x53;&#101;&#x72;&#x76;&#x69;&#x63;&#x65;&#x40;&#49;&#x2e;&#48;&#x5f;&#118;&#x65;&#110;&#100;&#x6f;&#114;">&#118;&#101;&#110;&#x64;&#111;&#x72;&#x2e;&#104;&#97;&#x72;&#109;&#97;&#110;&#x2e;&#104;&#97;&#114;&#100;&#x77;&#x61;&#x72;&#101;&#x2e;&#100;&#x65;&#109;&#x6f;&#x43;&#111;&#x6d;&#x70;&#111;&#x6e;&#x65;&#110;&#116;&#x2e;&#100;&#101;&#x6d;&#x6f;&#x53;&#101;&#x72;&#x76;&#x69;&#x63;&#x65;&#x40;&#49;&#x2e;&#48;&#x5f;&#118;&#x65;&#110;&#100;&#x6f;&#114;</a> 是通过接口描述文件自动生成的，同样可以在 &#x2F;out&#x2F;soong&#x2F;.intermediates&#x2F;… 目录下找到；</p></li><li><p>目标 <a href="mailto:&#118;&#x65;&#x6e;&#x64;&#111;&#x72;&#46;&#x68;&#x61;&#x72;&#x6d;&#x61;&#x6e;&#x2e;&#100;&#x65;&#x6d;&#111;&#x43;&#111;&#x6d;&#x70;&#x6f;&#x6e;&#101;&#110;&#x74;&#x2e;&#100;&#101;&#x6d;&#111;&#x53;&#x65;&#114;&#118;&#105;&#99;&#101;&#64;&#49;&#46;&#48;&#x2d;&#115;&#x65;&#114;&#118;&#x69;&#x63;&#x65;">&#118;&#x65;&#x6e;&#x64;&#111;&#x72;&#46;&#x68;&#x61;&#x72;&#x6d;&#x61;&#x6e;&#x2e;&#100;&#x65;&#x6d;&#111;&#x43;&#111;&#x6d;&#x70;&#x6f;&#x6e;&#101;&#110;&#x74;&#x2e;&#100;&#101;&#x6d;&#111;&#x53;&#x65;&#114;&#118;&#105;&#99;&#101;&#64;&#49;&#46;&#48;&#x2d;&#115;&#x65;&#114;&#118;&#x69;&#x63;&#x65;</a> 就是最终要生成的可执行文件；</p></li><li><p>属性 vendor: true 表示这是一个自定义的文件；</p></li><li><p>属性 relative_install_path: “hw” 和前一个属性共同作用，表示生成文件的相对存放位置在 <code>out/target/product/&lt;ProductName&gt;/vendor/bin/hw/ </code>目录；</p></li><li><p>属性 srcs 属性下包含了我们在之前几篇文章里编写的所有源文件 —— DemoService.cpp、DemoServiceImpl.cpp、BpDemoService.cpp 和 BnDemoService.cpp。</p></li></ul><h3 id="4-2-编写HAL启动脚本"><a href="#4-2-编写HAL启动脚本" class="headerlink" title="4.2 编写HAL启动脚本"></a>4.2 编写HAL启动脚本</h3><p>基于上述的 Makefile 在 <code>default/</code> 目录下<strong>手动（mm 命令）</strong>进行编译，我们能得到名为 <code>vendor.harman.demoComponent.demoService@1.0-service</code> 的可执行文件。为了让 demoComponent HAL 随系统启动而启动，我们还需要编写 <code>*.rc</code> 脚本，并在脚本中标注进程名、可执行文件、用户组等信息。</p><p>一般以可执行文件名作为脚本名，也就是 <code>vendor.harman.demoComponent.demoService@1.0-service.rc</code>。</p><p>在 <code>default/</code> 目录下新建脚本，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">service MyDemoService /vendor/bin/hw/vendor.harman.demoComponent.demoService@1.0-service<br>    class main<br>    user system<br>    group system<br>    capabilities sys_nice net_bind_service net_admin net_raw<br></code></pre></td></tr></table></figure><ul><li><p>关键字 service 用来定义一个进程（或称为本地服务），后面第一个参数 MyDemoService 是进程名，第二个参数是可执行文件的绝对路径；</p></li><li><p>class main 表示把 MyDemoService 归属到 main 类；</p></li><li><p>user system 和 group system 表示 MyDemoService 的用户和组用户都是 system；</p></li><li><p>capabilities 指定了一些权限相关的属性。</p></li></ul><h3 id="4-3-打包可执行文件到系统镜像"><a href="#4-3-打包可执行文件到系统镜像" class="headerlink" title="4.3 打包可执行文件到系统镜像"></a>4.3 打包可执行文件到系统镜像</h3><p>要实现 demoComponent HAL 随系统启动而启动，需要将它的 <code>可执行文件</code> 和 <code>*.rc</code> 文件都打包进系统镜像。通过修改产品的 Makefile 可以实现这一目的。</p><p>先在 <code>/device/&lt;CompanyName&gt;/&lt;PlatformName&gt;/common/</code> 路径下为 demoComponent HAL 新建一个名为 <code>demoComponent/</code> 的专属目录，再在这个目录下创建名为 <code>device_demoComponent.mk</code> 的 Makefile。（其实叫什么名字都可以，但是用 demoComponent 更直观）</p><p><strong>如此一来我们就有了 <code>/device/harman/broxton/common/demoComponent/device_demoComponent.mk</code>。</strong> 除去注释，Makefile 内容只有一句话：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">############################</span><br><span class="hljs-comment"># DemoService</span><br><span class="hljs-comment">############################</span><br><br>PRODUCT_PACKAGES += vendor.harman.demoComponent.demoService@1.0-service<br></code></pre></td></tr></table></figure><p>这句话表示要将可执行文件 <code>vendor.harman.demoComponent.demoService@1.0-service</code> 打包进系统镜像，确切地说是打包进 <code>vendor.img</code>。</p><p>切记，不要忘了把我们新建的 Makefile 添加到产品的 Makefile 中。 产品 Makefile 一般位于 <code>/device/&lt;CompanyName&gt;/&lt;PlatformName&gt;/&lt;ProductName&gt;/device.mk</code>，所以我们在 <code>/device/harman/broxton/XXXX/device.mk</code> 中增加以下语句（以 diff 形式展示）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">diff --git a/XXXX/device.mk b/XXXX/device.mk<br>index b0866f3d2..d7a7d8ef7 100755<br>--- a/XXXX/device.mk<br>+++ b/XXXX/device.mk<br>@@ -1,5 +1,6 @@<br> <span class="hljs-keyword">include</span> device/harman/broxton/common/device_common.mk<br> <span class="hljs-keyword">include</span> <span class="hljs-variable">$(LOCAL_PATH)</span>/audio/device_audio.mk<br>+<span class="hljs-keyword">include</span> device/harman/broxton/common/demoComponent/device_demoComponent.mk<br> <span class="hljs-keyword">include</span> device/harman/broxton/common/tuner/device_radioTuner.mk<br> <span class="hljs-keyword">include</span> device/harman/broxton/common/speech/vpa.mk<br></code></pre></td></tr></table></figure><p>注意上面以 <code>+</code> 开头的 <code>include</code> 语句，就是在引用我们的新建 Makefile。</p><hr><p><strong>【结语】</strong></p><p>打包已经完成，我们的 demoComponent HAL 正跃跃欲试。但如果你将打包好的系统镜像烧写到设备上，会发现 demoComponent HAL 不能按照预期工作，甚至连自启动都做不到。相反，我们会在 logcat 或 dmesg 里发现有很多日志提示我们没有操作权限。 下一节《添加执行权限》将介绍如何给 demoComponent HAL 添加必要的权限。</p><p>如果你急切地想看一看刚刚写好的 HAL 进程运行的样子，可以执行命令 <code>setenforce 0</code> 将设备的 SELinux 策略暂时关闭。 这样尽管系统仍然会报告权限错误，但不会禁止运行。</p><h2 id="5-添加执行权限"><a href="#5-添加执行权限" class="headerlink" title="5.添加执行权限"></a>5.添加执行权限</h2><p><strong>【前言】</strong></p><p>demoComponent HAL 已经成功编译且打包到系统镜像中，但到目前为止还没有被赋予访问 Binder 的权限。所以我们至少会看到，在将 demoService 注册为 Binder 服务时，日志中会打印类似下方的提示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[   <span class="hljs-number">10.368517</span>] type=<span class="hljs-number">1400</span> <span class="hljs-built_in">audit</span>(<span class="hljs-number">1483292256.112</span>:<span class="hljs-number">14</span>): avc: denied &#123; add &#125; ...<br></code></pre></td></tr></table></figure><p>这篇文章就是要说明完善 demoComponent HAL 所需要的 SELinux 权限的方法。</p><h3 id="5-1-编写策略文件"><a href="#5-1-编写策略文件" class="headerlink" title="5.1 编写策略文件"></a>5.1 编写策略文件</h3><p>依各公司习惯不同，用于配置产品权限的文件一般放在 <code>/device/&lt;CompanyName&gt;/sepolicy/</code> 或 <code>/device/&lt;CompanyName&gt;/common/sepolicy/</code> 目录下（也不排除是其它路径的可能性，但肯定是在<code>device/</code> 目录下的某个 <code>sepolicy/ </code>子目录）。在这个目录下，再为不同的部件分别创建相应的子目录，并在这个子目录中新建 <code>*.te</code> 文件和 <code>*_contexts</code> 文件，以添加必要的权限。</p><p>还是以我正在使用的平台为例，创建新目录 <code>/device/harman/sepolicy/demoComponent/</code>，并在该目录下新建如下图所示的文件：</p><img src="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/20200720203213989.png"><p>说明下各文件的内容和作用：</p><ul><li><strong>file_contexts:</strong><ul><li>首先编写 <code>file_contexts</code> 文件。这个文件名是由 SELinux 框架固定的。我们在 <code>file_contexts</code> 中将 demoService 的可执行文件定义为安全对象。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> demoService executable binary as a security object</span><br>/vendor/bin/hw/vendor.harman.demoComponent.demoService@<span class="hljs-number">1.0</span>-service   u:object_r:demoService_exec:s0<br></code></pre></td></tr></table></figure><ul><li><strong>hwservice_contexts:</strong><ul><li>然后，因为 demoComponent HAL 依赖 hwbinder 进行通信，所以我们还需要编写 <code>hwservice_contexts</code>。这个文件名也是由 SELinux 框架固定的。我们在这个文件中将新增的接口定义为一个安全对象，作用和 file_contexts 类似。（如果使用 vndbinder，则应编写 vndservice_contexts）</li><li>从 Android 8.0 开始，SELinux 也一分为二成为了 system 部分和 vendor 部分。其中 vendor 部分又因为不同部件使用的 binder 节点不同，从原先唯一的的 <code>service_contexts</code> 中剥离出了 <code>hwservice_contexts</code> 和 <code>vndservice_contexts</code> 两个文件。当使用 &#x2F;dev&#x2F;hwbinder 时手动创建前者并在文件中添加定义，当使用 &#x2F;dev&#x2F;vndbinder 时创建后者并同样在文件中添加定义。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> HAL interface as a security object</span><br>vendor.harman.hardware.demoComponent.demoService::IDemoServiceDef  u:object_r:vendor_demoService_hwservice:s0<br></code></pre></td></tr></table></figure><ul><li><strong>hwservicemanager.te</strong>:<ul><li>由于我们使用的是 hwbinder 节点，所以还应该编写 hwservicemanager.te。文件名也是固定的。在这个文件中声明 demoService 需要使用 hwbinder。（如果使用 vndbinder，则应编写 vndservicemanager.te）</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># grant demoService permission of using hwbinder</span><br><span class="hljs-built_in">hwbinder_use</span>(demoService)<br></code></pre></td></tr></table></figure><ul><li><strong>hwservice.te:</strong><ul><li>同理，编写 <code>hwservice.te</code>。文件名依然是固定的。在这个文件中为 demoService 定义了专属的 hwservice 类型，在添加 “注册服务” 权限时会用到。（如果使用 vndbinder，则应编写 <code>vndservice.te</code>）</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> demoService as hwservice_manager, so it can be added as a hwservice</span><br>type vendor_demoService_hwservice, hwservice_manager_type;<br></code></pre></td></tr></table></figure><ul><li><strong>demoService.te:</strong><ul><li>接着编写 demoService.te 文件。 这个文件通常以需要添加权限的对象为名。在这个文件中，我们为 demoService 定义了一个专属的安全域，赋予可 demoService 的执行文件以需要的文件属性，并且为 demoService 域添加和 Binder 操作相关的必要权限，比如 “注册为服务”、“允许 hwbinder 调用” 等。</li><li>不同的 HAL 进程或本地服务要操作的文件不同，其实现的作用也不同，所以这个文件里的内容差异也很大。依照最小权限规则，根据自己的实际需要添加权限即可。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> a security domain for demo service</span><br>type demoService, domain;<br><br><span class="hljs-meta"># specify demo service attributes</span><br>type demoService_exec, exec_type, file_type, vendor_file_type;<br><br><span class="hljs-meta"># initialize demo service domain</span><br><span class="hljs-built_in">init_daemon_domain</span>(demoService)<br><br><span class="hljs-built_in">add_hwservice</span>(demoService, vendor_demoService_hwservice)<br><br><span class="hljs-built_in">binder_call</span>(demoService, vndservicemanager)<br><span class="hljs-built_in">binder_call</span>(demoService, hwservicemanager)<br><span class="hljs-built_in">binder_call</span>(demoService, system_app)<br><br>allow demoService vndbinder_device:chr_file rw_file_perms;<br>allow demoService hwservicemanager_prop:file r_file_perms;<br></code></pre></td></tr></table></figure><ul><li><strong>system_app.te:</strong><ul><li>最后，还要为用户进程添加调用权限。我们通常会以 APP 对 demoService 的调用为例说明调用过程，所以这里新建 <code>system_app.te</code>。为 system_app 添加通过 hwservice_manager 查找服务、以及通过 binder 调用 demoService 的权限。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"># <span class="hljs-function">APP access priviledges <span class="hljs-keyword">for</span> demoService</span><br><span class="hljs-function"><span class="hljs-title">binder_call</span><span class="hljs-params">(system_app, demoService)</span></span><br><span class="hljs-function">allow system_app vendor_demoService_hwservice:hwservice_manager find;</span><br></code></pre></td></tr></table></figure><h3 id="5-2-应用策略文件"><a href="#5-2-应用策略文件" class="headerlink" title="5.2 应用策略文件"></a>5.2 应用策略文件</h3><p>为了使新增的安全规则生效，需要将刚刚创建的目录添加到 Makefile 中，这样一来编译镜像时就可以扫描到了。我们一般把这个改动添加到 <code>/device/&lt;CompanyName&gt;/&lt;PlatformName&gt;/&lt;ProductName&gt;/BoardConfig.mk</code>。</p><p>这里我改动的文件是 <code>/device/harman/broxton/XXXX/BoardConfig.mk</code>，修改部分如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile">diff --git a/XXXX/BoardConfig.mk b/XXXX/BoardConfig.mk<br>index 4979507a7..8e700f22d 100755<br>--- a/XXXX/BoardConfig.mk<br>+++ b/XXXX/BoardConfig.mk<br>@@ -72,6 +72,12 @@ BOARD_SEPOLICY_DIRS += device/harman/sepolicy/vold<br> INTEL_AUDIO_HAL=imc<br> BOARD_SEPOLICY_DIRS += device/harman/sepolicy/audio<br>+<br>+<span class="hljs-comment">########################################################</span><br>+<span class="hljs-comment"># DemoService</span><br>+<span class="hljs-comment">########################################################</span><br>+BOARD_SEPOLICY_DIRS += device/harman/sepolicy/demoComponent<br>+<br></code></pre></td></tr></table></figure><hr><p><strong>【结语】</strong></p><p>完全编译后，烧写镜像到设备上。待设备启动后，执行命令 <code>ps -A | grep -i demo</code> ，终于可以看到我们的 demoComponent HAL 进程已经随系统启动成功。</p><img src="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/2020072020305469.png"><p>如果在系统刚启动时执行命令 <code>logcat | grep -i demo</code>，还可以看到 demoComponent HAL 注册为 Binder 服务的日志打印：</p><img src="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/20200720203133940.png"><h2 id="6-感谢"><a href="#6-感谢" class="headerlink" title="6.感谢"></a>6.感谢</h2><p>🎊再次感谢大佬【Qidi_Huang】的精彩博客！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理学习笔记</title>
    <link href="/2023/03/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="《哈工大编译原理》学习笔记"><a href="#《哈工大编译原理》学习笔记" class="headerlink" title="《哈工大编译原理》学习笔记"></a>《哈工大编译原理》学习笔记</h1><blockquote><p>本系列博客主要记录自己学习编译原理的笔记，并手写一个C语言编译器</p><ul><li>☃️<strong>编译原理学习资料</strong>：哈工大陈鄞老师的《编译原理》</li></ul></blockquote><ul><li><p>✏️第一章：<a href="https://anmuxixixi.github.io/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/">编译原理绪论</a></p></li><li><p>🖊️第二章：<a href="https://anmuxixixi.github.io/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/">词法及文法</a></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二、语言及其文法</title>
    <link href="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/"/>
    <url>/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="二、语言及文法"><a href="#二、语言及文法" class="headerlink" title="二、语言及文法"></a>二、语言及文法</h1><h2 id="1-字母表"><a href="#1-字母表" class="headerlink" title="1.字母表"></a>1.字母表</h2><p>字母表Σ是一个有穷符号集合；这里的符号可以是字母、数字、标点符号……下面的例子都是字母表</p><ul><li>二进制字母表：{0,1}</li><li>ASCII字符集</li><li>Unicode字符集</li></ul><p>字母表有下面几种运算：</p><ul><li>乘积</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235051480.png" alt="image-20230302235051480" style="zoom:50%;"><ul><li>n次幂</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235116133.png" alt="image-20230302235116133" style="zoom:50%;"><ul><li>正闭包</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235140690.png" alt="image-20230302235140690" style="zoom:50%;"><ul><li>克林闭包</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235156202.png" alt="image-20230302235156202" style="zoom:50%;"><h2 id="2-串"><a href="#2-串" class="headerlink" title="2.串"></a>2.串</h2><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235218276.png" alt="image-20230302235218276" style="zoom: 50%;"><p>下面介绍一下串上的运算：</p><ul><li>连接</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235351581.png" alt="image-20230302235351581" style="zoom: 50%;"><ul><li>幂</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235405401.png" alt="image-20230302235405401" style="zoom:50%;"><h2 id="3-文法的定义"><a href="#3-文法的定义" class="headerlink" title="3.文法的定义"></a>3.文法的定义</h2>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、编译原理绪论</title>
    <link href="/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="一、编译原理绪论"><a href="#一、编译原理绪论" class="headerlink" title="一、编译原理绪论"></a>一、编译原理绪论</h1><h2 id="1-什么是编译"><a href="#1-什么是编译" class="headerlink" title="1.什么是编译"></a>1.什么是编译</h2><p>🫁<strong>编译</strong>：将高级语言【源语言】翻译成汇编语言或机器语言【目标语言】的过程</p><img src="/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/image-20230302225554584.png" alt="image-20230302225554584" style="zoom:67%;"><p>我们把C语言中的x &#x3D; 2编译成汇编语言<code>MOV X,2</code>，或是直接编译成机器语言<code>C706 0000 0002</code></p><p><strong>下面我们看一下整个编译的流程：</strong></p><img src="/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/image-20230302225855228.png" alt="image-20230302225855228" style="zoom: 67%;"><ul><li>预处理器：把存储在不同文件中的源程序聚合在一起；把被称为宏的缩写语句转换为原始语句</li><li>可重定位的机器代码：汇编器生成的可重定位起始代码在内存中存放的起始位置不是固定的，所有地址都是相对于起始位置的相对地址</li><li>加载器：修改可重定位地址；将修改后的指令和数据放在内存中适合的位置</li><li>链接器：将多个可重定位的机器代码文件（包括库文件）连接到一起；解决外部内部地址问题</li></ul><h2 id="2-编译器的结构"><a href="#2-编译器的结构" class="headerlink" title="2.编译器的结构"></a>2.编译器的结构</h2><img src="/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/image-20230302230959458.png" alt="image-20230302230959458" style="zoom:67%;"><p>编译器大致可以分为三个部分：</p><ul><li><p>前端部分，与源语言相关，也就是与我们写的高级语言C&#x2F;Java等有关</p></li><li><p>后端部分，与目标语言相关，也就是生成的目标机器语言</p></li><li><p>中间部分：机器无关代码优化器</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kernel下输入输出console如何实现</title>
    <link href="/2023/02/25/kernel%E4%B8%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BAconsole%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/02/25/kernel%E4%B8%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BAconsole%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="kernel下输入输出console如何实现"><a href="#kernel下输入输出console如何实现" class="headerlink" title="kernel下输入输出console如何实现"></a>kernel下输入输出console如何实现</h1><blockquote><p>🍛<strong>大部分内容转载自</strong>：</p><ul><li><a href="https://www.cnblogs.com/lifexy/p/7993136.html">https://www.cnblogs.com/lifexy/p/7993136.html</a></li><li><a href="https://blog.csdn.net/skyflying2012/article/details/41078349?spm=1001.2014.3001.5506">https://blog.csdn.net/skyflying2012/article/details/41078349?spm=1001.2014.3001.5506</a></li></ul></blockquote><h2 id="1-在驱动调试中-使用printk-是最简单-最方便的办法"><a href="#1-在驱动调试中-使用printk-是最简单-最方便的办法" class="headerlink" title="1.在驱动调试中,使用printk(),是最简单,最方便的办法"></a>1.在驱动调试中,使用printk(),是最简单,最方便的办法</h2><p>✨<strong>先说结论，当uboot命令行中设置不同的console参数，输出到的设备不同：</strong></p><ul><li><p>当uboot的命令行里的<strong>“console&#x3D;tty1”</strong>时,表示printk()输出在开发板的LCD屏上</p></li><li><p>当uboot的命令行里的<strong>“console&#x3D;ttySA0,115200”</strong>时,表示printk()输出在串口UART0上,波特率&#x3D;115200</p></li><li><p>当uboot的命令行里的<strong>“console&#x3D;tty1 console&#x3D;ttySA0,115200”</strong>时,表示printk()同时输出在串口上,以及开发板的LCD屏上</p></li></ul><p>内核又是怎么根据上面命令行参数来确定printk()的输出设备？</p><h2 id="2-以console-ttySA0-115200为例分析printk"><a href="#2-以console-ttySA0-115200为例分析printk" class="headerlink" title="2.以console=ttySA0,115200为例分析printk"></a>2.以<code>console=ttySA0,115200</code>为例分析printk</h2><h3 id="2-1-命令行激活-setup"><a href="#2-1-命令行激活-setup" class="headerlink" title="2.1 命令行激活__setup"></a>2.1 命令行激活__setup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel\printk\printk.c</span><br>__setup(<span class="hljs-string">&quot;console=&quot;</span>, console_setup);<br></code></pre></td></tr></table></figure><p>**__setup()**的作用就是：若uboot传递进来的命令行字符串里含有“console&#x3D;”,便调用console_setup()函数,并对“console&#x3D;”后面带的字符串”ttySA0,115200”进行分析</p><h3 id="2-2-调用console-setup函数"><a href="#2-2-调用console-setup函数" class="headerlink" title="2.2 调用console_setup函数"></a>2.2 调用console_setup函数</h3><p>我们以ttySA0,115200为例，分析一个<code>console_setup</code>函数，这里注意一下，这里结构体和数组同名，都是<code>console_cmdline</code>，区分一下🐖</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CMDLINECONSOLES 8</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console_cmdline</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span>name[<span class="hljs-number">16</span>];<span class="hljs-comment">/* Name of the driver    */</span><br><span class="hljs-type">int</span>    index;<span class="hljs-comment">/* Minor dev. to use    */</span><br><span class="hljs-type">char</span>*options;<span class="hljs-comment">/* Options for the driver   */</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console_cmdline</span> <span class="hljs-title">console_cmdline</span>[<span class="hljs-title">MAX_CMDLINECONSOLES</span>];</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">console_setup</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span>                    <span class="hljs-comment">//*str=&quot;ttySA0,115200&quot;</span><br>&#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-keyword">sizeof</span>(console_cmdline[<span class="hljs-number">0</span>].name)];     <span class="hljs-comment">// char name[16]</span><br>    <span class="hljs-type">char</span> *s, *options;<br>    <span class="hljs-type">int</span> idx; <br><br>    <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;                    <br>            <span class="hljs-built_in">strcpy</span>(name, <span class="hljs-string">&quot;ttyS&quot;</span>);<br>            <span class="hljs-built_in">strncpy</span>(name + <span class="hljs-number">4</span>, str, <span class="hljs-keyword">sizeof</span>(name) - <span class="hljs-number">5</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">strncpy</span>(name, str, <span class="hljs-keyword">sizeof</span>(name) - <span class="hljs-number">1</span>);   <span class="hljs-comment">//*name=&quot;ttySA0,115200&quot;</span><br>    &#125;<br><br>    name[<span class="hljs-keyword">sizeof</span>(name) - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">if</span> ((options = <span class="hljs-built_in">strchr</span>(str, <span class="hljs-string">&#x27;,&#x27;</span>)) != <span class="hljs-literal">NULL</span>)   <span class="hljs-comment">// 找到&#x27;,&#x27;,返回给options</span><br>            *(options++) = <span class="hljs-number">0</span>;                <span class="hljs-comment">//*options=&quot;115200&quot;</span><br><br><br>    <span class="hljs-keyword">for</span> (s = name; *s; s++)                                     <span class="hljs-comment">//*s=&quot;0&quot;</span><br>            <span class="hljs-keyword">if</span> ((*s &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; *s &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || *s == <span class="hljs-string">&#x27;,&#x27;</span>)<br>                    <span class="hljs-keyword">break</span>;<br><br>idx = simple_strtoul(s, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>);   <span class="hljs-comment">//和strtoul()一样,将s中的&quot;0&quot;提出来,所以idx=0</span><br>    *s = <span class="hljs-number">0</span>;<br><br>add_preferred_console(name, idx, options);      <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的代码和注释得到，最终调用add_preferred_console(“ttySA”, 0, “115200”)函数来添加控制台</p><h3 id="2-3-调用add-preferred-console函数"><a href="#2-3-调用add-preferred-console函数" class="headerlink" title="2.3 调用add_preferred_console函数"></a>2.3 调用add_preferred_console函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add_preferred_console</span><span class="hljs-params">(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> idx, <span class="hljs-type">char</span> *options)</span><br>&#123;<br><span class="hljs-keyword">return</span> __add_preferred_console(name, idx, options, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __add_preferred_console(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> idx, <span class="hljs-type">char</span> *options, <span class="hljs-type">char</span> *brl_options)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console_cmdline</span> *<span class="hljs-title">c</span>;</span><br><span class="hljs-type">int</span> i;<br><br>    <span class="hljs-comment">// MAX_CMDLINECONSOLES=8,表示最多添加8个控制台</span><br>    <span class="hljs-comment">// 这是直接将c指向了全局变量console_cmdline</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, c = console_cmdline; i &lt; MAX_CMDLINECONSOLES &amp;&amp; c-&gt;name[<span class="hljs-number">0</span>]; i++, c++) &#123;<br>        <span class="hljs-comment">// 该console名字和下标好已经存在了【目的是为了去重】</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(c-&gt;name, name) == <span class="hljs-number">0</span> &amp;&amp; c-&gt;index == idx) &#123;<br><span class="hljs-keyword">if</span> (!brl_options)<br>selected_console = i;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>    <br>    <span class="hljs-comment">// i == 8,表示数组存满了</span><br><span class="hljs-keyword">if</span> (i == MAX_CMDLINECONSOLES)<br><span class="hljs-keyword">return</span> -E2BIG;<br><span class="hljs-keyword">if</span> (!brl_options)<br>selected_console = i; <span class="hljs-comment">// 将selected_console设置为最新添加的console_cmdline的下标号</span><br><br>strlcpy(c-&gt;name, name, <span class="hljs-keyword">sizeof</span>(c-&gt;name));<br>c-&gt;options = options;<br>braille_set_options(c, brl_options);<br><br>c-&gt;index = idx;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>__add_preferred_console</code>将name idx options保存到数组下一个成员console_cmdline结构体中，如果数组中已有重名，则不添加，并置selected_console为最新添加的console_cmdline的下标号。</p><p>比如cmdline中有“console&#x3D;ttyS0,115200 console&#x3D;ttyS1,9600”</p><p>则在console_cmdline[8]数组中console_cmdline[0]代表ttyS0，console_cmdline[1]代表ttyS1，而selected_console&#x3D;1.</p><h3 id="2-4-kernel下如何选择printk-console"><a href="#2-4-kernel下如何选择printk-console" class="headerlink" title="2.4 kernel下如何选择printk console"></a>2.4 kernel下如何选择printk console</h3><p>根据<a href="https://anmuxixixi.github.io/2023/02/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E5%86%85%E6%A0%B8%E8%BE%93%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/">printk的实现原理</a>，printk最后调用console_unlock实现log_buf数据刷出到指定设备。</p><p>这里先不关心printk如何处理log buf数据(比如添加内容级别)，只关心printk如何一步步找到指定的输出设备，根据printk.c代码，可以找到如下线索。</p><p><strong>printk-&gt;vprintk-&gt;console_unlock-&gt;call_console_drivers</strong></p><p>看线索最底层的call_console_drivers</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> *<span class="hljs-title">console_drivers</span>;</span> <span class="hljs-comment">// 全局</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> for_each_console(con) \</span><br><span class="hljs-meta">for (con = console_drivers; con != NULL; con = con-&gt;next)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">call_console_drivers</span><span class="hljs-params">(<span class="hljs-type">int</span> level, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *text, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> *<span class="hljs-title">con</span>;</span><br><br>trace_console(text, len);<br><br><span class="hljs-keyword">if</span> (level &gt;= console_loglevel &amp;&amp; !ignore_loglevel)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (!console_drivers)<br><span class="hljs-keyword">return</span>;<br><br>for_each_console(con) &#123;<br><span class="hljs-keyword">if</span> (exclusive_console &amp;&amp; con != exclusive_console)  <span class="hljs-comment">// 如果指明了唯一的console，且当前不是那个console</span><br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (!(con-&gt;flags &amp; CON_ENABLED))  <span class="hljs-comment">// 当前的console不是enabled的</span><br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (!con-&gt;write)   <span class="hljs-comment">// 当前console没有write函数</span><br><span class="hljs-keyword">continue</span>;<br>con-&gt;write(con, text, len);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历console_drivers链表所有console struct，调用所有<u><strong>ENABLE</strong></u>的console的write方法将log buf中start到end的内容发出。</p><blockquote><p>到这里就很明了了，kernel下每次printk打印，首先存log_buf，然后遍历console_drivers，找到合适console，刷出log。</p><p>console_drivers链表的成员是哪里来的，接着来看下一部分，kernel下console的注册</p></blockquote><h3 id="2-5-console驱动注册"><a href="#2-5-console驱动注册" class="headerlink" title="2.5 console驱动注册"></a>2.5 console驱动注册</h3><p>接下来来搜索该数组，看看printk()如何调用控制台的硬件处理函数的。搜索到在<code>Printk.c</code>里的<code>register_console(struct console *console)</code>函数,有用到console_cmdline[]</p><p>显然,register_console()函数就用来注册控制台的,继续搜索register_console</p><img src="/2023/02/25/kernel%E4%B8%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BAconsole%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/image-20230225225234632.png" alt="image-20230225225234632" style="zoom:67%;"><p>我们以<code>drivers\tty\serial\serial_ks8695.c</code>为例，进行分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ks8695_console_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>add_preferred_console(SERIAL_KS8695_DEVNAME, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>register_console(&amp;ks8695_console);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>console_initcall(ks8695_console_init); <span class="hljs-comment">// 声明控制台初始化函数</span><br></code></pre></td></tr></table></figure><p>上面通过register_console()来注册<code>ks8695_console</code>结构体,该结构体成员如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERIAL_KS8695_DEVNAME<span class="hljs-string">&quot;ttyAM&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> <span class="hljs-title">ks8695_console</span> =</span> &#123;<br>.name= SERIAL_KS8695_DEVNAME,  <span class="hljs-comment">// 控制台名称</span><br>.write= ks8695_console_write,   <span class="hljs-comment">// 打印串口数据的硬件处理函数</span><br>.device= uart_console_device,    <span class="hljs-comment">// tty驱动</span><br>.setup= ks8695_console_setup,   <span class="hljs-comment">// 用来设置UART的波特率，发送，接收等功能</span><br>.flags= CON_PRINTBUFFER,        <span class="hljs-comment">// 标志位</span><br>.index= <span class="hljs-number">-1</span>,                     <span class="hljs-comment">// 索引</span><br>.data= &amp;ks8695_reg,            <span class="hljs-comment">// 寄存器</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在register_console()里，便会通过<code>ttyAM</code>来匹配console_cmdline[i]的名称,当匹配成功，printk()调用的console结构体便是ks8695_console了</p><p>☃️当驱动加载的时候，会走到MODULE_INIT，然后走到对应驱动注册的init函数中，在这里就是<code>ks8695_console_init</code>，紧接着会调用<code>register_console</code>，这里的register_console就是<code>printk.c</code>中的register_console。</p><hr><p>因此我们来看下printk.c中的register_console</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">register_console</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> console *newcon)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> *<span class="hljs-title">bcon</span> =</span> <span class="hljs-literal">NULL</span>;<br> <br>    <span class="hljs-comment">//如果注册的是bootconsole（kernel早期启动打印），需要检查console_drivers中</span><br>    <span class="hljs-comment">//没有“real console”也就是说bootconsole必须是第一个注册的console。</span><br>    <span class="hljs-keyword">if</span> (console_drivers &amp;&amp; newcon-&gt;flags &amp; CON_BOOT) &#123;<br>        <span class="hljs-comment">/* find the last or real console */</span><br>        for_each_console(bcon) &#123;<br>            <span class="hljs-keyword">if</span> (!(bcon-&gt;flags &amp; CON_BOOT)) &#123;<br>                printk(KERN_INFO <span class="hljs-string">&quot;Too late to register bootconsole %s%d\n&quot;</span>,<br>                    newcon-&gt;name, newcon-&gt;index);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span> (console_drivers &amp;&amp; console_drivers-&gt;flags &amp; CON_BOOT)<br>        bcon = console_drivers;<br> <br>    <span class="hljs-comment">//preferred console为console_cmdline中最后一个console</span><br>    <span class="hljs-keyword">if</span> (preferred_console &lt; <span class="hljs-number">0</span> || bcon || !console_drivers)<br>        preferred_console = selected_console;<br> <br>    <span class="hljs-keyword">if</span> (newcon-&gt;early_setup)<br>        newcon-&gt;early_setup();<br> <br>    <span class="hljs-keyword">if</span> (preferred_console &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;index &lt; <span class="hljs-number">0</span>)<br>            newcon-&gt;index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;setup == <span class="hljs-literal">NULL</span> ||<br>            newcon-&gt;setup(newcon, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">0</span>) &#123;<br>            newcon-&gt;flags |= CON_ENABLED;<br>            <span class="hljs-keyword">if</span> (newcon-&gt;device) &#123;<br>                newcon-&gt;flags |= CON_CONSDEV;<br>                preferred_console = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">//检查newcon是否是cmdline指定的console，如果是，则使能(CON_ENABLE)并初始化该console</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_CMDLINECONSOLES &amp;&amp; console_cmdline[i].name[<span class="hljs-number">0</span>];<br>            i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(console_cmdline[i].name, newcon-&gt;name) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;index &gt;= <span class="hljs-number">0</span> &amp;&amp;<br>            newcon-&gt;index != console_cmdline[i].index)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;index &lt; <span class="hljs-number">0</span>)<br>            newcon-&gt;index = console_cmdline[i].index;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;setup &amp;&amp;<br>            newcon-&gt;setup(newcon, console_cmdline[i].options) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        newcon-&gt;flags |= CON_ENABLED;<br>        newcon-&gt;index = console_cmdline[i].index;<br>        <span class="hljs-keyword">if</span> (i == selected_console) &#123;<br>            <span class="hljs-comment">//如果newcon是cmdline指定的最新的console，则置位CONSDEV</span><br>            newcon-&gt;flags |= CON_CONSDEV;<br>            preferred_console = selected_console;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">//该console没有使能，退出</span><br>    <span class="hljs-keyword">if</span> (!(newcon-&gt;flags &amp; CON_ENABLED))<br>        <span class="hljs-keyword">return</span>;<br> <br>    <span class="hljs-comment">//如果有bootconsole，则newcon不需要输出register之前的log，因为如果bootconsole和newcon是同一个设备</span><br>    <span class="hljs-comment">//则之前的log就输出2次</span><br>    <span class="hljs-keyword">if</span> (bcon &amp;&amp; ((newcon-&gt;flags &amp; (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV))<br>        newcon-&gt;flags &amp;= ~CON_PRINTBUFFER;<br> <br>    <span class="hljs-comment">//把newcon加入console_drivers链表，对于置位CON_CONSDEV的con，放在链表首</span><br>    console_lock();<br>    <span class="hljs-keyword">if</span> ((newcon-&gt;flags &amp; CON_CONSDEV) || console_drivers == <span class="hljs-literal">NULL</span>) &#123;<br>        newcon-&gt;next = console_drivers;<br>        console_drivers = newcon;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;next)<br>            newcon-&gt;next-&gt;flags &amp;= ~CON_CONSDEV;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        newcon-&gt;next = console_drivers-&gt;next;<br>        console_drivers-&gt;next = newcon;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newcon-&gt;flags &amp; CON_PRINTBUFFER) &#123;<br>        <span class="hljs-comment">//如果newcon置位PRINTBUFFER,则将log全部刷出</span><br>        raw_spin_lock_irqsave(&amp;logbuf_lock, flags);<br>        con_start = log_start;<br>        raw_spin_unlock_irqrestore(&amp;logbuf_lock, flags);<br>        <span class="hljs-comment">//修改printk输出的指定唯一exclusive_console为newcon</span><br>        <span class="hljs-comment">//保证将之前的log只输出到newcon</span><br>        exclusive_console = newcon;<br>    &#125;<br>    <span class="hljs-comment">//解锁console，刷出log到newcon</span><br>    console_unlock();<br>    console_sysfs_notify();<br> <br>    <span class="hljs-comment">//如果有bootconsole，则unregister bootconsole（从console_drivers中删掉）</span><br>    <span class="hljs-comment">//并告诉使用者现在console切换</span><br>    <span class="hljs-keyword">if</span> (bcon &amp;&amp;<br>        ((newcon-&gt;flags &amp; (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &amp;&amp;<br>        !keep_bootcon) &#123;<br>        printk(KERN_INFO <span class="hljs-string">&quot;console [%s%d] enabled, bootconsole disabled\n&quot;</span>,<br>            newcon-&gt;name, newcon-&gt;index);<br>        for_each_console(bcon)<br>            <span class="hljs-keyword">if</span> (bcon-&gt;flags &amp; CON_BOOT)<br>                unregister_console(bcon);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        printk(KERN_INFO <span class="hljs-string">&quot;%sconsole [%s%d] enabled\n&quot;</span>,<br>            (newcon-&gt;flags &amp; CON_BOOT) ? <span class="hljs-string">&quot;boot&quot;</span> : <span class="hljs-string">&quot;&quot;</span> ,<br>            newcon-&gt;name, newcon-&gt;index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果之前注册了bootconsole，则不会将该次register之前的log刷出，防止bootconsole和该次注册的newcon是同一个物理设备时，log打印2次。</p><p>如果没有bootconsole，则会指定exclusive_console&#x3D;newcon，console_unlock时，刷新全部log到该指定exclusive console。</p><p>console_unlock结束时会将exclusive_console置NULL，所以exclusive console默认情况下就是NULL。</p><p>最后会unregister bootconsole，是将bootconsole从console_drivers中删除，这样之后的printk就不会向bootconsole输出了。</p><p>有意思的一个地方是，在unregister bootconsole之前的printk：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">printk(KERN_INFO <span class="hljs-string">&quot;console [%s%d] enabled, bootconsole disabled\n&quot;</span>,<br>            newcon-&gt;name, newcon-&gt;index);<br></code></pre></td></tr></table></figure><p><u>因为此时bootconsole还没删掉，而newconsole已经加入console_drivers，如果bootconsole和newconsole是同一个物理设备，我们会看到这句printk会出现2次哦！</u></p><p>如果在cmdline指定2个I&#x2F;O设备，如<code>&quot;console==ttyS0,115200 console=ttyS1,115200&quot;</code>，因ttyS设备都是serial driver中注册的real console，所以会看到kernel的打印分别出现在2个串口上！</p><p><u><strong>boot console</strong>和<strong>real console</strong>差别在于bootconsole注册于kernel启动早期，方便对于kernel早期启动进行调试打印。</u></p><p>那这些console是在哪里调用register_console进行注册的？</p><ul><li><p>bootconsole的注册，如arch&#x2F;arm&#x2F;kernel&#x2F;early_printk.c，是在parse_args参数解析阶段注册bootconsole。</p><ul><li>在start_kernel中console_init函数也会遍历.con_initcall.init段中所有注册函数，而这些注册函数也可以来注册bootconsole。</li><li>.con_initcall.init段中函数的注册可以使用宏定义console_initcall。这些函数中调用register_console，方便在kernel初期实现printk打印。</li></ul></li><li><p>realconsole的注册，是在各个driver，如serial加载时完成。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】linux内核输出的日志去哪里了</title>
    <link href="/2023/02/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E5%86%85%E6%A0%B8%E8%BE%93%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/"/>
    <url>/2023/02/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E5%86%85%E6%A0%B8%E8%BE%93%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h1 id="linux内核输出的日志去哪里了"><a href="#linux内核输出的日志去哪里了" class="headerlink" title="linux内核输出的日志去哪里了"></a>linux内核输出的日志去哪里了</h1><blockquote><p>🍕转载自：<a href="https://mp.weixin.qq.com/s/mdDLw6AIp9ws9LTaHg64pg">https://mp.weixin.qq.com/s/mdDLw6AIp9ws9LTaHg64pg</a></p><p>🥯感谢大佬精彩的文章！！！</p></blockquote><p><img src="/2023/02/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E5%86%85%E6%A0%B8%E8%BE%93%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/image-20230221230542976.png" alt="image-20230221230542976">我们可以根据这张图，来理解printk的整体架构。</p><h2 id="1-printk实现简述"><a href="#1-printk实现简述" class="headerlink" title="1.printk实现简述"></a>1.printk实现简述</h2><h3 id="1-1-内核态printk"><a href="#1-1-内核态printk" class="headerlink" title="1.1 内核态printk"></a>1.1 内核态printk</h3><p>在内核编码时，如果想要输出一些信息，通常并不会直接使用printk，而是会使用其衍生函数，比如 pr_err &#x2F; pr_info &#x2F; pr_debug 等，这些衍生函数附带了日志级别、所属模块等其他信息，比较友好，但其最终还是调用了printk。</p><p>printk函数会将每次输出的日志，放到内核为其专门分配的名为<strong>ring buffer</strong>的一个槽位里。</p><ul><li><p>ring buffer其实就是一个用数组实现的环形队列，不过既然是环形队列，就会有一个问题，即当ring buffer满了的时候，下一条新的日志，会覆盖最开始的旧的日志。</p></li><li><p>ring buffer的大小，可以通过内核参数来修改。</p></li><li><p>printk在将日志放到ring buffer后，会再调用系统console的相关方法，将还未输出到系统控制台的消息，继续输出到控制台，这个后面会详细说，这里就暂不赘述。</p></li></ul><p>以上就是printk在内核态的实现。</p><h3 id="1-2-用户态printk"><a href="#1-2-用户态printk" class="headerlink" title="1.2 用户态printk"></a>1.2 用户态printk</h3><p>在用户态，我们有几个方式，可以查看printk输出的内核日志，比如使用dmesg命令，cat &#x2F;proc&#x2F;kmsg文件，或者是使用klogctl函数等，这些方式分别对应于全景图中用户态的橙色、绿色、和蓝色的部分。</p><p><strong>（1）dmesg命令</strong></p><p><strong>dmesg命令，在默认情况下，是通过读取&#x2F;dev&#x2F;kmsg文件</strong>，来实现查看内核日志的。</p><p>当该命令运行时，dmesg会先调用open函数，打开&#x2F;dev&#x2F;kmsg文件，该打开操作在内核中的逻辑，会为dmesg分配一个file实例，在这个file实例里，会有一个seq变量，该变量记录着下一条要读取的内核日志在ring buffer中的位置。</p><p>刚打开&#x2F;dev&#x2F;kmsg文件时，这个seq指向的就是ring buffer中最开始的那条日志。</p><p>之后，dmesg会以打开的&#x2F;dev&#x2F;kmsg文件为媒介，不断的调用read函数，从内核中读取日志消息，每读取出一条，seq的值都会加一，即指向下一条日志的位置，依次往复，直到所有的内核日志读取完毕，dmesg退出。</p><p>以上就是dmesg的主体实现。</p><p><strong>（2）cat &#x2F;proc&#x2F;kmsg 命令</strong></p><p>第二种查看内核日志的方式，是通过 cat &#x2F;proc&#x2F;kmsg 命令。</p><p>该命令和dmesg命令的实现机制基本类似，都是通过读文件，只不过cat读取的是&#x2F;proc&#x2F;kmsg文件，而dmesg读取的是&#x2F;dev&#x2F;kmsg文件。</p><p>读取这两个文件最大的区别是，&#x2F;dev&#x2F;kmsg文件每次打开时，内核都会为其分配一个单独的seq变量，而&#x2F;proc&#x2F;kmsg文件每次打开时，用的都是同一个全局的静态seq变量，叫做syslog_seq。</p><p>syslog_seq指向的也是下一条要读取的内核日志在ring buffer中的位置，但因为它是一个全局的静态变量，当有多个进程要读取&#x2F;proc&#x2F;kmsg文件时，就会有一个比较严重的问题，即内核日志会被这几个进程随机抢占读取，也就是说，每个进程读到的都是整个内核日志的一部分，是不完整的，这也是dmesg命令默认不使用&#x2F;proc&#x2F;kmsg文件的原因。</p><p><strong>（3）klogctl函数</strong></p><p>第三种查看内核日志的方式，是通过klogctl函数。</p><p>该函数是glibc对syslog系统调用的一个简单封装，其具体使用方式，可以参考全景图中用户态的蓝色部分。</p><p>klogctl函数可以指定很多命令，在上图的示例中，我们使用的是SYSLOG_ACTION_READ命令，以此来模拟 cat &#x2F;proc&#x2F;kmsg 行为。</p><p>其实在内核层面，cat &#x2F;proc&#x2F;kmsg命令，使用的就是klogctl对应的syslog系统调用的SYSLOG_ACTION_READ命令的处理逻辑，所以示例中的klogctl函数相关代码，和 cat &#x2F;proc&#x2F;kmsg 命令其实是等价的。</p><p>也就是说，klogctl函数在内核里使用的也是syslog_seq变量，它也有和&#x2F;proc&#x2F;kmsg文件同样的问题。</p><p><strong>（4）系统控制台</strong></p><p>其实还有一种方式可以查看内核日志，就是通过系统控制台。</p><p>但这种方式和前面讲的三种方式都不一样，它是完全被动的，是内核在调用printk函数，将日志信息放到ring buffer后，再去通知系统控制台，告知其可以输出这些日志。</p><p>系统控制台也是通过一个console_seq变量，记录下一条要输出内核日志的所在位置。</p><p>系统控制台输出的内容，是被日志级别过滤过的，内核默认的日志过滤级别是7，即debug级别以上的日志，比如info &#x2F; err 等，这些都会输出，但debug级别不会输出。</p><p>该日志过滤级别，可以通过很多方式改变，比如说，可以通过内核参数 loglevel，所以，如果发现系统控制台没有输出想要的日志信息，先看下其是否被过滤掉了。</p><h2 id="2-kernel日志调试设置"><a href="#2-kernel日志调试设置" class="headerlink" title="2.kernel日志调试设置"></a>2.kernel日志调试设置</h2><h3 id="2-1-查看日志级别"><a href="#2-1-查看日志级别" class="headerlink" title="2.1 查看日志级别"></a>2.1 查看日志级别</h3><p>输入<code>cat proc/sys/kernel/printk</code></p><p>这四个数字依次对应 console_loglevel，default_message_loglevel，minimum_console_loglevel，default_console_loglevel。</p><ul><li><p><strong>console_loglevel：</strong>控制台使用的日志级别；</p></li><li><p><strong>default_message_loglevel：</strong>调用 printk() 未指定日志级别时使用的日志级别；</p></li><li><p><strong>minimum_console_loglevel：</strong>允许设置的控制台日志级别（console_loglevel）最小值；</p></li><li><p><strong>default_console_loglevel：</strong>系统启动时使用的日志级别。</p></li></ul><h3 id="2-2-修改kernel日志级别"><a href="#2-2-修改kernel日志级别" class="headerlink" title="2.2 修改kernel日志级别"></a>2.2 修改kernel日志级别</h3><p>（1）最直接的方法就是：<code>echo xxx &gt; proc/sys/kernel/printk</code>，其余方式参考：<a href="https://blog.csdn.net/qq_34597963/article/details/128669281">https://blog.csdn.net/qq_34597963/article/details/128669281</a></p><p>日志级别如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_EMERG      KERN_SOH <span class="hljs-string">&quot;0&quot;</span>    /* system is unusable */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_ALERT      KERN_SOH <span class="hljs-string">&quot;1&quot;</span>    /* action must be taken immediately */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_CRIT       KERN_SOH <span class="hljs-string">&quot;2&quot;</span>    /* critical conditions */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_ERR        KERN_SOH <span class="hljs-string">&quot;3&quot;</span>    /* error conditions */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_WARNING    KERN_SOH <span class="hljs-string">&quot;4&quot;</span>    /* warning conditions */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_NOTICE     KERN_SOH <span class="hljs-string">&quot;5&quot;</span>    /* normal but significant condition */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_INFO       KERN_SOH <span class="hljs-string">&quot;6&quot;</span>    /* informational */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_DEBUG      KERN_SOH <span class="hljs-string">&quot;7&quot;</span>    /* debug-level messages */</span><br><br>-----------------<br><br>致命级(KERN_EMESG),<br>警戒级(KERN_ALERT),<br>临界级(KERN_CRIT),<br>错误级(KERN_ERR),<br>告警级(KERN_WARN)<br>注意级(KERN_NOTICE),<br>通知级(KERN_INFO),<br>调试级(KERN_DEBUG).<br></code></pre></td></tr></table></figure><p>（2）在kernel中修改log默认等级</p><p>找到<code>/include/linux/printk.h</code>，在下面这个函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">console_verbose</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><p>修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">console_loglevel = CONSOLE_LOGLEVEL_MIN; <span class="hljs-comment">//CONSOLE_LOGLEVEL_MOTORMOUTH;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-Android-Init进程日志打印不全"><a href="#2-3-Android-Init进程日志打印不全" class="headerlink" title="2.3 Android Init进程日志打印不全"></a>2.3 Android Init进程日志打印不全</h3><blockquote><p>参考：<a href="https://blog.csdn.net/superlee1125/article/details/114099144?spm=1001.2014.3001.5506">https://blog.csdn.net/superlee1125/article/details/114099144?spm=1001.2014.3001.5506</a></p></blockquote><p>在抓Android内核的log时，init进程的log往往打印不全，这是因为内核限制了log的输出，在内核代码中找到下面的文件，并按照下面的提示把代码注释掉，然后重新编译内核，再刷到设备中，init进程的打印就完整了。</p><p>内核代码中找到这个文件 <code>kernel/printk/printk.c</code>，在下面这个函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">devkmsg_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kiocb *iocb, <span class="hljs-keyword">struct</span> iov_iter *from)</span><br></code></pre></td></tr></table></figure><p>注释掉下面这两句话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">/* Ratelimit when not explicitly enabled. */</span><br>    <span class="hljs-keyword">if</span> (!(devkmsg_log &amp; DEVKMSG_LOG_MASK_ON)) &#123;<br>-       <span class="hljs-keyword">if</span> (!___ratelimit(&amp;user-&gt;rs, current-&gt;comm))<br>-           <span class="hljs-keyword">return</span> ret;<br>+       <span class="hljs-comment">//if (!___ratelimit(&amp;user-&gt;rs, current-&gt;comm))</span><br>+           <span class="hljs-comment">//return ret;</span><br>    &#125;<br>    buf = kmalloc(len+<span class="hljs-number">1</span>, GFP_KERNEL);<br></code></pre></td></tr></table></figure><h3 id="2-4-Android修改日志级别"><a href="#2-4-Android修改日志级别" class="headerlink" title="2.4 Android修改日志级别"></a>2.4 Android修改日志级别</h3><p>以Android 10.0 qcom平台为例，修改如下：<code>device/qcom/common/rootdir/etc/init.qcom.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">case &quot;$buildvariant&quot; in<br>    &quot;userdebug&quot; | &quot;eng&quot;)<br>        #set default loglevel to KERN_INFO<br>        echo &quot;6 6 1 7&quot; &gt; /proc/sys/kernel/printk  ##### 根据需要进行修改<br><br>        ;;<br>    *)<br>        #set default loglevel to KERN_WARNING<br>        echo &quot;4 4 1 4&quot; &gt; /proc/sys/kernel/printk<br>        ;;<br>esac<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android通用内核GKI</title>
    <link href="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/"/>
    <url>/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/</url>
    
    <content type="html"><![CDATA[<h1 id="Android通用内核GKI"><a href="#Android通用内核GKI" class="headerlink" title="Android通用内核GKI"></a>Android通用内核GKI</h1><h2 id="1-GKI概述"><a href="#1-GKI概述" class="headerlink" title="1.GKI概述"></a>1.GKI概述</h2><p><strong>快速了解</strong>： GKI全称为Generic kernel Image。自2019年开始，来自Google Android的Kernel team经过多年准备，开始在Android 11.0的研发版本上推行GKI设计。GKI的目标在于消除Android阵营Linux Kernel的碎片化状态。 <strong>GKI的终极目标是由Google统一发布boot.image镜像给全球用户使用</strong>。GKI是Google Treble项目的重要举措之一。</p><h3 id="1-1-谷歌为什么要提出GKI"><a href="#1-1-谷歌为什么要提出GKI" class="headerlink" title="1.1 谷歌为什么要提出GKI"></a>1.1 谷歌为什么要提出GKI</h3><p>直接搬运官网，讲的太详细了。</p><p><u><strong>Android 通用内核 (ACK)</strong></u> 是所有 Android 产品内核的基础。供应商内核和设备内核位于 ACK 的下游。供应商通过修改内核源代码并添加设备驱动程序，添加了对 SoC 和外围设备的支持。这些修改内容可能很多，以至于设备上运行的代码中有多达 50% 是树外代码（并非来自上游 Linux 和 AOSP 通用内核）。</p><p>因此，设备内核由以下部分组成：</p><ul><li>上游：来自 kernel.org 的 Linux 内核</li><li>AOSP：AOSP 通用内核的其他 Android 专用补丁程序</li><li>供应商：供应商提供的 SoC 和外围设备支持以及优化补丁程序</li><li>原始设备制造商 (OEM)&#x2F;设备：其他设备驱动程序和自定义项</li></ul><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230217234034047.png" alt="image-20230217234034047" style="zoom: 67%;"><p>Kernel从Linux分支一路到OEM厂商，不断进行修改，全球这么多vendor厂商，这么多oem厂商，每家都来这么一套自己的kernel，碎片化太太太严重了，谷歌真的很难维护。用官网的话，<strong>内核碎片化会对 Android 社区产生若干负面影响</strong>。</p><ul><li>安全更新需要耗费大量人力<ul><li>Android 安全公告 (ASB) 中引用的安全补丁程序必须向后移植到每个设备内核中。但是，由于存在内核碎片化问题，向正常使用的 Android 设备传播安全修复的代价非常之高。</li></ul></li><li>很难合并长期支持的更新<ul><li>长期支持 (LTS) 版本包含安全修复和其他重大问题修复。事实证明，使用最新的 LTS 版本是提供安全修复的最有效方式。我们发现，ASB 报告的内核安全问题中有 90% 都已在保持最新状态的 Pixel 设备上得到修复。</li></ul></li><li>妨碍 Android 平台进行版本升级<ul><li>由于碎片化问题，很难向正常使用的设备添加需要更改内核的 Android 新功能。Android 框架代码必须假设支持的内核版本多达 5 个，并且没有针对新的平台版本进行任何内核更改（Android 10 支持内核版本 3.18、4.4、4.9、4.14 和 4.19；在某些情况下，这些版本自 2017 年 Android 8 发布以来还未添加新功能）。</li></ul></li><li>很难将内核更改贡献回上游 Linux<ul><li>对内核进行完所有更改后，大多数旗舰设备附带的内核版本已经至少存在 18 个月了。例如，<code>kernel.org</code> 于 2017 年 11 月发布了 4.14 版内核，而首批使用 4.14 版内核的 Android 手机于 2019 年春季才发布。</li><li>上游内核发布与产品发布之间的这种长时间延迟导致 Android 社区很难将所需的功能和驱动程序馈送到上游内核中，因此解决碎片化问题并非易事。</li></ul></li></ul><h3 id="1-2-谷歌如何解决碎片化"><a href="#1-2-谷歌如何解决碎片化" class="headerlink" title="1.2 谷歌如何解决碎片化"></a>1.2 谷歌如何解决碎片化</h3><p>通用内核映像 (GKI) 项目通过统一核心内核并将 SoC 和板级支持从核心内核移至可加载模块中，解决了内核碎片化问题。GKI 内核为内核模块提供了稳定的内核模块接口 (KMI)，因此模块和内核可以独立进行更新。</p> <img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230217234449847.png" style="zoom: 80%;"><p>从图中可以看到，Google 会提供 KMI 接口，用于 vendor modules 和 GKI 的通讯。</p><blockquote><p>直白点说，就是谷歌把所有通用的Kernel放在了<code>Generic Kernel</code>里面，把通用的Moudules放在了<code>GKI Modules</code>里面。而与硬件强相关的，与各厂商紧密联系的模块放在了<code>Vendor Modules</code>里面。这样的好处是什么，我用户可以快速升级，只要到谷歌官网找到最新的GKI，就可以用上最新，最安全的Kernel！而与硬件强相关的，晚点升级也没事，既然手机能用，说明各大厂商对于驱动等早就适配好了。</p></blockquote><h3 id="1-3-GKI发展历程"><a href="#1-3-GKI发展历程" class="headerlink" title="1.3 GKI发展历程"></a>1.3 GKI发展历程</h3><p>Gogole GKI 分为下面两个阶段推进：</p><blockquote><p><em>•</em> I. GKI 兼容性：Android 11(R) + linux-5.4 require GKI compatibility test.</p><p><em>•</em> II. GKI 产品化：Android 12(S) + linux-5.x 及之后 require GKI kernel</p></blockquote><p><strong>GKI 1.0 - GKI 兼容性要求</strong></p><p>对于 Android 11 平台版本，为了保证与 Treble 兼容，必须对运行 v5.4 内核的设备进行 GKI 测试。</p><p>具备 GKI 兼容性是指设备通过将 GKI 启动映像刷写到 <code>boot</code> 分区并将 GSI 系统映像刷写到 <code>system</code> 分区来安装通用系统映像 (GSI) 和 GKI 内核，因此通过了 VTS 和 CTS-on-GSI+GKI 测试。设备可以附带不同的产品内核，并且可以使用 GKI 未提供的可加载模块。不过，产品内核和 GKI 内核都必须从相同的 <code>vendor_boot</code> 和 <code>vendor</code> 分区加载模块。因此，所有产品内核都必须具有相同的二进制内核模块接口 (KMI)。供应商可以扩展产品内核的 KMI，前提是它与 GKI KMI 兼容。GKI 1.0 不要求供应商模块可卸载。</p><p><strong>GKI 2.0 - GKI 产品</strong></p><p>搭载 Android S (2021) 平台版本且使用内核版本 v5.x（5.x 是 2020 年年底被选为 LTS 的内核版本）或更高版本的设备必须附带 GKI 内核。将提供已签名的启动映像，并通过 LTS 和重大问题修复定期对其进行更新。由于 KMI 将保持二进制稳定性，因此无需对供应商映像进行任何更改，即可安装这些启动映像。</p><h2 id="2-GKI后各镜像的变化"><a href="#2-GKI后各镜像的变化" class="headerlink" title="2.GKI后各镜像的变化"></a>2.GKI后各镜像的变化</h2><h3 id="2-1-boot分区变化"><a href="#2-1-boot分区变化" class="headerlink" title="2.1 boot分区变化"></a>2.1 boot分区变化</h3><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230219232030518.png" style="zoom:67%;"><p><code>boot</code> 分区包括头文件、内核以及内含启动 ramdisk 通用部分的 CPIO 归档。</p><p><code>boot</code> 分区使用 v3 版启动头文件后，先前的 <code>boot</code> 分区的以下部分将不复存在：</p><ul><li>第二阶段引导加载程序：如果设备具有第二阶段引导加载程序，则必须将相应引导加载程序存储在自己的分区中。</li><li>DTB：DTB 存储在供应商启动分区中。</li></ul><p><code>boot</code> 分区包含一个 CPIO压缩包，内含以下 GKI 组件：</p><ul><li>位于 <code>/lib/modules/</code> 的 GKI 内核模块</li><li><code>first_stage_init</code> 及其依赖的库</li><li><code>fastbootd</code> 和 <code>recovery</code>（用于 A&#x2F;B 和虚拟 A&#x2F;B 设备）</li></ul><h3 id="2-2-出现vendor-boot分区"><a href="#2-2-出现vendor-boot分区" class="headerlink" title="2.2 出现vendor_boot分区"></a>2.2 出现vendor_boot分区</h3><p><code>vendor_boot</code> 分区随 GKI 引入。该分区是采用A&#x2F;B 分区，包含一个头文件、供应商 ramdisk 和设备树 Blob。vendor ramdisk 是一个 CPIO 压缩包，其中包含设备启动所需的供应商模块。这包括用于启用关键 SoC 功能的模块，以及启动设备和显示启动画面所需的存储和显示驱动程序。</p><p>该 CPIO 压缩包包含：</p><ul><li>第一阶段 <code>init</code> 供应商内核模块，位于 <code>/lib/modules/</code></li><li><code>modprobe</code> 配置文件，位于 <code>/lib/modules</code></li><li><code>modules.load</code> 文件，用于指示要在第一阶段 <code>init</code> 期间加载的模块</li></ul><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><blockquote><p>全志的文档写的太好，非常感谢😸</p></blockquote><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230219232422846.png"><p>上图是 boot 分区支持 GKI 的变化情况，这张图很有指导意义，其中关键点有：</p><ul><li>boot.img 变为 boot.img + vendor-boot.img，其中 boot.img 中放的是 GKI 镜像 + ramdisk，<u>vendor-boot.img 中放的是需要启动加载的 vendor 模块 ko</u>；</li><li>启动过程中，需要 bootloader 加载并整合 boot.img 和 vendor-boot.img中的两个ramdisk</li><li>与 GKI 对应的，Google 还推出 GSI，也就是通用 system 镜像；</li><li>vendor.img 可以存放不需要要启动加载的 ko，这个跟以前是一样的。</li></ul><p>bootloader 开发需要注意的地方有：</p><ul><li>boot header V3.0</li><li>DTB 的存放位置从 boot.img 改到了 vendor-boot</li><li>启动过程中 boot 需要加载 boot.img 和 vendor-boot.img 中的 ramdisk 并做整合，而且 boot.img 的 ramdisk 优先级高</li></ul><h3 id="2-4-ramdisk拼接"><a href="#2-4-ramdisk拼接" class="headerlink" title="2.4 ramdisk拼接"></a>2.4 ramdisk拼接</h3><ul><li>Android 11中，ramdisk 分为两份，一份为<strong>boot_ramdisk</strong>，存放在 <strong>boot.img</strong>中。一份为<strong>vendor_boot_ramdisk</strong> 存放在 <strong>vendor_boot.img</strong> 中。</li><li>在 bootloader 启动时需要先后加载 boot_ramdisk，vendor_boot_ramdisk 并进行前后拼接。</li><li>ramdisk 用的是 cpio.lz4 格式，可以进行简单的首尾拼接，<u><strong>但是 bootloader 需要注意两个ramdisk 中间必须紧密拼接，不能对齐再拼接，否则会导致内核解压时失败</strong></u>，同时拼接后改变ramdisk 的大小。</li></ul><h2 id="3-如何下载最新的GKI"><a href="#3-如何下载最新的GKI" class="headerlink" title="3.如何下载最新的GKI"></a>3.如何下载最新的GKI</h2><h3 id="3-1-安卓官网描述"><a href="#3-1-安卓官网描述" class="headerlink" title="3.1 安卓官网描述"></a>3.1 安卓官网描述</h3><p>Android官网：<a href="https://source.android.com/docs/core/architecture/kernel/gki-android12-5_10-release-builds?hl=zh-cn">https://source.android.com/docs/core/architecture/kernel/gki-android12-5_10-release-builds?hl=zh-cn</a></p><p>如果要使用<code>boot.img</code>，选择boot-xxx.img</p><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230221223931378.png" alt="image-20230221223931378" style="zoom:67%;"><p>如果使用GKI，则点击kernel，选择image</p><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230221224045860.png" alt="image-20230221224045860" style="zoom:67%;"><blockquote><p>boot-xxx.img中的kernel和这个image是完全一模一样的！！！</p></blockquote><h3 id="3-2-全志文档"><a href="#3-2-全志文档" class="headerlink" title="3.2 全志文档"></a>3.2 全志文档</h3><p>根据全志文档，Android 12下载编译流程如下：</p><p><strong>1）下载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir android-kernel<br>cd android-kernel/<br>repo init -u https://android.googlesource.com/kernel/manifest -b common-android12-5.4<br>repo sync<br>repo start --all android12-5.4<br></code></pre></td></tr></table></figure><p><strong>2） 使用 Google 源码编译 GKI 镜像</strong></p><p>在 google 源码目录下运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">BUILD_BOOT_IMG=1 SKIP_VENDOR_BOOT=1 KERNEL_BINARY=Image GKI_RAMDISK_PREBUILT_BINARY=gki-<br>ramdisk.img BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh<br></code></pre></td></tr></table></figure><p>编译过程中在 LTO vmlinux.o 阶段可能会卡主一段时间（大概十分钟），属于正常现场，第一次编译会比较耗时。</p><p>编译完成以后，boot.img存放在<code>android-kernel/out/android12-5.4/dist/boot.img</code></p><h2 id="4-GKI启动流程"><a href="#4-GKI启动流程" class="headerlink" title="4. GKI启动流程"></a>4. GKI启动流程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">boot0<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">uboot: 加载boot.img中的GKI和ramdisk_1，加载vendor-boot.img的ramdisk_2，整合ramdisk_1和</span><br>ramdisk_2,jump to GKI<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">GKI: core kernel init</span><br>--&gt; kernel init： load modules ko<br>--&gt; android bringup<br></code></pre></td></tr></table></figure><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><ul><li><a href="https://bbs.16rd.com/thread-583693-1-1.html">https://bbs.16rd.com/thread-583693-1-1.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/240117889">https://zhuanlan.zhihu.com/p/240117889</a></li><li><a href="https://source.android.com/docs/core/architecture/kernel/generic-kernel-image?hl=zh-cn">https://source.android.com/docs/core/architecture/kernel/generic-kernel-image?hl=zh-cn</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>udev设备管理</title>
    <link href="/2023/02/16/udev%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <url>/2023/02/16/udev%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="udev设备管理器"><a href="#udev设备管理器" class="headerlink" title="udev设备管理器"></a>udev设备管理器</h1><p>🍋🍋🍋<strong>十分推荐阅读</strong>：<a href="http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf">http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf</a></p><h2 id="1-为什么会出现udev"><a href="#1-为什么会出现udev" class="headerlink" title="1.为什么会出现udev"></a>1.为什么会出现udev</h2><p><strong>devfs</strong>(设备文件系统)是由Linux2.4内核引入的，当时被许多工程师基于了高度的评价，devfs的出现使得设备驱动程序能够自主的管理自己的设备文件。比如，可以通过程序在设备初始化的时候在 &#x2F;dev 目录下创建设备文件，卸载时将他删除，而且设备驱动程序可以指定设备名，所有者和权限位，而且用户空间程序可以修改所有者和权限位，并且不再需要为设备驱动程序分配主设备号以及次设备号，在程序中可以直接给 register_chrdev()传递0主设备号用来获取可用的主设备号。并且可以在 devfs_register() 中指定次设备号。</p><p>🦋尽管devfs有这样和那样的优点，但是，在Linux 2.6内核中，devfs被认为是过时的方法，并最终被抛弃了，<strong>udev取代了它</strong>。</p><p>🐬<strong>Linux VFS内核维护者Al Viro指出了几点udev取代devfs的原因：</strong></p><ul><li>devfs所做的工作被确信可以在用户态来完成。</li><li>devfs被加入内核之时，大家期望它的质量可以迎头赶上</li><li>发现devfs有一些可修复和无法修复的bug。</li><li>对于可修复的bug，几个月前就已经被修复了，其维护者认为一切良好</li><li>对于后者，在相当长的一段时间内没有改观</li><li>devfs的维护者和作者对它感到失望并且已经停止了对代码的维护工作</li></ul><h2 id="2-udev简介"><a href="#2-udev简介" class="headerlink" title="2.udev简介"></a>2.udev简介</h2><p>udev是一个设备管理工具，**<u>udev以守护进程的形式运行</u>**，通过侦听内核发出来的uevent来管理&#x2F;dev目录下的设备文件。udev在用户空间运行，而不在内核空间 运行。它能够根据系统中的硬件设备的状态动态更新设备文件，包括设备文件的创建，删除等。设备文件通常放在&#x2F;dev目录下。使用udev后，在&#x2F;dev目录下就只包含系统中真正存在的设备。</p><blockquote><p><strong>DEVFS与UDEV的一个显著区别：</strong></p><ul><li>采用devfs，当一个<strong>并不存在的&#x2F;dev节点</strong>被打开的时候，devfs能<strong>自动加载对应的驱动</strong>，而<strong>udev则不这么做</strong></li><li>这是因为udev的设计者认为Linux应该在设备被发现的时候加载驱动模块，而不是当它被访问的时候。udev的设计者认为devfs所提供的打开&#x2F;dev节点时自动加载驱动的功能<strong>对一个配置正确的计算机来说是多余的</strong>。系统中所有的设备都应该产生热插拔事件并加载恰当的驱动， 而udev能注意到这点并且为它创建对应的设备节点</li></ul></blockquote><h2 id="3-udev的配置文件"><a href="#3-udev的配置文件" class="headerlink" title="3.udev的配置文件"></a>3.udev的配置文件</h2><p>主要的udev配置文件是&#x2F;etc&#x2F;udev&#x2F;udev.conf文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">udev_root=<span class="hljs-string">&quot;/dev/&quot;</span><br><br>udev_rules=<span class="hljs-string">&quot;/etc/udev/rules.d/&quot;</span><br><br>udev_log=<span class="hljs-string">&quot;err&quot;</span><br></code></pre></td></tr></table></figure><ul><li>udev_root：代表着设备文件添加到哪。</li><li>udev_rules：代表着udev的规则存储的目录。这个目录存储的是以.rules结束的文件。每一个文件处理一系列规则来帮助udev分配名字给设备文件以保证能被内核识别。你的&#x2F;etc&#x2F;udev&#x2F;rules.d下面可能有好几个udev规则文件，这些文件一部分是udev包安装的，另外一部分则是可能是别的硬件或者软件包生成的。该目录下有多个文件时，udev读取文件是按照文件名的ASCII字母顺序来读取的，如果udev一旦找到了与新加入的设备匹配的规则，udev 就会根据规则定义的措施对新设备进行配置。同时不再读后续的规则文件。</li><li>udev_log：代表着udev的日志级别，用syslog记录错误信息。</li></ul><h2 id="4-udev的工作流程图"><a href="#4-udev的工作流程图" class="headerlink" title="4.udev的工作流程图"></a>4.udev的工作流程图</h2><img src="/2023/02/16/udev%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20230215234615127.png" style="zoom:80%;"><h2 id="5-udev的匹配规则"><a href="#5-udev的匹配规则" class="headerlink" title="5.udev的匹配规则"></a>5.udev的匹配规则</h2><p>在&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;文件夹下有一系列的.rules文件，在这些文件中有一些匹配规则：</p><h3 id="5-1-udev规则的所有操作符"><a href="#5-1-udev规则的所有操作符" class="headerlink" title="5.1 udev规则的所有操作符"></a>5.1 udev规则的所有操作符</h3><ul><li><p>&#x3D;&#x3D; ：比较键、值，若等于，则该条件满足；</p></li><li><p>!&#x3D;  ：比较键、值，若不等于，则该条件满足；</p></li><li><p>&#x3D;   ：对一个键赋值；</p></li><li><p>+&#x3D; ：为一个表示多个条目的键赋值。</p></li><li><p>:&#x3D;  ：对一个键赋值，并拒绝之后所有对该键的改动。目的是防止后面的规则文件对该键赋值。</p></li></ul><h3 id="5-2-udev规则的匹配键"><a href="#5-2-udev规则的匹配键" class="headerlink" title="5.2 udev规则的匹配键"></a>5.2 <strong>udev规则的匹配键</strong></h3><ul><li>ACTION：事件(uevent)的行为，例如：add(添加设备)、remove(删除设备)。</li><li>KERNEL：内核设备名称，例如：sda,cdrom。</li><li>DEVPATH：设备的devpath路径。</li><li>SUBSYSTEM：设备的子系统名称，例如：sda的子系统为block。</li><li>BUS：设备在devpath 里的总线名称，例如：usb。</li><li>DRIVER：设备在devpath 里的设备驱动名称，例如：ide-cdrom。</li><li>ID：设备在devpath 里的识别号。</li><li>SYSFS{filename}：设备的devpath 路径下，设备的属性文件“filename”里的内容。</li></ul><blockquote><p>例如：SYSFS{model}&#x3D;&#x3D;“ST936701SS”表示：如果设备的型号为ST936701SS，则该设备匹配该匹配键。</p><p>在一条规则中，可以设定最多五条SYSFS的匹配键。</p></blockquote><ul><li>ENV{key}：环境变量。在一条规则中，可以设定最多五条环境变量的匹配键。</li><li>PROGRAM：调用外部命令。</li><li>RESULT：外部命令PROGRAM 的返回结果。例如：</li></ul><blockquote><p>PROGRAM&#x3D;&#x3D;”&#x2F;lib&#x2F;udev&#x2F;scsi_id-g -s $devpath”, RESULT&#x3D;&#x3D;“35000c50000a7ef67”</p><p>调用外部命令&#x2F;lib&#x2F;udev&#x2F;scsi_id查询设备的SCSIID，如果返回结果为35000c50000a7ef67，则该设备匹配该匹配键。</p></blockquote><h3 id="5-3-udev-的重要赋值键"><a href="#5-3-udev-的重要赋值键" class="headerlink" title="5.3 udev 的重要赋值键"></a>5.3 udev 的重要赋值键</h3><ul><li>NAME：在&#x2F;dev下产生的设备文件名。只有第一次对某个设备的NAME的赋值行为生效，之后匹配的规则再对该设备的NAME赋值行为将被忽略。如果没有任何规则对设备的NAME赋值，udev将使用内核设备名称来产生设备文件。</li><li>SYMLINK：为&#x2F;dev&#x2F;下的设备文件产生符号链接。由于udev只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的udev规则所产生的文件，推荐使用符号链接。</li><li>OWNER, GROUP, MODE：为设备设定权限。</li><li>ENV{key}：导入一个环境变量。</li><li>RUN:运行后面的程序。</li></ul><h3 id="5-4-udev-的值和可调用的替换操作符"><a href="#5-4-udev-的值和可调用的替换操作符" class="headerlink" title="5.4 udev 的值和可调用的替换操作符"></a>5.4 udev 的值和可调用的替换操作符</h3><p>在键值对中的键和操作符都介绍完了，最后是值(value)。Linux用户可以随意地定制udev规则文件的值。例如：my_root_disk,my_printer。同时也可以引用下面的替换操作符：</p><ul><li>$kernel, %k：设备的内核设备名称，例如：sda、cdrom。</li><li>$number, %n：设备的内核号码，例如：sda3的内核号码是3。</li><li>$devpath, %p：设备的devpath路径。</li><li>$id, %b：设备在devpath里的ID号。</li><li>$sysfs{file}，%s{file}：设备的sysfs里file的内容。其实就是设备的属性值。例如：sysfs{size}表示该设备(磁盘) 的大小。</li><li>$env{key}, %E{key}：一个环境变量的值。</li><li>$major, %M：设备的major号。</li><li>$minor %m：设备的minor号。</li><li>$result, %c：PROGRAM返回的结果。</li><li>$parent, %P：父设备的设备文件名。</li><li>$root, %r：udev_root的值，默认是&#x2F;dev&#x2F;。</li><li>$tempnode, %N：临时设备名。</li><li>%%：符号%本身。</li><li>$$： 符 号 ：符号：符号本身。</li></ul><p>注意：在匹配的过程中，要匹配所有的比较键都满足时，才算匹配成功。</p><h2 id="6-udev的使用方法"><a href="#6-udev的使用方法" class="headerlink" title="6.udev的使用方法"></a>6.udev的使用方法</h2><ol><li>使用udevadm 命令来查看设备的信息：在使用udev时需要获得该设备的一些信息，来用于匹配规则。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">udevadm info -a -p $(udevadm info -q path -n /dev/sdb)<br></code></pre></td></tr></table></figure><p>其中&#x2F;dev&#x2F;sdb是插入设备后设备在&#x2F;dev下的名字。</p><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs shell">Udevadm info starts with the device specified by the devpath and then<br>walks up the chain of parent devices. It prints for every device<br>found, all possible attributes in the udev rules key format.<br>A rule to match, can be composed by the attributes of the device<br>and the attributes from one single parent device.<br><br>  looking at device &#x27;/devices/pci0000:00/0000:00:10.0/host20/target20:0:1/20:0:1:0/block/sdb&#x27;:<br>    KERNEL==&quot;sdb&quot;<br>    SUBSYSTEM==&quot;block&quot;<br>    DRIVER==&quot;&quot;<br>    ATTR&#123;alignment_offset&#125;==&quot;0&quot;<br>    ATTR&#123;capability&#125;==&quot;50&quot;<br>    ATTR&#123;discard_alignment&#125;==&quot;0&quot;<br>    ATTR&#123;events&#125;==&quot;&quot;<br>    ATTR&#123;events_async&#125;==&quot;&quot;<br>    ATTR&#123;events_poll_msecs&#125;==&quot;-1&quot;<br>    ATTR&#123;ext_range&#125;==&quot;256&quot;<br>    ATTR&#123;hidden&#125;==&quot;0&quot;<br>    ATTR&#123;inflight&#125;==&quot;       0        0&quot;<br>    ATTR&#123;range&#125;==&quot;16&quot;<br>    ATTR&#123;removable&#125;==&quot;0&quot;<br>    ATTR&#123;ro&#125;==&quot;0&quot;<br>    ATTR&#123;size&#125;==&quot;41943040&quot;<br>    ATTR&#123;stat&#125;==&quot;      85        0     4184       20        0        0        0        0        0        8       20&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:10.0/host20/target20:0:1/20:0:1:0&#x27;:<br>    KERNELS==&quot;20:0:1:0&quot;<br>    SUBSYSTEMS==&quot;scsi&quot;<br>    DRIVERS==&quot;sd&quot;<br>    ATTRS&#123;blacklist&#125;==&quot;&quot;<br>    ATTRS&#123;device_blocked&#125;==&quot;0&quot;<br>    ATTRS&#123;device_busy&#125;==&quot;0&quot;<br>    ATTRS&#123;dh_state&#125;==&quot;detached&quot;<br>    ATTRS&#123;eh_timeout&#125;==&quot;10&quot;<br>    ATTRS&#123;evt_capacity_change_reported&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_inquiry_change_reported&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_lun_change_reported&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_media_change&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_mode_parameter_change_reported&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_soft_threshold_reached&#125;==&quot;0&quot;<br>    ATTRS&#123;inquiry&#125;==&quot;&quot;<br>    ATTRS&#123;iocounterbits&#125;==&quot;32&quot;<br>    ATTRS&#123;iodone_cnt&#125;==&quot;0x7a&quot;<br>    ATTRS&#123;ioerr_cnt&#125;==&quot;0x3&quot;<br>    ATTRS&#123;iorequest_cnt&#125;==&quot;0x7a&quot;<br>    ATTRS&#123;model&#125;==&quot;VMware Virtual S&quot;<br>    ATTRS&#123;queue_depth&#125;==&quot;32&quot;<br>    ATTRS&#123;queue_ramp_up_period&#125;==&quot;120000&quot;<br>    ATTRS&#123;queue_type&#125;==&quot;simple&quot;<br>    ATTRS&#123;rev&#125;==&quot;1.0 &quot;<br>    ATTRS&#123;scsi_level&#125;==&quot;3&quot;<br>    ATTRS&#123;state&#125;==&quot;running&quot;<br>    ATTRS&#123;timeout&#125;==&quot;180&quot;<br>    ATTRS&#123;type&#125;==&quot;0&quot;<br>    ATTRS&#123;vendor&#125;==&quot;VMware, &quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:10.0/host20/target20:0:1&#x27;:<br>    KERNELS==&quot;target20:0:1&quot;<br>    SUBSYSTEMS==&quot;scsi&quot;<br>    DRIVERS==&quot;&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:10.0/host20&#x27;:<br>    KERNELS==&quot;host20&quot;<br>    SUBSYSTEMS==&quot;scsi&quot;<br>    DRIVERS==&quot;&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:10.0&#x27;:<br>    KERNELS==&quot;0000:00:10.0&quot;<br>    SUBSYSTEMS==&quot;pci&quot;<br>    DRIVERS==&quot;mptspi&quot;<br>    ATTRS&#123;broken_parity_status&#125;==&quot;0&quot;<br>    ATTRS&#123;class&#125;==&quot;0x010000&quot;<br>    ATTRS&#123;config&#125;==&quot;&quot;<br>    ATTRS&#123;consistent_dma_mask_bits&#125;==&quot;32&quot;<br>    ATTRS&#123;d3cold_allowed&#125;==&quot;0&quot;<br>    ATTRS&#123;device&#125;==&quot;0x0030&quot;<br>    ATTRS&#123;dma_mask_bits&#125;==&quot;32&quot;<br>    ATTRS&#123;driver_override&#125;==&quot;(null)&quot;<br>    ATTRS&#123;enable&#125;==&quot;1&quot;<br>    ATTRS&#123;irq&#125;==&quot;17&quot;<br>    ATTRS&#123;local_cpulist&#125;==&quot;0-3&quot;<br>    ATTRS&#123;local_cpus&#125;==&quot;00000000,00000000,00000000,0000000f&quot;<br>    ATTRS&#123;msi_bus&#125;==&quot;1&quot;<br>    ATTRS&#123;numa_node&#125;==&quot;-1&quot;<br>    ATTRS&#123;revision&#125;==&quot;0x01&quot;<br>    ATTRS&#123;subsystem_device&#125;==&quot;0x1976&quot;<br>    ATTRS&#123;subsystem_vendor&#125;==&quot;0x15ad&quot;<br>    ATTRS&#123;vendor&#125;==&quot;0x1000&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00&#x27;:<br>    KERNELS==&quot;pci0000:00&quot;<br>    SUBSYSTEMS==&quot;&quot;<br>    DRIVERS==&quot;&quot;<br></code></pre></td></tr></table></figure><ol start="2"><li>编写.rules文件的规则：进入&#x2F;etc&#x2F;udev&#x2F;rules.d文件夹：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc/udev/rules.d<br></code></pre></td></tr></table></figure><p>新建文件10-usb.rules：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi 10-usb.rules<br></code></pre></td></tr></table></figure><p>在10-usb.rules文件中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">KERNEL==&quot;sdb&quot;,SUBSYSTEM==&quot;block&quot;,ACTION==&quot;add&quot;,SYMLINK+=&quot;USB_link&quot;<br></code></pre></td></tr></table></figure><p>然后保存，退出。</p><ol start="3"><li>使得udev文件生效的方法：通常，使得配置后的文件生效，需要采用热插拔的方法更新udev规则，不过有更简单的方法如下：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">udevadm test /sys/class/block/sdb<br></code></pre></td></tr></table></figure><p>4.结果如下：在&#x2F;dev文件夹下</p><img src="/2023/02/16/udev%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/20201228214401604.png"><h2 id="7-热插拔能自动设备，冷插拔怎么办？"><a href="#7-热插拔能自动设备，冷插拔怎么办？" class="headerlink" title="7.热插拔能自动设备，冷插拔怎么办？"></a>7.热插拔能自动设备，冷插拔怎么办？</h2><p>由于冷插拔的设备开机时就已经存在，在udev启动前已经被插入。针对这种情况，sysfs下的设备都存在uevent文件，向该文件写一个“add”,内核会重新发送netlink，之后udev就可以收到设备的详细信息了，从而创建&#x2F;dev下对应的设备节点。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://blog.csdn.net/chengziwang/article/details/111873757">https://blog.csdn.net/chengziwang/article/details/111873757</a></li><li><a href="https://gitee.com/low-level-of-logic/RaspberryPi/blob/master/docs/">https://gitee.com/low-level-of-logic/RaspberryPi/blob/master/docs/</a></li><li><a href="https://blog.csdn.net/woyimibayi/article/details/78320915">https://blog.csdn.net/woyimibayi/article/details/78320915</a></li><li><a href="http://m.wfuyu.com/server/23483.html">http://m.wfuyu.com/server/23483.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【实验】/dev目录无法同时挂载两个文件系统</title>
    <link href="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="【实验】-x2F-dev目录无法同时挂载两个文件系统"><a href="#【实验】-x2F-dev目录无法同时挂载两个文件系统" class="headerlink" title="【实验】&#x2F;dev目录无法同时挂载两个文件系统"></a>【实验】&#x2F;dev目录无法同时挂载两个文件系统</h1><p>先介绍一下我的开发板，NXP的IMX6ULL，里面是原生的Linux内核，版本为<code>4.1.5</code>。</p><p>下面开始做实验，证明&#x2F;dev目录无法同时挂载两个文件系统。</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p><strong>1.开机后查看当前的挂载的设备</strong></p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215220652226.png" alt="image-20230215220652226" style="zoom:67%;"><blockquote><p>可以看到此时devtmpfs大小为88.3M</p></blockquote><p><strong>2.尝试手动挂载&#x2F;dev</strong></p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215220610703.png" alt="image-20230215220610703" style="zoom:67%;"><p>我们知道tmpfs挂载后默认是RAM的一半</p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215220830308.png" alt="image-20230215220830308" style="zoom:67%;"><blockquote><p>可以发现devtmpfs跟随tmpfs一起办成了RAM的一半大小</p></blockquote><p><strong>3.再次确认挂载情况</strong></p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215220510027.png"><p><strong>4.查看此时&#x2F;dev目录是否正常</strong></p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215221013735.png"><blockquote><p>此时&#x2F;dev目录下为空，访问不到任何目录</p></blockquote><h2 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h2><p>通过实验我们可以发现：</p><ul><li>可以同时给<code>/dev</code>挂载两个文件系统，但是有问题</li><li>当系统以<code>devtmpfs</code>挂载后，再次以<code>tmpfs</code>挂载后，<code>devtmpfs</code>会随<code>tmpfs</code>大小一起变化，如果<code>tmpfs</code>挂载时不指明大小，默认为内存的一半</li><li>给<code>/dev</code>挂载两个文件系统后，<code>/dev</code>目录无法正常访问</li></ul><p><strong>说明：本文水平有限，可能存在诸多问题，请指正！</strong></p>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tmpfs文件系统与安卓</title>
    <link href="/2023/02/14/tmpfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%89%E5%8D%93/"/>
    <url>/2023/02/14/tmpfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%89%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="tmpfs文件系统与安卓"><a href="#tmpfs文件系统与安卓" class="headerlink" title="tmpfs文件系统与安卓"></a>tmpfs文件系统与安卓</h1><h2 id="1-什么是tmpfs文件系统"><a href="#1-什么是tmpfs文件系统" class="headerlink" title="1.什么是tmpfs文件系统"></a>1.什么是tmpfs文件系统</h2><p>先来看一下Kernel文档对于tmpfs文件系统的描述：<a href="https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt">https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">Tmpfs is a file system <span class="hljs-built_in">which</span> keeps all files <span class="hljs-keyword">in</span> virtual memory.<br><br>Everything <span class="hljs-keyword">in</span> tmpfs is temporary <span class="hljs-keyword">in</span> the sense that no files will be created on your hard drive. If you unmount a tmpfs instance, everything stored there <span class="hljs-keyword">in</span> is lost.<br><br>tmpfs puts everything into the kernel internal caches and grows andshrinks to accommodate the files it contains and is able to swap unneeded pages out to swap space. It has maximum size limits <span class="hljs-built_in">which</span> can be adjusted on the fly via <span class="hljs-string">&#x27;mount -o remount ...&#x27;</span><br><br>If you compare it to ramfs (<span class="hljs-built_in">which</span> was the template to create tmpfs) you gain swapping and <span class="hljs-built_in">limit</span> checking. Another similar thing is the RAMdisk (/dev/ram*), <span class="hljs-built_in">which</span> simulates a fixed size hard disk <span class="hljs-keyword">in</span> physical RAM, <span class="hljs-built_in">where</span> you have to create an ordinary filesystem on top. Ramdisks cannot swap and you <span class="hljs-keyword">do</span> not have the possibility to resize them. <br></code></pre></td></tr></table></figure><ul><li><p>tmpfs是一个将所有文件保存在虚拟内存中的文件系统。</p></li><li><p>tmpfs中的所有内容都是临时的，因为不会在硬盘上创建任何文件。如果卸载tmpfs实例，存储在其中的所有东西都丢失了</p></li><li><p>tmpfs将所有内容放入内核内部缓存，并进行增长和收缩以容纳其中包含的文件，并能够将不需要的页面交换出来以交换空间。它具有size限制，可以通过“mount-o remount…”进行动态调整</p></li><li><p>如果将其与ramfs（创建tmpfs的模板）进行比较，则会获得交换和限制检查。另一个类似的东西是RAMdisk（&#x2F;dev&#x2F;ram*），它在物理ram中模拟固定大小的硬盘，您必须在上面创建一个普通的文件系统。Ramdisks无法互换，您无法调整其大小。</p></li></ul><p><strong>我们总结一下tmpfs的特点：</strong></p><ol><li>由于是构建在内存中，存放在tmpfs中的所有数据在卸载或者断后丢失。【临时性】</li><li>内存的访问速度远远大于磁盘IO操作，即使使用了虚拟内存，性能仍然优于磁盘。【快速读写】</li><li>tmpfs一开始使用很小的空间，但是随着文件的复制和创建，tmpfs文件系统会分配更多的内存，并按照需求动态增加文件系统的空间，而且tmpfs文件系统会动态缩小文件并释放内存资源</li><li>像普通块设备需要mkfs格式化文件系统后才可以使用，但是tmpfs是独立的文件系统，只要挂载就可以使用。</li></ol><h2 id="2-Android中的tmpfs文件系统"><a href="#2-Android中的tmpfs文件系统" class="headerlink" title="2.Android中的tmpfs文件系统"></a>2.Android中的tmpfs文件系统</h2><p>Android中挂载tmpfs文件系统的时机主要在安卓init进程中的第一阶段挂载和第二阶段挂载【基于Android S】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FirstStageMain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br><br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/dev&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="hljs-string">&quot;mode=0755&quot;</span>));<br>    <br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/mnt&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=1000&quot;</span>));<br>    <br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/debug_ramdisk&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=0&quot;</span>));<br>    <br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, kSecondStageRes, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=0&quot;</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br># --------------------------------------------------------------------------------------<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SecondStageMain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-built_in">MountExtraFilesystems</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">MountExtraFilesystems</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// /apex is used to mount APEXes</span><br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/apex&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=0&quot;</span>));<br><br>    <span class="hljs-comment">// /linkerconfig is used to keep generated linker configuration</span><br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/linkerconfig&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=0&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看一下安卓真实运行环境中的挂载情况</p><img src="/2023/02/14/tmpfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%89%E5%8D%93/image-20230214223605505.png" style="zoom:80%;"><p>🐖【个人猜想】为什么类似&#x2F;dev，&#x2F;apex这种需要使用tmpfs文件系统：</p><ul><li>像安卓的设备创建后都在&#x2F;dev目录下，驱动会以&#x2F;dev&#x2F;xxx的文件形式存在，所以会发生大量的IO操作，显然使用tmpfs更快</li><li>像ART，VNDK等都存在于&#x2F;apex中，安卓启动的时候虚拟机ART创建都在&#x2F;apex中</li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://www.bilibili.com/video/BV1HG4y1K76E/">https://www.bilibili.com/video/BV1HG4y1K76E/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手动挂载apex包到loop设备</title>
    <link href="/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/"/>
    <url>/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="【实验】手动挂载apex镜像"><a href="#【实验】手动挂载apex镜像" class="headerlink" title="【实验】手动挂载apex镜像"></a>【实验】手动挂载apex镜像</h1><h2 id="1-loop设备"><a href="#1-loop设备" class="headerlink" title="1.loop设备"></a>1.loop设备</h2><p>在类 UNIX 系统里，loop 设备是一种伪设备(pseudo-device)，或者也可以说是仿真设备。它能使我们像块设备一样访问一个文件。</p><p>这要先从mount的流程来理解，挂载操作，实际上就是把设备上的文件系统&#x2F;目录文件连接到指定的目录（directory）下，在操作系统层面就是把挂载设备和挂载目录的对应关系加到内核中的Vfsmount里的对应表单里（内核启动后会从硬盘上加载到内存里），这样我们就可以通过访问目录路径来访问设备上的数据了。</p><p>loop mount是另一种mount方式，如果说普通mount解决了实际硬件存储设备的挂载，bind mount解决了目录到目录的挂载，那么loop mount则解决了将<strong>档案文件</strong>到目录的挂载</p><p>档案，英文Archive，与文件（file）不同，是一个打包好的文件集，里面一般包含许多文件, 比如 tar，jar，iso ，img就是常见的档案格式</p><p>那又是怎么实现将档案文件挂载到目录下呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs she">实际上，系统先把档案文件（比如某个.iso文件）映射到loop设备上<br>#losetup  /dev/loop0   xxxx.iso        使系统误认为xxxx.iso为存储设备/dev/loop0<br><br>再欺骗mount命令，使他认为  /dev/loop0真的是个设备在运行，挂载到指定目录<br>#mount   -t   xxxx.iso   /dev/loop0    /loop设备路径    <br><br></code></pre></td></tr></table></figure><p>但前提是，被访问的loop设备里的档案文件具有linux识别的文件系统，像tar, jar, zip 这样的档案，只是一种压缩格式，本身不是文件系统，即使通过loop mount挂载上去了，直接访问他也读不出什么数据，这很好理解，就像在windows下不装任何解压软件，就无法打开压缩文件一样。<u><strong>所有一般我们都是拿img、iso映射到loop设备。</strong></u></p><h2 id="2-apex包结构"><a href="#2-apex包结构" class="headerlink" title="2.apex包结构"></a>2.apex包结构</h2><p>APEX文件格式如下</p><img src="/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/20200601191934566.png"><p>从顶层看，APEX文件是一个Zip文件，其中的文件均是未压缩的。</p><p>其中的四个文件有<code>apex_manifest.json</code>，<code>AndroidManifest.xml</code>，<code>apex_pubkey</code>，<code>apex_payload.img</code></p><ul><li><p>apex_manifest.json文件包括package name和版本，用来标识该APEX文件</p></li><li><p>AndroidManifest.xml可以允许APEX文件使用一些apk的工具，像adb、package manager、 app install app等。举个例子APEX文件可以使用aapt检查文件的metadata。该文件还包括packcage name和版本号，这些内容通常也会再apex_manifest.json文件中。</p></li><li><p>apex_payload.img是依赖dm-verity的EXT4文件系统镜像。该镜像在运行时通过一个回环设备加载。具体地说，metadata和hash tree是通过libavb创建的。apex_payload.img还没有被解析，因为要求该文件是可挂载的。一些常规文件包含在该镜像中。</p></li><li><p>apex_pubkey是用来给文件系统签名的公钥。该公钥确保下载的apex文件是以编译阶段相同的方式签名。</p></li></ul><h2 id="3-开始实验"><a href="#3-开始实验" class="headerlink" title="3.开始实验"></a>3.开始实验</h2><ol><li><p><strong>将apex解压缩，上传到Linux中</strong></p><img src="/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/image-20230204111723539.png"></li></ol><p>其实apex包就是个压缩包，将后缀名改成<code>.zip</code>，自行使用Windows解压工具进行解压</p><p><strong>上传后我们可以看下它的文件结构和它的文件系统属性</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Android/system$ file apex_payload.img <br>apex_payload.img: Linux rev 1.0 ext2 filesystem data, UUID=7d1522e1-9dfa-5edb-a43e-98e3a4d20250 (extents) (large files) (huge files)<br><br>amx@amxxxx:~/Android/system$ tune2fs -l apex_payload.img <br>tune2fs 1.44.5 (15-Dec-2018)<br>Filesystem volume name:   &lt;none&gt;<br>Last mounted on:          &lt;not available&gt;<br>Filesystem UUID:          7d1522e1-9dfa-5edb-a43e-98e3a4d20250<br>Filesystem magic number:  0xEF53<br>Filesystem revision <span class="hljs-comment">#:    1 (dynamic)</span><br>Filesystem features:      ext_attr dir_index filetype extent sparse_super large_file huge_file uninit_bg dir_nlink extra_isize shared_blocks<br>Filesystem flags:         signed_directory_hash <br>Default mount options:    user_xattr acl<br>Filesystem state:         clean<br>Errors behavior:          Continue<br>Filesystem OS <span class="hljs-built_in">type</span>:       Linux<br>Inode count:              32<br>Block count:              8213<br>Reserved block count:     0<br>Free blocks:              8<br>Free inodes:              5<br>First block:              0<br>Block size:               4096<br>Fragment size:            4096<br>Blocks per group:         32768<br>Fragments per group:      32768<br>Inodes per group:         32<br>Inode blocks per group:   2<br>Filesystem created:       Thu Jan  1 08:00:01 1970<br>Last mount time:          n/a<br>Last write time:          Thu Jan  1 08:00:01 1970<br>Mount count:              0<br>Maximum mount count:      -1<br>Last checked:             Thu Jan  1 08:00:01 1970<br>Check interval:           0 (&lt;none&gt;)<br>Lifetime writes:          32 MB<br>Reserved blocks uid:      0 (user root)<br>Reserved blocks gid:      0 (group root)<br>First inode:              11<br>Inode size:               256<br>Required extra isize:     32<br>Desired extra isize:      32<br>Default directory <span class="hljs-built_in">hash</span>:   half_md4<br>Directory Hash Seed:      7d1522e1-9dfa-5edb-a43e-98e3a4d20250<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>查看当前空闲的loop设备</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Android/system$ sudo losetup -f<br>/dev/loop0<br></code></pre></td></tr></table></figure><p>可以看到当前空闲的loop设备为<code>/dev/loop0</code>，所以我们打算将apex与&#x2F;dev&#x2F;loop0进行关联</p><ol start="3"><li><strong>将apex镜像与loop设备关联</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Android/system$ sudo losetup /dev/loop0 apex_payload.img<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>将loop设备挂载到目标节点上</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Android/system$ sudo mount -o ro /dev/loop0 /home/amx/Android/apex/com.android.i18n<br></code></pre></td></tr></table></figure><p>这里我模仿了安卓将它挂载到了<code>/home/amx/Android/apex/com.android.i18n</code></p><blockquote><p>这里只能使用ro只读形式挂载，因为apex_playload.img采用了ext4文件系统，且在文件系统中添加了<code>shared_block</code>属性，该属性不允许随意修改镜像文件，也是为了将镜像文件尽量压缩到最小（从名字就可以看出来共享块）。这里可以通过改变inode结构改变这个属性，但是有点难度，需要了解ext文件系统才行。</p></blockquote><ol start="5"><li><strong>查看是否挂载成功</strong></li></ol><img src="/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/image-20230204111215939.png"><p>可以看到我们可以像访问块设备一样访问apex包啦</p><ol start="6"><li><strong>说明</strong></li></ol><p>真实的安卓环境中是先system&#x2F;apex下面的apex包挂载到对应的版本目录下，例如adb会先挂载到<code>/apex/com.android.adb@300009</code>，然后再将<code>/apex/com.android.adb@300009</code>以bind方式挂载到<code>/apex/com.android.adb</code></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><ul><li><a href="https://blog.csdn.net/shengxia1999/article/details/52081286?spm=1001.2014.3001.5506">https://blog.csdn.net/shengxia1999/article/details/52081286?spm=1001.2014.3001.5506</a></li><li><a href="https://blog.csdn.net/qq_28351465/article/details/106458089?spm=1001.2014.3001.5506">https://blog.csdn.net/qq_28351465/article/details/106458089?spm=1001.2014.3001.5506</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓开机动画</title>
    <link href="/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <url>/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓S开机动画流程"><a href="#安卓S开机动画流程" class="headerlink" title="安卓S开机动画流程"></a>安卓S开机动画流程</h1><p>开机动画是<strong>在SurfaceFlinger实例通过调用startBootAnim()启动的</strong>，BootAnim是如何启动和结束的，总体框架图如下：</p><img src="/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/整体架构2.png"><h2 id="1-SurfaceFlinger进程启动"><a href="#1-SurfaceFlinger进程启动" class="headerlink" title="1.SurfaceFlinger进程启动"></a>1.SurfaceFlinger进程启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">/frameworks/native/services/surfaceflinger/surfaceflinger.rc</span><br>service surfaceflinger /system/bin/surfaceflinger<br>    class core animation<br>    user system<br>    group graphics drmrpc readproc<br>    capabilities SYS_NICE<br>    onrestart restart zygote<br>    task_profiles HighPerformance<br>    socket pdx/system/vr/display/client     stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0<br>    socket pdx/system/vr/display/manager    stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0<br>    socket pdx/system/vr/display/vsync      stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0<br><br></code></pre></td></tr></table></figure><p>init进程会根据surfaceflinger.rc配置启动surfaceflinger进程，surfaceflinger进程(&#x2F;system&#x2F;bin&#x2F;surfaceflinger)启动，会走到main函数里面。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">/frameworks/native/services/surfaceflinger/Android.bp</span><br>filegroup &#123;<br>    name: &quot;surfaceflinger_binary_sources&quot;,<br>    srcs: [<br>        &quot;:libsurfaceflinger_sources&quot;,<br>        &quot;main_surfaceflinger.cpp&quot;,<br>    ],<br>&#125;<br><br>cc_binary &#123;<br>    name: &quot;surfaceflinger&quot;,<br>    defaults: [&quot;libsurfaceflinger_binary&quot;],<br>    init_rc: [&quot;surfaceflinger.rc&quot;],<br>    srcs: [<br>        &quot;:surfaceflinger_binary_sources&quot;,<br>        // Note: SurfaceFlingerFactory is not in the filegroup so that it<br>        // can be easily replaced.<br>        &quot;SurfaceFlingerFactory.cpp&quot;,<br>    ],<br>    shared_libs: [<br>        &quot;libSurfaceFlingerProp&quot;,<br>    ],<br><br>     logtags: [&quot;EventLog/EventLogTags.logtags&quot;],<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到编译surfaceflinger二进制进程的源文件为<code>surfaceflinger_binary_sources</code>和<code>SurfaceFlingerFactory.cpp</code>，其中surfaceflinger_binary_sources来源于<code>main_surfaceflinger.cpp</code></p><h2 id="2-注册启动surfaceflinger服务"><a href="#2-注册启动surfaceflinger服务" class="headerlink" title="2.注册启动surfaceflinger服务"></a>2.注册启动surfaceflinger服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// /frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>**)</span> </span>&#123;<br><span class="hljs-comment">// ...</span><br><br>    sp&lt;SurfaceFlinger&gt; flinger = surfaceflinger::<span class="hljs-built_in">createSurfaceFlinger</span>(); <span class="hljs-comment">//创建surfaceflinger服务实例</span><br><br><span class="hljs-comment">// ...</span><br>    flinger-&gt;<span class="hljs-built_in">init</span>();  <span class="hljs-comment">// 初始化flinger实例</span><br><br>    <span class="hljs-comment">// 向ServiceManager注册surfaceflinger服务</span><br>    <span class="hljs-function">sp&lt;IServiceManager&gt; <span class="hljs-title">sm</span><span class="hljs-params">(defaultServiceManager())</span></span>;<br>    sm-&gt;<span class="hljs-built_in">addService</span>(<span class="hljs-built_in">String16</span>(SurfaceFlinger::<span class="hljs-built_in">getServiceName</span>()), flinger, <span class="hljs-literal">false</span>,<br>                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);<br><br><span class="hljs-comment">// ...</span><br><br>    flinger-&gt;<span class="hljs-built_in">run</span>();   <span class="hljs-comment">// 启动surfaceflinger服务</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用SurfaceFlinger对象的init方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    mStartPropertySetThread = <span class="hljs-built_in">getFactory</span>().<span class="hljs-built_in">createStartPropertySetThread</span>(presentFenceReliable);<br><br>    <span class="hljs-keyword">if</span> (mStartPropertySetThread-&gt;<span class="hljs-built_in">Start</span>() != NO_ERROR) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Run StartPropertySetThread failed!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Done initializing&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>SurfaceFlinger调用init方法时会获取mStartPropertySetThread，调用该对象的Start方法，其实是准备启动一个线程去启动BootAnimation</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// /frameworks/native/services/surfaceflinger/StartPropertySetThread.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">StartPropertySetThread::Start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;SurfaceFlinger::StartPropertySetThread&quot;</span>, PRIORITY_NORMAL);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StartPropertySetThread::threadLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Set property service.sf.present_timestamp, consumer need check its readiness</span><br>    <span class="hljs-built_in">property_set</span>(kTimestampProperty, mTimestampPropertyValue ? <span class="hljs-string">&quot;1&quot;</span> : <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-comment">// 清除BootAnimation退出标志位service.bootanim.exit</span><br>    <span class="hljs-built_in">property_set</span>(<span class="hljs-string">&quot;service.bootanim.exit&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-comment">// 设置bootanim的进度为0</span><br>    <span class="hljs-built_in">property_set</span>(<span class="hljs-string">&quot;service.bootanim.progress&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-comment">// 通过service.bootanim.exit</span><br>    <span class="hljs-built_in">property_set</span>(<span class="hljs-string">&quot;ctl.start&quot;</span>, <span class="hljs-string">&quot;bootanim&quot;</span>);<br>    <span class="hljs-comment">// 立即退出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里一开始看起来比较疑惑，首先是StartPropertySetThread::Start函数，在<code>StartPropertySetThread.h</code>表明StartPropertySetThread继承自父类Thread，而父类Thread是由&lt;utils&#x2F;Thread.h&gt; 引入的，所以这里是子类引用父类方法，这里的run函数就是就是thread的run方法。这里会启动一个线程去运行，线程名为”StartPropertySetThread”，线程优先级为PRIORITY_NORMAL。线程启动以后，最终会调用 <code>_threadLoop</code> 函数，它会去调用threadLoop函数。这里整个函数调用栈就清楚了：</li></ul><img src="/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/线程函数调用.png"><ul><li>当系统属性发生改变时，init进程就会接收到一个系统属性变化通知，这个通知最终是由在init进程中的函数handle_property_set_fd来处理</li></ul><h2 id="3-bootanim进程启动"><a href="#3-bootanim进程启动" class="headerlink" title="3.bootanim进程启动"></a>3.bootanim进程启动</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// /frameworks/base/cmds/bootanimation/bootanimation_main.cpp</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    setpriority(PRIO_PROCESS, <span class="hljs-number">0</span>, ANDROID_PRIORITY_DISPLAY);<br><br>    <span class="hljs-type">bool</span> noBootAnimation = bootAnimationDisabled();<br>    ALOGI_IF(noBootAnimation,  <span class="hljs-string">&quot;boot animation disabled&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!noBootAnimation) &#123;<br>        <span class="hljs-comment">// 启动Binder线程池</span><br>        sp&lt;ProcessState&gt; <span class="hljs-title function_">proc</span><span class="hljs-params">(ProcessState::self())</span>;<br>        ProcessState::self()-&gt;startThreadPool();<br>        <br>        sp&lt;BootAnimation&gt; boot = new BootAnimation(audioplay::createAnimationCallbacks());<br><br>        waitForSurfaceFlinger();<br>        <br>        boot-&gt;run(<span class="hljs-string">&quot;BootAnimation&quot;</span>, PRIORITY_DISPLAY);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">bootAnimationDisabled</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> value[PROPERTY_VALUE_MAX];<br>    <span class="hljs-comment">// 如果debug.sf.nobootanimation=1，则不会显示动画</span><br>    property_get(<span class="hljs-string">&quot;debug.sf.nobootanimation&quot;</span>, value, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-keyword">if</span> (atoi(value) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-comment">// 如果ro.boot.quiescent=1，则不显示开机动画</span><br>    property_get(<span class="hljs-string">&quot;ro.boot.quiescent&quot;</span>, value, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-keyword">if</span> (atoi(value) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Only show the bootanimation for quiescent boots if this system property is set to enabled</span><br>        <span class="hljs-keyword">if</span> (!property_get_bool(<span class="hljs-string">&quot;ro.bootanim.quiescent.enabled&quot;</span>, <span class="hljs-literal">false</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断完BootAnimation是不是disabled之后，如果noBootAnimation为false，则创建一个BootAnimation对象。创建完了BootAnimation对象后，调用其run方法，由于BootAnimation也继承了Thread，所以最终也会走到对应的threadLoop方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BootAnimation::threadLoop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> r;<br><br>    <span class="hljs-keyword">if</span> (mZipFileName == <span class="hljs-literal">NULL</span>) &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r = <span class="hljs-built_in">movie</span>();  <span class="hljs-comment">// 调用movie方法</span><br>    &#125;<br>    <span class="hljs-comment">// 销毁 opengl 和 egl</span><br>    <span class="hljs-built_in">eglMakeCurrent</span>(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);<br>    <span class="hljs-built_in">eglDestroyContext</span>(mDisplay, mContext);<br>    <span class="hljs-built_in">eglDestroySurface</span>(mDisplay, mSurface);<br>    mFlingerSurface.<span class="hljs-built_in">clear</span>();<br>    mFlingerSurfaceControl.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">eglTerminate</span>(mDisplay);<br>    IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">stopProcess</span>();<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BootAnimation::movie</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    String8 desString;<br>    <span class="hljs-comment">// 读取 desc.txt 配置文件</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;desc.txt&quot;</span>, desString)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">char</span> <span class="hljs-type">const</span>* s = desString.<span class="hljs-built_in">string</span>();<br><br>    <span class="hljs-comment">// 解析描述文件</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;pcount ; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r=<span class="hljs-number">0</span> ; !part.count || r&lt;part.count ; r++) &#123;<br>            <span class="hljs-comment">// opengl 绘制操作</span><br>            <span class="hljs-built_in">glClearColor</span>(<br>                    part.backgroundColor[<span class="hljs-number">0</span>],<br>                    part.backgroundColor[<span class="hljs-number">1</span>],<br>                    part.backgroundColor[<span class="hljs-number">2</span>],<br>                    <span class="hljs-number">1.0f</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j=<span class="hljs-number">0</span> ; j&lt;fcount &amp;&amp; (!<span class="hljs-built_in">exitPending</span>() || part.playUntilComplete) ; j++) &#123;<br>                <span class="hljs-function"><span class="hljs-type">const</span> Animation::Frame&amp; <span class="hljs-title">frame</span><span class="hljs-params">(part.frames[j])</span></span>;<br>                <span class="hljs-type">nsecs_t</span> lastFrame = <span class="hljs-built_in">systemTime</span>();<br>                ...<br>                <span class="hljs-keyword">if</span> (r &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, frame.tid);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ...<br>                    <span class="hljs-built_in">initTexture</span>(frame);<br>                &#125;<br>                <br>                <span class="hljs-comment">// specify the y center as ceiling((mHeight - animation.height) / 2)</span><br>                <span class="hljs-comment">// which is equivalent to mHeight - (yc + animation.height)</span><br>                <span class="hljs-built_in">glDrawTexiOES</span>(xc, mHeight - (yc + animation.height),<br>                              <span class="hljs-number">0</span>, animation.width, animation.height);<br>                <span class="hljs-built_in">eglSwapBuffers</span>(mDisplay, mSurface);<br><br>                <span class="hljs-comment">// 不断绘制时检测是否需要退出</span><br>                <span class="hljs-built_in">checkExit</span>();<br>            &#125;<br>            <span class="hljs-comment">// 如果退出了就跳出结束绘制</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exitPending</span>() &amp;&amp; !part.count)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// free the textures for this part</span><br>        <span class="hljs-keyword">if</span> (part.count != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j=<span class="hljs-number">0</span> ; j&lt;fcount ; j++) &#123;<br>                <span class="hljs-function"><span class="hljs-type">const</span> Animation::Frame&amp; <span class="hljs-title">frame</span><span class="hljs-params">(part.frames[j])</span></span>;<br>                <span class="hljs-built_in">glDeleteTextures</span>(<span class="hljs-number">1</span>, &amp;frame.tid);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 读取 service.bootanim.exit 值是否是 1 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXIT_PROP_NAME <span class="hljs-string">&quot;service.bootanim.exit&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BootAnimation::checkExit</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Allow surface flinger to gracefully request shutdown</span><br>    <span class="hljs-type">char</span> value[PROPERTY_VALUE_MAX];<br>    <span class="hljs-built_in">property_get</span>(EXIT_PROP_NAME, value, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-type">int</span> exitnow = <span class="hljs-built_in">atoi</span>(value);<br>    <span class="hljs-keyword">if</span> (exitnow) &#123;<br>        <span class="hljs-built_in">requestExit</span>();<br>        <span class="hljs-keyword">if</span> (mAudioPlayer != <span class="hljs-literal">NULL</span>) &#123;<br>            mAudioPlayer-&gt;<span class="hljs-built_in">requestExit</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动动画底层采用的是 opengles 的方式来渲染绘制的，绘制的内容是本地的一个启动动画资源包，在绘制的过程中会不断的判断是否需要退出，读取的字段是 service.bootanim.exit ，为 1 代表需要 break 退出循环绘制。因此我们只需要找到 service.bootanim.exit 在哪里设置为 1 的，便可找到退出启动动画的入口。关闭动画的入口还是在 SurfaceFlinger 中只是这个调用流程比较复杂而已：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(IBinder token,</span></span><br><span class="hljs-params"><span class="hljs-function">                                boolean clearHide, boolean isForward, boolean reallyResume)</span> </span>&#123;<br>    ActivityClientRecord r = <span class="hljs-built_in">performResumeActivity</span>(token, clearHide);<br>    <span class="hljs-keyword">if</span> (r != null) &#123;<br>        <span class="hljs-keyword">if</span> (!r.onlyLocalRequest) &#123;<br>            r.nextIdle = mNewActivities;<br>            mNewActivities = r;<br>            <span class="hljs-comment">// 添加了一个 IdleHandler 消息</span><br>            Looper.<span class="hljs-built_in">myQueue</span>().<span class="hljs-built_in">addIdleHandler</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Idler</span>());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> Idler implements MessageQueue.IdleHandler &#123;<br>    @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> boolean <span class="hljs-built_in">queueIdle</span>() &#123;<br>        ActivityClientRecord a = mNewActivities;<br>        <span class="hljs-keyword">if</span> (a != null) &#123;<br>            mNewActivities = null;<br>            IActivityManager am = ActivityManagerNative.<span class="hljs-built_in">getDefault</span>();<br>            ActivityClientRecord prev;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (a.activity != null &amp;&amp; !a.activity.mFinished) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 调用 AMS 的 activityIdle</span><br>                        am.<span class="hljs-built_in">activityIdle</span>(a.token, a.createdConfig, stopProfiling);<br>                    &#125; <span class="hljs-built_in">catch</span> (RemoteException ex) &#123;<br>                        <span class="hljs-comment">// Ignore</span><br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">while</span> (a != null);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><br>@<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">activityIdle</span><span class="hljs-params">(IBinder token, Configuration config, boolean stopProfiling)</span> </span>&#123;<br>    <span class="hljs-built_in">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        ActivityStack stack = ActivityRecord.<span class="hljs-built_in">getStackLocked</span>(token);<br>        <span class="hljs-keyword">if</span> (stack != null) &#123;<br>            ActivityRecord r = mStackSupervisor.<span class="hljs-built_in">activityIdleInternalLocked</span>(token, <span class="hljs-literal">false</span>, config);<br>        &#125;<br>    &#125;<br>    Binder.<span class="hljs-built_in">restoreCallingIdentity</span>(origId);<br>&#125;<br><br><span class="hljs-comment">// Checked.</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> ActivityRecord <span class="hljs-title">activityIdleInternalLocked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> IBinder token, boolean fromTimeout,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                Configuration config)</span> </span>&#123;<br>    ActivityRecord r = ActivityRecord.forTokenLocked(token);<br>    <span class="hljs-keyword">if</span> (r != null) &#123;<br>        ...<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFrontStack</span>(r.task.stack) || fromTimeout) &#123;<br>                booting = <span class="hljs-built_in">checkFinishBootingLocked</span>();<br>            &#125;<br>    &#125;<br>    ...<br>        <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> boolean <span class="hljs-title">checkFinishBootingLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> boolean booting = mService.mBooting;<br>    boolean enableScreen = <span class="hljs-literal">false</span>;<br>    mService.mBooting = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!mService.mBooted) &#123;<br>        mService.mBooted = <span class="hljs-literal">true</span>;<br>        enableScreen = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (booting || enableScreen) &#123;<br>        mService.<span class="hljs-built_in">postFinishBooting</span>(booting, enableScreen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> booting;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enableScreenAfterBoot</span><span class="hljs-params">()</span> </span>&#123;<br>    mWindowManager.<span class="hljs-built_in">enableScreenAfterBoot</span>();<br>    <span class="hljs-built_in">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-built_in">updateEventDispatchingLocked</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">performEnableScreen</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">synchronized</span>(mWindowMap) &#123;<br>        <span class="hljs-keyword">if</span> (!mBootAnimationStopped) &#123;<br>            <span class="hljs-comment">// 向SurfaceFlinger 进程发起关闭开机界面的消息</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                IBinder surfaceFlinger = ServiceManager.<span class="hljs-built_in">getService</span>(<span class="hljs-string">&quot;SurfaceFlinger&quot;</span>);<br>                <span class="hljs-keyword">if</span> (surfaceFlinger != null) &#123;<br>                    Parcel data = Parcel.<span class="hljs-built_in">obtain</span>();<br>                    data.<span class="hljs-built_in">writeInterfaceToken</span>(<span class="hljs-string">&quot;android.ui.ISurfaceComposer&quot;</span>);<br>                    <span class="hljs-comment">// 向SurfaceComposer发送</span><br>                    surfaceFlinger.<span class="hljs-built_in">transact</span>(IBinder.FIRST_CALL_TRANSACTION, <span class="hljs-comment">// BOOT_FINISHED</span><br>                                            data, null, <span class="hljs-number">0</span>);<br>                    data.<span class="hljs-built_in">recycle</span>();<br>                &#125;<br>            &#125; <span class="hljs-built_in">catch</span> (RemoteException ex) &#123;<br>                ...<br>            &#125;<br>            mBootAnimationStopped = <span class="hljs-literal">true</span>;<br>        &#125;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ----------------------------------------------------------------------</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ISurfaceComposerTag</span> &#123;<br>    BOOT_FINISHED = IBinder::FIRST_CALL_TRANSACTION,<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// /frameworks/native/libs/gui/ISurfaceComposer.cpp</span><br><span class="hljs-type">status_t</span> BnSurfaceComposer::<span class="hljs-built_in">onTransact</span>(<br>    <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-type">uint32_t</span> flags)&#123;<br>    <span class="hljs-keyword">switch</span>(code) &#123;<br>            <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">case</span> BOOT_FINISHED: &#123;<br>            <span class="hljs-built_in">CHECK_INTERFACE</span>(ISurfaceComposer, data, reply);<br>            <span class="hljs-built_in">bootFinished</span>();<br>            <span class="hljs-keyword">return</span> NO_ERROR;<br>        &#125;<br>            <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// ----------------------------------------------------------------------</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::bootFinished</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 把 service.bootanim.exit 属性设置为 1 ，bootanim 进程读到 1 时就会退出开机启动动画</span><br>    <span class="hljs-built_in">property_set</span>(<span class="hljs-string">&quot;service.bootanim.exit&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭开机启动动画的流程还是比较复杂的，我们来缕一缕整个逻辑，我们的 Launcher 进程启动后会启动我们 Launcher Activity 界面，而 Activity 的生命周期调用都是由 ActivityThread 来执行的，其中就会执行到 handleResumeActivity 方法，在该方法中会添加一个 IdleHandler 消息，会调用到 AMS 的 activityIdle 方法，AMS 会调用 WMS 的 enableScreenAfterBoot 方法，WMS 会跨进程通知 SurfaceFlinger 去关闭我们的开机启动动画。</p><h2 id="4-开机动画包里有什么"><a href="#4-开机动画包里有什么" class="headerlink" title="4.开机动画包里有什么"></a>4.开机动画包里有什么</h2><p>这里建议先看一下官方文档：&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;bootanimation&#x2F;FORMAT.md</p><p>开机动画指的是以bootanimation.zip方式存在，启动的时候会依次选择一个bootanimation.zip加载</p><ol><li>&#x2F;system&#x2F;media&#x2F;bootanimation-encrypted.zip (if getprop(“vold.decrypt”) &#x3D; ‘1’)</li><li>&#x2F;system&#x2F;media&#x2F;bootanimation.zip</li><li>&#x2F;oem&#x2F;media&#x2F;bootanimation.zip</li></ol><p><code>bootanimation.zip</code> 文件中包含：</p><img src="/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/压缩文件.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">desc.txt - a text file<br>part0  \<br>part1   \  directories full of PNG frames<br>...     /<br>partN  /<br></code></pre></td></tr></table></figure><p><strong>“desc.txt”</strong>：<strong>用来描述用户自定义的开机动画是如何显示的</strong>。</p><p>以下面的例子为例：</p><blockquote><p>1280 720 1</p><p>p 1 1 part0</p><p>p 0 1 part1</p></blockquote><p>第一行的三个数字分别表示开机动画在屏幕中的显示宽度、高度以及帧速(fps)。剩余的每一行都用来描述一个动画片断，这些行必须要以字符“p”来开头，后面紧跟着两个数字以及一个文件目录路径名称。</p><p>第一个数字表示一个片断的循环显示次数，如果它的值等于0，那么就表示无限循环地显示该动画片断。</p><p>第二个数字表示每一个片断在两次循环显示之间的时间间隔。这个时间间隔是以一个帧的时间为单位的。</p><p>文件目录下面保存的是一系列png文件，这些png文件会被依次显示在屏幕中。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul><li><a href="https://blog.51cto.com/u_11176305/3796348">https://blog.51cto.com/u_11176305/3796348</a></li><li><a href="https://www.cnblogs.com/lufeibin/p/13529981.html">https://www.cnblogs.com/lufeibin/p/13529981.html</a></li><li><a href="https://blog.csdn.net/weixin_36044720/article/details/117277602?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_36044720/article/details/117277602?spm=1001.2014.3001.5506</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-Treble计划</title>
    <link href="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/"/>
    <url>/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<ul><li>🕊️本文来自视频：<a href="https://www.youtube.com/watch?v=zbebx1Kvqho">https://www.youtube.com/watch?v=zbebx1Kvqho</a></li><li>引用部分博客：<a href="https://new.qq.com/rain/a/20191016A070PF00">https://new.qq.com/rain/a/20191016A070PF00</a></li><li><a href="https://www.freesion.com/article/69471423144/">https://www.freesion.com/article/69471423144/</a></li></ul><h2 id="1-Andriod进入Treble之前存在什么问题"><a href="#1-Andriod进入Treble之前存在什么问题" class="headerlink" title="1.Andriod进入Treble之前存在什么问题"></a>1.Andriod进入Treble之前存在什么问题</h2><p>在Android 8.0（Android Oreo）之前那个时代，苹果手机一旦有了新的系统更新，用户都能在短时间内更新系统，对用户来说实在太简单了，用户只需要点击更新下载新系统就可以完美的拥有最新的系统功能。而对于安卓用户而言，当安卓发布新的源码以后，会经过下面一系列的操作，用户才能用上真正的全新安卓系统。</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/生成过程.png" style="zoom: 80%;"><ol><li>发布源码：Google将新系统源码发布至AOSP</li><li>启动硬件适配：芯片制造商如<strong>三星</strong>、<strong>高通</strong>、<strong>联发科</strong>、<strong>华为</strong>等对源码进行修改，确保自家的芯片在新版Android能正常运行和发挥性能</li><li>OEM适配：OEM 厂商进一步修改新系统</li><li>OEM测试：OEM 厂商对系统进行内部测试</li><li>推送给用户：试无误后的新版系统通过 OTA 推送给用户</li></ol><p>这样带来的问题是什么，用谷歌开发团队的话来说，整个过程会花费5-12个月的时间……寄🐓</p><p>虽然Google在提交AOSP源码上非常迅速，但是芯片制造商和OEM厂商往往因为技术问题、第三方系统定制原因等导致整体的进程偏慢，最终形成了用户茫茫然的等待，从以往的数据统计我们也可以看出，Android手机中新系统的覆盖率寥寥无几。</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/licheng.png" style="zoom: 50%;"><blockquote><p>可以看到自从安卓8.0退出Treble以来，安卓9.0开始突飞猛进，更新的用户几乎是8.0的一倍</p></blockquote><h2 id="2-Treble计划"><a href="#2-Treble计划" class="headerlink" title="2.Treble计划"></a>2.Treble计划</h2><h3 id="2-1-Treble简介"><a href="#2-1-Treble简介" class="headerlink" title="2.1 Treble简介"></a>2.1 Treble简介</h3><p>Android 8.0 版本的一项新元素是 Project Treble。这是 Android架构方面的一项重大改变，主要解决Android 版本碎片化问题，更方便快捷的升级到最新版本。其中最核心的一点是将AOSP代码和供应商（Vendor）代码做好解耦。贴一张张架构前后的对比图：</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/架构变化.png"><ul><li>升级前：Framework代码和Vendor的代码耦合，即使谷歌发布会完最新AOSP代码，设备厂商也需要花费很多时间处理和Vendor代码适配问题【Reworked】，所以升级会花费很大量的时间</li></ul><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/新架构.png"><ul><li>新的架构：Treble在Framework和Vendor实现代码中间定义一个稳定的接口，这样Framework代码和Vendor的代码实现解耦，这样设备厂商能够快速的升级AOSP，只要接口不变，系统还能正常起来。</li></ul><p>下面我们具体看一下以前的Framework层和HAL层是怎么交互的？</p><p><strong>Android O之前版本的框架：</strong></p><p>在此之前的Android 系统架构当中，Android Framework 与Android HAL是打包成一个system.img的，而且Framework 与HAL之间是紧耦合的，通过链接的方式使用相应的硬件相关so库。老版本的android 的系统框架当中framework与HAL之间的一般架构框架是：</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/框架.png"><p>所以每次Android framework的升级需要对应的Android HAL升级。所以这样每次Android 升级都需要Android 设备制造商投入大量的人力物理去升级相应的Vendor HAL Implemetation.</p><p><strong>Android O及之后的版本的框架：</strong></p><p>在Android O以及以后的版本当中，Android 更新了新的框架设计在新的框架设计当中，引入了一套叫HIDL的语言来定义Freamework与HAL之间的接口，新的架构如下图：</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/HIDL.png"><p>跟以往的Android 版本相比较，Android O里使用HIDL来解耦System Framework 与Vendor HAL Implemetation之间的关系【，从而简化降低Android系统升级的影响与难度。并且目前看起来，Android Framework与Vendor HAL Implemetation会存放在不同的分区当中，Android Framework会在system分区当中，而Vendor HAL Implemetation会在一个新定义的分区(Vendor.img)当中，这样刷新的system.img 才不会影响到Vendor HAL Implemetation。</p><p><strong>更清晰的调用关系</strong></p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/O之前.png" style="zoom:70%;"><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/O之后.png" style="zoom:70%;"><h3 id="2-2-Treble新技术"><a href="#2-2-Treble新技术" class="headerlink" title="2.2 Treble新技术"></a>2.2 Treble新技术</h3><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/架构对比.png"><p><strong>Treble架构中为了实现系统和供应商的分离，引入了许多新技术。关键技术包括：</strong></p><ul><li>HIDL：HAL接口定义语言，用于指定HAL和其他用户之间的接口的一直接口描述语言(IDL)</li><li>HAL：运行Android8.0或者更高版本的设备必须支持使用HIDL语言编写的HAL，分为binderized HAL（绑定式）和passthrough HAL（直通式）。</li><li>设备树叠加层(DTO)：将设备数(DT)分割为主DT和叠加DT。叠加DT由ODM厂商提供，存放在ODM分区。通过对叠加DT的修改升级，可以实现在DT中增加设备节点和修改设备属性。</li><li>供应商原生开发套件(VNDK)：提供了一组让供应商实现其HAL的专用库。</li><li>供应商接口对象(VINTF)：用于汇总设备的相关信息并通过可查询的API提供该信息。</li><li>SELinux：Android8.0实现SELinux策略的模块化和兼容性，目标是使SOC供应商和ODM生产商能够以隔离方式自定义SELinux配置，而无需跨分区修改。</li></ul><h2 id="修改历史"><a href="#修改历史" class="headerlink" title="修改历史"></a>修改历史</h2><ul><li>2023&#x2F;01&#x2F;14：首次编写《Android-Treble计划》</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何搭建hexo部署到github</title>
    <link href="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/"/>
    <url>/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/</url>
    
    <content type="html"><![CDATA[<blockquote><p>🏓本文的内容是记录搭建hexo博客，并且部署到github上<br>🐖哈哈哈，我就是课代表<br>🍔所有内容均来自于：<strong>B站CodeSheep</strong></p></blockquote><h2 id="1-安装Nodejs"><a href="#1-安装Nodejs" class="headerlink" title="1.安装Nodejs"></a>1.安装Nodejs</h2><h3 id="1-1-安装Nodejs"><a href="#1-1-安装Nodejs" class="headerlink" title="1.1 安装Nodejs"></a>1.1 安装Nodejs</h3><p>Nodejs官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/nodejs安装.png" alt="image-20230114121402814" style="zoom: 67%;"><p>直接无脑下一步安装，安装完成后<code>node -v</code>查看版本确认是否安装成功</p><h3 id="1-2-更换镜像"><a href="#1-2-更换镜像" class="headerlink" title="1.2 更换镜像"></a>1.2 更换镜像</h3><p>由于npm包管理工具实在太慢了，所以打算使用淘宝镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>最后可以通过<code>cnpm -v</code>查看一下cnpm是否安装成功</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/安装npm.png" alt="image-20230114121402814" style="zoom: 67%;"><h2 id="2-安装Hexo并初始化hexo项目"><a href="#2-安装Hexo并初始化hexo项目" class="headerlink" title="2.安装Hexo并初始化hexo项目"></a>2.安装Hexo并初始化hexo项目</h2><h3 id="2-1-安装hexo"><a href="#2-1-安装hexo" class="headerlink" title="2.1 安装hexo"></a>2.1 安装hexo</h3><p>先通过npm安装hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装完成以后，可以通过<code>hexo -v</code> 查看是否安装成功</p><h3 id="2-2-初始化hexo项目"><a href="#2-2-初始化hexo项目" class="headerlink" title="2.2 初始化hexo项目"></a>2.2 初始化hexo项目</h3><ol><li>本地创建一个文件夹，用于存放hexo的所有内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir hexo-blog<br></code></pre></td></tr></table></figure><ol start="2"><li>进入该项目文件夹，进行初始化</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br></code></pre></td></tr></table></figure><ol start="3"><li>本地打开该项目</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>通过<code>localhost:4000</code>进行访问</p><h3 id="2-3-创建一个新的项目"><a href="#2-3-创建一个新的项目" class="headerlink" title="2.3 创建一个新的项目"></a>2.3 创建一个新的项目</h3><p>创建自己的新博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new &quot;如何搭建hexo部署到github&quot;<br></code></pre></td></tr></table></figure><p>生成静态文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><p>启动项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>通过<code>localhost:4000</code>进行访问</p><h2 id="3-将hexo部署到github"><a href="#3-将hexo部署到github" class="headerlink" title="3.将hexo部署到github"></a>3.将hexo部署到github</h2><h3 id="3-1-新建一个github仓库"><a href="#3-1-新建一个github仓库" class="headerlink" title="3.1 新建一个github仓库"></a>3.1 新建一个github仓库</h3><blockquote><p>这里需要注意一下，创建的仓库名必须与你的username是一样的，比如我的usrname是anmuxixixi，则创建的仓库名为anmuxixixi.github.io；详情见GitHub如何创建一个Page</p></blockquote><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/创建github.jpg" alt="image-20230114121402814" style="zoom: 60%;"><h3 id="3-2-安卓hexo针对git的deploy组件"><a href="#3-2-安卓hexo针对git的deploy组件" class="headerlink" title="3.2 安卓hexo针对git的deploy组件"></a>3.2 安卓hexo针对git的deploy组件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/安装插件.png" alt="image-20230114121402814" style="zoom: 80%;"><h3 id="3-2-部署到github"><a href="#3-2-部署到github" class="headerlink" title="3.2 部署到github"></a>3.2 部署到github</h3><p>打开项目的<code>_config.xml</code>，设置<code>deploy</code>属性</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/设置deploy.png" alt="image-20230114121402814" style="zoom: 80%;"><blockquote><p> 这个repo对应的仓库名就是我们的<strong>github仓库地址</strong></p></blockquote><p>将其部署到github上</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo cl</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>浏览器输入<code>https://anmuxixixi.github.io/</code></p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/打开仓库.png" alt="image-20230114121402814" style="zoom: 50%;"><h2 id="4-设置主题"><a href="#4-设置主题" class="headerlink" title="4.设置主题"></a>4.设置主题</h2><h3 id="4-1-安装主题"><a href="#4-1-安装主题" class="headerlink" title="4.1 安装主题"></a>4.1 安装主题</h3><ul><li>Hexo官方设置主题的网站：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></li><li>Fluid主题：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></li><li>Fluid主题文档：<a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></li></ul><p>打开github，下载好Fluid主题，将其解压放在themes文件夹下</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/下载主题.png" alt="image-20230114121402814" style="zoom: 80%;"><p>打开<code>_config.xml</code>，设置<code>theme</code>为<code>fluid</code>，设置<code>language</code>为<code>zh-CN</code></p><p>启动后看下整体的效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><h3 id="4-2-简单的页面设置"><a href="#4-2-简单的页面设置" class="headerlink" title="4.2 简单的页面设置"></a>4.2 简单的页面设置</h3><ol><li>修改网页导航栏标题</li></ol><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/修改网页标题.png" alt="image-20230114203236266" style="zoom:67%;"><p>其对应的效果如下</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/标题栏.png"><ol start="2"><li>修改背景图片</li></ol><p>自己复制一张图片，将名字修改为<code>default.png</code></p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/背景.png"><ol start="3"><li>修改中间打字机文字</li></ol><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/打字机.png" alt="image-20230114203653973" style="zoom:79%;"><ol start="4"><li>整体效果如下</li></ol><p><a href="https://anmuxixixi.github.io/">https://anmuxixixi.github.io/</a></p><p>欢迎品尝🌭</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/zhengti.png">]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
