<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>struct结构体内存对齐</title>
    <link href="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://www.cnblogs.com/hyacinthLJP/p/16041690.html">https://www.cnblogs.com/hyacinthLJP/p/16041690.html</a></p><p>作者： <a href="https://www.cnblogs.com/hyacinthLJP">MElephant</a></p></blockquote><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>我们自定义两个结构体 A 和 B：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c1;<br>    <span class="hljs-type">char</span> c2;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> d;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c1;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> c2;<br>    <span class="hljs-type">double</span> d;<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过定义我们可以看出，结构体 A 和 B 拥有相同的成员，只不过在排列顺序上有所不同；</p><p>众所周知，char 类型占 1 个字节，int 类型占 4 个字节，double 类型占 8 个字节</p><p>那么，这两个结构体所占内存空间大小为多少呢？占用的空间是否相同？</p><p>空口无凭，让我们通过编译器告诉我们答案（我使用的是 VS2022，X86）。</p><p>在 main() 函数中输出如下语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;结构体A所占内存大小为：%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(A));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;结构体B所占内存大小为：%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(B));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行之前，先盲猜一个结果：</p><p> <code>sizeof(A) = sizeof(B) = sizeof(c1)+sizeof(c2)+sizeof(i)+sizeof(d) = 1+1+4+8 = 14</code></p><p>到底对不对呢？让我们来看看运行结果：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322175926325-808092561.png" alt="img" style="zoom: 80%;"><p>amazing~~</p><p>竟然一个都没猜对，这究竟是怎么回事呢？</p><p>下面开始进入今天的主题——struct 内存对齐。</p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>一种提高内存访问速度的策略，CPU 在访问未对齐的内存可能需要经过两次的内存访问，而经过内存对齐一次就可以了。</p><p>假定现在有一个 32 位处理器，那这个处理器一次性读取或写入都是四字节。</p><p>假设现在有一个 32 位处理器要读取一个 int 类型的变量，在内存对齐的情况下，处理器是这样进行读取的：</p><p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322180540589-204374352.png" alt="img" style="zoom:80%;">那如果数据存储没有按照内存对齐的方式进行的话，处理器就会这样进行读取：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322180810600-1218351587.png" alt="img" style="zoom:80%;"><p>对比内存对齐和内存没有对齐两种情况我们可以明显地看到，在内存对齐的情况下，取得这个 int型 变量只需要经过一次寻址（0~3）；</p><p>但在内存没有对齐的情况下，取得这个 int型 变量需要经过两次的寻址（0<del>3 和 4</del>7），然后再合并数据。</p><p>通过上述的分析，我们可以知道内存对齐能够提升性能，这也是我们要进行内存对齐的原因之一。</p><h2 id="内存对齐的原则"><a href="#内存对齐的原则" class="headerlink" title="内存对齐的原则"></a>内存对齐的原则</h2><ol><li>对于结构体的各个成员，除了第一个成员的偏移量为 0 外，其余成员的偏移量是 其实际长度 的整数倍，如果不是，则在前一个成员后面补充字节。</li><li>结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍。</li><li>如程序中有 #pragma pack(n) 预编译指令，则所有成员对齐以 n字节 为准（即偏移量是n的整数倍），不再考虑当前类型以及最大结构体内类型。</li></ol><p>下面通过样例来分享一下我的见解，为方便理解，声明如下：</p><ul><li>定义的结构体包含 char , short , int , double类型各一个，并通过不同的组合构造出不同的结构体 Test01 , Test02 , Test03 , Test04</li><li>内存地址的编号设置为 0~24</li><li>char 类型占1 个 字节，并用橙色填充</li><li>short 类型占 2个 字节，并用黄色填充</li><li>int 类型占 4个 字节，并用绿色填充</li><li>double 类型占 8个 字节，并用蓝色填充</li><li>补充字节用黑色填充</li></ul><h3 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test01</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">short</span> s;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> d;<br>&#125;t1;<br></code></pre></td></tr></table></figure><p>内存分布情况：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322210431773-1594212085.png" alt="img" style="zoom:80%;"><ul><li>第一个成员 c 的偏移量为 0，所以成员 c 的内存空间的首地址为 0</li><li>第二个成员 s 的内存空间的首地址为 2 号地址，偏移量为 2 - 0 &#x3D; 2</li><li>第三个成员 i 的内存空间的首地址为 4 号地址，偏移量为 4 - 0 &#x3D; 4</li><li>第三个成员 d 的内存空间的首地址为 8 号地址，偏移量为 8 - 0 &#x3D; 8</li><li>Test01 所占内存大小为 16 个字节</li></ul><p>让我们通过输出来验证一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">showTest01</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test01所占内存大小：%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(Test01));<br>    <span class="hljs-comment">//并按照声明顺序输出 Test01 中的成员变量地址对应的十六进制</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;t1.c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;t1.s);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;t1.i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;t1.d);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322212203167-1077116233.png" alt="img" style="zoom:80%;"><p>我们将输出的十六进制地址转化为十进制：</p><blockquote><p> 00209400 -&gt; 2135040</p><p> 00209402 -&gt; 2135042</p><p> 00209404 -&gt; 2135044</p><p> 00209408 -&gt; 2135048</p></blockquote><ul><li>以第一个成员 c 的起始地址为起点</li><li>第二个成员 s 的偏移量为 2</li><li>第三个成员 i 的偏移量为 4</li><li>第四个成员 d 的偏移量为 8</li><li>所占内存大小为 16</li></ul><p>验证成功！</p><h3 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h3><p>调换一下成员顺序，再次测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test02</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">double</span> d;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">short</span> s;<br>&#125;t2;<br></code></pre></td></tr></table></figure><p>内存分布情况：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322213003845-1448339865.png" alt="img" style="zoom:80%;"><ul><li>第一个成员 c 的偏移量为 0，所以成员 c 的内存空间的首地址为 0</li><li>第二个成员 d 的内存空间的首地址为 8 号地址，偏移量为 8 - 0 &#x3D; 8（double 类型的整倍数）</li><li>第三个成员 i 的内存空间的首地址为 16 号地址，偏移量为 16 - 0 &#x3D; 16（int 类型的整倍数）</li><li>第三个成员 s 的内存空间的首地址为 20 号地址，偏移量为 20 - 0 &#x3D; 20（short 类型的整倍数）</li><li>Test02 所占内存大小为 24 个字节（结构体占用内存大小是结构体内最大数据成员 double 的最小整数倍：24 &#x2F; 8 &#x3D; 4）</li></ul><p>接着通过输出来验证一下：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322213218244-1085267920.png" alt="img" style="zoom:80%;"><p>我们将输出的十六进制地址转化为十进制：</p><blockquote><p> 007C9410 -&gt; 8164368</p><p> 007C9418 -&gt; 8164376</p><p> 007C9420 -&gt; 8164384</p><p> 007C9424 -&gt; 8164388</p></blockquote><ul><li>以第一个成员 c 的起始地址为起点</li><li>第二个成员 d 的偏移量为 8164376 - 8164368 &#x3D; 8 </li><li>第三个成员 i 的偏移量为 8164384 - 8164368 &#x3D; 16 </li><li>第四个成员 d 的偏移量为 8164388 - 8164368 &#x3D; 20 </li><li>所占内存大小为 24</li></ul><p>验证成功！</p><h3 id="实验3-amp-实验4"><a href="#实验3-amp-实验4" class="headerlink" title="实验3 &amp; 实验4"></a>实验3 &amp; 实验4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test03</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">short</span> s;<br>    <span class="hljs-type">double</span> d;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> i;<br>&#125;t3;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test04</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">double</span> d;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">short</span> s;<br>&#125;t4;<br></code></pre></td></tr></table></figure><p>内存分布情况：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322214300062-750016192.png" alt="img" style="zoom:80%;"><p>可自行输出验证！！！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过自行模拟，再回过头看看内存对齐的原则，是不是有种恍然大明白的感觉~</p><p>通过模拟上述不同情况，你会发现同种类型的成员变量通过不同的组合，所占用的总内存是不相同的；</p><p>那么，关于结构体内成员定义的顺序应该遵循这样一个原则：按照长度递增的顺序依次定义各个成员。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>System DE Master Key流程分析</title>
    <link href="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="System-DE-Master-Key流程分析"><a href="#System-DE-Master-Key流程分析" class="headerlink" title="System DE Master Key流程分析"></a>System DE Master Key流程分析</h1><blockquote><p>参考：<a href="https://blog.csdn.net/cs_tech/article/details/127593457?spm=1001.2014.3001.5506">https://blog.csdn.net/cs_tech/article/details/127593457?spm=1001.2014.3001.5506</a></p><p>仅作自己学习备忘，侵权联系删除</p></blockquote><h2 id="1-创建-System-DE-Master-Key-流程"><a href="#1-创建-System-DE-Master-Key-流程" class="headerlink" title="1. 创建 System DE Master Key 流程"></a>1. 创建 System DE Master Key 流程</h2><p>下图展示了在设备第一次启动时，创建 System DE Master Key 的完整流程，在这个章节会对其拆分，分别介绍。</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/b325b451b58545b2aa95646471b01109.png" alt="img" style="zoom:80%;"><h3 id="1-1-创建-System-DE-Master-Key"><a href="#1-1-创建-System-DE-Master-Key" class="headerlink" title="1.1 创建 System DE Master Key"></a>1.1 创建 System DE Master Key</h3><p>在 vold 函数 fscrypt_initialize_systemwide_keys 中，Vold 通过 keymaster HAL 向 keymaster TA 请求创建 Master Key。在请求参数中， km::TAG_STORAGE_KEY 表明了创建一个用于存储器加密的 Master Key，HLOS 将这个 key 用作 System DE Master Key。</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/a564146a9d814d8987692446b88e4d1f.png" alt="img" style="zoom: 50%;"><p>这里要注意 keymaster TA 不会直接将 Master Key 的明文直接返回到 HLOS，而是 Master Key Blob。那么 Master Key Blob 是怎么生成的？</p><ol><li>KM TA 首选创建一个 AES 算法加密 key，作为 Master Key；</li><li>使用由 SHK 派生出来的 KEK 将 Master Key 加密，并把密文存放到特殊数据结构，即 key blob；</li><li>再使用由 SHK 派生出来的 HMAC Key 通过 HMAC 算法对 key blob 签名；</li><li>这样就生成了 Master Key Blob，返回到 HLOS 的 Vold；</li></ol><p><strong>疑问：SHK 是什么？KEK 是什么？HMAC Key 是什么？</strong></p><p>① SHK 是设备使能 secure boot 后，生成的一个每个设备唯一、软件或者固件无法导出的 key，TZ 可以从 SHK 派生出各种用途的 key。</p><p>② KEK 派生自 SHK ，用于加密 KM TA 生成的 key，因为 key 不允许暴露在 HLOS：</p><ul><li>当 HLOS 请求 KM TA 生成 key 时，可以使用 KEK 将 key 加密成 key blob 后返回给 HLOS；</li><li>key 只能在 secure world 下使用（包括：加密、解密、签名、校验等操作）。因此时 HLOS 有需求时，请求 KM TA 执行相关操作，需要将数据和 key blob 一起传给 KM TA，KM TA 使用 KEK 解密 key blob 得到 key，再对数据执行相关的操作；</li></ul><p>③ HMAC Key 派生自 SHK ，用于对 key blob 签名，保证了  key blob 不被恶意篡改或者检查是否损坏；</p><p><strong>疑问：为什么 TZ 要将 key 加密后返回 HLOS 呢？</strong></p><p>在实际用户场景中，各种各样的进程可能会创建几十个甚至几百个用于各种各样的任务的 key，加密后返回 HLOS，由使用者自行管理，那么 TZ 就无需维护较大的存储区域以及这些 key 与客户端的联系。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> KeyGeneration <span class="hljs-title">makeGen</span><span class="hljs-params">(<span class="hljs-type">const</span> EncryptionOptions&amp; options)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> KeyGeneration&#123;FSCRYPT_MAX_KEY_SIZE, <span class="hljs-literal">true</span>, options.use_hw_wrapped_key&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">retrieveOrGenerateKey</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key_path, <span class="hljs-type">const</span> std::string&amp; tmp_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-type">const</span> KeyAuthentication&amp; key_authentication, <span class="hljs-type">const</span> KeyGeneration&amp; gen,</span></span><br><span class="hljs-params"><span class="hljs-function">                           KeyBuffer* key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pathExists</span>(key_path)) &#123;<br>        <span class="hljs-built_in">LOG</span>(DEBUG) &lt;&lt; <span class="hljs-string">&quot;Key exists, using: &quot;</span> &lt;&lt; key_path;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">retrieveKey</span>(key_path, key_authentication, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!gen.allow_gen) &#123;<br>            <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;No key found in &quot;</span> &lt;&lt; key_path;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Creating new key in &quot;</span> &lt;&lt; key_path;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateStorageKey</span>(gen, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 生成Master Key</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">storeKeyAtomically</span>(key_path, tmp_path, key_authentication, *key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 生成最终的加密秘钥encrypted key</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里先调用generateStorageKey生成Master Key：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">generateStorageKey</span><span class="hljs-params">(<span class="hljs-type">const</span> KeyGeneration&amp; gen, KeyBuffer* key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (gen.use_hw_wrapped_key) &#123;  <span class="hljs-comment">/* 使用硬件生成密钥 */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">generateWrappedStorageKey</span>(key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">/* 纯软生成随机秘钥 */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">randomKey</span>(gen.keysize, key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用generateWrappedStorageKey生成秘钥</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">generateWrappedStorageKey</span><span class="hljs-params">(KeyBuffer* key)</span> </span>&#123;<br>    Keymaster keymaster;  <span class="hljs-comment">// 创建对象</span><br>    <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string key_temp;<br>    <span class="hljs-keyword">auto</span> paramBuilder = km::<span class="hljs-built_in">AuthorizationSetBuilder</span>().<span class="hljs-built_in">AesEncryptionKey</span>(AES_KEY_BYTES * <span class="hljs-number">8</span>);<br>    paramBuilder.<span class="hljs-built_in">Authorization</span>(km::TAG_STORAGE_KEY);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeymasterKey</span>(keymaster, paramBuilder, &amp;key_temp)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//</span><br>    *key = <span class="hljs-built_in">KeyBuffer</span>(key_temp.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-built_in">memcpy</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(key-&gt;<span class="hljs-built_in">data</span>()), key_temp.<span class="hljs-built_in">c_str</span>(), key-&gt;<span class="hljs-built_in">size</span>());  <span class="hljs-comment">// 将临时生成的秘钥拷贝到key中</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">generateKeymasterKey</span><span class="hljs-params">(Keymaster&amp; keymaster,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> km::AuthorizationSetBuilder&amp; paramBuilder,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 std::string* key)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> paramsWithRollback = paramBuilder;<br>    paramsWithRollback.<span class="hljs-built_in">Authorization</span>(km::TAG_ROLLBACK_RESISTANCE);<br>    <span class="hljs-keyword">if</span> (!keymaster.<span class="hljs-built_in">generateKey</span>(paramsWithRollback, key)) &#123; <span class="hljs-comment">// 调用keymaster对象的generateKey方法</span><br>        <span class="hljs-keyword">if</span> (!keymaster.<span class="hljs-built_in">generateKey</span>(paramBuilder, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Keymaster::generateKey</span><span class="hljs-params">(<span class="hljs-type">const</span> km::AuthorizationSet&amp; inParams, std::string* key)</span> </span>&#123;<br>    ks2::KeyDescriptor in_key = &#123;<br>            .domain = ks2::Domain::BLOB,<br>            .alias = std::<span class="hljs-literal">nullopt</span>,<br>            .nspace = VOLD_NAMESPACE,<br>            .blob = std::<span class="hljs-literal">nullopt</span>,<br>    &#125;;<br>    ks2::KeyMetadata keyMetadata;<br>    <span class="hljs-comment">// securityLevel是共享智能指针std::shared_ptr&lt;ks2::IKeystoreSecurityLevel&gt; securityLevel;</span><br>    <span class="hljs-keyword">auto</span> rc = securityLevel-&gt;<span class="hljs-built_in">generateKey</span>(in_key, std::<span class="hljs-literal">nullopt</span>, inParams.<span class="hljs-built_in">vector_data</span>(), <span class="hljs-number">0</span>, &#123;&#125;, &amp;keyMetadata);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">logKeystore2ExceptionIfPresent</span>(rc, <span class="hljs-string">&quot;generateKey&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (keyMetadata.key.blob == std::<span class="hljs-literal">nullopt</span>) &#123;<br>        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;keystore2 generated key blob was null&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (key) *key = std::<span class="hljs-built_in">string</span>(keyMetadata.key.blob-&gt;<span class="hljs-built_in">begin</span>(), keyMetadata.key.blob-&gt;<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-built_in">zeroize_vector</span>(keyMetadata.key.blob.<span class="hljs-built_in">value</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>这里面有个地方需要说明一下，IKeystoreSecurityLevel这个里面提供的aidl接口，参考<a href="https://blog.csdn.net/weixin_42135087/article/details/125172636">https://blog.csdn.net/weixin_42135087/article/details/125172636</a></p></blockquote><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230711231226553.png" alt="image-20230711231226553" style="zoom:67%;"><h3 id="1-2-HLOS-把-System-DE-Master-Key-Blob-加密后保存到文件系统"><a href="#1-2-HLOS-把-System-DE-Master-Key-Blob-加密后保存到文件系统" class="headerlink" title="1.2 HLOS 把 System DE Master Key Blob 加密后保存到文件系统"></a>1.2 HLOS 把 System DE Master Key Blob 加密后保存到文件系统</h3><p>在上一个步骤中，KM TA 创建了 Master Key （ km::TAG_STORAGE_KEY FBE），并以 key blob 的形式返回到 HLOS。在 vold 收到 Master Key Blob 后，又将这个 key blob 加密后保存到文件系统中。</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/da064c351cf545baac70a0203018796f.png" alt="img" style="zoom: 67%;"><p><strong>疑问：Master Key Blob 已经是密文了，为什么 vold 还要将 key blob 二次加密？</strong></p><p>这个操作似乎有点多余，如果对 key 加密一次不安全，那么加密两次也不见得更安全，或者为什么不加密更多次呢？</p><p>这里我们要从 FBE 的设计来看，<strong>Google 把 userdata 分区划分了不同安全等级的存储位置，但仅使用不同的密钥并不能体现出安全等级这个概念，而是要从对密钥的约束来体现，比如经过什么样的认证后，哪些位置的数据才允许访问，言下之意就是对应的加密密钥才允许被使用。</strong>那怎么认证呢？</p><p>System DE Master Key 的安全认证正是通过二次加密来体现的，但是加密 Master Key 的 key （KEK） 怎么做到这一点呢？System DE 的设计初衷就是相应的存储位置是设备绑定，即这些存储位置的数据只能在特定的设备（CPU、存储器绑定）上才能解密和访问。Master Key 只负责用户加解密文件的数据，但是特定的设备怎么保证呢？</p><p>这就是加密 Master Key 的 key 要达成的目标，我们把这个 key 称作 KSK（Key Strorage Key，这不是专有名词，而是按照 Google 代码变量名来命名 ）。</p><p>从流程图中可以看出，在创建 KSK 时需要指定 app id（即表明谁创建的？）。同样后续使用这个 key 时，也必须指定相同的 appid。appid 的组成中包括设备绑定的信息（每台设备，KSK 的 appid 不一样，因为从它的创建流程可以看出，包括两个随机数 Secdiscardable 和 storage_binding_info.seed）。不仅如此，在 KM TA 内部还会将 secure boot 状态、设备锁状态、安全补丁日期等等信息和 KSK 绑定，在使用 KSK 之前，会校验相关的信息是否严格匹配，只有完全满足后，KSK 才允许用于解密 Master Blob。这些约束的实现都是在 KM TA 完成的。</p><p>这里举几个实际的例子说明：</p><blockquote><p><strong>例1：把一台设备的存储器所有数据，dump 到另外一台完全一致的设备上，用户数据为什么无法解密？</strong></p><p>因为 KSK 已经和 secure boot 状态绑定，在另外一台设备上，无法知道 EKE，进而无法解密 KSK blob，KSK 即无法被使用。当然被 KSK 加密的 master key blob 也无法解密，自然获取不到 master key 。实际实现不只如此简单，这里不做详细介绍。</p><p><strong>例2：同一台设备，如果 OTA 更新到安全补丁日期升级的软件后，再回滚到旧软件版本，用户数据为什么无法解密？</strong></p><p>因为 KSK 已经和安全补丁日期绑定，安全补丁日期不能减小。安全补丁日期回滚后，KSK 将不可用。</p><p><strong>例3：设备第一次开机是在设备锁（也叫 fastboot锁）锁定的情况下开机，那么 unlock 设备锁后，用户数据为什么无法解密？</strong></p><p>因为 KSK 和设备锁的状态绑定，如果设备锁的状态出现反转，KSK 将不可用。</p></blockquote><p><strong>疑问：加密 Master Key Blob 的 key KSK 从何而来 ？</strong></p><p>和 Master Key 类似，都是由 KM TA 创建的，并以 key blob 的形式返回 HLOS，由 vold 自行管理。这里注意创建 key 时，参数 km::AuthorizationSet 不一样，这就导致在 KM TA 内部，它们的管理和用途都是不一样。</p><p>vold 请求 KM TA 创建 KSK 所使用的 appid的参数、KSK Blob、加密后的 Master Key Blob 被存储到 &#x2F;data&#x2F;unencrypted&#x2F;key&#x2F;：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ls /data/unencrypted/key/ -l</span><br>total 16<br>-rw------- 1 root root   268 1970-01-03 04:47 encrypted_key<br>-rw------- 1 root root   194 1970-01-03 04:47 keymaster_key_blob<br>-rw------- 1 root root 16384 1970-01-03 04:47 secdiscardable<br>-rw------- 1 root root    10 1970-01-03 04:47 stretching<br>-rw------- 1 root root     1 1970-01-03 04:47 version<br></code></pre></td></tr></table></figure><p><strong>疑问：第一次开机时，为什么要把 KSK blob  和 加密后的 Master Key Blob 保存到文件系统？</strong></p><p>后续每次开机，可以直接通过 KSK blob （&#x2F;data&#x2F;unencrypted&#x2F;key&#x2F;keymaster_key_blob）解密Master Key Blob 的密文（&#x2F;data&#x2F;unencrypted&#x2F;keyencrypted_key）得到 Master Key Blob，这个动作是在 TZ 内部完成的，有了 Master Key Blob，那么可以将 Master Key 安装到 kernel keyring，详见下文。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">storeKey</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; dir, <span class="hljs-type">const</span> KeyAuthentication&amp; auth, <span class="hljs-type">const</span> KeyBuffer&amp; key)</span> </span>&#123;<br><span class="hljs-comment">// 将kCurrentVersion(1)写入到/data/unencrypted/key/version</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kCurrentVersion, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_version)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string secdiscardable_hash;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">createSecdiscardable</span>(dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_secdiscardable, &amp;secdiscardable_hash)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string stretching = <span class="hljs-built_in">getStretching</span>(auth);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(stretching, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_stretching)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string appId;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateAppId</span>(auth, stretching, secdiscardable_hash, &amp;appId)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string encryptedKey;<br>    <span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;<br>        Keymaster keymaster;<br>        <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        std::string kmKey;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeyStorageKey</span>(keymaster, appId, &amp;kmKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kmKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_keymaster_key_blob)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        km::AuthorizationSet keyParams = <span class="hljs-built_in">beginParams</span>(appId);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithKeymasterKey</span>(keymaster, dir, keyParams, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithoutKeymaster</span>(appId, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(encryptedKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_encrypted_key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">FsyncDirectory</span>(dir)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-1-写入version"><a href="#1-2-1-写入version" class="headerlink" title="1.2.1 写入version"></a>1.2.1 写入version</h4><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230711231926237.png" alt="image-20230711231926237" style="zoom: 67%;"><h4 id="1-2-2-写入secdiscardable"><a href="#1-2-2-写入secdiscardable" class="headerlink" title="1.2.2 写入secdiscardable"></a>1.2.2 写入secdiscardable</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// filename: /data/unencrypted/key/secdiscardable</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">createSecdiscardable</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename, std::string* hash)</span> </span>&#123;<br>    std::string secdiscardable;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">readRandomBytesOrLog</span>(SECDISCARDABLE_BYTES, &amp;secdiscardable)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 通过/dev/urandom生成随机数</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(secdiscardable, filename)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 将生成的随机数保存到/data/unencrypted/key/secdiscardable</span><br>    <span class="hljs-built_in">hashWithPrefix</span>(kHashPrefix_secdiscardable, secdiscardable, hash); <span class="hljs-comment">// 将生成的随机数取hash</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-3-写入stretching"><a href="#1-2-3-写入stretching" class="headerlink" title="1.2.3 写入stretching"></a>1.2.3 写入stretching</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string stretching = <span class="hljs-built_in">getStretching</span>(auth); <span class="hljs-comment">// 如果有锁屏密码值为none，没有锁屏密码为nopassword</span><br><span class="hljs-built_in">writeStringToFile</span>(stretching, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_stretching);<span class="hljs-comment">// 将stretching值写入到/data/unencrypted/key/stretching</span><br><br><br><span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">getStretching</span><span class="hljs-params">(<span class="hljs-type">const</span> KeyAuthentication&amp; auth)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;<br>        <span class="hljs-keyword">return</span> kStretch_nopassword;  <span class="hljs-comment">// nopassword</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> kStretch_none;  <span class="hljs-comment">// none</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里得说下什么情况下，auth的usesKeymaster返回true</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712213844099.png" alt="image-20230712213844099" style="zoom:50%;"><p>我们知道这个secret是从FWK传下来的锁屏Credential。</p><p><strong>所以如果secret为空，也就是没有设置锁屏密码，返回True！</strong></p><h4 id="1-2-4-写入keymaster-key-blob"><a href="#1-2-4-写入keymaster-key-blob" class="headerlink" title="1.2.4 写入keymaster_key_blob"></a>1.2.4 写入keymaster_key_blob</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string appId;<br><span class="hljs-comment">// // 生成appId，如果设置了锁屏密码，则为appId = secdiscardable_hash + auth.secret；没有设置锁屏密码，则appId = secdiscardable_hash</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateAppId</span>(auth, stretching, secdiscardable_hash, &amp;appId)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>std::string encryptedKey;<br><span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;  <span class="hljs-comment">// 没有锁屏密码的时候</span><br>    Keymaster keymaster;<br>    <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string kmKey;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeyStorageKey</span>(keymaster, appId, &amp;kmKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 将生成的KSK Blob写入到/data/unencrypted/key/keymaster_key_blob</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kmKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_keymaster_key_blob)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    km::AuthorizationSet keyParams = <span class="hljs-built_in">beginParams</span>(appId);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithKeymasterKey</span>(keymaster, dir, keyParams, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 有锁屏密码的时候生成随机encryptedKey</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithoutKeymaster</span>(appId, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）generateKeyStorageKey生成KSK Blob</p><p>这里System CE Master Key走的是keymaster管理分支</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">generateKeyStorageKey<br>     -&gt; generateKeymasterKey<br>    -&gt; keymaster.generateKey<br></code></pre></td></tr></table></figure><p>最终还是调用了keymaster的generateKey方法（1.1节创建Master Key的时候已经创建过一次了），不同点在于：</p><ul><li>第一次生成的是Master Key的Blob</li><li>这次生成的是KeyStorageKey（简称KSK）的Blob</li><li>至于为什么要再生成KSK Blob，上面博主已经写得很清楚了</li></ul><p>（2）encryptWithKeymasterKey将生成的KSK Blob对Master Key Blob二次加密，生成最终的encryptedKey</p><h4 id="1-2-5-写入encrypted-key"><a href="#1-2-5-写入encrypted-key" class="headerlink" title="1.2.5 写入encrypted_key"></a>1.2.5 写入encrypted_key</h4><p>上面生成了最终的加密秘钥encrypted_key，随后写入到&#x2F;data&#x2F;unencrypted&#x2F;key&#x2F;encrypted_key</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712215850630.png" alt="image-20230712215850630" style="zoom:67%;"><h3 id="1-3-安装-Master-Key-到-kernel-keyring"><a href="#1-3-安装-Master-Key-到-kernel-keyring" class="headerlink" title="1.3 安装 Master Key 到 kernel keyring"></a>1.3 安装 Master Key 到 kernel keyring</h3><p>在上一步骤中，已经成功创建了 Master Key，那接下来就是要把 Master Key 注册到 kernel keyring。在文件 I&#x2F;O 时可以通过  Encryption Policy 的 master_key_identifier 字段从 kernel keyring 中找到 Master Key。</p><p>在这个步骤中的两个重点操作：</p><ol><li>安装 Master Key 到 kernel keyring；</li><li>生成 Master Key 的 master_key_identifier；</li></ol><p>软件流程图如下所示：</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/d231d91958ff4902bc5118818bb13942.png" alt="img" style="zoom: 80%;"><h2 id="2-User-0-CE-Master-Key"><a href="#2-User-0-CE-Master-Key" class="headerlink" title="2.User.0 CE Master Key"></a>2.User.0 CE Master Key</h2><p>当用户设置用户锁屏密码后， User CE Master  key 的认证方式会改变，受用户密码保护，只有密码校验成功后，才能得到 User.0 CE Master Key，并将其安装到 kernel keyring。</p><p>User.0 CE Master Key 相关的认证数据被存储到目录 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;current 下。我们对比一下未设置锁屏密码和设置锁屏密码后，该目录下的文件差异：</p><ul><li>未设置锁屏密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; adb shell <span class="hljs-built_in">ls</span> /data/misc/vold/user_keys/ce/0/current -l<br>-rw------- 1 root root   268 2022-11-05 22:08 encrypted_key<br>-rw------- 1 root root   194 2022-11-05 22:08 keymaster_key_blob<br>-rw------- 1 root root 16384 2022-11-05 22:08 secdiscardable<br>-rw------- 1 root root    10 2022-11-05 22:08 stretching<br>-rw------- 1 root root     1 2022-11-05 22:08 version<br></code></pre></td></tr></table></figure><ul><li>设置锁屏密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; adb shell <span class="hljs-built_in">ls</span> /data/misc/vold/user_keys/ce/0/current -l<br>-rw------- 1 root root   268 2022-11-05 22:11 encrypted_key<br>-rw------- 1 root root 16384 2022-11-05 22:11 secdiscardable<br>-rw------- 1 root root     4 2022-11-05 22:11 stretching<br>-rw------- 1 root root     1 2022-11-05 22:11 version<br></code></pre></td></tr></table></figure><p>可以看到设置锁屏密码后，少了文件 keymaster_key_blob。在介绍 System DE Master Key 时已经知道，keymaster_key_blob 是 KM TA 创建的一个用于加密 Master Key Blob 的 key（上文称其为 KSK），用于保证 Master Key Blob 的安全性，作为设备绑定认证的一种实现，即 KSK 只能在唯一的设备（和CPU、存储器等器件绑定）上可用。</p><p>在用户设置锁屏密码后，认证更加严格，不仅要唯一的设备，而且需要用户输入正确的锁屏密码。因此，Master Key Blob  不再用 KSK 加密，它已经不能满足需求。</p><p><strong>疑问：encrypted_key 仍然存在，表明仍然使用对 Master Key Blob 加密的方式实现认证。但是加密 Master Key Blob 的 key 从哪里来？和用户锁屏密码存在什么关系？</strong></p><p>我们先看以下用户设置锁屏密码时，导致 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;current 下文件内容变化的流程：</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/9ff061c0788748cbadc82023fc2f90b6.png" alt="img" style="zoom:80%;"><p>AuthenticationToken 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthenticationToken</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> mVersion;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Here is the relationship between these fields:</span><br><span class="hljs-comment"> * Generate two random block P0 and P1. P1 is recorded in mEscrowSplit1 but P0 is not.</span><br><span class="hljs-comment"> * mSyntheticPassword = hash(P0 || P1)</span><br><span class="hljs-comment"> * E0 = P0 encrypted under syntheticPassword, recoreded in mEncryptedEscrowSplit0.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-meta">@NonNull</span> <span class="hljs-type">byte</span>[] mSyntheticPassword;<br><span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-type">byte</span>[] mEncryptedEscrowSplit0;<br><span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-type">byte</span>[] mEscrowSplit1;<br> <br>AuthenticationToken(<span class="hljs-type">byte</span> version) &#123;<br>mVersion = version;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Derives a subkey from the synthetic password. For v3 and later synthetic passwords the</span><br><span class="hljs-comment"> * subkeys are 256-bit; for v1 and v2 they are 512-bit.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] deriveSubkey(<span class="hljs-type">byte</span>[] personalization) &#123;<br><span class="hljs-keyword">if</span> (mVersion == SYNTHETIC_PASSWORD_VERSION_V3) &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">SP800Derive</span>(mSyntheticPassword))<br>.withContext(personalization, PERSONALISATION_CONTEXT);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> SyntheticPasswordCrypto.personalisedHash(personalization,<br>mSyntheticPassword);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] deriveDiskEncryptionKey() &#123;<br><span class="hljs-keyword">return</span> deriveSubkey(PERSONALIZATION_FBE_KEY);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Re-creates synthetic password from both escrow splits. See javadoc for</span><br><span class="hljs-comment"> * AuthenticationToken.mSyntheticPassword for details on what each block means.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recreate</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] escrowSplit0, <span class="hljs-type">byte</span>[] escrowSplit1)</span> &#123;<br>mSyntheticPassword = bytesToHex(SyntheticPasswordCrypto.personalisedHash(<br>PERSONALIZATION_SP_SPLIT, escrowSplit0, escrowSplit1));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Assign escrow data to this auth token. This is a prerequisite to call</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> AuthenticationToken#recreateFromEscrow&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEscrowData</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> <span class="hljs-type">byte</span>[] encryptedEscrowSplit0,</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> <span class="hljs-type">byte</span>[] escrowSplit1)</span> &#123;<br>mEncryptedEscrowSplit0 = encryptedEscrowSplit0;<br>mEscrowSplit1 = escrowSplit1;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Generates a new random synthetic password with escrow data.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> AuthenticationToken <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">AuthenticationToken</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthenticationToken</span>(SYNTHETIC_PASSWORD_VERSION_V3);<br><span class="hljs-type">byte</span>[] escrowSplit0 = secureRandom(SYNTHETIC_PASSWORD_LENGTH);<br><span class="hljs-type">byte</span>[] escrowSplit1 = secureRandom(SYNTHETIC_PASSWORD_LENGTH);<br>result.recreate(escrowSplit0, escrowSplit1);<br><span class="hljs-type">byte</span>[] encrypteEscrowSplit0 = SyntheticPasswordCrypto.encrypt(result.mSyntheticPassword,<br>PERSONALIZATION_E0, escrowSplit0);<br>result.setEscrowData(encrypteEscrowSplit0,  escrowSplit1);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结合代码和流程图可以看到，用户设置密码后，框架会直接调到 vold 执行更换 MasterKey 认证方式：</p><ol><li>调用函数 fscrypt_add_user_key_auth(user_id, serial, secret_hex），增加对 CE Master Key 的认证方式：<ol><li>首先，加载 keymaster_key_blob ，使用 KSK 解密 encrypted_key，得到 Master CE Key Blob；</li><li>接着，生成新的 appid，appid 由 fscrypt_add_user_key_auth 传入的参数 secret_hex 组成；</li><li>将 appid Hash 成 AES Key;</li><li>使用生成的 AES Key 加密  Master CE Key Blob，得到 encrypted_key；</li><li>将新的认证数据存储到 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;cx0000000000 下；</li><li>此时 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0 下已经存在两种 CE Master Key 的认证方式，如下所示</li></ol></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 老的认证方式，通过 KM key KSK 认证</span><br>&gt; adb shell <span class="hljs-built_in">ls</span> /data/misc/vold/user_keys/ce/0/current<br>encrypted_key<br>keymaster_key_blob<br>secdiscardable<br>stretching<br>version<br> <br><span class="hljs-comment"># 新的认证方式，通过用户密码校验认证</span><br>&gt; adb shell <span class="hljs-built_in">ls</span> /data/misc/vold/user_keys/ce/0/cx0000000000<br>encrypted_key<br>secdiscardable<br>stretching<br>version<br></code></pre></td></tr></table></figure><ol start="2"><li>调用 fscrypt_fixate_newest_user_key_auth，清除老的认证方式，改用用户密码认证，完成后，&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;cx0000000000 的内容将覆盖 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;current。vold 会打出如下的 log ：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">vold    : fscrypt_fixate_newest_user_key_auth 0<br>vold    : Deleting key /data/misc/vold/user_keys/ce/0/current/keymaster_key_blob from Keymaster<br>vold    : /system/bin/secdiscard<br>vold    :     --<br>vold    :     /data/misc/vold/user_keys/ce/0/current/encrypted_key<br>vold    :     /data/misc/vold/user_keys/ce/0/current/secdiscardable<br>vold    :     /data/misc/vold/user_keys/ce/0/current/keymaster_key_blob<br>vold    : /system/bin/rm<br>vold    :     -rf<br>vold    :     /data/misc/vold/user_keys/ce/0/current<br>vold    : Renaming /data/misc/vold/user_keys/ce/0/cx0000000000 to /data/misc/vold/user_keys/ce/0/current<br></code></pre></td></tr></table></figure><p>从上面流程可以看到，函数 fscrypt_add_user_key_auth(user_id, serial, secret_hex）中的参数 secret_hex 是关键，可以认为 secret_hex 被用于加密 Master CE Key Blob。</p><ul><li>secret_hex 是由 AuthenticationToken 中的 mSyntheticPassword 通过函数 deriveDiskEncryptionKey() 派生得到的 Key；</li><li>mSyntheticPassword 被用户用户密码间接加密，只有用户输入密码校验成功后，才能得到 mSyntheticPassword，进而得到  secret_hex；（mSyntheticPassword 加密的流程属于用户密码认证的一部分，不在这里介绍）</li></ul><h3 id="3-1-addUserKeyAuth层层调用"><a href="#3-1-addUserKeyAuth层层调用" class="headerlink" title="3.1  addUserKeyAuth层层调用"></a>3.1  addUserKeyAuth层层调用</h3><p>⭐ 在Android系统重的设置密码、清除密码、修改密码，都是调用到LockSettingsService.java的setLockCredential函数进行的，而setLockCredential又调用了setLockCredentialInternal。【引用：<a href="https://blog.csdn.net/weixin_42135087/article/details/109726612?spm=1001.2014.3001.5506%E3%80%91">https://blog.csdn.net/weixin_42135087/article/details/109726612?spm=1001.2014.3001.5506】</a></p><blockquote><p>从<a href="https://blog.csdn.net/weixin_42135087">代码改变世界ctw</a>大哥的博客中可以知道，当我们创建了设置用户密码的时候会调用到setLockCredentialInternal ，下面的调用栈如下：</p><p>setLockCredentialInternal -&gt; setUserKeyProtection -&gt; addUserKeyAuth</p><p>从addUserKeyAuth从和FBE扯上了关系</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\locksettings\LockSettingsService.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUserKeyAuth</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> mUserManager.getUserInfo(userId);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">callingId</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>    <span class="hljs-comment">// 调用SMS的addUserKeyAuth方法</span><br>    mStorageManager.addUserKeyAuth(userId, userInfo.serialNumber, token, secret);<br>&#125;<br><br><span class="hljs-comment">// ---------------------------------------------------------------</span><br><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\StorageManagerService.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUserKeyAuth</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">int</span> serialNumber, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret)</span> &#123;<br>    mVold.addUserKeyAuth(userId, serialNumber, encodeBytes(token), encodeBytes(secret));<br>&#125;<br><br><span class="hljs-comment">// ---------------------------------------------------------------</span><br><span class="hljs-comment">// system\vold\VoldNativeService.cpp</span><br>binder::Status VoldNativeService::addUserKeyAuth(int32_t userId, int32_t userSerial,<br>                                                 const std::string&amp; token,<br>                                                 const std::string&amp; secret) &#123;<br>    <span class="hljs-keyword">if</span> (!token_empty(token)) &#123;<br>        LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;Vold doesn&#x27;t use auth tokens, but non-empty token passed to addUserKeyAuth.&quot;</span>;<br>        <span class="hljs-keyword">return</span> binder::Status::fromServiceSpecificError(-EINVAL);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> translateBool(fscrypt_add_user_key_auth(userId, userSerial, secret));<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的注释可以看出，Vold服务是不需要AuthToken的，所以不需要向FBE传递。</p><h3 id="3-2-fscrypt-add-user-key-auth开始添加用户权限"><a href="#3-2-fscrypt-add-user-key-auth开始添加用户权限" class="headerlink" title="3.2 fscrypt_add_user_key_auth开始添加用户权限"></a>3.2 fscrypt_add_user_key_auth开始添加用户权限</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fscrypt_add_user_key_auth</span><span class="hljs-params">(<span class="hljs-type">userid_t</span> user_id, <span class="hljs-type">int</span> serial, <span class="hljs-type">const</span> std::string&amp; secret_hex)</span> </span>&#123;<br><span class="hljs-comment">// 判断是否支持文件级加密</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">fscrypt_is_native</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 还原锁屏码</span><br>    <span class="hljs-keyword">auto</span> auth = <span class="hljs-built_in">authentication_from_hex</span>(secret_hex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fscrypt_rewrap_user_key</span>(user_id, serial, kEmptyAuthentication, *auth);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用fscrypt_rewrap_user_key</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">fscrypt_rewrap_user_key</span><span class="hljs-params">(<span class="hljs-type">userid_t</span> user_id, <span class="hljs-type">int</span> serial,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> android::vold::KeyAuthentication&amp; retrieve_auth,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> android::vold::KeyAuthentication&amp; store_auth)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前用户的CE_KEY目录: /data/misc/vold/user_keys/ce/&lt;userid&gt;</span><br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> directory_path = <span class="hljs-built_in">get_ce_key_directory_path</span>(user_id);<br>    KeyBuffer ce_key;<br>    std::string ce_key_current_path = <span class="hljs-built_in">get_ce_key_current_path</span>(directory_path); <span class="hljs-comment">// /data/misc/vold/user_keys/ce/&lt;userid&gt;/current</span><br>    <span class="hljs-built_in">retrieveKey</span>(ce_key_current_path, kEmptyAuthentication, &amp;ce_key);<br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> paths = <span class="hljs-built_in">get_ce_key_paths</span>(directory_path);<br>    std::string ce_key_path;<br>    <span class="hljs-comment">// 新路径: /data/misc/vold/user_keys/ce/&lt;userid&gt;/current/cx%010u，例如/data/misc/vold/user_keys/ce/0/current/cx0000000000</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">get_ce_key_new_path</span>(directory_path, paths, &amp;ce_key_path)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// user_key_temp: /data/misc/vold/user_keys/temp</span><br>    <span class="hljs-comment">// 保存CE Key</span><br>    <span class="hljs-keyword">if</span> (!android::vold::<span class="hljs-built_in">storeKeyAtomically</span>(ce_key_path, user_key_temp, store_auth, ce_key))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>历史总是惊人的相似【1.1节创建System DE Master Key】，这里又调用storeKeyAtomically保存当前用户的User CE Master Key</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">storeKeyAtomically</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key_path, <span class="hljs-type">const</span> std::string&amp; tmp_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> KeyAuthentication&amp; auth, <span class="hljs-type">const</span> KeyBuffer&amp; key)</span> </span>&#123;<br>    <span class="hljs-comment">// 后面会将tmp_path换成Key_path，所以我直接改为key_path</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">storeKey</span>(key_path, auth, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用storeKey【⭐ 这里所有的操作即使都是在&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;temp中处理的，只是后面会有RenameKeyDir和FsyncParentDirectory操作，只要操作成功了，就相当于<code>/data/misc/vold/user_keys/ce/&lt;userid&gt;/current</code>】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">storeKey</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; dir, <span class="hljs-type">const</span> KeyAuthentication&amp; auth, <span class="hljs-type">const</span> KeyBuffer&amp; key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">mkdir</span>(dir.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0700</span>)) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;key mkdir &quot;</span> &lt;&lt; dir;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 向/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/version中写入1</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kCurrentVersion, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_version)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 创建随机的secdiscardable_hash值</span><br>    std::string secdiscardable_hash;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">createSecdiscardable</span>(dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_secdiscardable, &amp;secdiscardable_hash)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 如果有锁屏密码，则stretching为none; 如果没有锁屏密码，则stretching为nopassword</span><br>    std::string stretching = <span class="hljs-built_in">getStretching</span>(auth);<br>    <span class="hljs-comment">// 向/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/stretching中写入stretching的值</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(stretching, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_stretching)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 生成appId，如果设置了锁屏密码，则为appId = hash + auth.secret；没有设置锁屏密码，则appId = hash</span><br>    std::string appId;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateAppId</span>(auth, stretching, secdiscardable_hash, &amp;appId)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string encryptedKey;<br>    <span class="hljs-comment">// 如果没有设置锁屏密码，使用keymaster管理</span><br>    <span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;<br>        Keymaster keymaster;<br>        <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        std::string kmKey;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeyStorageKey</span>(keymaster, appId, &amp;kmKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kmKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_keymaster_key_blob)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        km::AuthorizationSet keyParams = <span class="hljs-built_in">beginParams</span>(appId);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithKeymasterKey</span>(keymaster, dir, keyParams, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 设置了锁屏密码，不适用keymaster</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithoutKeymaster</span>(appId, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将加密后的CE key写入/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/encrypted_key</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(encryptedKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_encrypted_key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">FsyncDirectory</span>(dir)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贺利坚汇编原理学习笔记</title>
    <link href="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="贺利坚汇编原理学习笔记"><a href="#贺利坚汇编原理学习笔记" class="headerlink" title="贺利坚汇编原理学习笔记"></a>贺利坚汇编原理学习笔记</h1><h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1.绪论"></a>1.绪论</h2><h2 id="2-寄存器与内存"><a href="#2-寄存器与内存" class="headerlink" title="2.寄存器与内存"></a>2.寄存器与内存</h2><h3 id="2-1-寄存器与数据存储"><a href="#2-1-寄存器与数据存储" class="headerlink" title="2.1 寄存器与数据存储"></a>2.1 寄存器与数据存储</h3><p>CPU的组成：</p><ul><li>运算器进行信息处理</li><li>寄存器进行信息存储</li><li>控制器协调各种器件进行工作</li><li>内部总线实现CPU内部各个器件之间的联系</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710233214391.png" alt="image-20230710233214391" style="zoom: 67%;"><p><strong>寄存器是CPU内部的信息存储单元</strong></p><p>8086CPU有14个寄存器：</p><ul><li>通用寄存器：AX、BX、CX、DX</li><li>编制寄存器：SI、DI</li><li>指针寄存器：SP、BP</li><li>指令指针寄存器：IP</li><li>段寄存器：CS、SS、DS、ES</li><li>标志寄存器：PSW</li></ul><p><strong>共性：8086CPU所有的寄存器都是16位的，可以存放两个字节</strong></p><h4 id="2-1-1-通用寄存器——以AX为例"><a href="#2-1-1-通用寄存器——以AX为例" class="headerlink" title="2.1.1 通用寄存器——以AX为例"></a>2.1.1 通用寄存器——以AX为例</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710233531410.png" alt="image-20230710233531410" style="zoom:50%;"><ul><li>一个寄存器存储一个16的数据<ul><li>最大值为2^16-1</li></ul></li><li>例如：在AX中存储18D，换算成16进制为12H，换算成2进制为10010B</li><li>例如：在AX中存储20000D，换算成16进制为4E20H，换算成2进制为0100111000100000B</li></ul><h4 id="2-1-2-如何兼容8位CPU"><a href="#2-1-2-如何兼容8位CPU" class="headerlink" title="2.1.2 如何兼容8位CPU"></a>2.1.2 如何兼容8位CPU</h4><p>8086上一代CPU中的寄存器都是8位的，如何保证程序的兼容性</p><blockquote><p>通用寄存器均可以分为两个独立的8位寄存器使用</p></blockquote><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710233807727.png" alt="image-20230710233807727" style="zoom:67%;"><ul><li>AX可以分为AH和AL</li><li>BX可以分为BH和BL</li><li>CX可以分为CH和CL</li><li>DX可以分为DH和DL</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710233838706.png" alt="image-20230710233838706" style="zoom:80%;"><h4 id="2-1-3-“字”在寄存器中的存储"><a href="#2-1-3-“字”在寄存器中的存储" class="headerlink" title="2.1.3 “字”在寄存器中的存储"></a>2.1.3 “字”在寄存器中的存储</h4><ul><li>8086是16位CPU<ul><li>8086的字长(word size)为16bit</li></ul></li><li>一个字(word)可以存在一个16位寄存器中<ul><li>这个字的高位字节存在这个寄存器的高8位寄存器</li><li>这个字的低位字节存在这个寄存器的低8位寄存器</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710233936082.png" alt="image-20230710233936082" style="zoom: 67%;"><h3 id="2-2-mov和add指令"><a href="#2-2-mov和add指令" class="headerlink" title="2.2 mov和add指令"></a>2.2 mov和add指令</h3><h4 id="2-2-1-学习汇编指令——用中学"><a href="#2-2-1-学习汇编指令——用中学" class="headerlink" title="2.2.1 学习汇编指令——用中学"></a>2.2.1 学习汇编指令——用中学</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710234028265.png" alt="image-20230710234028265" style="zoom:80%;"><h4 id="2-2-2-写出汇编指令执行的结果-1"><a href="#2-2-2-写出汇编指令执行的结果-1" class="headerlink" title="2.2.2 写出汇编指令执行的结果(1)"></a>2.2.2 写出汇编指令执行的结果(1)</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710234058102.png" alt="image-20230710234058102" style="zoom:80%;"><h4 id="2-2-3-写出汇编指令执行的结果-2"><a href="#2-2-3-写出汇编指令执行的结果-2" class="headerlink" title="2.2.3 写出汇编指令执行的结果(2)"></a>2.2.3 写出汇编指令执行的结果(2)</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710234149190.png" alt="image-20230710234149190" style="zoom:80%;"><h3 id="2-3-确定物理地址的办法"><a href="#2-3-确定物理地址的办法" class="headerlink" title="2.3 确定物理地址的办法"></a>2.3 确定物理地址的办法</h3><h4 id="2-3-1-物理地址"><a href="#2-3-1-物理地址" class="headerlink" title="2.3.1 物理地址"></a>2.3.1 物理地址</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710234217377.png" alt="image-20230710234217377" style="zoom:67%;"><ul><li>CPU访问内存单元时要给出内存单元的地址。</li><li>所有的内存单元构成的存储空间是一个一维的线性空间。</li><li>每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为<strong>物理地址</strong>。</li><li>事实：<ul><li>8086有20位地址总线，可传送20位地址，<strong>寻址能力为1M</strong>。</li><li>8086是16位结构的CPU<ul><li>运算器一次最多可以处理16位的数据，寄存器的最大宽度为16位</li><li>在8086内部处理的、传输、暂存的地址也是16位，<strong>寻址能力也只有64KB</strong>！</li></ul></li></ul></li><li><strong>问题：8086如何处理在寻址空间上的这个矛盾？！</strong></li></ul><hr><p><strong>8086CPU给出物理地址的方法</strong></p><ul><li>8086CPU的解决方法<ul><li>用两个16位地址(段地址、偏移地址)合成一个20位的物理地址。</li></ul></li><li>地址加法器合成物理地址的方法：<ul><li>物理地址&#x3D;段地址×16+偏移地址</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710234435359.png" alt="image-20230710234435359" style="zoom:67%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710234448354.png" alt="image-20230710234448354" style="zoom: 50%;"><h4 id="2-3-2-演示：物理地址-x3D-段地址×16-偏移地址"><a href="#2-3-2-演示：物理地址-x3D-段地址×16-偏移地址" class="headerlink" title="2.3.2 演示：物理地址&#x3D;段地址×16+偏移地址"></a>2.3.2 演示：物理地址&#x3D;段地址×16+偏移地址</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/寻址.gif" style="zoom:67%;"><p><strong>思考：段地址是123CH，可否？</strong></p><blockquote><p>可以，段地址×16+偏移地址&#x3D;0x123C8，还是没变</p></blockquote><h4 id="2-3-3-“段地址×16-偏移地址-x3D-物理地址”的本质"><a href="#2-3-3-“段地址×16-偏移地址-x3D-物理地址”的本质" class="headerlink" title="2.3.3 “段地址×16+偏移地址&#x3D;物理地址”的本质"></a>2.3.3 “段地址×16+偏移地址&#x3D;物理地址”的本质</h4><ul><li><p>要解决的问题</p><ul><li>用两个16位的地址（段地址、偏移地址），相加得到一个20位的物理地址</li></ul></li><li><p>本质含义</p><ul><li>CPU在访问内存时，用一个基础地址（段地址×16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</li></ul></li></ul><h3 id="2-4-内存的分段表示法"><a href="#2-4-内存的分段表示法" class="headerlink" title="2.4 内存的分段表示法"></a>2.4 内存的分段表示法</h3><h4 id="2-4-1-用分段的方式管理内存"><a href="#2-4-1-用分段的方式管理内存" class="headerlink" title="2.4.1 用分段的方式管理内存"></a>2.4.1 用分段的方式管理内存</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710235315274.png" alt="image-20230710235315274" style="zoom: 67%;"><h4 id="2-4-2-同一段内存，多种分段方案"><a href="#2-4-2-同一段内存，多种分段方案" class="headerlink" title="2.4.2 同一段内存，多种分段方案"></a>2.4.2 同一段内存，多种分段方案</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710235333716.png" alt="image-20230710235333716" style="zoom: 67%;"><h4 id="2-4-3-用不同的段地址和偏移地址形成同一个物理地址"><a href="#2-4-3-用不同的段地址和偏移地址形成同一个物理地址" class="headerlink" title="2.4.3 用不同的段地址和偏移地址形成同一个物理地址"></a>2.4.3 用不同的段地址和偏移地址形成同一个物理地址</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710235404944.png" alt="image-20230710235404944" style="zoom:67%;">]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 文件级加密（File-based Encryption）之密钥管理</title>
    <link href="/2023/07/06/Android-%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86%EF%BC%88File-based-Encryption%EF%BC%89%E4%B9%8B%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/"/>
    <url>/2023/07/06/Android-%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86%EF%BC%88File-based-Encryption%EF%BC%89%E4%B9%8B%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-文件级加密（File-based-Encryption）之密钥管理"><a href="#Android-文件级加密（File-based-Encryption）之密钥管理" class="headerlink" title="Android 文件级加密（File-based Encryption）之密钥管理"></a>Android 文件级加密（File-based Encryption）之密钥管理</h1>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fsck_msdos学习笔记</title>
    <link href="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="fsck-msdos学习笔记"><a href="#fsck-msdos学习笔记" class="headerlink" title="fsck_msdos学习笔记"></a>fsck_msdos学习笔记</h1><h2 id="1-了解什么是FAT交叉链"><a href="#1-了解什么是FAT交叉链" class="headerlink" title="1.了解什么是FAT交叉链"></a>1.了解什么是FAT交叉链</h2><p>首先看一下这个定义：</p><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703214405538.png" alt="image-20230703214405538" style="zoom: 50%;"><blockquote><p>cross-linked files是那些指向了同一个簇的fat entry。</p></blockquote><p>下面我们再看这里给出的详细定义：<a href="http://www.edusoftmax.com/cross_linked_file.html">http://www.edusoftmax.com/cross_linked_file.html</a></p><blockquote><p>MS-DOS organizes the disk’s data area into sections called clusters or allocation units. Each file has its own directory entry, which includes the file name, size, attribute information, date, time, and the cluster where the start of the file is stored.</p><p>The file allocation table (FAT) includes an entry for each cluster. Each cluster’s entry includes either a code specifying that it is the last cluster in the file, or the number of the next cluster used by the file. Clusters can also be marked unusable, which CHKDSK reports as bad sectors.</p><p>When the computer tries to save data to the hard drive in a place where a file already exists, the two files become cross-linked. When this occurs, data from both files share the same sector on the hard drive causing both to become corrupt. In some cases, one of the cross-linked files can be saved, but often both must be deleted.</p><p>For example, suppose you have two files, each 512 bytes in size. Each file requires one cluster. If both files are marked as being located in cluster 5, then cluster 5 probably contains the file with the later date. You can confirm this by looking at it (if it’s a data file) or running it (if it’s a program).</p><p>Cross-linked files are generally created when the computer is improperly shut down or an application abnormally aborts.</p></blockquote><p>这里解释的也是相当的清楚，<strong>当计算机试图将数据保存到已经存在文件的硬盘时，这两个文件会交叉连接。</strong></p><hr><p>下面只是定义，看起来仍然比较的抽象，下面我画一个图进行说明：</p><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703215118346.png" alt="image-20230703215118346" style="zoom:67%;"><ul><li>假设文件hello1.txt的簇链为3-&gt;5-&gt;7-&gt;8</li><li>假设文件hello2.txt的簇链为4-&gt;6-&gt;7-&gt;8</li><li>可以发现两条链是相交的，且相交点在7这个位置！</li></ul><h2 id="2-Android-P之前fsck-msdos"><a href="#2-Android-P之前fsck-msdos" class="headerlink" title="2.Android P之前fsck_msdos"></a>2.Android P之前fsck_msdos</h2><p>前面读取bootblock啥的都比较简单就不贴了！</p><h3 id="2-1-读取fat表readfat"><a href="#2-1-读取fat表readfat" class="headerlink" title="2.1 读取fat表readfat"></a>2.1 读取fat表readfat</h3><p>这里先只看FAT32，其余的FAT12和FAT16都是大差不差的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">readfat</span><span class="hljs-params">(<span class="hljs-type">int</span> fs, <span class="hljs-keyword">struct</span> bootblock *boot, <span class="hljs-type">int</span> no, <span class="hljs-keyword">struct</span> fatEntry **fp)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fatEntry</span> *<span class="hljs-title">fat</span>;</span><br>u_char *buffer, *p;<br><span class="hljs-type">cl_t</span> cl;<br><span class="hljs-type">int</span> ret = FSOK;<br><br>boot-&gt;NumFree = boot-&gt;NumBad = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 读取FAT到buffer中</span><br><span class="hljs-keyword">if</span> (!_readfat(fs, boot, no, &amp;buffer))<br><span class="hljs-keyword">return</span> FSFATAL;<br><br>    <span class="hljs-comment">// 分配内存：最大为4G，具体见第4节</span><br>fat = <span class="hljs-built_in">calloc</span>(boot-&gt;NumClusters, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> fatEntry));<br><br><span class="hljs-keyword">switch</span> (boot-&gt;ClustMask) &#123;<br><span class="hljs-keyword">case</span> CLUST32_MASK:<br>p = buffer + <span class="hljs-number">8</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (cl = CLUST_FIRST; cl &lt; boot-&gt;NumClusters;) &#123;<br><span class="hljs-keyword">switch</span> (boot-&gt;ClustMask) &#123;<br><span class="hljs-keyword">case</span> CLUST32_MASK:<br>fat[cl].next = p[<span class="hljs-number">0</span>] + (p[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>) + (p[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>) + (p[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">24</span>);  <span class="hljs-comment">// 读取4个字节</span><br>fat[cl].next &amp;= boot-&gt;ClustMask; <span class="hljs-comment">// 与操作，通过掩码过滤前4位(保留位)</span><br>ret |= checkclnum(boot, no, cl, &amp;fat[cl].next); <span class="hljs-comment">// 检验簇的合法性</span><br>cl++; <span class="hljs-comment">// 簇++</span><br>p += <span class="hljs-number">4</span>; <span class="hljs-comment">// 每一个簇是4个字节，所以递增4</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">free</span>(buffer);<br>*fp = fat;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-检查fat表项checkfat"><a href="#2-2-检查fat表项checkfat" class="headerlink" title="2.2 检查fat表项checkfat"></a>2.2 检查fat表项checkfat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// external/fsck_msdos/fat.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">checkfat</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bootblock *boot, <span class="hljs-keyword">struct</span> fatEntry *fat)</span><br>&#123;<br><span class="hljs-type">cl_t</span> head, p, h, n;<br>u_int len;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> conf;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * pass 1: 确定所有的簇链</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (head = CLUST_FIRST; head &lt; boot-&gt;NumClusters; head++) &#123;<br><span class="hljs-comment">/* find next untravelled chain */</span><br><span class="hljs-keyword">if</span> (fat[head].head != <span class="hljs-number">0</span><span class="hljs-comment">/* 如果当前的head不是0，说明当前节点已经隶属于另外一条簇链了 */</span><br>    || fat[head].next == CLUST_FREE<br>    || fat[head].next == CLUST_BAD)<br><span class="hljs-keyword">continue</span>;<span class="hljs-comment">/* skip it. */</span><br><br><span class="hljs-comment">/* 遍历簇链：将链上的每一个节点设置为当前的簇链头head */</span><br><span class="hljs-keyword">for</span> (len = <span class="hljs-number">0</span>, p = head;<br>     p &gt;= CLUST_FIRST &amp;&amp; p &lt; boot-&gt;NumClusters &amp;&amp;<br>     fat[p].head != head;<br>     p = fat[p].next) &#123;<br>fat[p].head = head;<br>len++;<br>&#125;<br><br><span class="hljs-comment">/* 给簇链头设置簇链长度 */</span><br>fat[head].length = fat[head].next == CLUST_FREE ? <span class="hljs-number">0</span> : len;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * pass 2: 检查是否有交叉链</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (head = CLUST_FIRST; head &lt; boot-&gt;NumClusters; head++) &#123;<br><span class="hljs-comment">/* 找到簇链头 */</span><br><span class="hljs-keyword">if</span> (fat[head].head != head)<br><span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 退出循环的条件有2个</span><br>        <span class="hljs-comment">// 1.出现交叉链，也就是fat[n].fat.head!=head</span><br>        <span class="hljs-comment">// 2.簇链已经损坏</span><br><span class="hljs-keyword">for</span> (p = head,wdk=boot-&gt;NumClusters;<br>     (n = fat[p].next) &gt;= CLUST_FIRST &amp;&amp; n &lt; boot-&gt;NumClusters &amp;&amp; wdk;p = n,wdk--) &#123;<br><span class="hljs-keyword">if</span> (fat[n].head != head)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>        <span class="hljs-comment">// 情况一：如果是正常的结尾：包括FAT结尾或者文件簇链结尾</span><br><span class="hljs-keyword">if</span> (n &gt;= CLUST_EOFS)<br><span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">// 情况二：当前簇是空闲的或者在保留簇区域内</span><br><span class="hljs-keyword">if</span> (n == CLUST_FREE || n &gt;= CLUST_RSRVD) &#123;<br>pwarn(<span class="hljs-string">&quot;Cluster chain starting at %u ends with cluster marked %s\n&quot;</span>, head, rsrvdcltype(n));<br>ret |= tryclear(boot, fat, head, &amp;fat[p].next);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>        <span class="hljs-comment">// 情况三：当前簇在前2个簇以内或超出簇数量</span><br><span class="hljs-keyword">if</span> (n &lt; CLUST_FIRST || n &gt;= boot-&gt;NumClusters) &#123;<br>pwarn(<span class="hljs-string">&quot;Cluster chain starting at %u ends with cluster out of range (%u)\n&quot;</span>, head, n);<br>ret |= tryclear(boot, fat, head, &amp;fat[p].next);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>        <span class="hljs-comment">// 情况四：出现了交叉链</span><br>pwarn(<span class="hljs-string">&quot;Cluster chains starting at %u and %u are linked at cluster %u\n&quot;</span>, head, fat[n].head, n);<br>conf = tryclear(boot, fat, head, &amp;fat[p].next);<br>ret |= conf;<br>&#125;<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们以第1节中的交叉链为例进行说明，此时2个链的情况分别如下：</p><ul><li>簇链1：3-&gt;5-&gt;7-&gt;8</li></ul><table><thead><tr><th>节点</th><th>3</th><th>5</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>簇值</td><td>5</td><td>7</td><td>8</td><td>EOF</td></tr><tr><td>头</td><td>3</td><td>3</td><td>3</td><td>3</td></tr></tbody></table><ul><li>簇链2：4-&gt;6-&gt;7-&gt;8</li></ul><table><thead><tr><th>节点</th><th>4</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>簇值</td><td>6</td><td>7</td><td>8</td><td>EOF</td></tr><tr><td>头</td><td>4</td><td>4</td><td>4</td><td>4</td></tr></tbody></table><p>说明一下代码的执行流程：</p><ol><li>当遍历第一个簇链时，发现fat[7].next &#x3D; 8，此时fat[7].head &#x3D; 3，同理fat[8].head &#x3D; 3</li><li>但是当遍历第二哥簇链时，fat[7].head &#x3D; 4，同理fat[8].head &#x3D; 4</li></ol><p>因此交叉链出现，在p<strong>ass 2: 检查是否有交叉链</strong>时，就会检测出这是交叉链，因此此时<strong>fat[7].head !&#x3D; 3</strong></p><p>⭐此时就会触发一个流程，就是tryclear清除交叉链，总共有2种玩法：</p><ul><li>调用clearchain清理交叉点的簇，全部设置为FREE【这样破坏的就是第一个簇链】</li><li>直接将交叉点处设置为CLUST_EOF【这样第一个和第二个簇链都被破坏了】</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">tryclear</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bootblock *boot, <span class="hljs-keyword">struct</span> fatEntry *fat, <span class="hljs-type">cl_t</span> head, <span class="hljs-type">cl_t</span> *trunc)</span><br>&#123;<br><span class="hljs-keyword">if</span> (ask(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Clear chain starting at %u&quot;</span>, head)) &#123;<br>clearchain(boot, fat, head);<br><span class="hljs-keyword">return</span> FSFATMOD;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ask(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Truncate&quot;</span>)) &#123;<br>*trunc = CLUST_EOF;<br><span class="hljs-keyword">return</span> FSFATMOD;<br>&#125; <span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> FSERROR;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">clearchain</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bootblock *boot, <span class="hljs-keyword">struct</span> fatEntry *fat, <span class="hljs-type">cl_t</span> head)</span><br>&#123;<br><span class="hljs-type">cl_t</span> p, q;<br><br>   <span class="hljs-comment">// 遍历第一条簇链，将簇链的交叉点之前截断，全部设置为FREE</span><br><span class="hljs-keyword">for</span> (p = head; p &gt;= CLUST_FIRST &amp;&amp; p &lt; boot-&gt;NumClusters; p = q) &#123;<br><span class="hljs-keyword">if</span> (fat[p].head != head)<br><span class="hljs-keyword">break</span>;<br>q = fat[p].next;<br>fat[p].next = fat[p].head = CLUST_FREE;<br>fat[p].length = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Android-S开始fsck-msdos的处理"><a href="#3-Android-S开始fsck-msdos的处理" class="headerlink" title="3.Android S开始fsck_msdos的处理"></a>3.Android S开始fsck_msdos的处理</h2><p>此处是<strong>Li Xin</strong>大佬提交的代码，故而拜读其文章后不得赞叹，现贴出其思想学习：<a href="https://blog.delphij.net/posts/2021/06/fsck_msdosfs/">https://blog.delphij.net/posts/2021/06/fsck_msdosfs/</a></p><blockquote><p>我们在上面的代码中是在检查是否出现了交叉链，那么新的算法如下：</p><p>先假定所有的簇都是链头，然后一次遍历整个线性表，将被 <code>next</code> 指针引用的簇标记为不是链头。此方法只需遍历整个线性表，即 <code>O(N)</code>。 由此，我们将获得一个表示对应簇是否是簇链头的位映射图 （<code>headbitmap</code>）。</p><p>需要注意的是，这个方法标记的是每个节点是否是链头，而并不知道该节点对应的链头是谁， 自然也就无从立即知晓簇链的长度。该任务可以延后到检查目录项完整性的部分来进行， 因为目录项中保存了链簇头节点的位置，故而只需判断该簇是否是链头，如果是， 则沿着该簇链逐个遍历直到找到链尾并计算长度。</p></blockquote><h3 id="3-1-读取fat表-readfat"><a href="#3-1-读取fat表-readfat" class="headerlink" title="3.1 读取fat表_readfat"></a>3.1 读取fat表_readfat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br>_readfat(<span class="hljs-keyword">struct</span> fat_descriptor *fat)<br>&#123;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">size_t</span> i;<br><span class="hljs-type">off_t</span> off;<br><span class="hljs-type">size_t</span> readsize;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bootblock</span> *<span class="hljs-title">boot</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fat32_cache_entry</span> *<span class="hljs-title">entry</span>;</span><br><br>boot = boot_of_(fat);<br>fd = fd_of_(fat);<br>fat-&gt;fatsize = boot-&gt;FATsecs * boot-&gt;bpbBytesPerSec;<br><br>off = boot-&gt;bpbResSectors;<br>off *= boot-&gt;bpbBytesPerSec;<br><br>fat-&gt;is_mmapped = <span class="hljs-literal">false</span>;<br>fat-&gt;use_cache = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">/* Attempt to mmap() first */</span><br><span class="hljs-keyword">if</span> (allow_mmap) &#123;<br>fat-&gt;fatbuf = mmap(<span class="hljs-literal">NULL</span>, fat-&gt;fatsize,<br>PROT_READ | (rdonly ? <span class="hljs-number">0</span> : PROT_WRITE),<br>MAP_SHARED, fd_of_(fat), off);<br><span class="hljs-keyword">if</span> (fat-&gt;fatbuf != MAP_FAILED) &#123;<br>fat-&gt;is_mmapped = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Unfortunately, we were unable to mmap().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Only use the cache manager when it&#x27;s necessary, that is,</span><br><span class="hljs-comment"> * when the FAT is sufficiently large; in that case, only</span><br><span class="hljs-comment"> * read in the first 4 MiB of FAT into memory, and split the</span><br><span class="hljs-comment"> * buffer into chunks and insert to the LRU queue to populate</span><br><span class="hljs-comment"> * the cache with data.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (boot-&gt;ClustMask == CLUST32_MASK &amp;&amp;<br>    fat-&gt;fatsize &gt;= fat32_cache_size) &#123;<br>readsize = fat32_cache_size;<br>fat-&gt;use_cache = <span class="hljs-literal">true</span>;<br><br>fat-&gt;fat32_offset = boot-&gt;bpbResSectors * boot-&gt;bpbBytesPerSec;<br>fat-&gt;fat32_lastaddr = fat-&gt;fatsize &amp; ~(fat32_cache_chunk_size);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>readsize = fat-&gt;fatsize;<br>&#125;<br>fat-&gt;fatbuf = <span class="hljs-built_in">malloc</span>(readsize);<br><span class="hljs-keyword">if</span> (fat-&gt;fatbuf == <span class="hljs-literal">NULL</span>) &#123;<br>perr(<span class="hljs-string">&quot;No space for FAT (%zu)&quot;</span>, readsize);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (lseek(fd, off, SEEK_SET) != off) &#123;<br>perr(<span class="hljs-string">&quot;Unable to read FAT&quot;</span>);<br><span class="hljs-keyword">goto</span> err;<br>&#125;<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>)read(fd, fat-&gt;fatbuf, readsize) != readsize) &#123;<br>perr(<span class="hljs-string">&quot;Unable to read FAT&quot;</span>);<br><span class="hljs-keyword">goto</span> err;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When cache is used, split the buffer into chunks, and</span><br><span class="hljs-comment"> * connect the buffer into the cache.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (fat-&gt;use_cache) &#123;<br>TAILQ_INIT(&amp;fat-&gt;fat32_cache_head);<br>entry = <span class="hljs-built_in">calloc</span>(fat32_cache_entries, <span class="hljs-keyword">sizeof</span>(*entry));<br><span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">NULL</span>) &#123;<br>perr(<span class="hljs-string">&quot;No space for FAT cache (%zu of %zu)&quot;</span>,<br>    fat32_cache_entries, <span class="hljs-keyword">sizeof</span>(entry));<br><span class="hljs-keyword">goto</span> err;<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; fat32_cache_entries; i++) &#123;<br>entry[i].addr = fat32_cache_chunk_size * i;<br>entry[i].chunk = &amp;fat-&gt;fatbuf[entry[i].addr];<br>TAILQ_INSERT_TAIL(&amp;fat-&gt;fat32_cache_head,<br>    &amp;entry[i], entries);<br>&#125;<br>fat-&gt;fat32_cache_allentries = entry;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>err:<br><span class="hljs-built_in">free</span>(fat-&gt;fatbuf);<br>fat-&gt;fatbuf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面提到，FAT32最多可以有 2^28 个簇，这需要占用 1GiB 的空间。第一遍扫描时我们是把 FAT 作为一个线性表来做线性扫描的，完全没有任何必要将其整个载入内存。之后检查目录项时， 在极端情况（文件系统非常碎块化）时，我们可能会需要反复访问FAT的不同区域。</p><p>综合以上考虑，一个显然的解决方案就是增加一个缓存层，并将原先实现中直接读写 FAT 内部表现形式的部分改写为直接使用一个抽象的访问函数来进行操作，并将缓存的问题交给缓存层来进行。 操作系统已经为我们提供了一个很好的缓存实现，因此如果能用的话直接 <code>mmap(2)</code> 是最佳策略； 如果不能，则退而求其次，自己实现一个 LRU 队列。</p><p>前面提到 FAT12 和 FAT16 的最大尺寸都足够小，因此可以直接将其放进内存。FAT32 则分两种情况， 对于能使用操作系统的缓存系统的情况，我们只需把整个 FAT 映射到内存中并当作一个大数组访问即可； 对于自行实现 LRU 队列的情况，则创建一个 LRU 缓存池（尺寸是拍脑门定的 4MiB， 每个缓存块是 128kiB）。</p><p>LRU 的实现过于简单且并无特别，再次不再赘述，淘汰时如果缓存块发生过写操作，则将其写回磁盘原位置。</p><h3 id="3-2-通过位图检查表项"><a href="#3-2-通过位图检查表项" class="headerlink" title="3.2 通过位图检查表项"></a>3.2 通过位图检查表项</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 遍历 FAT 表并创建簇链头位图。</span><br><span class="hljs-comment"> * 首先假定每一个簇都是一个簇链的头，然后遍历整个 FAT 表，</span><br><span class="hljs-comment"> * 并将其中不是簇链头，即那些有其他簇将其指为后继节点的那些簇从该位图中删去，</span><br><span class="hljs-comment">         * 在此过程中修复一些明显的问题。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 每个 &quot;next&quot; 簇的可能取值如下：</span><br><span class="hljs-comment"> * a) CLUST_FREE 或 CLUST_BAD。当前簇不可能是簇链起点。</span><br><span class="hljs-comment"> * b) 超出范围的值。此时必须将簇链在此处切断。</span><br><span class="hljs-comment"> * c) 有效簇。这说明此簇 (nextcl) 不可能是簇链起点。</span><br><span class="hljs-comment"> *    在遍历过程中，每个簇最多只能被一个其他簇指为下一簇，</span><br><span class="hljs-comment"> *    因此若该簇已经被标记为不是簇起点，则表示出现了链交叉的情况，</span><br><span class="hljs-comment"> *    此时只能在当前簇切断。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 完成此扫描之后，簇链头位图中仍然为1的就是所有潜在的簇链头了。</span><br><span class="hljs-comment"> * 不过我们暂时还不知道它们是否以正确的EOF终结，也不知道它们的长度。</span><br><span class="hljs-comment">         * 这将在检查目录结构时由 checkchain() 进行，</span><br><span class="hljs-comment">         * 由于簇链只能属于一个文件，因此检查过的簇链头也将从位图中清除。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 最终，位图中余下的簇链头即为丢失簇链头。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">for</span> (cl = CLUST_FIRST; cl &lt; boot-&gt;NumClusters; cl++) &#123;<br>    nextcl = fat_get_cl_next(fat, cl);<br><br>    <span class="hljs-comment">/* 检查 nextcl 是否在有效范围 */</span><br>    <span class="hljs-keyword">if</span> (nextcl == CLUST_FREE) &#123;<br>        <span class="hljs-comment">/* 如果尚不知道最后一个未分配簇在哪，保存该簇号 */</span><br>        <span class="hljs-keyword">if</span> (boot-&gt;FSNext == <span class="hljs-number">0</span>) &#123;<br>            boot-&gt;FSNext = cl;<br>        &#125;<br>        <span class="hljs-comment">/* 该簇不可能是簇链头，标记 */</span><br>        <span class="hljs-keyword">if</span> (fat_is_cl_head(fat, cl)) &#123;<br>            fat_clear_cl_head(fat, cl);<br>        &#125;<br>        <span class="hljs-comment">/* 记账 */</span><br>        boot-&gt;NumFree++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextcl == CLUST_BAD) &#123;<br>        <span class="hljs-comment">/* 该簇不可能是簇链头，标记 */</span><br>        <span class="hljs-keyword">if</span> (fat_is_cl_head(fat, cl)) &#123;<br>            fat_clear_cl_head(fat, cl);<br>        &#125;<br>        <span class="hljs-comment">/* 记账 */</span><br>        boot-&gt;NumBad++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!valid_cl(fat, nextcl) &amp;&amp; nextcl &lt; CLUST_RSRVD) &#123;<br>        <span class="hljs-comment">/* 无效簇号，切断 */</span><br>        pwarn(<span class="hljs-string">&quot;Cluster %u continues with out of range &quot;</span><br>              <span class="hljs-string">&quot;cluster number %u\n&quot;</span>,<br>              cl,<br>              nextcl &amp; boot-&gt;ClustMask);<br>        <span class="hljs-keyword">if</span> (ask(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Truncate&quot;</span>)) &#123;<br>            ret |= fat_set_cl_next(fat, cl, CLUST_EOF);<br>            ret |= FSFATMOD;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valid_cl(fat, nextcl)) &#123;<br>        <span class="hljs-comment">/* 有效簇号，如果没有其他簇链引用过，则该簇一定不是簇链头 */</span><br>        <span class="hljs-keyword">if</span> (fat_is_cl_head(fat, nextcl)) &#123;<br>            fat_clear_cl_head(fat, nextcl);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/* 出现了交叉 */</span><br>            pwarn(<span class="hljs-string">&quot;Cluster %u crossed another chain at %u\n&quot;</span>,<br>                  cl, nextcl);<br>            <span class="hljs-keyword">if</span> (ask(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Truncate&quot;</span>)) &#123;<br>                ret |= fat_set_cl_next(fat, cl, CLUST_EOF);<br>                ret |= FSFATMOD;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>初始状态，所有的节点都是簇头：</li></ul><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703231451831.png" alt="image-20230703231451831" style="zoom:67%;"><ul><li>遍历到3的时候，这时候nextcl&#x3D;5，则此时是5有效的簇头，需要在位图中清理，置为F</li></ul><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703231548196.png" alt="image-20230703231548196" style="zoom:67%;"><ul><li>遍历到4的时候，这时候nextcl&#x3D;6，则此时是6是有效的簇头，需要为位图中清理，置为F</li></ul><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703231704977.png" alt="image-20230703231704977" style="zoom:67%;"><ul><li>遍历到5的时候，这时候nextcl&#x3D;6，此时发现<strong>6已经不是簇头</strong>了，说明之前已经有一个链占用了它，那么此时已经发生了交叉</li></ul><h2 id="4-两者的差异"><a href="#4-两者的差异" class="headerlink" title="4.两者的差异"></a>4.两者的差异</h2><p>在Android P里面，是将所有的Fat entry都读取到fatEntry这个数组中，最后一个个遍历fatEntry设置每一个节点的head来检验是否交叉：</p><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703232110410.png" alt="image-20230703232110410" style="zoom:50%;"><p>其开辟的内存calloc为 <code>NumberClusters * sizeof(fatEntry)</code></p><ul><li>已知Fat32最大支持的簇为2^28【虽然一个簇是32位，但是前4位是保留的，只用了28位】</li><li>fatEntry的大小为16字节【此处已经进行了内存对齐，都是32位】</li><li>最终开辟的内存为 2^32(Byte)&#x3D;4(GB)</li></ul><hr><p>而Android S里面是通过位图来检验是否发生了交叉</p><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703232906748.png" alt="image-20230703232906748" style="zoom: 50%;"><p>相较于之前的算法，我们可以认为fat_descriptor开辟的内存是微乎其微的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>fat文件系统学习一本通</title>
    <link href="/2023/06/30/fat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B8%80%E6%9C%AC%E9%80%9A/"/>
    <url>/2023/06/30/fat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B8%80%E6%9C%AC%E9%80%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="fat文件系统学习一本通"><a href="#fat文件系统学习一本通" class="headerlink" title="fat文件系统学习一本通"></a>fat文件系统学习一本通</h1><p>下面的是学习fat文件系统的顺序：</p><ul><li><p><a href="https://anmuxixixi.github.io/2023/06/29/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">vfat文件系统</a></p></li><li><p><a href="https://anmuxixixi.github.io/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">FAT文件系统原理</a></p></li><li><p><a href="https://anmuxixixi.github.io/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/">【实验】定位和提取FAT32分区的文件数据</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定位和提取FAT32分区的文件数据</title>
    <link href="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/"/>
    <url>/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="【实验】定位和提取FAT32分区的文件数据"><a href="#【实验】定位和提取FAT32分区的文件数据" class="headerlink" title="【实验】定位和提取FAT32分区的文件数据"></a>【实验】定位和提取FAT32分区的文件数据</h1><blockquote><p>转载自：<a href="https://ceyewan.top/p/27eb4295.html">https://ceyewan.top/p/27eb4295.html</a></p><p>仅用作自己记录，侵权联系删除！</p></blockquote><h2 id="使用-winHex-分析"><a href="#使用-winHex-分析" class="headerlink" title="使用 winHex 分析"></a>使用 winHex 分析</h2><p>这里要求的是直接从磁盘，文件系统的层面来提取数据。需要用到的工具是 winHex 。我们将 U 盘格式化为 FAT32 格式，创建一个文件，然后使用 winHex 将打开磁盘。先查看第一个扇区，得到的内容如下，可以提取出一些基本信息。</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221005195218939.png" alt="image-20221005195218939" style="zoom: 67%;"><ul><li>保留扇区数 0x0842</li><li>每簇扇区数 0x08</li><li>每扇区字节数 0x0200</li><li>FAT的个数 0x02</li><li>每个 FAT 占用的扇区数 0x00003BDF</li><li>BPB_RootClus 0x0002</li></ul><blockquote><p>FirstDataSector&#x3D;保留扇区数 + (FAT个数*每个FAT所占扇区数)</p><p>FirstSectorofCluster &#x3D; ((N-2)*每簇扇区数) + FirstDataSector</p></blockquote><p>我们通过上面可以求出根目录的扇区为： <code>0x0842 + 0x02 * 0x3BDF = 0x8000 = 32768</code> 。根目录扇区存储的内容就是根目录里的文件（夹）。查看这个扇区：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221005200017391.png" alt="image-20221005200017391" style="zoom: 67%;"><p>可以得到我们需要的文件（前八个字节是文件名）的起始簇号为 6 ，文件大小为 <code>0x12E = 302</code> ：</p><p>我们继续查看 FAT1 （扇区为 <code>0x0842</code>），FAT2 是 FAT1 的一个备份，这里面存储的是簇链：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221005200437307.png" alt="image-20221005200437307" style="zoom: 67%;"><p>我们可以看到第 6 个项就是一个结束项，说明我们的文件只有这一个簇。</p><p>文件第 6 簇的偏移 &#x3D; 更目录首簇偏移 + （文件某簇号 - 更目录首簇号）* 每簇扇区数</p><p>&#x3D; 32768 + （6 - 2）* 8 &#x3D; 32800，查看第 32800 到 32808 个扇区（一簇是八个扇区），就是文件内容：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221005200922882.png" alt="image-20221005200922882" style="zoom: 67%;"><p>现在我们再来考虑大文件的长文件名文件，长文件名会截取文件名的前 6 个字符和 ~i（i 取 1 到 5，从 1 开始，如果有了就后移）拼接成短文件名。短文件目录项上面是倒叙的长文件目录项，注意，上面长文件目录项使用的 unicode 编码（可能因为长文件名一般都不是纯 ASCII 码字符吧）：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221005202953894.png" alt="image-20221005202953894" style="zoom: 67%;"><p>我们可以看到，起始簇号为 7 ，大小为 <code>0x15D20 = 89376</code> 。继续查看 FAT1：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221005203255683.png" alt="image-20221005203255683" style="zoom: 67%;"><p>我们可以看到这个文件使用了从 7 到 <code>0x1C = 28</code> 这些簇，同理查看第 7 簇到第 28 簇的内容即可。也就是扇区 32808 到 32982 。注意，每簇 8 个扇区。</p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><p>python 的 read 就可以直接读取磁盘，读取后的文件对象 disk 可以通过 seek 方法控制偏移，从而读取不同位置的磁盘文件。我们读到的东西都是些 byte 类型，而且很奇怪，我们需要将其转化为 16 进制，对于 byte 类型的以 16 进制表示的数还是很难处理，因此我将其转化为了字符串。</p><ol><li>将以两个一组，逆序（小端序）的 16 进制数据转化为 10 进制数据：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_count</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    ans, beishu = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-built_in">dict</span> = &#123;&#125;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>(i)] = i<br>    <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]):<br>        <span class="hljs-built_in">dict</span>[c] = i + <span class="hljs-number">10</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-number">2</span>):<br>        ans += (<span class="hljs-built_in">dict</span>[s[i]] * <span class="hljs-number">16</span> + <span class="hljs-built_in">dict</span>[s[i + <span class="hljs-number">1</span>]]) * beishu<br>        beishu *= <span class="hljs-number">16</span> * <span class="hljs-number">16</span><br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><ol start="2"><li>读取 DBR 得到一些有用的数据，根目录的扇区号，FAT1 的扇区号，每个扇区的字节数，根目录的簇号和每簇的扇区数:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_DBR</span>(<span class="hljs-params">disk</span>):<br>    DBR = <span class="hljs-built_in">str</span>(binascii.hexlify(<br>        disk.read(<span class="hljs-number">512</span>)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]<br>    byte_per_sector = get_count(DBR[<span class="hljs-number">22</span>: <span class="hljs-number">26</span>])<br>    sector_per_clust = get_count(DBR[<span class="hljs-number">26</span>: <span class="hljs-number">28</span>])<br>    reserve_sector = get_count(DBR[<span class="hljs-number">28</span>: <span class="hljs-number">32</span>])<br>    count_fat = get_count(DBR[<span class="hljs-number">32</span>: <span class="hljs-number">34</span>])<br>    count_sector = get_count(DBR[<span class="hljs-number">64</span>: <span class="hljs-number">72</span>])<br>    sector_per_fat = get_count(DBR[<span class="hljs-number">72</span>: <span class="hljs-number">80</span>])<br>    BPB_RootClus = get_count(DBR[<span class="hljs-number">88</span>: <span class="hljs-number">96</span>])<br>    sector_of_root_dic = reserve_sector + count_fat * sector_per_fat<br>    <span class="hljs-keyword">return</span> sector_of_root_dic, reserve_sector, byte_per_sector, BPB_RootClus, sector_per_clust<br></code></pre></td></tr></table></figure><ol start="3"><li>通过 FAT1 和首簇得到簇链：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_clust_list</span>(<span class="hljs-params">fat1, first_clust</span>):<br>    ans = []<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        ans.append(first_clust)<br>        first_clust = get_count(fat1[first_clust * <span class="hljs-number">8</span>:(first_clust + <span class="hljs-number">1</span>) * <span class="hljs-number">8</span>])<br>        <span class="hljs-keyword">if</span> first_clust == <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0x0fffffff&#x27;</span>, <span class="hljs-number">16</span>):<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><ol start="4"><li>主函数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># 将文件路径切分</span><br>    file_list = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入文件路径：&quot;</span>).split(<span class="hljs-string">&quot;/&quot;</span>)<br>    <span class="hljs-comment"># 将文件夹名和文件名都转化为对应的 16 进制字符串</span><br>    real_filename = [<span class="hljs-built_in">str</span>(binascii.hexlify(<br>        <span class="hljs-built_in">bytes</span>(file_list[i], <span class="hljs-string">&#x27;utf-8&#x27;</span>)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(file_list))]<br>    <br>    <span class="hljs-comment"># 文件名不考虑后缀</span><br>    file_list[-<span class="hljs-number">1</span>] = file_list[-<span class="hljs-number">1</span>].split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 打开文件系统</span><br>    disk = <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;\\.\\&#x27;</span> + file_list[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;rb&#x27;</span>)<br>    <span class="hljs-comment"># 读取 DBR 得到一些用于的数据</span><br>    root_addr, fat1_addr, byte_per_sector, BPB_RootClus, sector_per_clust = read_DBR(<br>        disk)<br>    <span class="hljs-comment"># 最开始的簇链就是根目录</span><br>    clust_list = [BPB_RootClus]<br>    <span class="hljs-comment"># 对应每个文件（夹）名，通过簇链定位它的上一级目录的内容从而得到它的首簇，再得到簇链</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(file_list)):<br>        <span class="hljs-comment"># 注意要转大写</span><br>        filename = <span class="hljs-built_in">str</span>(binascii.hexlify(<br>            <span class="hljs-built_in">bytes</span>(file_list[i].upper(), <span class="hljs-string">&#x27;utf-8&#x27;</span>)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 扇区号还得乘以每个扇区的字节数才是偏移量</span><br>        disk.seek(<br>            (root_addr + (clust_list[<span class="hljs-number">0</span>] - BPB_RootClus) * sector_per_clust) * byte_per_sector)<br>        <span class="hljs-comment"># print((root_addr + (clust_list[0] - BPB_RootClus) * sector_per_clust))</span><br>        current_sector = <span class="hljs-built_in">str</span>(binascii.hexlify(<br>            disk.read(sector_per_clust * byte_per_sector)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># print(current_sector)</span><br>        <span class="hljs-comment"># print(filename)</span><br>        index = -<span class="hljs-number">1</span><br>        <span class="hljs-comment"># 短文件名，直接查看文件名对应的 16 进制字符串</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(filename) &lt;= <span class="hljs-number">16</span>:<br>            index = current_sector.find(filename)<br>            <span class="hljs-comment"># print(index)</span><br>        <span class="hljs-comment"># 长文件名查找 文件名的前 “6 个字符和 ~i‘ 然后再去和长文件目录项匹配</span><br>        <span class="hljs-keyword">else</span>:<br>            num = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">14</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">24</span>, <span class="hljs-number">28</span>, <span class="hljs-number">30</span>]<br>            <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):<br>                <span class="hljs-comment"># print(</span><br>                <span class="hljs-comment">#     filename[:12] + str(binascii.hexlify(bytes(&quot;~&quot; + str(number), &#x27;utf-8&#x27;)))[2:-1])</span><br>                index = current_sector.find(<br>                    filename[:<span class="hljs-number">12</span>] + <span class="hljs-built_in">str</span>(binascii.hexlify(<span class="hljs-built_in">bytes</span>(<span class="hljs-string">&quot;~&quot;</span> + <span class="hljs-built_in">str</span>(number), <span class="hljs-string">&#x27;utf-8&#x27;</span>)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>])<br>                temp = <span class="hljs-string">&quot;&quot;</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(real_filename[i]) / <span class="hljs-number">26</span>) + <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">13</span>):<br>                        temp += current_sector[index - <span class="hljs-number">64</span> * (<br>                            j + <span class="hljs-number">1</span>) + num[k] * <span class="hljs-number">2</span>: index - <span class="hljs-number">64</span> * (j + <span class="hljs-number">1</span>) + num[k] * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>]<br>                <span class="hljs-comment"># print(real_filename)</span><br>                <span class="hljs-comment"># print(temp)</span><br>                <span class="hljs-keyword">if</span> temp[:<span class="hljs-built_in">len</span>(real_filename[i])] == real_filename[i]:<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># print(index)</span><br>        <span class="hljs-comment"># 没找到这个文件名，说明是错误的地址</span><br>        <span class="hljs-keyword">if</span> index == -<span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;wrong path.&quot;</span>)<br>            exit(-<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 得到首簇</span><br>        first_clust = get_count(current_sector[index + <span class="hljs-number">40</span>:index + <span class="hljs-number">44</span>]) * \<br>            <span class="hljs-built_in">pow</span>(<span class="hljs-number">16</span>, <span class="hljs-number">4</span>) + get_count(current_sector[index + <span class="hljs-number">52</span>:index + <span class="hljs-number">56</span>])<br>        <span class="hljs-comment"># print(&quot;first_clust:&quot;, first_clust)</span><br>        <span class="hljs-comment"># 查找簇链</span><br>        disk.seek(fat1_addr * byte_per_sector)<br>        fat1 = <span class="hljs-built_in">str</span>(binascii.hexlify(<br>            disk.read(sector_per_clust * byte_per_sector)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]<br>        clust_list = get_clust_list(fat1, first_clust)<br>        <span class="hljs-built_in">print</span>(clust_list)<br>    <span class="hljs-comment"># 得到最后的文件的簇链，全部读取，然后写入到文件之中</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;copy.txt&quot;</span>, mode=<span class="hljs-string">&quot;w+&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>, newline=<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> clust <span class="hljs-keyword">in</span> clust_list:<br>            disk.seek(<br>                (root_addr + (clust - BPB_RootClus) * sector_per_clust) * byte_per_sector)<br>            filecontent = <span class="hljs-built_in">str</span>(binascii.hexlify(<br>                disk.read(sector_per_clust * byte_per_sector)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]<br>            <span class="hljs-comment"># print(binascii.unhexlify(filecontent.encode()).decode())</span><br>            s = binascii.unhexlify(filecontent.encode()).decode().rstrip(<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            f.write(s)<br>    <span class="hljs-comment"># print(filecontent)</span><br></code></pre></td></tr></table></figure><p>最后，展示一些结果：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221012205900741.png" alt="image-20221012205900741" style="zoom:80%;"><p>同样，实验了一下长文件夹名，长文件名和长簇链：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221012205951138.png" alt="image-20221012205951138" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】FAT文件系统原理</title>
    <link href="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <url>/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="【转载】FAT文件系统原理"><a href="#【转载】FAT文件系统原理" class="headerlink" title="【转载】FAT文件系统原理"></a>【转载】FAT文件系统原理</h1><blockquote><p>转载自：<a href="http://info.mrtlab.com/filesystem/FAT-principle-three.html">http://info.mrtlab.com/filesystem/FAT-principle-three.html</a></p><p>仅作为个人学习记录，侵权联系删除！</p></blockquote><p>FAT表(File Allocation Table 文件分配表)，是Microsoft在FAT文件系统中用于磁盘数据(文件)索引和定位引进的一种链式结构。假如把磁盘比作一本书，FAT表可以认为相当于书中的目录，而文件就是各个章节的内容。但FAT表的表示方法却与目录有很大的不同。</p><p>在FAT文件系统中，文件的存储依照FAT表制定的簇链式数据结构来进行。同时，FAT文件系统将组织数据时使用的目录也抽象为文件，以简化对数据的管理。</p><hr><p> ★存储过程假想：</p><p>我们模拟对一个分区存储数据的过程来说明FAT文件系统中数据的存储原则。</p><p>假定现在有一个空的完全没有存放数据的磁盘，大小为100KB，我们将其想象为线形的空间地址。为了存储管理上的便利，我们人为的将这100KB的空间均分成100份，每份1KB。我们来依次存储这样几个文件：A.TXT(大小10KB),B.TXT(大小53.6KB)，C.TXT(大小20.5KB)。</p><p>最起码能够想到，我们可以顺序的在这100KB空间中存放这3个文件。同时不要忘了，我们还要记下他们的大小和开始的位置，这样下次要用时才能找的到，这就像是目录。为了便于查找，我们假定用第1K的空间来存储他们的特征(属性)。还有，我们设计的存储单位是1KB，所以，A.TXT我们需要10个存储单位(为了说明方便，我们把存储单位叫做“簇”吧。也能少打点字，呵呵。)，B.TXT需要54个簇，C.TXT需要21个簇。可能有人会说B.TXT和C.TXT不是各自浪费了不到1簇的空间吗？干嘛不让他们紧挨着，不是省地方吗？我的回答是，如果按照这样的方式存储，目录中原本只需要记下簇号，现在还需要记下簇内的偏移，这样会增加目录的存储量，而且存取没有了规则，读取也不太方便，是得不偿失的。</p><p>根据上面所说的思想，我们设计了这样的图4.3.1所示的存储方式。</p><img src="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/9E224840581.gif" alt="img" style="zoom:100%;"><p>我们再考虑如何来写这三个文件的目录。对于每个文件而言，一定要记录的有：文件名，开始簇，大小，创建日期、时间，修改日期、时间，文件的读写属性等。这里大小能不能用结束簇来计算呢？一定不能，因为文件的大小不一定就是整数个簇的大小，否则的话像B.TXT的内容就是54KB的内容了，少了固然不行，可多了也是不行的。那么我们怎么记录呢？可以想象一下。为了管理上的方便，我们用数据库的管理方式来管理我们的目录。于是我把1KB再分成10份，假定开始簇号为0，定义每份100B的各个位置的代表含义如图4.3.2：</p><img src="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/D7224840866.gif" alt="img"><p>这样设计的结构绝对可以对文件进行正确的读写了。接着让我们设计的文件系统工作吧。先改动个文件，比如A.TXT，增加点内容吧！咦？增加后往哪里放呀，虽然存储块的后面有很多空间，但紧随其后B.TXT的数据还顶着呢？要是把A.TXT移到后边太浪费处理资源，而且也不一定解决问题。这个问题看来暂时解决不了。</p><p>那我们换个操作，把B.txt删了，b.txt的空间随之释放。这时候空间如图4.3.3，目录如图4.3.4：</p><img src="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/AF224840326.gif" alt="img"><p>这个操作看来还可以，我们接着做，在存入一个文件D.txt(大小为60.3KB),总共100簇的空间只用了31簇，还有68簇剩余，按说能放下。可是？往那里放呢？没有61个连续的空间了，目录行没办法写了，看来无连续块存储暂时也不行。</p><p>你一定能够想到我们可以在连续空间不够或增加文件长度的时候转移影响我们操作的其他文件，从而腾出空间来，但我要问你，那不是成天啥也不要干了，就是倒腾东西了吗？</p><p>看来我们设计的文件系统有致命的漏洞，怎么解决呢？。。。。</p><hr><p>其实可以这样解决：</p><p>首先我们允许文件的不连续存储。目录中依然只记录开始簇和文件的大小。那么我们怎么记录文件占用那些簇呢，以文件映射簇不太方便，因为文件名是不固定的。我们换个思想，可以用簇来映射文件，在整个存储空间的前部留下几簇来记录数据区中数据与簇号的关系。对于上例因为总空间也不大，所以用前部的1Kb的空间来记录这种对应，假设3个文件都存储，空间分配如图4.3.5，同时修改一下目录，如图4.3.6：</p><img src="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/FF224840997.gif" alt="img"><p>第一簇用来记录数据区中每一簇的被占用情况，暂时称其为文件分配表。结合文件分配表和文件目录就可以达到完全的文件读取了。我们想到，把文件分配表做成一个数据表，以图4.3.7的形式记录簇与数据的对应。</p><p>用图4.3.7的组织方式是完全可以实现对文件占有簇的记录的。但还不够效率。比如文件名在文件分配表中记录太多，浪费空间，而实际上在目录中已经记录了文件的开始簇了。所以可以改良一下，用链的方式来存放占有簇的关系，变成图4.3.8的组织方式。</p><img src="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/DC224840568.gif" alt="img"><p>参照图4.3.8来理解一下文件分配表的意义。如文件a.txt我们根据目录项中指定的a.txt的首簇为2，然后找到文件分配表的第2簇记录，上面登记的是3，我们就能确定下一簇是3。找到文件分配表的第3簇记录，上面登记的是4，我们就能确定下一簇是4……直到指到第11簇，发现下一个指向是FF，就是结束。文件便丝毫无误读取完毕。</p><p>我们再看上面提到的第三种情况，就是将b.txt删除以后，存入一个大小为60.3KB的d.txt。利用簇链可以很容易的实现。实现后的磁盘如图4.3.9 4.3.10 4.3.11：</p><img src="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20230630230351647.png" alt="image-20230630230351647" style="zoom: 45%;">]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vfat文件系统</title>
    <link href="/2023/06/29/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/06/29/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="vfat文件系统"><a href="#vfat文件系统" class="headerlink" title="vfat文件系统"></a>vfat文件系统</h1><blockquote><p><a href="https://www.cnblogs.com/Chary/p/12981056.html">https://www.cnblogs.com/Chary/p/12981056.html</a></p></blockquote><h2 id="1-分析Vfat文件系统的DBR"><a href="#1-分析Vfat文件系统的DBR" class="headerlink" title="1.分析Vfat文件系统的DBR"></a>1.分析Vfat文件系统的DBR</h2><p>vfat文件系统的DBR有5部分组成，分别为跳转指令，OEM代号，BPB，引导程序和结束标志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs shell">00000000  eb 58 90 6d 6b 66 73 2e  66 61 74 00 02 08 20 00  |.X.mkfs.fat... .|<br>00000010  02 00 00 00 00 f8 00 00  3f 00 ff 00 00 08 00 00  |........?.......|<br>00000020  00 00 39 00 40 0e 00 00  00 00 00 00 02 00 00 00  |..9.@...........|<br>00000030  01 00 06 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000040  80 00 29 d7 6c d4 7e 4e  4f 20 4e 41 4d 45 20 20  |..).l.~NO NAME  |<br>00000050  20 20 46 41 54 33 32 20  20 20 0e 1f be 77 7c ac  |  FAT32   ...w|.|<br>00000060  22 c0 74 0b 56 b4 0e bb  07 00 cd 10 5e eb f0 32  |&quot;.t.V.......^..2|<br>00000070  e4 cd 16 cd 19 eb fe 54  68 69 73 20 69 73 20 6e  |.......This is n|<br>00000080  6f 74 20 61 20 62 6f 6f  74 61 62 6c 65 20 64 69  |ot a bootable di|<br>00000090  73 6b 2e 20 20 50 6c 65  61 73 65 20 69 6e 73 65  |sk.  Please inse|<br>000000a0  72 74 20 61 20 62 6f 6f  74 61 62 6c 65 20 66 6c  |rt a bootable fl|<br>000000b0  6f 70 70 79 20 61 6e 64  0d 0a 70 72 65 73 73 20  |oppy and..press |<br>000000c0  61 6e 79 20 6b 65 79 20  74 6f 20 74 72 79 20 61  |any key to try a|<br>000000d0  67 61 69 6e 20 2e 2e 2e  20 0d 0a 00 00 00 00 00  |gain ... .......|<br>000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|<br>00000200  52 52 61 41 00 00 00 00  00 00 00 00 00 00 00 00  |RRaA............|<br>00000210  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>000003e0  00 00 00 00 72 72 41 61  6b 1c 07 00 02 00 00 00  |....rrAak.......|<br>000003f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|<br>00000400  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>00000c00  eb 58 90 6d 6b 66 73 2e  66 61 74 00 02 08 20 00  |.X.mkfs.fat... .|<br>00000c10  02 00 00 00 00 f8 00 00  3f 00 ff 00 00 08 00 00  |........?.......|<br>00000c20  00 00 39 00 40 0e 00 00  00 00 00 00 02 00 00 00  |..9.@...........|<br>00000c30  01 00 06 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000c40  80 00 29 d7 6c d4 7e 4e  4f 20 4e 41 4d 45 20 20  |..).l.~NO NAME  |<br>00000c50  20 20 46 41 54 33 32 20  20 20 0e 1f be 77 7c ac  |  FAT32   ...w|.|<br>00000c60  22 c0 74 0b 56 b4 0e bb  07 00 cd 10 5e eb f0 32  |&quot;.t.V.......^..2|<br>00000c70  e4 cd 16 cd 19 eb fe 54  68 69 73 20 69 73 20 6e  |.......This is n|<br>00000c80  6f 74 20 61 20 62 6f 6f  74 61 62 6c 65 20 64 69  |ot a bootable di|<br>00000c90  73 6b 2e 20 20 50 6c 65  61 73 65 20 69 6e 73 65  |sk.  Please inse|<br>00000ca0  72 74 20 61 20 62 6f 6f  74 61 62 6c 65 20 66 6c  |rt a bootable fl|<br>00000cb0  6f 70 70 79 20 61 6e 64  0d 0a 70 72 65 73 73 20  |oppy and..press |<br>00000cc0  61 6e 79 20 6b 65 79 20  74 6f 20 74 72 79 20 61  |any key to try a|<br>00000cd0  67 61 69 6e 20 2e 2e 2e  20 0d 0a 00 00 00 00 00  |gain ... .......|<br>00000ce0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>00000df0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|<br>00000e00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>00004000  f8 ff ff 0f ff ff ff 0f  f8 ff ff 0f 00 00 00 00  |................|<br>00004010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>001cc000  f8 ff ff 0f ff ff ff 0f  f8 ff ff 0f 00 00 00 00  |................|<br>001cc010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>72000000<br></code></pre></td></tr></table></figure><p><strong>（1）跳转指令</strong></p><p><strong>E8 58 90 ：(跳转指令) 本身占2字节它将程序执行流程跳转到引导程序处。</strong></p><p><strong>（2）OEM代号</strong></p><p><strong>4D 53 57 49 4E 34 2E 31 :(OEM代号) 这部分占8字节，其内容由创建该文件系统的OEM厂商具体安排。</strong></p><p><strong>（3）BPB</strong></p><p>vfat的BPB从DBR的第12个字节开始，占用79字节，记录了有关该文件系统的重要信息，各参数解释如下表：</p><p><strong>前面53个字节是BPB，后面26个字节是扩展BPB。</strong></p><table><thead><tr><th>对应值</th><th>字段长度（Byte）</th><th>名称和定义</th><th>取值含义</th></tr></thead><tbody><tr><td>0x0200</td><td>2</td><td>扇区字节数（Byte Per Sector）</td><td>每个扇区512字节</td></tr><tr><td>0x08</td><td>1</td><td>每簇扇区数（Sector Per Cluster）</td><td>每簇8个扇区</td></tr><tr><td>0x0020</td><td>2</td><td>保留扇区数</td><td>保留32个扇区</td></tr><tr><td>0x02</td><td>1</td><td>FAT数</td><td>2个FAT</td></tr><tr><td>0x0000</td><td>2</td><td>根目录项数（只有FAT12&#x2F;FAT16使用此字段）</td><td>根目录项数为0</td></tr><tr><td>0x0000</td><td>2</td><td>小扇区数（只有FAT12&#x2F;FAT16使用此字段）</td><td>小扇区数为0</td></tr><tr><td>0xf8</td><td>1</td><td>媒体描述符（0xf8表示硬盘）</td><td>硬盘</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vold中fork子进程执行命令</title>
    <link href="/2023/06/26/vold%E4%B8%ADfork%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/06/26/vold%E4%B8%ADfork%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="vold中fork子进程执行命令"><a href="#vold中fork子进程执行命令" class="headerlink" title="vold中fork子进程执行命令"></a>vold中fork子进程执行命令</h1><blockquote><p>🍃 前置知识：</p><ul><li><a href="https://anmuxixixi.github.io/2023/06/26/linux%E4%B8%ADpipe%E5%92%8Cdup2%E8%AF%A6%E8%A7%A3/">linux中pipe和dup2详解</a></li><li><a href="https://anmuxixixi.github.io/2023/06/26/Linux%E4%B8%AD%E7%9A%84STDIN-FILENO%E5%92%8CSTDOUT-FILENO/">Linux中的STDIN_FILENO和STDOUT_FILENO_</a></li><li><a href="https://blog.csdn.net/duapple/article/details/126918593">记录fork子进程执行execl阻塞卡死的问题</a></li></ul></blockquote><h2 id="1-fork子进程执行命令"><a href="#1-fork子进程执行命令" class="headerlink" title="1.fork子进程执行命令"></a>1.fork子进程执行命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\vold\Utils.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">ForkExecvp</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt;&amp; args, std::vector&lt;std::string&gt;* output,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">security_context_t</span> context)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> argv = <span class="hljs-built_in">ConvertToArgv</span>(args);<br><br>    android::base::unique_fd pipe_read, pipe_write;<br>    <span class="hljs-keyword">if</span> (!android::base::<span class="hljs-built_in">Pipe</span>(&amp;pipe_read, &amp;pipe_write)) &#123;<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Pipe in ForkExecvp&quot;</span>;<br>        <span class="hljs-keyword">return</span> -errno;<br>    &#125;<br><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        pipe_read.<span class="hljs-built_in">reset</span>();<br>        <span class="hljs-comment">// 将STDOUT_FILENO(也就是终端输出)重定向到pipe_write</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dup2</span>(pipe_write.<span class="hljs-built_in">get</span>(), STDOUT_FILENO) == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;dup2 in ForkExecvp&quot;</span>;<br>            _exit(EXIT_FAILURE);<br>        &#125;<br>        pipe_write.<span class="hljs-built_in">reset</span>();<br>        <span class="hljs-comment">// 执行命令</span><br>        <span class="hljs-built_in">execvp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>**&gt;(argv.<span class="hljs-built_in">data</span>()));<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;exec in ForkExecvp&quot;</span>;<br>        _exit(EXIT_FAILURE);<br>    &#125;<br><br>    pipe_write.<span class="hljs-built_in">reset</span>();<br>    <span class="hljs-keyword">auto</span> st = <span class="hljs-built_in">ReadLinesFromFdAndLog</span>(output, std::<span class="hljs-built_in">move</span>(pipe_read));<br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> st;<br><br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-comment">// 等待子进程执行结束</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">waitpid</span>(pid, &amp;status, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;waitpid in ForkExecvp&quot;</span>;<br>        <span class="hljs-keyword">return</span> -errno;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>---------------------------------------------------<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">status_t</span> <span class="hljs-title">ReadLinesFromFdAndLog</span><span class="hljs-params">(std::vector&lt;std::string&gt;* output,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      android::base::unique_fd ufd)</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;FILE, <span class="hljs-title">int</span> <span class="hljs-params">(*)</span><span class="hljs-params">(FILE*)</span>&gt; <span class="hljs-title">fp</span><span class="hljs-params">(android::base::Fdopen(std::move(ufd), <span class="hljs-string">&quot;r&quot;</span>), fclose)</span></span>;<br>    <span class="hljs-type">char</span> line[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fgets</span>(line, <span class="hljs-built_in">sizeof</span>(line), fp.<span class="hljs-built_in">get</span>()) != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">LOG</span>(DEBUG) &lt;&lt; line;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里其实就是fork子进程后理解调用exec族函数execvp去执行命令。</p><img src="/2023/06/26/vold%E4%B8%ADfork%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/image-20230626230653727.png" alt="image-20230626230653727" style="zoom: 80%;"><h2 id="2-异步执行fork子进程执行命令"><a href="#2-异步执行fork子进程执行命令" class="headerlink" title="2.异步执行fork子进程执行命令"></a>2.异步执行fork子进程执行命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">ForkExecvpAsync</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt;&amp; args)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> argv = <span class="hljs-built_in">ConvertToArgv</span>(args);<br><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 关闭了所有的流</span><br>        <span class="hljs-built_in">close</span>(STDIN_FILENO);<br>        <span class="hljs-built_in">close</span>(STDOUT_FILENO);<br>        <span class="hljs-built_in">close</span>(STDERR_FILENO);<br><span class="hljs-comment">// 执行命令行</span><br>        <span class="hljs-built_in">execvp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>**&gt;(argv.<span class="hljs-built_in">data</span>()));<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;exec in ForkExecvpAsync&quot;</span>;<br>        _exit(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">return</span> pid;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-差异"><a href="#3-差异" class="headerlink" title="3.差异"></a>3.差异</h2><p>ForkExecvp与ForkExecvpAsync对比后差异在于：</p><ul><li>ForkExecvp会将命令行执行的结果通过日志打印出来，而ForkExecvpAsync则执行执行命令行</li><li>ForkExecvp在多线程某种极端的情况下，可能发生死锁【<a href="https://blog.csdn.net/duapple/article/details/126918593%E3%80%91%E3%80%82">https://blog.csdn.net/duapple/article/details/126918593】。</a></li><li>使用了匿名管道的ForkExecvp是非异步的，而ForkExecvpAsync是异步的</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】linux中pipe和dup2详解</title>
    <link href="/2023/06/26/linux%E4%B8%ADpipe%E5%92%8Cdup2%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/06/26/linux%E4%B8%ADpipe%E5%92%8Cdup2%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="【转载】linux中pipe和dup2详解"><a href="#【转载】linux中pipe和dup2详解" class="headerlink" title="【转载】linux中pipe和dup2详解"></a>【转载】linux中pipe和dup2详解</h1><blockquote><p>转载自：<a href="https://www.cnblogs.com/Hxinguan/p/5007393.html">https://www.cnblogs.com/Hxinguan/p/5007393.html</a></p></blockquote><h2 id="1-什么是管道"><a href="#1-什么是管道" class="headerlink" title="1.什么是管道"></a>1.什么是管道</h2><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道； 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）； 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p><h2 id="2-管道的创建"><a href="#2-管道的创建" class="headerlink" title="2.管道的创建"></a>2.管道的创建</h2><p>int pipe(int fd[2])</p><p>该函数创建的管道的两端处于一个中间进程，在实际应用中并没有太大意义，一般在pipe()创建管道后，再fork()一个子进程，然后通过管道实现父子进程之间的通信。</p><h2 id="3-管道的读写规则"><a href="#3-管道的读写规则" class="headerlink" title="3.管道的读写规则"></a>3.管道的读写规则</h2><p>管道两端可分别用描述字fd[0]以及fd[1]来描述，需要注意的是，管道的两端是固定了任务的。即一端只能用于读，由描述字fd[0]表示，称其为管道读端；另一端则只能用于写，由描述字fd[1]来表示，称其为管道写端。</p><h2 id="4-pipe函数"><a href="#4-pipe函数" class="headerlink" title="4.pipe函数"></a>4.pipe函数</h2><p>头文件：#include&lt;unistd.h&gt;</p><p>函数原型： int pipe(int fd[2])</p><p>函数参数：fd[2],管道的两个文件描述符，之后就是可以直接操作这两个文件描述符。其中fd[0]为读取端，fd[1]为写入端</p><p>返回值：成功返回0，否则返回-1</p><ul><li><p>读fd[0]: close(fd[1]); read(fd[0], buf, BUF_SIZE);</p></li><li><p>写fd[1]: close(fd[0]); read(fd[1], buf, strlen(buf));</p></li></ul><h2 id="5-例子"><a href="#5-例子" class="headerlink" title="5.例子"></a>5.例子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">pipe</span>(fd) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is the father process, here write a string to the pipe\n&quot;</span>);<br>        <span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;Hello! write a string in the father process\n&quot;</span>;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">write</span>(fd[<span class="hljs-number">1</span>], s, <span class="hljs-built_in">sizeof</span>(s));              <span class="hljs-comment">// 向管道中写入数据</span><br><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is the child process, here read a string from the pipe\n&quot;</span>);<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">read</span>(fd[<span class="hljs-number">0</span>], buf, <span class="hljs-built_in">sizeof</span>(buf));          <span class="hljs-comment">//从管道中读取数据</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>    &#125;<br>    <span class="hljs-built_in">waitpid</span>(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><img src="/2023/06/26/linux%E4%B8%ADpipe%E5%92%8Cdup2%E8%AF%A6%E8%A7%A3/image-20230626220856696.png" alt="image-20230626220856696" style="zoom:80%;"><p>当管道中数据被读取后，管道为空。之后再read操作将默认的被阻塞，等待某些数据被写入。如需要设置为非阻塞，则可做如下设置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">fcntl</span>(filedes[<span class="hljs-number">0</span>], F_SETFL, O_NONBLOCK);<br><span class="hljs-built_in">fcntl</span>(filedes[<span class="hljs-number">1</span>], F_SETFL, O_NONBLOCK);<br></code></pre></td></tr></table></figure><h2 id="6-dup2读取"><a href="#6-dup2读取" class="headerlink" title="6.dup2读取"></a>6.dup2读取</h2><p>用来复制一个现存的文件描述符，使两个文件描述符指向同一个<code>file</code>结构体。</p><p>其中头文件：#include &lt;unistd.h&gt;</p><p>函数原型：int dup2(int oldhandle, int newhandle);</p><p>例子还是使用上面那个例子，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">int</span> newfd;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">pipe</span>(fd) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is the father process, here write a string to the pipe\n&quot;</span>);<br>        <span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;Hello! write a string in the father process\n&quot;</span>;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">write</span>(fd[<span class="hljs-number">1</span>], s, <span class="hljs-built_in">sizeof</span>(s));              <span class="hljs-comment">// 向管道中写入数据</span><br><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is the child process, here read a string from the pipe\n&quot;</span>);<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">0</span>], newfd);<br>        <span class="hljs-built_in">read</span>(newfd, buf, <span class="hljs-built_in">sizeof</span>(buf));          <span class="hljs-comment">//从管道中读取数据</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>    &#125;<br>    <span class="hljs-built_in">waitpid</span>(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行的结果还是一样。只是在36行代码中调用了dup2,把fd[0]复制给newfd。</p><img src="/2023/06/26/linux%E4%B8%ADpipe%E5%92%8Cdup2%E8%AF%A6%E8%A7%A3/image-20230626221136998.png" alt="image-20230626221136998" style="zoom:80%;"><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br> <br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILENME   <span class="hljs-string">&quot;1.txt&quot;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">O_RDWR: 可读可写</span><br><span class="hljs-comment">O_TRUNC: 会把原有内容删除  。 英文读：欧擦克</span><br><span class="hljs-comment">O_CREAT: 如果a.txt 没有这个文件，就会新建一个 a.txt</span><br><span class="hljs-comment">O_APPEND: 接续添加要写入的内容 。 英文读：欧额盆得</span><br><span class="hljs-comment">*/</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> fd1 = <span class="hljs-number">-1</span>, fd2 = <span class="hljs-number">-1</span>;<br><br>fd1 = <span class="hljs-built_in">open</span>(FILENME, O_RDWR | O_APPEND ); <br><br><span class="hljs-keyword">if</span> (fd1 &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd1 = %d.\n&quot;</span>, fd1);<br><br><span class="hljs-comment">//如果正确 就会返回新的 文件描述符 16 </span><br>fd2 = <span class="hljs-built_in">dup2</span>(fd1,<span class="hljs-number">16</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd2 = %d .\n&quot;</span>,fd2);<br><br><span class="hljs-comment">//因为只打开了 fd1, 所以只关闭fd1就可以了</span><br><span class="hljs-built_in">close</span>(fd1);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/2023/06/26/linux%E4%B8%ADpipe%E5%92%8Cdup2%E8%AF%A6%E8%A7%A3/6766a5c4f0924a6aa4c0e99f3826b24b.png" alt="img" style="zoom: 80%;">]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的STDIN_FILENO和STDOUT_FILENO</title>
    <link href="/2023/06/26/Linux%E4%B8%AD%E7%9A%84STDIN-FILENO%E5%92%8CSTDOUT-FILENO/"/>
    <url>/2023/06/26/Linux%E4%B8%AD%E7%9A%84STDIN-FILENO%E5%92%8CSTDOUT-FILENO/</url>
    
    <content type="html"><![CDATA[<h1 id="【转载】Linux中的STDIN-FILENO和STDOUT-FILENO"><a href="#【转载】Linux中的STDIN-FILENO和STDOUT-FILENO" class="headerlink" title="【转载】Linux中的STDIN_FILENO和STDOUT_FILENO"></a>【转载】Linux中的STDIN_FILENO和STDOUT_FILENO</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/sinat_25457161/article/details/48548231?spm=1001.2014.3001.5506">https://blog.csdn.net/sinat_25457161/article/details/48548231?spm=1001.2014.3001.5506</a></p></blockquote><p><strong>说明：</strong></p><blockquote><p>STDIN_FILENO：接收键盘的输入</p><p>STDOUT_FILENO：向屏幕输出</p></blockquote><p><strong>程序：</strong></p><blockquote><p>接收用户在屏幕上输入的数据，并在屏幕上输出（要求使用read和wirte实现），用户输入quit就退出程序。</p></blockquote><p><strong>图解说明：</strong></p><img src="/2023/06/26/Linux%E4%B8%AD%E7%9A%84STDIN-FILENO%E5%92%8CSTDOUT-FILENO/20150918165941312.jpeg" alt="img" style="zoom:80%;"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *args[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义读取文件的缓冲区</span><br><span class="hljs-type">char</span> buf_read[<span class="hljs-number">1024</span>];<br><span class="hljs-comment">// 定义写入文件的缓冲区</span><br><span class="hljs-type">char</span> buf_write[<span class="hljs-number">1024</span>];<br><br><span class="hljs-comment">// 循环读取用户从键盘输入的信息</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">// 清空读取文件缓冲区中的内存</span><br><span class="hljs-built_in">memset</span>(buf_read, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buf_read));<br><span class="hljs-comment">// 清空写入文件缓冲区中的内存</span><br><span class="hljs-built_in">memset</span>(buf_write, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buf_write));<br><br><span class="hljs-comment">// 打印提示信息</span><br><span class="hljs-type">char</span> input_message[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;input some words : &quot;</span>;<br><span class="hljs-built_in">write</span>(STDOUT_FILENO, input_message, <span class="hljs-built_in">sizeof</span>(input_message));<br><span class="hljs-comment">// 读取用户的键盘输入信息</span><br><span class="hljs-built_in">read</span>(STDIN_FILENO, buf_read, <span class="hljs-built_in">sizeof</span>(buf_read));<br><span class="hljs-comment">// 判断用户输入的内容是否为quit</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(buf_read, <span class="hljs-string">&quot;quit&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 如果用户输入的是quit，程序退出循环</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 如果用户输入的不是quit</span><br><span class="hljs-comment">// 把内容拷贝到写入文件缓冲区中</span><br><span class="hljs-built_in">strcpy</span>(buf_write, buf_read);<br><span class="hljs-comment">// 打印提示信息</span><br><span class="hljs-type">char</span> output_message[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;output some words : &quot;</span>;<br><span class="hljs-built_in">write</span>(STDOUT_FILENO, output_message, <span class="hljs-built_in">sizeof</span>(output_message));<br><span class="hljs-comment">// 将信息显示在屏幕上</span><br><span class="hljs-built_in">write</span>(STDOUT_FILENO, buf_write, <span class="hljs-built_in">strlen</span>(buf_write));<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/06/26/Linux%E4%B8%AD%E7%9A%84STDIN-FILENO%E5%92%8CSTDOUT-FILENO/image-20230626215903169.png" alt="image-20230626215903169" style="zoom:80%;"><p>程序实现了，没有使用scanf和printf，从键盘接收用户输入和将用户输入的信息打印到屏幕上。</p>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【科普】非对称加密技术（公钥体系）【公钥 私钥 数字签名 CA证书】</title>
    <link href="/2023/06/24/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%EF%BC%88%E5%85%AC%E9%92%A5%E4%BD%93%E7%B3%BB%EF%BC%89%E3%80%90%E5%85%AC%E9%92%A5-%E7%A7%81%E9%92%A5-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-CA%E8%AF%81%E4%B9%A6%E3%80%91/"/>
    <url>/2023/06/24/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%EF%BC%88%E5%85%AC%E9%92%A5%E4%BD%93%E7%B3%BB%EF%BC%89%E3%80%90%E5%85%AC%E9%92%A5-%E7%A7%81%E9%92%A5-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-CA%E8%AF%81%E4%B9%A6%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="【科普】非对称加密技术（公钥体系）【公钥-私钥-数字签名-CA证书】"><a href="#【科普】非对称加密技术（公钥体系）【公钥-私钥-数字签名-CA证书】" class="headerlink" title="【科普】非对称加密技术（公钥体系）【公钥 私钥 数字签名 CA证书】"></a>【科普】非对称加密技术（公钥体系）【公钥 私钥 数字签名 CA证书】</h1><p><a href="https://www.bilibili.com/video/BV15P4y1S7Jw/">https://www.bilibili.com/video/BV15P4y1S7Jw/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【实验】openssl模拟证书的生成过程</title>
    <link href="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="【实验】openssl模拟证书的生成过程"><a href="#【实验】openssl模拟证书的生成过程" class="headerlink" title="【实验】openssl模拟证书的生成过程"></a>【实验】openssl模拟证书的生成过程</h1><blockquote><p>实验内容来自：<a href="https://www.cnblogs.com/frisk/p/12628159.html">https://www.cnblogs.com/frisk/p/12628159.html</a></p><p>🔕基础知识参考博客先进行回顾！！！</p></blockquote><p>🥇 <strong>openssl x509工具主要用于输出证书信息, 签署证书请求文件、自签署、转换证书格式等。它就像是一个完整的小型的CA工具箱。</strong></p><p><strong>（1）运营商私钥</strong></p><p> 模拟生成运营商的私钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">需要经常输入密码</span><br>openssl genrsa -des3 -out server_private.key 2048 会有输入密码的要求<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">去除密码</span><br>openssl rsa -in server_private.key -out server_private.key<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">无密码证书秘钥</span><br>openssl genrsa -out server_private.key 2048<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成公钥</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">openssl rsa -<span class="hljs-keyword">in</span> server_private.key -pubout -out server_public.key</span><br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621223828285.png" alt="image-20230621223828285" style="zoom: 67%;"><p><strong>（2）运营商向CA申请证书文件</strong></p><p>模拟生成运营商 证书申请文件&#x2F;证书签名请求文件 <code>.req</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -new -key server_private.key -out server.req<br><span class="hljs-meta prompt_"># </span><span class="language-bash">会让输入Country Name 填 CN; Common Name 填 ip 也可以不填。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看server.req</span><br>openssl req -in server.req -text<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621224000406.png" alt="image-20230621224000406" style="zoom: 67%;"><p><strong>（3）CA机构要有自己的私钥，为运营商签发证书</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl genrsa -out ca_private.key 2048<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621224112637.png" alt="image-20230621224112637" style="zoom:67%;"><p><strong>（4）CA机构 也要向 更高级的CA机构 申请证书, 有了自己的证书 才能为运营商签发证书</strong></p><p> 生成 CA证书申请文件&#x2F;证书签名请求文件 <code>.req</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -new -key ca_private.key  -out ca_request.req<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看ca_request.req</span><br>openssl req -in ca_request.req -text<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621224223565.png" alt="image-20230621224223565" style="zoom:67%;"><p><strong>（5）CA机构获得证书</strong></p><p>创建CA证书，用来给运营商的证书签名。</p><p>这个证书，本来应由更高级的CA用它的private key对这个证书请求进行签发，</p><p>由于此时模拟的CA是 root CA，没有更高级的CA了，所以要进行自签发，用 自己的private key对 自己的证书请求 进行签发。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -req -in ca_request.req -signkey ca_private.key -days 365 -out ca.pem<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看证书</span><br>openssl x509 -in ca.pem -noout -text<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621224336866.png" alt="image-20230621224336866" style="zoom:67%;"><p><strong>（6）CA机构向运营商签发证书</strong></p><p>CA用自己的CA证书ca.pem 和 私钥ca_private.key 为 server.req运营商请求文件签名，生成运营商的证书:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -req -in server.req -CA ca.pem -CAkey ca_private.key -days 365 -CAcreateserial -out server.pem<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看证书</span><br>openssl x509 -in server.pem -noout -text<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看公钥</span><br>openssl x509 -in server.pem -noout -pubkey<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621225245969.png" alt="image-20230621225245969" style="zoom:67%;"><p><strong>（7）查看服务器证书的modulus和服务器私钥的modulus，应该一样：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -in server.pem -noout -modulus<br>openssl rsa -in server_private.key -noout -modulus<br></code></pre></td></tr></table></figure><p><strong>（8）用户访问https网站，服务器会用private key加密数据传输，同时会把证书传给用户，里面有public key信息，用于解密数据。</strong></p><p>用户使用公钥解密的时候，要确认此公钥是否是服务商的，是否是受信任的。</p><p>用户从服务商证书中发现，其证书是由某CA签发的，从CA官网下载他的证书，发现它由 更高级CA签发 或者 是root证书，自签发的。</p><p>这时就可以一级一级的验证证书的合法性，最终确认服务商的证书是否被信任。</p><p>验证后就可以使用公钥解密信息，进行通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl verify -CAfile ca.pem server.pem<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621225426965.png" alt="image-20230621225426965" style="zoom:67%;"><p><strong>（9）从证书导出公钥</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -in server.pem -noout -pubkey -out server_public.key<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621225505365.png" alt="image-20230621225505365" style="zoom:67%;"><p><strong>（10）使用公钥加密，私钥解密</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建测试文件</span><br>cat amx.txt<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621225609552.png" alt="image-20230621225609552" style="zoom: 67%;"><p>加解密</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加密</span><br>openssl rsautl -encrypt -in test.txt -inkey server_public.key -pubin -out test_encrypt.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解密</span><br>openssl rsautl -decrypt -in test_encrypt.txt -inkey server_private.key -out test_decrypt.txt<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621225700280.png" alt="image-20230621225700280" style="zoom:67%;"><p>最终的文本解密成功…</p><p><strong>（11）查看证书内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打印出证书的内容：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -text</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印出证书的系列号：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -serial</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印出证书的拥有者名字：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -subject</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">以RFC2253规定的格式打印出证书的拥有者名字：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -subject -nameopt RFC2253</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印出证书的MD5特征参数：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -fingerprint</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印出证书有效期：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -dates</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印出证书公钥：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -pubkey</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">验证证书的有效性：openssl verify -CAfile ca.pem server.pem</span><br></code></pre></td></tr></table></figure><p>⭐<strong>（12）证书秘钥要使用相同的编码格式</strong></p><p><strong>（13）证书格式转换</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">PEM转DER格式：openssl x509 -inform pem -<span class="hljs-keyword">in</span> server.pem -outform der -out server.der</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">DER转PEM格式：openssl x509 -inform der -<span class="hljs-keyword">in</span> server.der -outform pem -out server.pem0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓锁屏与FBE浅浅理解</title>
    <link href="/2023/06/18/%E5%AE%89%E5%8D%93%E9%94%81%E5%B1%8F%E4%B8%8EFBE%E6%B5%85%E6%B5%85%E7%90%86%E8%A7%A3/"/>
    <url>/2023/06/18/%E5%AE%89%E5%8D%93%E9%94%81%E5%B1%8F%E4%B8%8EFBE%E6%B5%85%E6%B5%85%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓锁屏与FBE浅浅理解"><a href="#安卓锁屏与FBE浅浅理解" class="headerlink" title="安卓锁屏与FBE浅浅理解"></a>安卓锁屏与FBE浅浅理解</h1><blockquote><p>🔴 <strong>注意</strong>：本文是基于Android 12(S)进行分析的，可能与Android 10(Q)有些出入。</p></blockquote><h2 id="1-LockscreenCredential对象"><a href="#1-LockscreenCredential对象" class="headerlink" title="1.LockscreenCredential对象"></a>1.LockscreenCredential对象</h2><img src="/2023/06/18/%E5%AE%89%E5%8D%93%E9%94%81%E5%B1%8F%E4%B8%8EFBE%E6%B5%85%E6%B5%85%E7%90%86%E8%A7%A3/image-20230618201829816.png" alt="image-20230618201829816" style="zoom:75%;"><p>从安卓文档可以看出，LockscreenCredential是一个锁屏凭证，可以是空密码，图案，密码，或者PIN码等。也就是说LockscreenCredential是一个锁屏凭证的抽象。我们可以通过<strong>LockscreenCredential.createPassword</strong>去构造一个credential对象。</p><blockquote><p>这里详细的可以先学习：<a href="https://blog.csdn.net/weixin_42135087/article/details/124565234">https://blog.csdn.net/weixin_42135087/article/details/124565234</a></p></blockquote><hr><h2 id="2-设置锁屏与FBE的关系"><a href="#2-设置锁屏与FBE的关系" class="headerlink" title="2.设置锁屏与FBE的关系"></a>2.设置锁屏与FBE的关系</h2><h3 id="2-1-addUserKeyAuth层层调用"><a href="#2-1-addUserKeyAuth层层调用" class="headerlink" title="2.1 addUserKeyAuth层层调用"></a>2.1 addUserKeyAuth层层调用</h3><p>⭐ 在Android系统重的设置密码、清除密码、修改密码，都是调用到LockSettingsService.java的setLockCredential函数进行的，而setLockCredential又调用了setLockCredentialInternal。【引用：<a href="https://blog.csdn.net/weixin_42135087/article/details/109726612?spm=1001.2014.3001.5506%E3%80%91">https://blog.csdn.net/weixin_42135087/article/details/109726612?spm=1001.2014.3001.5506】</a></p><blockquote><p>从<a href="https://blog.csdn.net/weixin_42135087">代码改变世界ctw</a>大哥的博客中可以知道，当我们创建了设置用户密码的时候会调用到setLockCredentialInternal ，下面的调用栈如下：</p><p>setLockCredentialInternal -&gt; setUserKeyProtection -&gt;  addUserKeyAuth</p><p>从addUserKeyAuth从和FBE扯上了关系</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\locksettings\LockSettingsService.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUserKeyAuth</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> mUserManager.getUserInfo(userId);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">callingId</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>    <span class="hljs-comment">// 调用SMS的addUserKeyAuth方法</span><br>    mStorageManager.addUserKeyAuth(userId, userInfo.serialNumber, token, secret);<br>&#125;<br><br><span class="hljs-comment">// ---------------------------------------------------------------</span><br><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\StorageManagerService.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUserKeyAuth</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">int</span> serialNumber, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret)</span> &#123;<br>    mVold.addUserKeyAuth(userId, serialNumber, encodeBytes(token), encodeBytes(secret));<br>&#125;<br><br><span class="hljs-comment">// ---------------------------------------------------------------</span><br><span class="hljs-comment">// system\vold\VoldNativeService.cpp</span><br>binder::Status VoldNativeService::addUserKeyAuth(int32_t userId, int32_t userSerial,<br>                                                 const std::string&amp; token,<br>                                                 const std::string&amp; secret) &#123;<br>    <span class="hljs-keyword">if</span> (!token_empty(token)) &#123;<br>        LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;Vold doesn&#x27;t use auth tokens, but non-empty token passed to addUserKeyAuth.&quot;</span>;<br>        <span class="hljs-keyword">return</span> binder::Status::fromServiceSpecificError(-EINVAL);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> translateBool(fscrypt_add_user_key_auth(userId, userSerial, secret));<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的注释可以看出，Vold服务是不需要AuthToken的，所以不需要向FBE传递。</p><h3 id="2-2-fscrypt-add-user-key-auth开始添加用户权限"><a href="#2-2-fscrypt-add-user-key-auth开始添加用户权限" class="headerlink" title="2.2 fscrypt_add_user_key_auth开始添加用户权限"></a>2.2 fscrypt_add_user_key_auth开始添加用户权限</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fscrypt_add_user_key_auth</span><span class="hljs-params">(<span class="hljs-type">userid_t</span> user_id, <span class="hljs-type">int</span> serial, <span class="hljs-type">const</span> std::string&amp; secret_hex)</span> </span>&#123;<br><span class="hljs-comment">// 判断是否支持文件级加密</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">fscrypt_is_native</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 还原锁屏码</span><br>    <span class="hljs-keyword">auto</span> auth = <span class="hljs-built_in">authentication_from_hex</span>(secret_hex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fscrypt_rewrap_user_key</span>(user_id, serial, kEmptyAuthentication, *auth);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用fscrypt_rewrap_user_key</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">fscrypt_rewrap_user_key</span><span class="hljs-params">(<span class="hljs-type">userid_t</span> user_id, <span class="hljs-type">int</span> serial,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> android::vold::KeyAuthentication&amp; retrieve_auth,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> android::vold::KeyAuthentication&amp; store_auth)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前用户的CE_KEY目录: /data/misc/vold/user_keys/ce/&lt;userid&gt;</span><br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> directory_path = <span class="hljs-built_in">get_ce_key_directory_path</span>(user_id);<br>    KeyBuffer ce_key;<br>    std::string ce_key_current_path = <span class="hljs-built_in">get_ce_key_current_path</span>(directory_path); <span class="hljs-comment">// /data/misc/vold/user_keys/ce/&lt;userid&gt;/current</span><br>    <span class="hljs-built_in">retrieveKey</span>(ce_key_current_path, kEmptyAuthentication, &amp;ce_key);<br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> paths = <span class="hljs-built_in">get_ce_key_paths</span>(directory_path);<br>    std::string ce_key_path;<br>    <span class="hljs-comment">// 新路径: /data/misc/vold/user_keys/ce/&lt;userid&gt;/current/cx%010u，例如/data/misc/vold/user_keys/ce/0/current/cx0000000000</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">get_ce_key_new_path</span>(directory_path, paths, &amp;ce_key_path)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// user_key_temp: /data/misc/vold/user_keys/temp</span><br>    <span class="hljs-comment">// 保存CE Key</span><br>    <span class="hljs-keyword">if</span> (!android::vold::<span class="hljs-built_in">storeKeyAtomically</span>(ce_key_path, user_key_temp, store_auth, ce_key))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用storeKeyAtomically保存当前用户的CE Key</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">storeKeyAtomically</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key_path, <span class="hljs-type">const</span> std::string&amp; tmp_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> KeyAuthentication&amp; auth, <span class="hljs-type">const</span> KeyBuffer&amp; key)</span> </span>&#123;<br>    <span class="hljs-comment">// 后面会将tmp_path换成Key_path，所以我直接改为key_path</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">storeKey</span>(key_path, auth, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用storeKey【⭐ 这里所有的操作即使都是在&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;temp中处理的，只是后面会有RenameKeyDir和FsyncParentDirectory操作，只要操作成功了，就相当于<code>/data/misc/vold/user_keys/ce/&lt;userid&gt;/current</code>】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">storeKey</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; dir, <span class="hljs-type">const</span> KeyAuthentication&amp; auth, <span class="hljs-type">const</span> KeyBuffer&amp; key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">mkdir</span>(dir.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0700</span>)) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;key mkdir &quot;</span> &lt;&lt; dir;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 向/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/version中写入1</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kCurrentVersion, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_version)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 创建随机的secdiscardable_hash值</span><br>    std::string secdiscardable_hash;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">createSecdiscardable</span>(dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_secdiscardable, &amp;secdiscardable_hash)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 如果有锁屏密码，则stretching为none; 如果没有锁屏密码，则stretching为nopassword</span><br>    std::string stretching = <span class="hljs-built_in">getStretching</span>(auth);<br>    <span class="hljs-comment">// 向/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/stretching中写入stretching的值</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(stretching, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_stretching)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 生成appId，如果设置了锁屏密码，则为appId = hash + auth.secret；没有设置锁屏密码，则appId = hash</span><br>    std::string appId;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateAppId</span>(auth, stretching, secdiscardable_hash, &amp;appId)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string encryptedKey;<br>    <span class="hljs-comment">// 如果没有设置锁屏密码，使用keymaster管理</span><br>    <span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;<br>        Keymaster keymaster;<br>        <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        std::string kmKey;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeyStorageKey</span>(keymaster, appId, &amp;kmKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kmKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_keymaster_key_blob)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        km::AuthorizationSet keyParams = <span class="hljs-built_in">beginParams</span>(appId);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithKeymasterKey</span>(keymaster, dir, keyParams, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 设置了锁屏密码，不适用keymaster</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithoutKeymaster</span>(appId, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将加密后的CE key写入/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/encrypted_key</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(encryptedKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_encrypted_key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">FsyncDirectory</span>(dir)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>☃️ <strong>这里就揭示了锁屏密码与FBE的关系，当设置了锁屏密码的时候，最终会将锁屏元素中的secret生成appId，在加密ce key的时候要用到。</strong></p></blockquote><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><blockquote><p><a href="https://www.cnblogs.com/bobfly1984/p/14090078.html">https://www.cnblogs.com/bobfly1984/p/14090078.html</a></p></blockquote><ol><li>根据&#x2F;data&#x2F;unencrypted&#x2F;key和&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;de&#x2F;0&#x2F;路径是否存在判断首次开机还是非首次开机</li><li>system DE存储空间和user DE存储空间使用keymasterkey加解密，密钥元素secret和token为空</li><li><strong>不设置锁屏密码，user CE存储空间使用keymasterkey加解密，密钥元素secret和token为空</strong></li><li><strong>设置锁屏密码，user CE存储空间使用withoutkeymastery加解密，密钥元素secret为非空，token为空</strong></li><li>删除锁屏密码后，user CE 存储空间采用 不设置锁密码 加密策略</li><li>添加锁屏密码、修改锁屏密码、删除锁屏密码后在添加锁屏密码，传下来的secret值是一样的，确保不同场景下加密的文件都能解密</li><li>对user CE存储空间加解密的key，不管是设置锁屏密码还是不设置锁屏密码，这个key始终是一样的即首次开机生成的key。不同的只是加密元素和加密方式。</li><li>&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;current # cat stretching<br>nopassword &#x2F;&#x2F; 没有设置锁屏密码<br>none &#x2F;&#x2F; 设置锁屏密</li><li>&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;current&#x2F;keymaster_key_blob &#x2F;&#x2F; 此文件存在意味keymaster加解密、否则使用withoutkeymastery加解密</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 12多用户机制中的连接与会话</title>
    <link href="/2023/06/06/Android-12%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BC%9A%E8%AF%9D/"/>
    <url>/2023/06/06/Android-12%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BC%9A%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-12多用户机制中的连接与会话"><a href="#Android-12多用户机制中的连接与会话" class="headerlink" title="Android 12多用户机制中的连接与会话"></a>Android 12多用户机制中的连接与会话</h1><img src="/2023/06/06/Android-12%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BC%9A%E8%AF%9D/image-20230606233821913.png" alt="image-20230606233821913" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓分区存储</title>
    <link href="/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/"/>
    <url>/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓分区存储"><a href="#安卓分区存储" class="headerlink" title="安卓分区存储"></a>安卓分区存储</h1><blockquote><p>版权声明：本文为CSDN博主「guolin」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/guolin_blog/article/details/105419420/">https://blog.csdn.net/guolin_blog/article/details/105419420/</a></p></blockquote><p>⭐<strong>分区存储的前提是解决SD卡存储的问题，也就是外部存储的问题，所以不涉及原本的安卓内部存储。</strong></p><h2 id="1-理解分区存储"><a href="#1-理解分区存储" class="headerlink" title="1.理解分区存储"></a>1.理解分区存储</h2><p>Android长久以来都支持外置存储空间这个功能，也就是我们常说的SD卡存储。这个功能使用得极其广泛，几乎所有的App都喜欢在SD卡的根目录下建立一个自己专属的目录，用来存放各类文件和数据。</p><p>那么这么做有什么好处吗？我想了一下，大概有两点吧。第一，存储在SD卡的文件不会计入到应用程序的占用空间当中，也就是说即使你在SD卡存放了1G的文件，你的应用程序在设置中显示的占用空间仍然可能只有几十K。第二，存储在SD卡的文件，即使应用程序被卸载了，这些文件仍然会被保留下来，这有助于实现一些需要数据被永久保留的功能。</p><p>然而，这些“好处”真的是好处吗？或 许对于开发者而言这算是好处吧，但对于用户而言，上述好处无异于一些流氓行为。因为这会将用户的SD卡空间搞得乱糟糟的，而且即使我卸载了一个完全不再使用的程序，它所产生的垃圾文件却可能会一直保留在我的手机上。</p><p>另外，存储在SD卡上的文件属于公有文件，所有的应用程序都有权随意访问，这也对数据的安全性带来了很大的挑战。</p><p>为了解决上述问题，Google在Android 10当中加入了作用域存储功能。</p><p>那么到底什么是作用域存储呢？简单来讲，就是Android系统对SD卡的使用做了很大的限制。**从Android 10开始，每个应用程序只能有权在自己的外置存储空间关联目录下读取和创建文件，获取该关联目录的代码是：context.getExternalFilesDir()**。关联目录对应的路径大致如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/storage/emulated/<span class="hljs-number">0</span>/Android/data/&lt;包名&gt;/files<br></code></pre></td></tr></table></figure><p>将数据存放到这个目录下，你将可以完全使用之前的写法来对文件进行读写，不需要做任何变更和适配。但同时，刚才提到的那两个“好处”也就不存在了。这个目录中的文件会被计入到应用程序的占用空间当中，同时也会随着应用程序的卸载而被删除。</p><p>那么有些朋友可能会问了，我就是需要访问其他目录该怎么办呢？比如读取手机相册中的图片，或者向手机相册中添加一张图片。为此，Android系统针对文件类型进行了分类，图片、音频、视频这三类文件将可以通过MediaStore API来进行访问，而其他类型的文件则需要使用系统的文件选择器来进行访问。</p><p>另外，<strong>我们的应用程序向媒体库贡献的图片、音频或视频，将会自动拥有其读写权限</strong>，不需要额外申请READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限。<strong>而如果你要读取其他应用程序向媒体库贡献的图片、音频或视频，则必须要申请READ_EXTERNAL_STORAGE权限才行</strong>。WRITE_EXTERNAL_STORAGE权限将会在未来的Android版本中废弃。</p><p>好了，关于作用域存储的理论知识就先讲到这里，相信你已经对它有了一个基本的了解了，那么接下来我们就开始上手操作吧。</p><hr><p>还有一部分帖子也有这种说法，<strong>外卡（外部存储卷）， 只能访问所谓的共享文件夹，或者说公共目录。而且只能访问这些目录的多媒体文件(图片，视频，音频)。非多媒体文件只能通过系统文件选择器访问，无法像MediaStore一样列举了。</strong></p><img src="/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/image-20230606225153789.png" alt="image-20230606225153789" style="zoom:67%;"><h2 id="2-我一定要升级吗"><a href="#2-我一定要升级吗" class="headerlink" title="2.我一定要升级吗"></a>2.我一定要升级吗</h2><p>一定会有很多朋友关心这个问题，因为每当适配升级面临着需要更改大量代码的时候，大多数人的第一想法都是能不升就不升，或者能晚升就晚升。而在作用域存储这个功能上面，恭喜大家，暂时确实是可以不用升级的。</p><p>目前Android 10系统对于作用域存储适配的要求还不是那么严格，毕竟之前传统外置存储空间的用法实在是太广泛了。如果你的项目指定的targetSdkVersion低于29，那么即使不做任何作用域存储方面的适配，你的项目也可以成功运行到Android 10手机上。</p><p>而如果你的targetSdkVersion已经指定成了29，也没有关系，假如你还不想进行作用域存储的适配，只需要在AndroidManifest.xml中加入如下配置即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span> &gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">android:requestLegacyExternalStorage</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">...</span>&gt;</span><br>    ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这段配置表示，即使在Android 10系统上，仍然允许使用之前遗留的外置存储空间的用法来运行程序，这样就不用对代码进行任何修改了。当然，这只是一种权宜之计，在未来的Android系统版本中，这段配置随时都可能会失效（Android 11中已强制启用作用域存储，这段配置在Android 11当中已不再有效）。因此，我们还是非常有必要现在就来学习一下，到底该如何对作用域存储进行适配。</p><p>另外，本篇文章中演示的所有示例，都可以到ScopedStorageDemo这个开源库中找到其对应的源码。</p><p>开源库地址是：<a href="https://github.com/guolindev/ScopedStorageDemo">https://github.com/guolindev/ScopedStorageDemo</a></p><h2 id="3-获取相册中的图片"><a href="#3-获取相册中的图片" class="headerlink" title="3.获取相册中的图片"></a>3.获取相册中的图片</h2><p>首先来学习一下如何在作用域存储当中获取手机相册里的图片。注意，虽然本篇文章中我是以图片来举例的，但是获取音频、视频的用法也是基本相同的。</p><p>不同于过去可以直接获取到相册中图片的绝对路径，在作用域存储当中，我们只能借助MediaStore API获取到图片的Uri，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">val</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;$&#123;MediaStore.MediaColumns.DATE_ADDED&#125; desc&quot;</span>)<br><span class="hljs-keyword">if</span> (cursor != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">while</span> (cursor.moveToNext()) &#123;<br>        <span class="hljs-type">val</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID))<br>        <span class="hljs-type">val</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id)<br>        println(<span class="hljs-string">&quot;image uri is $uri&quot;</span>)<br>    &#125;<br>cursor.close()<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们先是通过ContentResolver获取到了相册中所有图片的id，然后再借助ContentUris将id拼装成一个完整的Uri对象。一张图片的Uri格式大致如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">content:<span class="hljs-comment">//media/external/images/media/321</span><br></code></pre></td></tr></table></figure><p>那么有些朋友可能会问了，获取到了Uri之后，我又该怎样将这张图片显示出来呢？这就有很多种办法了，比如使用Glide来加载图片，它本身就支持传入Uri对象来作为图片路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Glide.with(context).load(uri).into(imageView)<br></code></pre></td></tr></table></figure><p>而如果你没有使用Glide或其他图片加载框架，想在不借助第三方库的情况下直接将一个Uri对象解析成图片，可以使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">val</span> <span class="hljs-variable">fd</span> <span class="hljs-operator">=</span> contentResolver.openFileDescriptor(uri, <span class="hljs-string">&quot;r&quot;</span>)<br><span class="hljs-keyword">if</span> (fd != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">val</span> <span class="hljs-variable">bitmap</span> <span class="hljs-operator">=</span> BitmapFactory.decodeFileDescriptor(fd.fileDescriptor)<br>fd.close()<br>    imageView.setImageBitmap(bitmap)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们调用了ContentResolver的openFileDescriptor()方法，并传入Uri对象来打开文件句柄，然后再调用BitmapFactory的decodeFileDescriptor()方法将文件句柄解析成Bitmap对象即可。</p><img src="/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/20200409205348955.gif" alt="img" style="zoom: 80%;"><h2 id="4-将图片添加到相册"><a href="#4-将图片添加到相册" class="headerlink" title="4.将图片添加到相册"></a>4.将图片添加到相册</h2><p>将一张图片添加到手机相册要相对稍微复杂一点，因为不同系统版本之间的处理方式是不太一样的。</p><p>我们还是通过一段代码示例来直观地学习一下，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addBitmapToAlbum</span><span class="hljs-params">(bitmap: <span class="hljs-type">Bitmap</span>, displayName: <span class="hljs-type">String</span>, mimeType: <span class="hljs-type">String</span>, compressFormat: <span class="hljs-type">Bitmap</span>.<span class="hljs-type">CompressFormat</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> values = ContentValues()<br>    values.put(MediaStore.MediaColumns.DISPLAY_NAME, displayName)<br>    values.put(MediaStore.MediaColumns.MIME_TYPE, mimeType)<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;<br>        values.put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DCIM)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        values.put(MediaStore.MediaColumns.DATA, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;Environment.getExternalStorageDirectory().path&#125;</span>/<span class="hljs-subst">$&#123;Environment.DIRECTORY_DCIM&#125;</span>/<span class="hljs-variable">$displayName</span>&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">val</span> uri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values)<br>    <span class="hljs-keyword">if</span> (uri != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">val</span> outputStream = contentResolver.openOutputStream(uri)<br>        <span class="hljs-keyword">if</span> (outputStream != <span class="hljs-literal">null</span>) &#123;<br>            bitmap.compress(compressFormat, <span class="hljs-number">100</span>, outputStream)<br>outputStream.close()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码演示了如何将一个Bitmap对象添加到手机相册当中，我来简单解释一下。</p><p>想要将一张图片添加到手机相册，我们需要构建一个ContentValues对象，然后向这个对象中添加三个重要的数据。一个是DISPLAY_NAME，也就是图片显示的名称，一个是MIME_TYPE，也就是图片的mime类型。还有一个是图片存储的路径，不过这个值在Android 10和之前的系统版本中的处理方式不一样。Android 10中新增了一个RELATIVE_PATH常量，表示文件存储的相对路径，可选值有DIRECTORY_DCIM、DIRECTORY_PICTURES、DIRECTORY_MOVIES、DIRECTORY_MUSIC等，分别表示相册、图片、电影、音乐等目录。而在之前的系统版本中并没有RELATIVE_PATH，所以我们要使用DATA常量（已在Android 10中废弃），并拼装出一个文件存储的绝对路径才行。</p><p>有了ContentValues对象之后，接下来调用ContentResolver的insert()方法即可获得插入图片的Uri。但仅仅获得Uri仍然是不够的，我们还需要向该Uri所对应的图片写入数据才行。调用ContentResolver的openOutputStream()方法获得文件的输出流，然后将Bitmap对象写入到该输出流当中即可。</p><p>以上代码即可实现将Bitmap对象存储到手机相册当中，那么有些朋友可能会问了，如果我要存储的图片并不是Bitmap对象，而是一张网络上的图片，或者是当前应用关联目录下的图片该怎么办呢？</p><p>其实方法都是相似的，因为不管是网络上的图片还是关联目录下的图片，我们都能获取到它的输入流，只要不断读取输入流中的数据，然后写入到相册图片所对应的输出流当中就可以了，示例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">writeInputStreamToAlbum</span><span class="hljs-params">(inputStream: <span class="hljs-type">InputStream</span>, displayName: <span class="hljs-type">String</span>, mimeType: <span class="hljs-type">String</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> values = ContentValues()<br>    values.put(MediaStore.MediaColumns.DISPLAY_NAME, displayName)<br>    values.put(MediaStore.MediaColumns.MIME_TYPE, mimeType)<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;<br>        values.put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DCIM)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        values.put(MediaStore.MediaColumns.DATA, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;Environment.getExternalStorageDirectory().path&#125;</span>/<span class="hljs-subst">$&#123;Environment.DIRECTORY_DCIM&#125;</span>/<span class="hljs-variable">$displayName</span>&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">val</span> bis = BufferedInputStream(inputStream)<br>    <span class="hljs-keyword">val</span> uri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values)<br>    <span class="hljs-keyword">if</span> (uri != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">val</span> outputStream = contentResolver.openOutputStream(uri)<br>        <span class="hljs-keyword">if</span> (outputStream != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">val</span> bos = BufferedOutputStream(outputStream)<br>            <span class="hljs-keyword">val</span> buffer = ByteArray(<span class="hljs-number">1024</span>)<br>            <span class="hljs-keyword">var</span> bytes = bis.read(buffer)<br>            <span class="hljs-keyword">while</span> (bytes &gt;= <span class="hljs-number">0</span>) &#123;<br>                bos.write(buffer, <span class="hljs-number">0</span> , bytes)<br>                bos.flush()<br>                bytes = bis.read(buffer)<br>            &#125;<br>            bos.close()<br>        &#125;<br>    &#125;<br>    bis.close()<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中只是将输入流和输出流的部分重新编写了一下，其他部分和之前存储Bitmap的代码是完全一致的，相信很好理解。</p><img src="/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/20200409205454790.gif" alt="img" style="zoom:80%;"><h2 id="5-下载文件到Download目录"><a href="#5-下载文件到Download目录" class="headerlink" title="5.下载文件到Download目录"></a>5.下载文件到Download目录</h2><p>执行文件下载操作是一个很常见的场景，比如说下载pdf、doc文件，或者下载APK安装包等等。在过去，这些文件我们通常都会下载到Download目录，这是一个专门用于存放下载文件的目录。而从Android 10开始，我们已经不能以绝对路径的方式访问外置存储空间了，所以文件下载功能也会受到影响。</p><p>那么该如何解决呢？主要有以下两种方式。</p><p>第一种同时也是最简单的一种方式，就是更改文件的下载目录。将文件下载到应用程序的关联目录下，这样不用修改任何代码就可以让程序在Android 10系统上正常工作。但使用这种方式，你需要知道，下载的文件会被计入到应用程序的占用空间当中，同时如果应用程序被卸载了，该文件也会一同被删除。另外，存放在关联目录下的文件只能被当前的应用程序所访问，其他程序是没有读取权限的。</p><p>以上几个限制条件如果不能满足你的需求，那么就只能使用第二种方式，对Android 10系统进行代码适配，仍然将文件下载到Download目录下。</p><p>其实将文件下载到Download目录，和向相册中添加一张图片的过程是差不多的，Android 10在MediaStore中新增了一种Downloads集合，专门用于执行文件下载操作。但由于每个项目下载功能的实现都各不相同，有些项目的下载实现还十分复杂，因此怎么将以下的示例代码融合到你的项目当中是你自己需要思考的问题。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">downloadFile</span><span class="hljs-params">(fileUrl: <span class="hljs-type">String</span>, fileName: <span class="hljs-type">String</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.Q) &#123;<br>        Toast.makeText(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;You must use device running Android 10 or higher&quot;</span>, Toast.LENGTH_SHORT).show()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    thread &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">val</span> url = URL(fileUrl)<br><span class="hljs-keyword">val</span> connection = url.openConnection() <span class="hljs-keyword">as</span> HttpURLConnection<br>connection.requestMethod = <span class="hljs-string">&quot;GET&quot;</span><br>connection.connectTimeout = <span class="hljs-number">8000</span><br>connection.readTimeout = <span class="hljs-number">8000</span><br><span class="hljs-keyword">val</span> inputStream = connection.inputStream<br><span class="hljs-keyword">val</span> bis = BufferedInputStream(inputStream)<br><span class="hljs-keyword">val</span> values = ContentValues()<br>values.put(MediaStore.MediaColumns.DISPLAY_NAME, fileName)<br>values.put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DOWNLOADS)<br><span class="hljs-keyword">val</span> uri = contentResolver.insert(MediaStore.Downloads.EXTERNAL_CONTENT_URI, values)<br><span class="hljs-keyword">if</span> (uri != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">val</span> outputStream = contentResolver.openOutputStream(uri)<br><span class="hljs-keyword">if</span> (outputStream != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">val</span> bos = BufferedOutputStream(outputStream)<br><span class="hljs-keyword">val</span> buffer = ByteArray(<span class="hljs-number">1024</span>)<br><span class="hljs-keyword">var</span> bytes = bis.read(buffer)<br><span class="hljs-keyword">while</span> (bytes &gt;= <span class="hljs-number">0</span>) &#123;<br>bos.write(buffer, <span class="hljs-number">0</span> , bytes)<br>bos.flush()<br>bytes = bis.read(buffer)<br>&#125;<br>bos.close()<br>&#125;<br>&#125;<br>bis.close()<br>&#125; <span class="hljs-keyword">catch</span>(e: Exception) &#123;<br>e.printStackTrace()<br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码总体来讲还是比较好理解的，主要就是添加了一些Http请求的代码，并将MediaStore.Images.Media改成了MediaStore.Downloads，其他部分几乎是没有变化的，我就不再多加解释了。</p><p>注意，上述代码只能在Android 10或更高的系统版本上运行，因为MediaStore.Downloads是Android 10中新增的API。至于Android 9及以下的系统版本，请你仍然使用之前的代码来进行文件下载。</p><img src="/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/20200409205714266.gif" alt="img" style="zoom:80%;"><h2 id="6-使用文件选择器"><a href="#6-使用文件选择器" class="headerlink" title="6.使用文件选择器"></a>6.使用文件选择器</h2><p>如果我们要读取SD卡上非图片、音频、视频类的文件，比如说打开一个PDF文件，这个时候就不能再使用MediaStore API了，而是要使用文件选择器。</p><p>但是，我们不能再像之前的写法那样，自己写一个文件浏览器，然后从中选取文件，而是必须要使用手机系统中内置的文件选择器。示例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> PICK_FILE = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pickFile</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT)<br>    intent.addCategory(Intent.CATEGORY_OPENABLE)<br>    intent.type = <span class="hljs-string">&quot;*/*&quot;</span><br>    startActivityForResult(intent, PICK_FILE)<br>&#125;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(requestCode: <span class="hljs-type">Int</span>, resultCode: <span class="hljs-type">Int</span>, <span class="hljs-keyword">data</span>: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="hljs-keyword">data</span>)<br>    <span class="hljs-keyword">when</span> (requestCode) &#123;<br>        PICK_FILE -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (resultCode == Activity.RESULT_OK &amp;&amp; <span class="hljs-keyword">data</span> != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">val</span> uri = <span class="hljs-keyword">data</span>.<span class="hljs-keyword">data</span><br>                <span class="hljs-keyword">if</span> (uri != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">val</span> inputStream = contentResolver.openInputStream(uri)<br><span class="hljs-comment">// 执行文件读取操作</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里在pickFile()方法当中通过Intent去启动系统的文件选择器，注意Intent的action和category都是固定不变的。而type属性可以用于对文件类型进行过滤，比如指定成image&#x2F;就可以只显示图片类型的文件，这里写成&#x2F;*表示显示所有类型的文件。注意type属性必须要指定，否则会产生崩溃。</p><p>然后在onActivityResult()方法当中，我们就可以获取到用户选中文件的Uri，之后通过ContentResolver打开文件输入流来进行读取就可以了。</p><img src="/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/20200409205805627.gif" alt="img" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android加密之文件级加密</title>
    <link href="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/"/>
    <url>/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Android加密之文件级加密"><a href="#Android加密之文件级加密" class="headerlink" title="Android加密之文件级加密"></a>Android加密之文件级加密</h1><blockquote><p>声明：本文整理自</p><ul><li><a href="https://blog.csdn.net/myfriend0/article/details/77094890/?spm=1001.2014.3001.5506">https://blog.csdn.net/myfriend0/article/details/77094890/?spm=1001.2014.3001.5506</a></li><li><a href="https://blog.csdn.net/cs_tech/article/details/127579028">https://blog.csdn.net/cs_tech/article/details/127579028</a></li></ul><p>仅作为自己学习备忘使用，如有侵权，联系删除！再次感谢2位前辈精彩的博客！</p></blockquote><h2 id="1-什么是文件级加密"><a href="#1-什么是文件级加密" class="headerlink" title="1.什么是文件级加密"></a>1.什么是文件级加密</h2><p>Android 7.0 及更高版本支持文件级加密 (FBE)。采用文件级加密时，可以使用不同的密钥对不同的文件进行加密，并且可以对这些文件进行单独解密。</p><h2 id="2-全盘加密和文件级加密的区别"><a href="#2-全盘加密和文件级加密的区别" class="headerlink" title="2.全盘加密和文件级加密的区别"></a>2.全盘加密和文件级加密的区别</h2><p>借助文件级加密，Android 7.0 中引入了一项称为直接启动的新功能。该功能处于启用状态时，已加密设备在启动后将直接进入锁定屏幕。之前，在使用全盘加密 (FDE) 的已加密设备上，用户在访问任何数据之前都需要先提供凭据，从而导致手机无法执行除最基本操作之外的所有其他操作。例如，闹钟无法运行，无障碍服务不可用，手机无法接电话，而只能进行基本的紧急拨号操作。</p><h2 id="3-文件级加密概述"><a href="#3-文件级加密概述" class="headerlink" title="3.文件级加密概述"></a>3.文件级加密概述</h2><p>引入文件级加密 (FBE) 和新 API 后，便可以将应用设为加密感知型应用，这样一来，它们将能够在受限环境中运行。这些应用将可以在用户提供凭据之前运行，同时系统仍能保护私密用户信息。</p><p>在启用了 FBE 的设备上，每位用户均有两个可供应用使用的存储位置：</p><ul><li>🥇凭据加密 (CE) 存储空间：<strong>这是默认存储位置，只有在用户解锁设备后才可用。</strong></li><li>🥈设备加密 (DE) 存储空间：<strong>在直接启动模式期间以及用户解锁设备后均可用。</strong></li></ul><p>这种区分能够使工作资料更加安全，因为这样一来，加密不再只基于启动时密码，从而能够同时保护多位用户。</p><p>Direct Boot API 允许加密感知型应用访问上述每个区域。应用生命周期会发生一些变化，以便在用户的 CE 存储空间因用户在锁定屏幕上首次输入凭据而解锁时，或者在工作资料提供工作挑战时，通知应用。无论是否实现了 FBE，运行 Android 7.0 的设备都必须要支持这些新的 API 和生命周期。不过，如果没有 FBE，DE 和 CE 存储空间将始终处于解锁状态。</p><h3 id="3-1-启动文件级加密"><a href="#3-1-启动文件级加密" class="headerlink" title="3.1 启动文件级加密"></a>3.1 启动文件级加密</h3><p>如需在设备上启用文件级加密 (FBE)，就必须在内部存储设备 (userdata) 上启用 FBE。这也会自动为可合并的存储设备启用 FBE；但是，如有必要，可以覆盖可合并的存储设备的加密格式。内部存储设备通过将 fileencryption&#x3D;contents_encryption_mode[:filenames_encryption_mode[:flags]] 选项<strong>添加到 userdata 的 fstab 行 fs_mgr_flags 列，可启用 FBE</strong>。此选项用于定义内部存储设备的加密格式。它最多包含三个以英文冒号分隔的参数：</p><p>Android10：ext4 fileencryption&#x3D;ice,</p><p>Android11：f2fs fileencryption&#x3D;aes-256-xts:</p><ul><li>contents_encryption_mode 参数指定将哪种加密算法用于加密文件内容，可为 aes-256-xts 或 adiantum</li><li>filenames_encryption_mode 参数指定将哪种加密算法用于加密文件名，可为 aes-256-cts、aes-256-heh 或 adiantum。如果不指定，则当 contents_encryption_mode 为 aes-256-xts 时该参数默认为 aes-256-cts，当 contents_encryption_mode 为 adiantum 时该参数默认为 adiantum。</li><li>Android 11 中新增的 flags 参数是以 + 字符分隔的一个标记列表。支持以下标记：<ul><li>v1 标记用于选择第 1 版加密政策；v2 标记用于选择第 2 版加密政策。第 2 版加密政策使用更安全、更灵活的密钥派生函数。如果设备搭载的是 Android 11 或更高版本（由 ro.product.first_api_level 确定），则默认选择第 2 版；如果设备搭载的是 Android 10 或更低版本，则默认选择第 1 </li><li>inlinecrypt_optimized 标记用于选择针对无法高效处理大量密钥的内嵌加密硬件进行了优化的加密格式。其具体做法是仅为每个 CE 或 DE 密钥派生一个文件内容加密密钥，而不是为每个文件派生一个。IV（初始化向量）的生成也会相应地进行调整。</li><li>emmc_optimized 标记与 inlinecrypt_optimized 类似，但它还选择了将 IV 限制为 32 位的 IV 生成方法。此标记应仅在符合 JEDEC eMMC v5.2 规范的内嵌加密硬件上使用，因此仅支持 32 位 IV。在其他内嵌加密硬件上，请改用 inlinecrypt_optimized。此标记一律不得在基于 UFS 的存储设备上使用；UFS 规范允许使用 64 位 IV。</li><li>wrappedkey_v0 标记允许使用硬件封装的密钥。启用该标记后，FBE 密钥就不会由软件生成，而是由 Keymaster 使用 STORAGE_KEY 标签生成。然后，实际向内核提供的每个 FBE 密钥都是从 Keymaster 导出的 STORAGE_KEY 密钥，这会导致每次启动时都使用临时密钥对密钥进行封装。然后，内核会将封装的密钥直接提供给内嵌加密硬件。正确实现后，系统内存中永远不会显示解封的密钥，并且已破解的封装密钥在重新启动后将无法使用。此标记需要硬件支持、对 STORAGE_KEY 的 Keymaster 支持、内核驱动程序支持、inlinecrypt 装载选项以及 inlinecrypt_optimized 标记或 emmc_optimized 标记。</li></ul></li></ul><p>如果不使用内嵌加密硬件，则对于大多数设备推荐设置为 fileencryption&#x3D;aes-256-xts。如果使用内嵌加密硬件，则对于大多数设备推荐设置为 fileencryption&#x3D;aes-256-xts:aes-256-cts:inlinecrypt_optimized。在没有采用任何形式的 AES 加速的设备上，可以设置 fileencryption&#x3D;adiantum，从而用 Adiantum代替 AES。</p><p>在搭载 Android 10 或更低版本的设备上，也可以使用 fileencryption&#x3D;ice 来指定使用 FSCRYPT_MODE_PRIVATE 文件内容加密模式。Android 通用内核未实现该模式，但供应商可使用自定义内核补丁程序实现该模式。该模式生成的磁盘格式因供应商而异。在搭载 Android 11 或更高版本的设备上，不允许再使用该模式，而必须使用标准加密格式。</p><p>设备制造商还可以执行以下手动测试。在启用了 FBE 的设备上进行以下手动测试：</p><ul><li>检查 ro.crypto.state 是否存在<ul><li>确认 ro.crypto.state 是否已加密</li></ul></li><li>检查 ro.crypto.type 是否存在<ul><li>确认 ro.crypto.type 是否已设置为 file</li></ul></li></ul><h3 id="3-2-直接启动"><a href="#3-2-直接启动" class="headerlink" title="3.2 直接启动"></a>3.2 直接启动</h3><blockquote><p>安卓官网：<a href="https://developer.android.google.cn/training/articles/direct-boot?hl=zh-cn">https://developer.android.google.cn/training/articles/direct-boot?hl=zh-cn</a></p></blockquote><p>当设备已开机但用户尚未解锁设备时，Android 7.0 将在安全的“直接启动”模式下运行。为支持此模式，系统为数据提供了两个存储位置：</p><ul><li>凭据加密存储，这是默认存储位置，仅在用户解锁设备后可用。</li><li>设备加密存储，该存储位置在“直接启动”模式下和用户解锁设备后均可使用。</li></ul><p>默认情况下，应用不会在“直接启动”模式下运行。如果您的应用需要在“直接启动”模式下执行操作，您可以注册应在此模式下运行的应用组件。需要在“直接启动”模式下运行的一些常见应用用例包括：</p><ul><li>已安排通知的应用，如闹钟应用。</li><li>提供重要用户通知的应用，如短信应用。</li><li>提供无障碍服务的应用，如 Talkback。</li></ul><p>如果应用在“直接启动”模式下运行时需要访问数据，请使用DE设备加密存储。设备加密存储包含使用密钥加密的数据，该密钥只有在设备成功执行启动时验证后才可用。</p><p>对于应使用与用户凭据（如 PIN 码或密码）关联的密钥加密的数据，请使用CE凭据加密存储。凭据加密存储仅在用户成功解锁设备后可用，直到用户再次重启设备。如果用户在解锁设备后启用锁定屏幕，则不会锁定凭据加密存储。</p><p><strong>（1）请求在“直接启动”模式下运行</strong></p><p>应用必须先向系统注册其组件，然后才能在“直接启动”模式下运行或访问设备加密存储。应用通过将组件标记为加密感知来向系统注册。如需将您的组件标记为加密感知，请在清单中将 <code>android:directBootAware</code> 属性设为 true。</p><p>当设备重启后，加密感知组件可以注册以接收来自系统的 <code>ACTION_LOCKED_BOOT_COMPLETED</code> 广播消息。此时，设备加密存储可用，您的组件可以执行需要在“直接启动”模式下运行的任务，例如触发已设定的闹铃。</p><p>以下代码段示例说明了如何在应用清单中将 <code>BroadcastReceiver</code> 注册为加密感知并为 <code>ACTION_LOCKED_BOOT_COMPLETED</code> 添加 intent 过滤器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:directBootAware</span>=<span class="hljs-string">&quot;true&quot;</span> &gt;</span><br>    ...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.LOCKED_BOOT_COMPLETED&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br>    <br></code></pre></td></tr></table></figure><p>在用户解锁设备后，所有组件均可访问设备加密存储和凭据加密存储。</p><p><strong>（2）接收用户解锁通知</strong></p><p>当用户在重启后解锁设备时，应用可以切换至访问凭据加密CE存储，并使用依赖用户凭据的常规系统服务。</p><p>为了在重启后用户解锁设备时收到通知，请从正在运行的组件注册 <code>BroadcastReceiver</code> 以监听解锁通知消息。在用户重启后解锁设备时：</p><ul><li>如果应用具有需要立即获得通知的前台进程，请监听 <code>ACTION_USER_UNLOCKED</code> 消息。</li><li>如果应用仅使用可以对延迟通知执行操作的后台进程，请监听 <code>ACTION_BOOT_COMPLETED</code> 消息。</li></ul><p>您可以通过调用 <code>UserManager.isUserUnlocked()</code> 直接查询用户是否已解锁设备。</p><h3 id="3-3-设计概览"><a href="#3-3-设计概览" class="headerlink" title="3.3 设计概览"></a>3.3 设计概览</h3><blockquote><p>采用文件级加密时：</p><ul><li>可以使用不同的密钥对不同的文件进行加密，也可以对加密文件单独解密</li><li>可以有的放矢，没有安全要求的文件可以不加密</li><li>支持多用户，不同用户使用不同的密钥</li></ul></blockquote><p>基于这些特性，Google 对 Android 用户数据分区的目录做了安全等级划分，一些非用户隐私数据可以在设备启动后直接可以访问，解决了 FDE（Full Disk Encryption）的弊端。</p><p>在 FBE 的设计中，根据文件内容的私密性，Google 把用户数据分区的存储位置划分安全等级，包括下几类：</p><p>①. 不加密的存储位置</p><ul><li>Unencrypted</li></ul><p>②. 加密的存储位置 </p><ul><li>与用户无关的系统设备存储位置<ul><li>System Device Encrypted (DE) Storage ：一般存储一些设备相关，Framework 相关等用户无关的数据。</li></ul></li><li>与用户相关的存储位置 ：<ul><li>Device Encrypted (DE) Storage ：与用户相关的数据，安全性要求一般，在设备启动后以及用户解锁设备后都可以直接访问。</li><li>Credential Encrypted (CE) Storage ：与用户相关的数据，安全性等级高，如果用户设置了锁屏密码，必须在用户解锁设备后这些存储位置的数据才可用。</li></ul></li></ul><img src="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/image-20230604201431654.png" alt="image-20230604201431654" style="zoom: 67%;"><p>需要注意的点：</p><p>①. 从 User.x DE&#x2F;CE 以及对应文件夹的命名可知，FBE 天然支持多用户 ：</p><ul><li>每个用户都拥有2个单独的加密密钥： DE Master Key 和 CE Master Key。</li></ul><p>②. 当用户未设置锁屏密码时：</p><ul><li>DE 密钥和 CE 密钥安全等级一致，即开机过程中，APP 就可以直接访问 Device Encrypted (DE) Storage 和 Credential Encrypted (CE) Storage。</li></ul><p>③. 当用户设置锁屏密码时：</p><ul><li>只有校验用户密码成功后，用户的 CE 密钥才可用。即用户输入锁屏密码解锁设备后，APP 才可访问 Credential Encrypted (CE) Storage，同时访问到文件的明文数据。</li><li>用户 0 由于是特殊用户，必须先登录设备（设备启动后会自动登录用户0）；<br>不同存储位置的加解密顺序存在依赖关系：<ul><li>解密 System DE Storage 所需的密钥信息被存储在未加密目录 &#x2F;data&#x2F;unencrypted；</li><li>解密 User Device Encrypted (DE) Storage 和 User Credential Encrypted (CE) Storage 所需的密钥信息被存储在 System DE Storage 路径 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys；</li></ul></li></ul><p>🎈 这里再次重复磁盘数据加密解决的问题，对于后面理解 FBE 的设计很重要。</p><blockquote><p>解决设备被盗，丢失或者送修等机器不在用户手中的情况下，依然保护用户的隐私数据不被窃取。<strong>但是对于用户正常使用过程中，黑客通过提权等手段窃取数据的行为，这些技术基本无能为力，目前主要还是靠传统的 DAC（user、group、others） 和 MAC（selinux）</strong>。</p></blockquote><h3 id="3-4-秘钥管理"><a href="#3-4-秘钥管理" class="headerlink" title="3.4 秘钥管理"></a>3.4 秘钥管理</h3><p>①.对不同安全等级的加密存储位置，至少涉及 3 个密钥，包括：</p><ul><li>System DE key</li><li>User DE key for user 0</li><li>User CE key for user 0</li></ul><p>②. 密钥的安全管理，包括：</p><ul><li>在安全的内核密钥环（kernel keyring）和 ARM TZ 环境中管理密钥</li><li>密钥不允许出现在 HLOS</li><li>每个文件及其名称都应使用不同且唯一的密钥进行加密</li><li>根据 HLOS 请求，创建，更新和失效密钥等（支持远程擦除密钥）</li><li>……</li></ul><h3 id="3-5-密钥存储及其保护措施"><a href="#3-5-密钥存储及其保护措施" class="headerlink" title="3.5 密钥存储及其保护措施"></a>3.5 密钥存储及其保护措施</h3><blockquote><p>2023&#x2F;06&#x2F;19发现好文：<a href="https://blog.csdn.net/csdn_liqian/article/details/129362100">https://blog.csdn.net/csdn_liqian/article/details/129362100</a></p></blockquote><p>系统不会存储 per-boot key ，除此之外其他所有的 FBE key 将被<code>vold</code> 管理，并且存储在磁盘上。FBE key存储的位置如下表所示：</p><img src="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/image-20230619220158827.png" alt="image-20230619220158827" style="zoom: 80%;"><p>vold对所有的FBE key都有一层加密。</p><p>除了用于内部存储的 CE 密钥之外，每个密钥都由自己的 Keystore key（该密钥不在 TEE 外部公开）和 AES-256-GCM 算法来加密。这确保FBE key无法被解锁，除非可信操作系统已启动（就像开机校验强制执行，验证下一阶段的完整性和真实性）。</p><p>此外，Keystore key 需要设置抗回滚，以便 Keymaster 在支持抗回滚的设备上也能安全地删除 FBE 密钥。抗回滚：一旦使用 deleteKey 或者 deleteAllKeys 来删除密钥，安全硬件将保证该密钥不再可用，即删除的密钥无法恢复。</p><p>为了在抗回滚不可用时能够尽可能地回退，16384 个随机字节的 SHA-512 哈希值存储在与密钥一起存储的 secdiscardable 文件中，作为 Keystore key中的app ID tag。只有将这些字节全部恢复，才能恢复 FBE key。</p><p>用于内部存储的 CE key 将获得更高级别的保护，以确保在未获取用户的LSKF (LSKF：Lock Screen Knowledge Factor，即PIN 码 personal identification、图案pattern 或 口令password）、安全密码重置令牌（secure passcode reset token）或在重启恢复操作后的客户端密钥及服务器端密钥的情况下，CE key 无法被解锁。只允许为工作资料和完全受管设备（for work profiles and fully managed devices）创建密码重置令牌。</p><p>为此，vold 用AES-256-GCM算法加密用于内部存储的CE key，其加密密钥源自用户合成的口令。该合成口令是为每个用户随机生成的不可变的高级无序的（high-entropy，高熵）加密的密码。system_server 中的 LockSettingsService 用于管理合成口令及其保护方式。</p><p>用 LSKF 保护合成口令时，LockSettingsService 首先会扩展 LSKF（可以通过 scrypt 传递 LSKF，目标时间约为 25 毫秒且内存用量约为 2 MiB）。</p><p>由于 LSKF 通常较短，因此该步骤通常无法提供太多安全性。主要的安全保障是SE (SE： Secure Element安全元素) 或者由 TEE 强制执行的速率限制。</p><p><strong>（1）如果设备有SE， LockSettingsService 使用 Weaver HAL 将经过扩展的 LSKF 映射到存储在 SE 中的高级无序随机密码（secret）。</strong><br>然后，LockSettingsService 将对合成口令进行双重加密：</p><ul><li>第一次加密：使用扩展的 LSKF 和 Weaver secret派生软件密钥；</li><li>第二次加密：使用未经身份验证绑定(non-auth-bound)的 Keystore key。</li></ul><p>这样即可对 LSKF 猜测行为施加 SE 强制速率限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Weaver HAL代码路径: platform/hardware/interfaces/refs/heads/master/./weaver/<span class="hljs-number">1.0</span>/IWeaver.hal<br></code></pre></td></tr></table></figure><p><strong>（2）如果设备没有 SE，则 LockSettingsService 使用扩展的 LSKF 作为 Gatekeeper 口令。</strong></p><p>然后，LockSettingsService 将对合成口令进行双重加密：</p><ul><li>第一次加密：使用扩展的 LSKF 和 secdiscardable 文件的哈希值派生软件密钥；</li><li>第二次加密：使用经过身份验证绑定(auth-bound)到Gatekeeper的 Keystore key。</li></ul><p>这样即可对 LSKF 猜测行为施加 SE 强制速率限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Gatekeeper：<br><span class="hljs-built_in">TEE</span>(Trusted Execution Environment，可信执行环境)中，使用硬件支持的Keystore key通过HMAC注册并验证设备的图案或者口令（用TEE派生的共享密钥来进行身份验证）。<br>在连续数次验证失败时会限制验证尝试，拒绝为请求提供服务。<br></code></pre></td></tr></table></figure><p>当LSKF改变时，<code>LockSettingsService</code> 会删除所有旧的LSKF以及合成口令绑定的相关信息。在支持 Weaver 或者抗回滚的 Keystore key 的设备上，这样做可以保证安全地删除旧绑定。因此，即使用户没有设置 LSKF，系统也会进行上述保护措施。</p><h2 id="4-HLOS软件流程"><a href="#4-HLOS软件流程" class="headerlink" title="4.HLOS软件流程"></a>4.HLOS软件流程</h2><h3 id="4-1-Native软件流程"><a href="#4-1-Native软件流程" class="headerlink" title="4.1 Native软件流程"></a>4.1 Native软件流程</h3><p>Android 在 init rc 中 触发 FBE 软件流程：</p><blockquote><ul><li>在启动过程中，准备 FBE Master key，设置和校验各加密存储位置的加密策略（Encryption Policy）。</li><li>真正数据加密和解密是发生在文件 I&#x2F;O 时，而加密和解密所需的信息来源于文件的 Encryption Policy。Encryption Policy 包括：<ul><li>使用哪个 Master Key 加密；</li><li>文件数据的加密算法；</li><li>文件名的加密算法；</li></ul></li></ul></blockquote><img src="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/e09ee7d3490e49b1bd615011c7ecfc77.png" alt="img" style="zoom:80%;"><img src="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/450367269c4d4d3781406d3411f3e6e4.png" alt="img" style="zoom: 50%;"><p><strong>① installkey &#x2F;data</strong></p><p>软件流程进入 Vold 函数 fscrypt_initialize_systemwide_keys()。</p><p>设备第一次启动时：</p><ul><li>创建 System DE Master Key 和生成 System DE Encryption Policy；</li><li>把 System DE Encryption Policy 保存到文件  &#x2F;data&#x2F;unencrypted&#x2F;ref；</li></ul><p>后续每次启动时：</p><ul><li>加载 System DE Master Key；</li></ul><p><strong>② mkdir &lt;system de storage&gt;</strong></p><ul><li>如果 System DE Storage 不存在，创建并为文件夹设置 System DE Encryption Policy；</li><li>如果 System DE Storage 已经存在，则校验 System DE  Encryption Policy；<br>校验失败会强制设备启动到 recovery ，格式化 userdata 分区；</li></ul><p><strong>③ init_user0</strong></p><p>软件流程进入 Vold 函数 fscrypt_init_user0()。</p><p>设备第一次启动时：</p><ul><li>创建 User 0 DE Master Key 和生成 User 0 DE Encryption Policy；</li><li>创建 User 0 CE  Master Key 和生成 User 0 CE Encryption Policy；</li><li>创建 User 0 DE Storage，并为这些文件夹设置 User 0 DE Encryption Policy</li></ul><p>后续每次启动时：</p><ul><li>加载 User 0 DE Master Key；</li><li>准备 User 0 DE Storage，并校验文件夹 Encryption Policy；<ul><li>校验失败，不会强制格式化 userdata ，但是用户数据将无法使用，可能无法开机。</li></ul></li></ul><h3 id="4-2-Framework软件流程"><a href="#4-2-Framework软件流程" class="headerlink" title="4.2 Framework软件流程"></a>4.2 Framework软件流程</h3><p>可以发现在 Native 软件流程中， init_user0 中关于 User 0 CE 的流程相比 User 0 DE 存在缺失，主要包括：</p><p><strong>(1) 第一次启动时， User 0 CE Storage 是什么时候创建的呢？</strong></p><p>设备继续启动，由框架 UserController 通过 binder 触发 Vold 创建 User 0 CE Storage 和为相关文件夹设置 User 0 CE Encryption Policy</p><p><strong>(2) 后续每次启动时，加载 User 0 DE Master Key、准备 User 0 DE Storage 、校验 User 0 CE Encryption Policy 是什么时候发生？</strong></p><p>① 用户未设置锁屏密码时，设备启动 completed 后，ActivityManagerService 层层触发 Vold 完成这些任务；</p><img src="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/7227b1872aed453187f68be2bbd5c74e.png" alt="img" style="zoom:50%;"><p> <strong>②</strong> 用户设置锁屏密码时，用户输入密码并校验通过后，LockSettingsService 层层触发 Vold 完成这些任务；</p><img src="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/7575d136392e43b2be21ae3b9494fb43.png" alt="img" style="zoom: 50%;"><p>从图中可以看到，无论是设置用户密码，软件流程又回到了 Vold：</p><ul><li>fscrypt_unlock_user_key ： 加载 User 0 CE Master Key</li><li>fscrypt_prepare_user_storage：准备 User 0 CE Storage，并校验文件夹 Encryption Policy；</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓12多用户机制</title>
    <link href="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓12多用户机制"><a href="#安卓12多用户机制" class="headerlink" title="安卓12多用户机制"></a>安卓12多用户机制</h1><h2 id="1-CPP中的基类指针指向子类对象"><a href="#1-CPP中的基类指针指向子类对象" class="headerlink" title="1.CPP中的基类指针指向子类对象"></a>1.CPP中的基类指针指向子类对象</h2><p>☃️ 基类指针指向子类对象时：调用的是基类的函数，因为子类的函数被隐藏。 但是当基类函数有virtual关键字修饰的时候调用的是子类的函数【详细的可以了解一下<a href="https://zhuanlan.zhihu.com/p/98776075">虚函数表</a>】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> age) &#123;<br>        mAge = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printName</span><span class="hljs-params">(string name)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base -&gt; name = &quot;</span> &lt;&lt; name &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">doMount</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doMount</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> mAge;<br><br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Child</span>():<span class="hljs-built_in">Base</span>(<span class="hljs-number">24</span>)&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doMount</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;child do Mount&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> child = <span class="hljs-built_in">shared_ptr</span>&lt;Base&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Child</span>());<br><br>    child-&gt;<span class="hljs-built_in">printName</span>(<span class="hljs-string">&quot;amxixixi&quot;</span>);<br>    child-&gt;<span class="hljs-built_in">mount</span>();<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230607223135870.png" alt="image-20230607223135870" style="zoom:80%;"><h2 id="2-创建用户"><a href="#2-创建用户" class="headerlink" title="2.创建用户"></a>2.创建用户</h2><p>多用户的创建流程主要在UserManagerService.createUserInternalUnchecked()方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> UserInfo <span class="hljs-title function_">createUserInternalUnchecked</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String name,</span><br><span class="hljs-params">                                             <span class="hljs-meta">@NonNull</span> String userType, <span class="hljs-meta">@UserInfoFlag</span> <span class="hljs-type">int</span> flags, <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> parentId,</span><br><span class="hljs-params">                                             <span class="hljs-type">boolean</span> preCreate, <span class="hljs-meta">@Nullable</span> String[] disallowedPackages,</span><br><span class="hljs-params">                                             <span class="hljs-meta">@Nullable</span> Object token)</span> <span class="hljs-keyword">throws</span> UserManager.CheckedUserOperationException &#123;<br>    <span class="hljs-comment">// 获取下一个可用的用户ID，从10开始</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">nextProbableUserId</span> <span class="hljs-operator">=</span> getNextAvailableId();<br>    <span class="hljs-type">UserInfo</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        newUser = createUserInternalUncheckedNoTracing(name, userType, flags, parentId,<br>                                                       preCreate, disallowedPackages, t, token);<br>        <span class="hljs-keyword">return</span> newUser;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用createUserInternalUncheckedNoTracing</p><blockquote><p>🍃<strong>这里我们不讨论带有parentId类型的用户创建，离我本人的业务比较偏离</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// parentId: UserHandle.USER_NULL = -1000</span><br><span class="hljs-comment">// preCreate: false</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> UserInfo <span class="hljs-title">createUserInternalUncheckedNoTracing</span><span class="hljs-params">(@Nullable String name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                      @NonNull String userType, @UserInfoFlag <span class="hljs-type">int</span> flags, @UserIdInt <span class="hljs-type">int</span> parentId,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                      boolean preCreate, @Nullable String[] disallowedPackages,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                      @NonNull TimingsTraceAndSlog t, @Nullable Object token)</span></span><br><span class="hljs-function">    throws UserManager.CheckedUserOperationException </span>&#123;<br>    <br>    flags |= userTypeDetails.<span class="hljs-built_in">getDefaultUserInfoFlags</span>();<br><br>    <span class="hljs-built_in">synchronized</span> (mUsersLock) &#123;<br>        <span class="hljs-keyword">if</span> (mForceEphemeralUsers) &#123;<br>            flags |= UserInfo.FLAG_EPHEMERAL;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Try to use a pre-created user (if available).</span><br>    <span class="hljs-keyword">if</span> (!preCreate &amp;&amp; parentId &lt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">isUserTypeEligibleForPreCreation</span>(userTypeDetails)) &#123;<br>        <span class="hljs-keyword">final</span> UserInfo preCreatedUser = <span class="hljs-built_in">convertPreCreatedUserIfPossible</span>(userType, flags, name,token);<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> boolean isProfile = userTypeDetails.<span class="hljs-built_in">isProfile</span>();   <span class="hljs-comment">// 创建的用户是不是Profile</span><br>    <span class="hljs-keyword">final</span> boolean isGuest = UserManager.<span class="hljs-built_in">isUserTypeGuest</span>(userType);    <span class="hljs-comment">// 创建的是不是访客用户</span><br>    <span class="hljs-keyword">final</span> boolean isRestricted = UserManager.<span class="hljs-built_in">isUserTypeRestricted</span>(userType);  <span class="hljs-comment">// 创建的用户类型是不是被限制</span><br>    <span class="hljs-keyword">final</span> boolean isDemo = UserManager.<span class="hljs-built_in">isUserTypeDemo</span>(userType);  <span class="hljs-comment">// 创建的用户是不是一个Demo</span><br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ident = Binder.<span class="hljs-built_in">clearCallingIdentity</span>();<br>    UserInfo userInfo;<br>    UserData userData;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> userId;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">synchronized</span> (mPackagesLock) &#123;<br>            UserData parent = null;<br><br>            userId = <span class="hljs-built_in">getNextAvailableId</span>();  <span class="hljs-comment">// 获取下一个即将使用的UserId</span><br>            Environment.<span class="hljs-built_in">getUserSystemDirectory</span>(userId).<span class="hljs-built_in">mkdirs</span>();  <span class="hljs-comment">// 创建文件夹: /data/system/users/&lt;user_id&gt;</span><br><br>            <span class="hljs-built_in">synchronized</span> (mUsersLock) &#123;<br>                <span class="hljs-comment">// 实例化UserInfo并进行初始化赋值</span><br>                userInfo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">UserInfo</span>(userId, name, null, flags, userType);<br>                userInfo.serialNumber = mNextSerialNumber++; <span class="hljs-comment">// 串行号，根据经验来看等于UserId</span><br>                userInfo.creationTime = <span class="hljs-built_in">getCreationTime</span>();<br>                userInfo.partial = <span class="hljs-literal">true</span>;<br>                userInfo.preCreated = preCreate;<br>                userInfo.lastLoggedInFingerprint = Build.FINGERPRINT;<br>                userData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">UserData</span>();<br>                userData.info = userInfo;<br>                <span class="hljs-comment">// mUsers是SparseArray类型</span><br>                mUsers.<span class="hljs-built_in">put</span>(userId, userData);<br>            &#125;<br>            <span class="hljs-comment">// 详见2.2节</span><br>            <span class="hljs-built_in">writeUserLP</span>(userData);  <span class="hljs-comment">// 构造包含新用户信息的UserData，并固化到/data/system/users/&lt;user_id&gt;.xml</span><br>            <span class="hljs-built_in">writeUserListLP</span>();      <span class="hljs-comment">// 将新创建新UserId固化到 data/system/users/userlist.xml</span><br>        &#125;<br><br><br>        <span class="hljs-keyword">final</span> StorageManager storage = mContext.<span class="hljs-built_in">getSystemService</span>(StorageManager.<span class="hljs-keyword">class</span>);<br>        storage.<span class="hljs-built_in">createUserKey</span>(userId, userInfo.serialNumber, userInfo.<span class="hljs-built_in">isEphemeral</span>());<br><br>        mUserDataPreparer.<span class="hljs-built_in">prepareUserData</span>(userId, userInfo.serialNumber,<br>                                          StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE);<br><br>        <span class="hljs-comment">// 2.3节 获取当前用户类型需要安装的应用有哪些</span><br>        <span class="hljs-keyword">final</span> Set&lt;String&gt; userTypeInstallablePackages =<br>            mSystemPackageInstaller.<span class="hljs-built_in">getInstallablePackagesForUserType</span>(userType);<br><br>        <span class="hljs-comment">// 2.3节PMS安装新用户应用</span><br>        mPm.<span class="hljs-built_in">createNewUser</span>(userId, userTypeInstallablePackages, disallowedPackages);<br><br>        userInfo.partial = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">synchronized</span> (mPackagesLock) &#123;<br>            <span class="hljs-built_in">writeUserLP</span>(userData);  <span class="hljs-comment">// 再次调用2.2节中的方法</span><br>        &#125;<br>        <span class="hljs-built_in">updateUserIds</span>();<br><br>        Bundle restrictions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bundle</span>();<br>        <span class="hljs-keyword">if</span> (isGuest) &#123;<br><span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 添加默认的用户限制</span><br>            userTypeDetails.<span class="hljs-built_in">addDefaultRestrictionsTo</span>(restrictions);<br>        &#125;<br>        <span class="hljs-built_in">synchronized</span> (mRestrictionsLock) &#123;<br>            <span class="hljs-comment">// 更新RestrictionsSet.java中维护的mUserRestrictions的数据结构</span><br>            mBaseUserRestrictions.<span class="hljs-built_in">updateRestrictions</span>(userId, restrictions);<br>        &#125;<br><br>        mPm.<span class="hljs-built_in">onNewUserCreated</span>(userId, <span class="hljs-comment">/* convertedFromPreCreated= */</span> <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 设置用户默认的系统配置和安全配置</span><br>        <span class="hljs-built_in">applyDefaultUserSettings</span>(userTypeDetails, userId);<br>        <span class="hljs-built_in">setDefaultCrossProfileIntentFilters</span>(userId, userTypeDetails, restrictions, parentId);<br><br>        <span class="hljs-keyword">if</span> (preCreate) &#123;<br><span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">dispatchUserAdded</span>(userInfo, token);<br>        &#125;<br><br>    &#125; finally &#123;<br>        Binder.<span class="hljs-built_in">restoreCallingIdentity</span>(ident);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> userInfo;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-初始化用户信息"><a href="#2-1-初始化用户信息" class="headerlink" title="2.1 初始化用户信息"></a>2.1 初始化用户信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实例化UserInfo并进行初始化赋值</span><br>userInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserInfo</span>(userId, name, <span class="hljs-literal">null</span>, flags, userType);<br>userInfo.serialNumber = mNextSerialNumber++; <span class="hljs-comment">// 串行号，根据经验来看等于UserId</span><br>userInfo.creationTime = getCreationTime();<br>userInfo.partial = <span class="hljs-literal">true</span>;<br>userInfo.preCreated = preCreate;<br>userInfo.lastLoggedInFingerprint = Build.FINGERPRINT;<br>userData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserData</span>();<br>userData.info = userInfo;<br><span class="hljs-comment">// mUsers是SparseArray类型</span><br>mUsers.put(userId, userData);<br></code></pre></td></tr></table></figure><p>⭐ <strong>SparseArray</strong>并不像HashMap采用一维数组+单链表结构，而是采用两个一维数组，一个是存储key(int类型),一个是存在value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] mKeys;<br><span class="hljs-keyword">private</span> Object[] mValues;<br></code></pre></td></tr></table></figure><p>这里记住，UserManagerService维护了一个Key，Value的数据结构，Key为UserId，Value为UserData用户数据。</p><p>⭐ 我们平常使用<strong>dumpsys user</strong>打印的就是UserInfo类的ToString方法</p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230608232128458.png" alt="image-20230608232128458" style="zoom:67%;"><h3 id="2-2-保存新创建的用户信息"><a href="#2-2-保存新创建的用户信息" class="headerlink" title="2.2 保存新创建的用户信息"></a>2.2 保存新创建的用户信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">writeUserLP(userData);  <span class="hljs-comment">// 构造包含新用户信息的UserData，并固化到/data/system/users/&lt;user_id&gt;.xml</span><br>writeUserListLP();      <span class="hljs-comment">// 将新创建新UserId固化到 data/system/users/userlist.xml</span><br><br><span class="hljs-comment">// --------------------------------------------------</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeUserLP</span><span class="hljs-params">(UserData userData)</span> &#123;<br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 原子创建文件 /data/system/users/&lt;user_id&gt;.xml</span><br>    <span class="hljs-type">AtomicFile</span> <span class="hljs-variable">userFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(mUsersDir, userData.info.id + XML_SUFFIX));<br>    <span class="hljs-keyword">try</span> &#123;<br>        fos = userFile.startWrite();<br>        <span class="hljs-comment">// 将UserData中的消息写到/data/system/users/&lt;user_id&gt;.xml</span><br>        writeUserLP(userData, fos);<br>        userFile.finishWrite(fos);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ioe) &#123;<br>        Slog.e(LOG_TAG, <span class="hljs-string">&quot;Error writing user info &quot;</span> + userData.info.id, ioe);<br>        userFile.failWrite(fos);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// --------------------------------------------------</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeUserListLP</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 原子创建文件data/system/users/userlist.xml</span><br>    <span class="hljs-type">AtomicFile</span> <span class="hljs-variable">userListFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicFile</span>(mUserListFile);<br>    <span class="hljs-comment">// 写信息...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>⭐ <strong>原子类文件流操作</strong>：<a href="https://blog.csdn.net/FightFightFight/article/details/80069886">https://blog.csdn.net/FightFightFight/article/details/80069886</a></p><blockquote><p>AtomicFile是Android API17中引入的对文件进行原子操作的帮助类，所谓原子性，是指在对整个文件操作时，要么不操作，要么操作成功。如果操作失败，不会影响文件内容。</p><p>在获取该实例时，会在内部创建两个File对象，一个代表原文件，一个代表备份文件，通过这两个文件保证原文件的原子性！</p></blockquote><ul><li>构造包含新用户信息的UserData，并固化到 <code>/data/system/users/&lt;user_id&gt;.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">root@virgo:/ # cat data/system/users/10.xml<br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27; standalone=&#x27;yes&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">serialNumber</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">flags</span>=<span class="hljs-string">&quot;17&quot;</span> <span class="hljs-attr">created</span>=<span class="hljs-string">&quot;1561361447098&quot;</span> <span class="hljs-attr">lastLoggedIn</span>=<span class="hljs-string">&quot;1561460313625&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>security space<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">restrictions</span> <span class="hljs-attr">no_install_unknown_sources</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">no_usb_file_transfer</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">no_debugging_features</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>将新创建新UserId固化到 <code>data/system/users/userlist.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">root@virgo:/ # cat data/system/users/userlist.xml<br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27; standalone=&#x27;yes&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">users</span> <span class="hljs-attr">nextSerialNumber</span>=<span class="hljs-string">&quot;12&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">guestRestrictions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">restrictions</span> <span class="hljs-attr">no_config_wifi</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">no_outgoing_calls</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">no_sms</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">guestRestrictions</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;10&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;11&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">users</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-PMS安装新用户应用"><a href="#2-3-PMS安装新用户应用" class="headerlink" title="2.3 PMS安装新用户应用"></a>2.3 PMS安装新用户应用</h3><p><strong>（1）先获取要安装的包要有哪些</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span> Set&lt;String&gt; <span class="hljs-title function_">getInstallablePackagesForUserType</span><span class="hljs-params">(String userType)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">mode</span> <span class="hljs-operator">=</span> getWhitelistMode();  <span class="hljs-comment">// mode = 13，可以通过dumpsys user查看UserSystemPackageInstaller中的dump函数打印</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">implicitlyWhitelist</span> <span class="hljs-operator">=</span> isImplicitWhitelistMode(mode)<br>        || (isImplicitWhitelistSystemMode(mode) &amp;&amp; mUm.isUserTypeSubtypeOfSystem(userType));<br>    <span class="hljs-keyword">final</span> Set&lt;String&gt; whitelistedPackages = getWhitelistedPackagesForUserType(userType); <span class="hljs-comment">// 获取白名单安装包</span><br><br>    <span class="hljs-keyword">final</span> Set&lt;String&gt; installPackages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArraySet</span>&lt;&gt;();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">PackageManagerInternal</span> <span class="hljs-variable">pmInt</span> <span class="hljs-operator">=</span> LocalServices.getService(PackageManagerInternal.class);<br>    pmInt.forEachPackage(pkg -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (!pkg.isSystem()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (shouldInstallPackage(pkg, mWhitelistedPackagesForUserTypes,<br>                                 whitelistedPackages, implicitlyWhitelist)) &#123;<br>            <span class="hljs-comment">// Although the allowlist uses manifest names, this function returns packageNames.</span><br>            installPackages.add(pkg.getPackageName());<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> installPackages;<br>&#125;<br><span class="hljs-comment">// -------------------------------------------------------------</span><br><span class="hljs-meta">@NonNull</span> Set&lt;String&gt; <span class="hljs-title function_">getWhitelistedPackagesForUserType</span><span class="hljs-params">(String userType)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">userTypeMask</span> <span class="hljs-operator">=</span> getUserTypeMask(userType);  <span class="hljs-comment">//好获取当前用户类型的掩码</span><br>    <span class="hljs-keyword">final</span> Set&lt;String&gt; installablePkgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArraySet</span>&lt;&gt;(mWhitelistedPackagesForUserTypes.size());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mWhitelistedPackagesForUserTypes.size(); i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">pkgName</span> <span class="hljs-operator">=</span> mWhitelistedPackagesForUserTypes.keyAt(i);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">whitelistedUserTypes</span> <span class="hljs-operator">=</span> mWhitelistedPackagesForUserTypes.valueAt(i);<br>        <span class="hljs-comment">// 假设当前用户类型为GUEST，那么其掩码为 1 &lt;&lt; 1</span><br>        <span class="hljs-comment">// 又com.android.internal.display.cutout.emulation.corner位图的第2位为1，相&amp;之后不为0【具体见下图】</span><br>        <span class="hljs-comment">// 则这个包应该安装</span><br>        <span class="hljs-keyword">if</span> ((userTypeMask &amp; whitelistedUserTypes) != <span class="hljs-number">0</span>) &#123;<br>            installablePkgs.add(pkgName);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> installablePkgs;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>⭐ 下面说明一下<strong>mWhitelistedPackagesForUserTypes</strong>这个变量的存储方式，他是一个ArrayMap，键为包名，值为可以安装该应用对应的位图</p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230609203512256.png" alt="image-20230609203512256" style="zoom:67%;"><blockquote><p>下图为<strong>dumpsys user</strong>的打印结果</p></blockquote><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230609202459128.png" alt="image-20230609202459128" style="zoom:67%;"><p><strong>（2）安装应用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createNewUser</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-meta">@Nullable</span> Set&lt;String&gt; userTypeInstallablePackages,</span><br><span class="hljs-params">                   String[] disallowedPackages)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (mInstallLock) &#123;<br>        <span class="hljs-comment">// 在mSettintgs中调用PMS安装应用</span><br>        mSettings.createNewUserLI(<span class="hljs-built_in">this</span>, mInstaller, userId, userTypeInstallablePackages, disallowedPackages);<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        scheduleWritePackageRestrictionsLocked(userId);<br>        scheduleWritePackageListLocked(userId);<br>        mAppsFilter.onUsersChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-添加对用户的限制"><a href="#2-4-添加对用户的限制" class="headerlink" title="2.4 添加对用户的限制"></a>2.4 添加对用户的限制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">userTypeDetails.addDefaultRestrictionsTo(restrictions);<br><br><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\pm\UserTypeDetails.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addDefaultRestrictionsTo</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bundle currentRestrictions)</span> &#123;<br>    UserRestrictionsUtils.merge(currentRestrictions, mDefaultRestrictions);<br>&#125;<br></code></pre></td></tr></table></figure><p>⭐ 不同的用户类型在初始化<strong>UserTypeDetails</strong>的时候都会去设置限制，例如<strong>SecondaryUser</strong>类型的用户会添加2项限制：<code>no_outgoing_calls</code>和<code>no_sms</code></p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230609210435607.png" alt="image-20230609210435607" style="zoom:67%;"><p>我们可以再次通过<code>dumpsys user</code>查看一下：</p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230609211103672.png" alt="image-20230609211103672" style="zoom:67%;"><p>妈妈耶，对上了对上了！！</p><h2 id="3-切换用户"><a href="#3-切换用户" class="headerlink" title="3.切换用户"></a>3.切换用户</h2><p>先上实际操作的GIF，用眼睛看往往更加直观~</p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/切换用户.gif" style="zoom:50%;"><h3 id="3-1-开始切换用户"><a href="#3-1-开始切换用户" class="headerlink" title="3.1 开始切换用户"></a>3.1 开始切换用户</h3><p>Android多用户的切换函数入口ActivityManagerService.switchUser方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">switchUser</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> targetUserId)</span> &#123;<br>    <span class="hljs-keyword">return</span> mUserController.switchUser(targetUserId);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用UserController的switchUser方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\am\UserController.java</span><br><span class="hljs-function">boolean <span class="hljs-title">switchUser</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> targetUserId)</span> </span>&#123;<br>    <span class="hljs-type">int</span> currentUserId = <span class="hljs-built_in">getCurrentUserId</span>();  <span class="hljs-comment">// 获取当前用户的userId</span><br>    UserInfo targetUserInfo = <span class="hljs-built_in">getUserInfo</span>(targetUserId);  <span class="hljs-comment">// 获取即将切换用户的信息</span><br><br>    <span class="hljs-comment">// ...</span><br>    <br>    boolean userSwitchUiEnabled;<br>    <span class="hljs-built_in">synchronized</span> (mLock) &#123;<br>        mTargetUserId = targetUserId;<br>        userSwitchUiEnabled = mUserSwitchUiEnabled;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (userSwitchUiEnabled) &#123;<br>        UserInfo currentUserInfo = <span class="hljs-built_in">getUserInfo</span>(currentUserId);<br>        Pair&lt;UserInfo, UserInfo&gt; userNames = <span class="hljs-keyword">new</span> Pair&lt;&gt;(currentUserInfo, targetUserInfo);<br>        mUiHandler.<span class="hljs-built_in">removeMessages</span>(START_USER_SWITCH_UI_MSG);<br>        mUiHandler.<span class="hljs-built_in">sendMessage</span>(mUiHandler.<span class="hljs-built_in">obtainMessage</span>(START_USER_SWITCH_UI_MSG, userNames));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mHandler.<span class="hljs-built_in">removeMessages</span>(START_USER_SWITCH_FG_MSG);<br>        mHandler.<span class="hljs-built_in">sendMessage</span>(mHandler.<span class="hljs-built_in">obtainMessage</span>(START_USER_SWITCH_FG_MSG, targetUserId, <span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终会传递一个Handler消息<strong>START_USER_SWITCH_UI_MSG</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> START_USER_SWITCH_UI_MSG:<br><span class="hljs-comment">// 拿到Handler的参数</span><br>    <span class="hljs-keyword">final</span> Pair&lt;UserInfo, UserInfo&gt; fromToUserPair = (Pair&lt;UserInfo, UserInfo&gt;) msg.obj;<br>    showUserSwitchDialog(fromToUserPair);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>调用切换用户的对话框【在切换用户的时候，主界面会有一个UI显示】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showUserSwitchDialog</span><span class="hljs-params">(Pair&lt;UserInfo, UserInfo&gt; fromToUserPair)</span> &#123;<br>    mInjector.showUserSwitchingDialog(fromToUserPair.first, fromToUserPair.second,<br>                                      getSwitchingFromSystemUserMessage(), getSwitchingToSystemUserMessage());<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">showUserSwitchingDialog</span><span class="hljs-params">(UserInfo fromUser, UserInfo toUser,</span><br><span class="hljs-params">                             String switchingFromSystemUserMessage, String switchingToSystemUserMessage)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Dialog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserSwitchingDialog</span>(mService, mService.mContext, fromUser,<br>                                             toUser, <span class="hljs-literal">true</span> <span class="hljs-comment">/* above system */</span>, switchingFromSystemUserMessage,<br>                                             switchingToSystemUserMessage);<br>    d.show();<br>&#125;<br></code></pre></td></tr></table></figure><p>调用一个继承自Dialog的自定义对话框类UserSwitchingDialog，然后调用其show方法在主界面进行显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.show();<br>    mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_START_USER), WINDOW_SHOWN_TIMEOUT_MS);<br>&#125;<br></code></pre></td></tr></table></figure><p>又传递了一个Handler信息<strong>MSG_START_USER</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> MSG_START_USER:<br>    startUser();<br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-comment">// 调用UserSwitchingDialog的startUser</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">startUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!mStartedUser) &#123;<br>            mService.mUserController.startUserInForeground(mUserId);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Slog.i(TAG, <span class="hljs-string">&quot;user &quot;</span> + mUserId + <span class="hljs-string">&quot; already started&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>又重新调用到了UserController的startUserInForeground方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">startUserInForeground</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> targetUserId)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> startUser(targetUserId, <span class="hljs-comment">/* foreground */</span> <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startUser</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> foreground)</span> &#123;<br>    <span class="hljs-keyword">return</span> startUser(userId, foreground, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startUser</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> foreground, <span class="hljs-meta">@Nullable</span> IProgressListener unlockListener)</span> &#123;<br>    <span class="hljs-keyword">return</span> startUserNoChecks(userId, foreground, unlockListener);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startUserNoChecks</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> foreground,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@Nullable</span> IProgressListener unlockListener)</span> &#123;<br>    <span class="hljs-keyword">return</span> startUserInternal(userId, foreground, unlockListener, t);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终调用到了startUserInternal</p><h3 id="3-2-启动用户startUserInternal"><a href="#3-2-启动用户startUserInternal" class="headerlink" title="3.2 启动用户startUserInternal"></a>3.2 启动用户startUserInternal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从上面一路传下来的foreground为true</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startUserInternal</span><span class="hljs-params">(<span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId, <span class="hljs-type">boolean</span> foreground,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@Nullable</span> IProgressListener unlockListener, <span class="hljs-meta">@NonNull</span> TimingsTraceAndSlog t)</span> &#123;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">callingUid</span> <span class="hljs-operator">=</span> Binder.getCallingUid();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">callingPid</span> <span class="hljs-operator">=</span> Binder.getCallingPid();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ident</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">oldUserId</span> <span class="hljs-operator">=</span> getCurrentUserId();  <span class="hljs-comment">// 获取当前用户的userId</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> getUserInfo(userId); <span class="hljs-comment">// 获取当前用户的信息</span><br><br>        <span class="hljs-comment">// 1. 冻结输入事件</span><br>        <span class="hljs-comment">// 2. 强制结束所有动画</span><br>        <span class="hljs-comment">// 3. 截取当前屏幕并展示</span><br>        <span class="hljs-keyword">if</span> (foreground &amp;&amp; isUserSwitchUiEnabled()) &#123;<br>            mInjector.getWindowManager().startFreezingScreen(R.anim.screen_user_exit, R.anim.screen_user_enter);<br>        &#125;<br>        <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needStart</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">updateUmState</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        UserState uss;<br><br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            uss = mStartedUsers.get(userId);<br>            <span class="hljs-keyword">if</span> (uss == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 初始状态为STATE_BOOTING</span><br>                uss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserState</span>(UserHandle.of(userId));<br>                uss.mUnlockProgress.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserProgressListener</span>());<br>                <span class="hljs-comment">// mStartedUsers维护了用户id和用户状态</span><br>                mStartedUsers.put(userId, uss);<br>                updateStartedUserArrayLU();<br>                needStart = <span class="hljs-literal">true</span>;<br>                updateUmState = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (uss.state == UserState.STATE_SHUTDOWN &amp;&amp; !isCallingOnHandlerThread()) &#123;<br>               <span class="hljs-comment">// ...</span><br>            &#125;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">userIdInt</span> <span class="hljs-operator">=</span> userId;<br>            mUserLru.remove(userIdInt);<br>            mUserLru.add(userIdInt);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (foreground) &#123;<br>            mInjector.reportGlobalUsageEvent(UsageEvents.Event.SCREEN_NON_INTERACTIVE);<br>            <span class="hljs-type">boolean</span> userSwitchUiEnabled;<br>            <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>                mCurrentUserId = userId;<br>                mTargetUserId = UserHandle.USER_NULL;<br>                userSwitchUiEnabled = mUserSwitchUiEnabled;<br>            &#125;<br>            <span class="hljs-comment">// 从Setting Provider读取需要切换用户的字体、语言、地区等配置并更新</span><br>            <span class="hljs-comment">// 如果是初创用户，对于字体则使用默认配置，语言和地区使用当前用户的配置</span><br>            mInjector.updateUserConfiguration();<br>            <span class="hljs-comment">// 更新当前用户附属的ManageProfile</span><br>            updateCurrentProfileIds();<br>            <span class="hljs-comment">// 设置当前用户下所有window的可见性</span><br>            <span class="hljs-comment">// 设置切换用户的屏幕分辨率</span><br>            mInjector.getWindowManager().setCurrentUser(userId, getCurrentProfileIds());<br>            mInjector.reportCurWakefulnessUsageEvent();<br>            <span class="hljs-keyword">if</span> (userSwitchUiEnabled) &#123;<br>                <span class="hljs-comment">// 切换过程中关闭Keyguard的指纹监听</span><br>                mInjector.getWindowManager().setSwitchingUser(<span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 设置Keyguard锁屏(锁屏keyguard属于SystemUI)</span><br>                mInjector.getWindowManager().lockNow(<span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (uss.state == UserState.STATE_BOOTING) &#123;<br>            <span class="hljs-comment">// 设置新用户的权限，校验或准备新用户app存储</span><br>            mInjector.getUserManager().onBeforeStartUser(userId);<br>            <span class="hljs-comment">// 通知系统所有的服务新用户已经启动</span><br>            mHandler.sendMessage(mHandler.obtainMessage(USER_START_MSG, userId, <span class="hljs-number">0</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (foreground) &#123;<br>            <span class="hljs-comment">// 3.2.1 通知各服务切换用户</span><br>            mHandler.sendMessage(mHandler.obtainMessage(USER_CURRENT_MSG, userId, oldUserId));<br>        &#125;<br><br><br>        <span class="hljs-comment">// 详见3.2.2</span><br>        <span class="hljs-keyword">if</span> (foreground) &#123;<br>            moveUserToForeground(uss, oldUserId, userId);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            finishUserBoot(uss);<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Binder.restoreCallingIdentity(ident);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-2-1-通知各服务切换用户"><a href="#3-2-1-通知各服务切换用户" class="headerlink" title="3.2.1 通知各服务切换用户"></a>3.2.1 通知各服务切换用户</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">mHandler.sendMessage(mHandler.obtainMessage(USER_CURRENT_MSG, userId, oldUserId));<br><br><br>处理Handler消息:<br><span class="hljs-keyword">case</span> USER_CURRENT_MSG:<br>    mInjector.getSystemServiceManager().onUserSwitching(msg.arg2, msg.arg1);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>调用SystemServiceManager的onUserSwitching方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\SystemServiceManager.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUserSwitching</span><span class="hljs-params">(<span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> from, <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> to)</span> &#123;<br>    <span class="hljs-keyword">final</span> TargetUser curUser, prevUser;<br>    <span class="hljs-keyword">synchronized</span> (mTargetUsers) &#123;<br>        <span class="hljs-keyword">if</span> (mCurrentUser == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            prevUser = mCurrentUser;<br>        &#125;<br>        curUser = mCurrentUser = getTargetUser(to);<br>    &#125;<br>    onUser(TimingsTraceAndSlog.newAsyncLog(), USER_SWITCHING, prevUser, curUser);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用onUser方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUser</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String onWhat, <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId)</span> &#123;<br>    onUser(TimingsTraceAndSlog.newAsyncLog(), onWhat, <span class="hljs-comment">/* prevUser= */</span> <span class="hljs-literal">null</span>, getTargetUser(userId));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUser</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> TimingsTraceAndSlog t, <span class="hljs-meta">@NonNull</span> String onWhat,</span><br><span class="hljs-params">                    <span class="hljs-meta">@Nullable</span> TargetUser prevUser, <span class="hljs-meta">@NonNull</span> TargetUser curUser)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">curUserId</span> <span class="hljs-operator">=</span> curUser.getUserIdentifier();<br><span class="hljs-comment">// SMS管理的所有服务存储在mServices中</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">serviceLen</span> <span class="hljs-operator">=</span> mServices.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; serviceLen; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SystemService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> mServices.get(i);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> service.getClass().getName();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">switch</span> (onWhat) &#123;<br>                <span class="hljs-keyword">case</span> USER_SWITCHING:<br>                    service.onUserSwitching(prevUser, curUser);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br><span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>SystemServiceManager</strong>会通知其管理的所有服务调用其<strong>onUserSwitching</strong>方法，如StorageManagerService的onUserSwitching方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\StorageManagerService.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUserSwitching</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TargetUser from, <span class="hljs-meta">@NonNull</span> TargetUser to)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">currentUserId</span> <span class="hljs-operator">=</span> to.getUserIdentifier();<br>    mStorageManagerService.mCurrentUserId = currentUserId;<br><br>    <span class="hljs-type">UserManagerInternal</span> <span class="hljs-variable">umInternal</span> <span class="hljs-operator">=</span> LocalServices.getService(UserManagerInternal.class);<br>    <span class="hljs-keyword">if</span> (umInternal.isUserUnlocked(currentUserId)) &#123;<br>        mStorageManagerService.maybeRemountVolumes(currentUserId);<br>        mStorageManagerService.mRemountCurrentUserVolumesOnUnlock = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mStorageManagerService.mRemountCurrentUserVolumesOnUnlock = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前用户已经解锁，那么直接重新挂载所有的卷。</p><h4 id="3-2-2-最后都会走到finishUserBoot"><a href="#3-2-2-最后都会走到finishUserBoot" class="headerlink" title="3.2.2 最后都会走到finishUserBoot"></a>3.2.2 最后都会走到finishUserBoot</h4><p>不同的是我们创建完，切换用户的时候是foregound，因此调用的是moveUserToForeground</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveUserToForeground</span><span class="hljs-params">(UserState uss, <span class="hljs-type">int</span> oldUserId, <span class="hljs-type">int</span> newUserId)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">homeInFront</span> <span class="hljs-operator">=</span> mInjector.taskSupervisorSwitchUser(newUserId, uss);<br>    <span class="hljs-keyword">if</span> (homeInFront) &#123;<br>        <span class="hljs-comment">// 如果之前没有前台应用，则启动HomeActivity</span><br>        mInjector.startHomeActivity(newUserId, <span class="hljs-string">&quot;moveUserToForeground&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果之前有前台应用，则resume该Activity</span><br>        mInjector.taskSupervisorResumeFocusedStackTopActivity();<br>    &#125;<br>    <span class="hljs-comment">// // 对于切换前的用户，发送ACTION_USER_BACKGROUND广播，对于切换后的用户，发送 ACTION_USER_FOREGROUND和ACTION_USER_SWITCHED广播</span><br>    sendUserSwitchBroadcasts(oldUserId, newUserId);<br>&#125;<br></code></pre></td></tr></table></figure><p>引用一下<a href="https://blog.csdn.net/qq_14978113/article/details/94654401?spm=1001.2014.3001.5506%E7%89%B9%E5%88%AB%E6%A3%92%E7%9A%84%E4%B8%80%E5%BC%A0%E4%BB%8EAMS%E5%88%B0finishUserBoot%E7%9A%84%E5%9B%BE%E7%89%87">https://blog.csdn.net/qq_14978113/article/details/94654401?spm=1001.2014.3001.5506特别棒的一张从AMS到finishUserBoot的图片</a></p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE0OTc4MTEz.png" alt="img" style="zoom: 60%;"><p>🐇 <strong>所以不管我们是前台切换还是后台切换，最终都会总到finishUserBoot</strong></p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230619224008130.png" alt="image-20230619224008130" style="zoom: 50%;"><h3 id="3-3-切换用户结束finishUserBoot-万物归宗"><a href="#3-3-切换用户结束finishUserBoot-万物归宗" class="headerlink" title="3.3 切换用户结束finishUserBoot(万物归宗)"></a>3.3 切换用户结束finishUserBoot(万物归宗)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishUserBoot</span><span class="hljs-params">(UserState uss)</span> &#123;<br>    finishUserBoot(uss, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishUserBoot</span><span class="hljs-params">(UserState uss, IIntentReceiver resultTo)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> uss.mHandle.getIdentifier();<br><br>    <span class="hljs-comment">// 设置用户状态，从booting设置为running_locked</span><br>    <span class="hljs-keyword">if</span> (uss.setState(STATE_BOOTING, STATE_RUNNING_LOCKED)) &#123;<br>        logUserLifecycleEvent(userId, USER_LIFECYCLE_EVENT_USER_RUNNING_LOCKED,<br>                              USER_LIFECYCLE_EVENT_STATE_NONE);<br>        <span class="hljs-comment">// UserManagerService维护的用户状态中添加userid,uss</span><br>        mInjector.getUserManagerInternal().setUserState(userId, uss.state);<br><br>        <span class="hljs-keyword">if</span> (!mInjector.getUserManager().isPreCreated(userId)) &#123;<br>            mHandler.sendMessage(mHandler.obtainMessage(REPORT_LOCKED_BOOT_COMPLETE_MSG,<br>                                                        userId, <span class="hljs-number">0</span>));<br>            <span class="hljs-keyword">if</span> (!(UserManager.isHeadlessSystemUserMode() &amp;&amp; uss.mHandle.isSystem())) &#123;<br>                sendLockedBootCompletedBroadcast(resultTo, userId);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 如果当前用户是profile类型</span><br>    <span class="hljs-keyword">if</span> (mInjector.getUserManager().isProfile(userId)) &#123;<br><span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        maybeUnlockUser(userId);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>调用maybeUnlockUser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">maybeUnlockUser</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId)</span> &#123;<br>    <span class="hljs-keyword">return</span> unlockUserCleared(userId, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">unlockUserCleared</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret, IProgressListener listener)</span> &#123;<br>    UserState uss;<br>    <span class="hljs-comment">// 如果用户没有解锁</span><br>    <span class="hljs-keyword">if</span> (!StorageManager.isUserKeyUnlocked(userId)) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> getUserInfo(userId);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">IStorageManager</span> <span class="hljs-variable">storageManager</span> <span class="hljs-operator">=</span> mInjector.getStorageManager();<br>        <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 调用SMS解锁CE Storage</span><br>            storageManager.unlockUserKey(userId, userInfo.serialNumber, token, secret);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException | RuntimeException e) &#123;<br>            Slogf.w(TAG, <span class="hljs-string">&quot;Failed to unlock: &quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">if</span> (!finishUserUnlocking(uss)) &#123;<br>        notifyFinished(userId, listener);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-1-解锁CE-Storage"><a href="#3-3-1-解锁CE-Storage" class="headerlink" title="3.3.1 解锁CE Storage"></a>3.3.1 解锁CE Storage</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlockUserKey</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">int</span> serialNumber, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isFsEncrypted</span> <span class="hljs-operator">=</span> StorageManager.isFileEncryptedNativeOrEmulated();<br>    <span class="hljs-comment">// 判断用户是否已经解锁</span><br>    <span class="hljs-keyword">if</span> (isUserKeyUnlocked(userId)) &#123;<br>        Slog.d(TAG, <span class="hljs-string">&quot;User &quot;</span> + userId + <span class="hljs-string">&quot;&#x27;s CE storage is already unlocked&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>   <span class="hljs-comment">// 如果支持文件加密，则调用Vold的unlockUserKey方法</span><br>    <span class="hljs-keyword">if</span> (isFsEncrypted) &#123;<br>        mVold.unlockUserKey(userId, serialNumber, encodeBytes(token), encodeBytes(secret));<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        mLocalUnlockedUsers.append(userId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-结束解锁finishUserUnlocking"><a href="#3-3-2-结束解锁finishUserUnlocking" class="headerlink" title="3.3.2 结束解锁finishUserUnlocking"></a>3.3.2 结束解锁finishUserUnlocking</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">finishUserUnlocking</span><span class="hljs-params">(<span class="hljs-keyword">final</span> UserState uss)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> uss.mHandle.getIdentifier();<br>    <span class="hljs-keyword">if</span> (!StorageManager.isUserKeyUnlocked(userId)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    FgThread.getHandler().post(() -&gt; &#123;<br>        mInjector.getUserManager().onBeforeUnlockUser(userId);<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            <span class="hljs-keyword">if</span> (!uss.setState(STATE_RUNNING_LOCKED, STATE_RUNNING_UNLOCKING)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 设置用户状态</span><br>        mInjector.getUserManagerInternal().setUserState(userId, uss.state);<br><br>        <span class="hljs-comment">// 发送handler信息</span><br>        mHandler.obtainMessage(USER_UNLOCK_MSG, userId, <span class="hljs-number">0</span>, uss).sendToTarget();<br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理handler信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> USER_UNLOCK_MSG:<br>    finishUserUnlocked((UserState) msg.obj);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>调用finishUserUnlocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">finishUserUnlocked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> UserState uss)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> uss.mHandle.getIdentifier();<br><br>    mInjector.installEncryptionUnawareProviders(userId);<br><br>    <span class="hljs-keyword">if</span> (!mInjector.getUserManager().isPreCreated(userId)) &#123;<br>        <span class="hljs-comment">//发送ACTION_USER_UNLOCKED广播，并行广播</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">unlockedIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_USER_UNLOCKED);<br>        unlockedIntent.putExtra(Intent.EXTRA_USER_HANDLE, userId);<br>        unlockedIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);<br>        mInjector.broadcastIntent(unlockedIntent, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>,<br>                                  <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, AppOpsManager.OP_NONE, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, MY_PID, SYSTEM_UID,<br>                                  Binder.getCallingUid(), Binder.getCallingPid(), userId);<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> getUserInfo(userId);<br> <span class="hljs-comment">//用户fingerprint改变，则发送广播</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">UserInfo</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> getUserInfo(userId);<br>    <span class="hljs-keyword">if</span> (!Objects.equals(info.lastLoggedInFingerprint, Build.FINGERPRINT)<br>        || SystemProperties.getBoolean(<span class="hljs-string">&quot;persist.pm.mock-upgrade&quot;</span>, <span class="hljs-literal">false</span>)) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> quiet;<br>        <span class="hljs-keyword">if</span> (info.isManagedProfile()) &#123;<br><span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            quiet = <span class="hljs-literal">false</span>;<br>        &#125;<br>        mInjector.sendPreBootBroadcast(userId, quiet, () -&gt; finishUserUnlockedCompleted(uss));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        finishUserUnlockedCompleted(uss);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后的最后，我们结束整个的解锁finishUserUnlockedCompleted</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishUserUnlockedCompleted</span><span class="hljs-params">(UserState uss)</span> &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> uss.mHandle.getIdentifier();<br><br>      mInjector.getUserManager().onUserLoggedIn(userId);<br><br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">initializeUser</span> <span class="hljs-operator">=</span> () -&gt; mInjector.getUserManager().makeInitialized(userInfo.id);<br>      <span class="hljs-keyword">if</span> (!userInfo.isInitialized()) &#123;<br>          <span class="hljs-keyword">if</span> (userInfo.preCreated) &#123;<br>              <span class="hljs-comment">// ...</span><br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userId != UserHandle.USER_SYSTEM) &#123;<br>              <span class="hljs-comment">//发送ACTION_USER_INITIALIZE广播去给user初始化，，串行广播</span><br>              <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_USER_INITIALIZE);<br>              intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND<br>                      | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);<br>              mInjector.broadcastIntent(intent, <span class="hljs-literal">null</span>,<br>                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">IIntentReceiver</span>.Stub() &#123;<br>                          <span class="hljs-meta">@Override</span><br>                          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performReceive</span><span class="hljs-params">(Intent intent, <span class="hljs-type">int</span> resultCode,</span><br><span class="hljs-params">                                  String data, Bundle extras, <span class="hljs-type">boolean</span> ordered,</span><br><span class="hljs-params">                                  <span class="hljs-type">boolean</span> sticky, <span class="hljs-type">int</span> sendingUser)</span> &#123;<br>                              initializeUser.run();<br>                          &#125;<br>                      &#125;, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, AppOpsManager.OP_NONE,<br>                      <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, MY_PID, SYSTEM_UID, Binder.getCallingUid(),<br>                      Binder.getCallingPid(), userId);<br>          &#125;<br>      &#125;<br><br>      mInjector.startUserWidgets(userId);<br><br>      mHandler.obtainMessage(USER_UNLOCKED_MSG, userId, <span class="hljs-number">0</span>).sendToTarget();<br><br><span class="hljs-comment">//发送ACTION_BOOT_COMPLETED广播，串行广播</span><br>      <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">bootIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_BOOT_COMPLETED, <span class="hljs-literal">null</span>);<br>      bootIntent.putExtra(Intent.EXTRA_USER_HANDLE, userId);<br>      bootIntent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT<br>              | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND<br>              | Intent.FLAG_RECEIVER_OFFLOAD);<br><br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">callingUid</span> <span class="hljs-operator">=</span> Binder.getCallingUid();<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">callingPid</span> <span class="hljs-operator">=</span> Binder.getCallingPid();<br>      FgThread.getHandler().post(() -&gt; &#123;<br>          mInjector.broadcastIntent(bootIntent, <span class="hljs-literal">null</span>,<br>                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">IIntentReceiver</span>.Stub() &#123;<br>                      <span class="hljs-meta">@Override</span><br>                      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performReceive</span><span class="hljs-params">(Intent intent, <span class="hljs-type">int</span> resultCode, String data,</span><br><span class="hljs-params">                              Bundle extras, <span class="hljs-type">boolean</span> ordered, <span class="hljs-type">boolean</span> sticky, <span class="hljs-type">int</span> sendingUser)</span><br>                                      <span class="hljs-keyword">throws</span> RemoteException &#123;<br>                          mBootCompleted = <span class="hljs-literal">true</span>;<br>                      &#125;<br>                  &#125;, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,<br>                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;android.Manifest.permission.RECEIVE_BOOT_COMPLETED&#125;,<br>                  AppOpsManager.OP_NONE,<br>                  getTemporaryAppAllowlistBroadcastOptions(REASON_BOOT_COMPLETED).toBundle(),<br>                  <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, MY_PID, SYSTEM_UID, callingUid, callingPid, userId);<br>      &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="4-处理H-BOOT-COMPLETED消息"><a href="#4-处理H-BOOT-COMPLETED消息" class="headerlink" title="4.处理H_BOOT_COMPLETED消息"></a>4.处理H_BOOT_COMPLETED消息</h2><blockquote><p>参考：<a href="https://blog.csdn.net/geshifei/article/details/130194916">https://blog.csdn.net/geshifei/article/details/130194916</a></p></blockquote><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230626000521128.png" alt="image-20230626000521128" style="zoom:70%;"><p>当启动完成后，SystemServiceManager发送H_BOOT_COMPLETED消息。StorageManagerService收到开机广播消息H_BOOT_COMPLETED，按时间顺序完成以下4件事情：</p><ul><li>init用户目录的加密状态</li><li>reset external storage service</li><li>reset vold service</li><li>添加用户</li></ul><p>代码整体逻辑如下：</p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/cd5c71637c0b460f8aaae4a915c7f212.png" alt="img"><h3 id="4-1-init用户目录的加密状态"><a href="#4-1-init用户目录的加密状态" class="headerlink" title="4.1 init用户目录的加密状态"></a>4.1 init用户目录的加密状态</h3><p>代码路径：StorageManagerServiceHandler::handleMessage –&gt; handleBootCompleted –&gt; initIfBootedAndConnected</p><p>分两种情况：<br>1）用户目录采用硬件加解密（native encryption），此阶段什么事也不做，函数直接返回<br>2）用户目录采用软件加解密（enmulated encryption），执行lock  encryption key（用户目录已加密的情况）或者unlock encryption key（用户目录未加密的情况）</p><p>从安全性、性能角度看，硬件加解密更好。</p><p>现在的手机基本都是硬件加解密方式，通过<code>adb shell getprop ro.crypto.state</code>可查询手机用的是哪种加解密方式。</p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230625235902263.png" alt="image-20230625235902263" style="zoom: 67%;"><h2 id="5-拿捏小细节"><a href="#5-拿捏小细节" class="headerlink" title="5.拿捏小细节"></a>5.拿捏小细节</h2><h3 id="5-1-解锁用户"><a href="#5-1-解锁用户" class="headerlink" title="5.1 解锁用户"></a>5.1 解锁用户</h3><h4 id="5-1-1-存储了已解锁的用户"><a href="#5-1-1-存储了已解锁的用户" class="headerlink" title="5.1.1 存储了已解锁的用户"></a>5.1.1 存储了已解锁的用户</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// /frameworks/base/core/java/android/os/storage/StorageManager.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUserKeyUnlocked</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span> &#123;<br><br>    sStorageManager = IStorageManager.Stub.asInterface(ServiceManager.getService(<span class="hljs-string">&quot;mount&quot;</span>));<br>   <br>    <span class="hljs-keyword">return</span> sStorageManager.isUserKeyUnlocked(userId);<br>&#125;<br><br><span class="hljs-comment">// /frameworks/base/services/core/java/com/android/server/StorageManagerService.java</span><br><span class="hljs-comment">// WatchedLockedUsers中维护了列表，表示已经解锁的用户</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">WatchedLockedUsers</span> <span class="hljs-variable">mLocalUnlockedUsers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WatchedLockedUsers</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUserKeyUnlocked</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        <span class="hljs-keyword">return</span> mLocalUnlockedUsers.contains(userId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过dumpsys mount查看已解锁的用户</p><h4 id="5-1-2-数据结构mLocalUnlockedUsers"><a href="#5-1-2-数据结构mLocalUnlockedUsers" class="headerlink" title="5.1.2 数据结构mLocalUnlockedUsers"></a>5.1.2 数据结构mLocalUnlockedUsers</h4><p>我们调用SMS中的isUserKeyUnlocked，实际上就是查询mLocalUnlockedUsers是否包含了该用户Id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">WatchedLockedUsers</span> <span class="hljs-variable">mLocalUnlockedUsers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WatchedLockedUsers</span>();<br></code></pre></td></tr></table></figure><p>WatchedLockedUsers是一个类，内部维护了一个列表。因此我们在理解mLocalUnlockedUsers的时候，就可以直接理解成一个列表。</p><h4 id="5-1-3-向mLocalUnlockedUsers添加已解锁用户时机"><a href="#5-1-3-向mLocalUnlockedUsers添加已解锁用户时机" class="headerlink" title="5.1.3 向mLocalUnlockedUsers添加已解锁用户时机"></a>5.1.3 向mLocalUnlockedUsers添加已解锁用户时机</h4><p>当用户最后调用finishUserBoot后，依次调用：</p><p><strong>finishUserBoot -&gt; maybeUnlockUser -&gt; unlockUserCleared  -&gt; unlockUserKey</strong></p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230620215447143.png" alt="image-20230620215447143" style="zoom: 50%;"><p>也就是说调用Vold解锁CE Storage没有问题后，认为该用户解锁成功，那么将该用户添加到mLocalUnlockedUsers中</p><h4 id="5-1-4-删除未解锁用户【有问题】"><a href="#5-1-4-删除未解锁用户【有问题】" class="headerlink" title="5.1.4 删除未解锁用户【有问题】"></a>5.1.4 删除未解锁用户【有问题】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockUserKey</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用vold锁住用户</span><br>        mVold.lockUserKey(userId);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Slog.wtf(TAG, e);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// mLocalUnlockedUsers移除传进来的userId</span><br>    <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        mLocalUnlockedUsers.remove(userId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-用户类型managed-profile"><a href="#5-2-用户类型managed-profile" class="headerlink" title="5.2 用户类型managed profile"></a>5.2 用户类型managed profile</h3><p><a href="https://source.android.com/docs/devices/admin/multi-user?hl=zh-cn#user_types">https://source.android.com/docs/devices/admin/multi-user?hl=zh-cn#user_types</a></p><p>用户经常想在企业环境中使用他们的私人设备。这种情况可能让企业陷入困境。如果用户使用他们的私人设备，企业不得不担心在这个不受控制的设备上的机密信息（例如员工的电子邮件和通讯录）。</p><p>为了处理这种情况，Android 5.0（API 21）允许企业设置 managed profile。如果设备有 managed profile，这个 profile 的设置是在企业管理员的控制之下的。管理员可以选择在这个 profile 之下，什么应用程序可以运行，什么设备功能可以允许。</p><p>如果一个设备有 managed profile，那么，无论应用程序在哪个 profile 之下运行，都意味着：</p><ul><li><p>默认情况下，大部分的 intent 无法从一个 profile 跨越到另一个。如果在某个 profile 之下的一个应用程序创建了 intent，而这个 profile 无法响应，又因为 profile 的限制这个 intent 不允许跨越到其他 profile，那么，这个请求就失败了，应用程序可能意外关闭。</p></li><li><p>profile 管理员可以在 managed profile 中限制哪个系统应用程序可以运行。这个限制可能导致在 managed profile 中一些常见的 intent 无法处理。</p></li><li><p>因为 managed profile 和非 managed profile 有各自的存储区域，导致文件 URI 在一个 profile 中有效，但在其他 profile 中无效。在一个 profile 中创建的 intent 可能在其他 profile（取决于 profile 设置）中被响应，所以在 intent 中放置文件 URI 是不安全的。</p></li></ul><p><a href="https://www.w3cschool.cn/android_training_course/android_training_course-t3xv27in.html">https://www.w3cschool.cn/android_training_course/android_training_course-t3xv27in.html</a></p><h3 id="5-3-SMS维护用户状态的变化UserState-Uss"><a href="#5-3-SMS维护用户状态的变化UserState-Uss" class="headerlink" title="5.3 SMS维护用户状态的变化UserState(Uss)"></a>5.3 SMS维护用户状态的变化UserState(Uss)</h3>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓fuse文件系统</title>
    <link href="/2023/05/31/%E5%AE%89%E5%8D%93fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/05/31/%E5%AE%89%E5%8D%93fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓fuse文件系统"><a href="#安卓fuse文件系统" class="headerlink" title="安卓fuse文件系统"></a>安卓fuse文件系统</h1><p><a href="https://xie.infoq.cn/article/655c0893ed150ff65f2b7a16f">https://xie.infoq.cn/article/655c0893ed150ff65f2b7a16f</a></p><h2 id="1-Fuse是什么"><a href="#1-Fuse是什么" class="headerlink" title="1.Fuse是什么"></a>1.Fuse是什么</h2><p>Linux内核官方文档对 FUSE 的解释如下：</p><blockquote><p>What is FUSE?FUSE is a userspace filesystem framework. It consists of a kernel module (fuse.ko), a userspace library (libfuse.*) and a mount utility (fusermount).</p></blockquote><p><strong>划重点：FUSE 是一个用来实现用户态文件系统的框架</strong>，这套 FUSE 框架包含 3 个组件：</p><ol><li><strong>内核模块</strong> <code>fuse.ko</code> ：用来接收 vfs 传递下来的 IO 请求，并且把这个 IO 封装之后通过管道发送到用户态；</li><li><strong>用户态 lib 库</strong> <code>libfuse</code> ：解析内核态转发出来的协议包，拆解成常规的 IO 请求；</li><li><strong>mount 工具</strong> <code>fusermount</code> ；</li></ol><p>这就是 FUSE 框架的 3 大内容了，下面我们解释下。这 3 个组件只为了完成一件事：让 IO 在内核态和用户态之间自由穿梭。</p><p>一般我们认为 FUSE 是 Filesystem in Userspace 的缩写，也就是常说的用户态文件系统。</p><h2 id="2-Fuse原理"><a href="#2-Fuse原理" class="headerlink" title="2.Fuse原理"></a>2.Fuse原理</h2><p>接下来我们看下 IO 的路径，来理解下 FUSE 的原理。首先看一眼 wiki 上有对 FUSE 的 <code>ls -l /tmp/fuse</code> 命令的演示图：</p><img src="/2023/05/31/%E5%AE%89%E5%8D%93fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/b360be6f915a98e85780454c03160882-1686063758401-3.png" alt="img" style="zoom: 50%;"><p>这个图的意思是：</p><ol><li>背景：一个用户态文件系统，挂载点为 <code>/tmp/fuse</code> ，用户二进制程序文件为 <code>./hello</code> ；</li><li>当执行 <code>ls -l /tmp/fuse</code> 命令的时候，流程如下：</li><li>IO 请求先进内核，经 vfs 传递给内核 FUSE 文件系统模块；</li><li>内核 FUSE 模块把请求发给到用户态，由 <code>./hello</code> 程序接收并且处理。处理完成之后，响应原路返回；</li></ol><p>简化的 IO 动画示意图：</p><img src="/2023/05/31/%E5%AE%89%E5%8D%93fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/fuse1.gif" alt="img" style="zoom: 67%;"><p>通过这两张图，对 FUSE IO 的流程应该就清晰了，内核 FUSE 模块在内核态中间做协议包装和协议解析的工作。承接 vfs 下来的请求并按照 FUSE 协议转发到用户态，然后接收用户态的响应，回复给用户。</p><p>FUSE 在这条 IO 路径是是指做了一个透明中转站的作用，用户完全不感知这套框架。我们把中间的 FUSE 当作一个黑盒遮住，就更容易理解了。<img src="/2023/05/31/%E5%AE%89%E5%8D%93fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/daa6faab9efe0b3c4271bc9db2eba122.gif" alt="img" style="zoom: 67%;"></p><p><strong>思考问题：内核的 fuse.ko 模块，还有 libfuse 库。这两个角色是的作用？</strong></p><p>⭐ 划重点：这两个模块一个位于内核，一个位于用户态，是配套使用的，<strong>最核心的功能是协议封装和解析</strong>。</p><p>举给例子，内核 fuse.ko 用于承接 vfs 下来的 io 请求，然后封装成 FUSE 数据包，转发给用户态。这个时候，用户态文件系统收到这个 FUSE 数据包，它如果想要看懂这个数据包，就必须实现一套 FUSE 协议的代码，这套代码是公开透明的，属于 FUSE 框架的公共的代码，这种代码不能够让所有的用户文件系统都重复实现一遍，<strong>于是 libfuse 用户库就诞生了</strong>。</p><blockquote><p>🔴<strong>安卓对于libfuse的引入：</strong></p><ul><li>文件路径: external\libfuse</li><li>编译生成：libfuse.so</li></ul><p>顺便介绍一下安卓源码目录external: Android引入的第三方库，Google会把一些比较优秀的开源库纳入到源码里面，比如app开发常用的okhttp，zxing，sqlite等</p></blockquote><p>回到开篇的问题，FUSE 能做什么？</p><p>看到这里你应该就清晰了，FUSE 能够转运 vfs 下来的 io 请求到用户态，用户程序处理之后，经由 FUSE 框架回应给用户。<strong>从而就可以把文件系统的实现全部放到用户态实现了</strong>。</p><h2 id="3-Fuse协议格式"><a href="#3-Fuse协议格式" class="headerlink" title="3.Fuse协议格式"></a>3.Fuse协议格式</h2><p>我们分析一眼 FUSE 数据转运的数据格式（ fuse 协议的格式 ），请求包和响应包是什么样子的呢？好奇不？</p><h3 id="3-1-Fuse请求包"><a href="#3-1-Fuse请求包" class="headerlink" title="3.1 Fuse请求包"></a>3.1 Fuse请求包</h3><ul><li><code>Header</code> ： 这个是所有请求共用的，比如 <code>open</code> 请求，<code>read</code> 请求，<code>write</code> 请求，<code>getxattr</code> 请求，头部都至少有这个结构体，<code>Header</code> 结构体能描述整个 FUSE 请求，其中字段能区分请求类型；</li><li><code>Payload</code> ：这个东西是每个 IO 类型会是不同的，比如 <code>read</code> 请求就没这个，<code>write</code> 请求就有这个，因为 <code>write</code> 请求是携带数据的；</li></ul><p>数据包分为两部分：header，payload 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">type inHeader <span class="hljs-keyword">struct</span> &#123;<br>  Len    uint32<br>  Opcode uint32<br>  Unique uint64<br>  Nodeid uint64<br>  Uid    uint32<br>  Gid    uint32<br>  Pid    uint32<br>  _      uint32<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Len: 是整个请求的字节数长度（<code>Header</code> + <code>Payload</code>）</li><li>Opcode: 请求的类型，比如区分 open、read、write 等等；</li><li>Unique: 请求唯一标识（和响应中要对应）</li><li>Nodeid: 请求针对的文件 nodeid，目标文件或者文件夹的 nodeid；</li><li>Uid: 文件&#x2F;文件夹操作的进程的用户 ID</li><li>Gid: 文件&#x2F;文件夹操作的进程的用户组 ID</li><li>Pid: 文件&#x2F;文件夹操作的进程的进程 ID</li></ul><h3 id="3-2-Fuse响应包"><a href="#3-2-Fuse响应包" class="headerlink" title="3.2 Fuse响应包"></a>3.2 Fuse响应包</h3><p>FUSE 响应包也分为两部分：</p><ul><li><code>Header</code> ：这个结构体也是在数据头部的，所有 IO 类型的响应都至少有这个结构体。该结构体用于描述整个响应请求；</li><li><code>Payload</code> ：每个请求的类型可能不同，比如 <code>read</code> 请求就会有这个，因为要携带 <code>read</code> 出来的用户数据，<code>write</code> 请求就不会有；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">type outHeader <span class="hljs-keyword">struct</span> &#123;<br>  Len    uint32<br>  Error  int32<br>  Unique uint64<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Len: 整个响应的字节数长度（ <code>Header</code> + <code>Payload</code> ）；</li><li>Error: 响应错误码，成功返回 0，其他对应着系统的错误代码，负数；</li><li>Unique: 对应者请求的唯一标识，和请求对应；</li></ul><h2 id="4-内核态、用户态的纽带"><a href="#4-内核态、用户态的纽带" class="headerlink" title="4.内核态、用户态的纽带"></a>4.内核态、用户态的纽带</h2><p>现在对数据协议的格式，转发和转运的模块我们也知道了。现在还差一个关键的点：<strong>数据包的通道</strong>，也就是高速公路。</p><p>换句话说，内核模块的“包裹”发到哪里？用户程序又从哪里读取拿到这个“包裹”。</p><p><strong>答案是：</strong><code>/dev/fuse</code> <strong>，这个虚设备文件就是内核模块和用户程序的桥梁。</strong></p><p>一切都顺理成章了，内核在这个过程中相当于一个信使，用户的 io 通过正常的系统调用进来，走到内核文件系统 fuse ，fuse 文件系统把这个 io 请求封装起来，打包成特定的格式，通过 <code>/dev/fuse</code> 这个管道传递到用户态。在此之前有守护进程监听这个管道，看到有消息出来之后，立马读出来，然后利用 <code>libfuse</code> 库解析协议，之后就是用户文件系统的代码逻辑了。</p><p>示意图如下（省略了拆解包的步骤）：</p><img src="/2023/05/31/%E5%AE%89%E5%8D%93fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/0b7beda12f1ffea18de8c62fbfc3c941.gif" alt="img" style="zoom: 67%;">]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓中的控制反转IOC</title>
    <link href="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/"/>
    <url>/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓中的控制反转IOC"><a href="#安卓中的控制反转IOC" class="headerlink" title="安卓中的控制反转IOC"></a>安卓中的控制反转IOC</h1><h2 id="1-IOC简介"><a href="#1-IOC简介" class="headerlink" title="1.IOC简介"></a>1.IOC简介</h2><h3 id="1-1-IOC是什么"><a href="#1-1-IOC是什么" class="headerlink" title="1.1 IOC是什么"></a>1.1 IOC是什么</h3><p><strong>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。</strong>在Java开发中，<strong>Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong>如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p><p> ● <strong>谁控制谁，控制什么：</strong>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；<strong>谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</strong></p><p> ● <strong>为何是反转，哪些方面反转了：</strong>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？<strong>因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</strong></p><p>用图例说明一下，传统程序设计如图，都是主动去创建相关对象然后再组合起来：</p><img src="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/image1.png" style="zoom: 80%;"><p>当有了IoC的容器后，在客户端类中不再主动去创建这些对象了，如图所示:</p><img src="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/image2.png" style="zoom: 80%;"><h3 id="1-2-IOC能做什么"><a href="#1-2-IOC能做什么" class="headerlink" title="1.2 IOC能做什么"></a>1.2 IOC能做什么</h3><p>IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p><p> 其实<strong>IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC&#x2F;DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</strong></p><p>IOC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><h3 id="1-3-SpringIOC创建容器"><a href="#1-3-SpringIOC创建容器" class="headerlink" title="1.3 SpringIOC创建容器"></a>1.3 SpringIOC创建容器</h3><h4 id="1-3-1-原生耦合方式"><a href="#1-3-1-原生耦合方式" class="headerlink" title="1.3.1 原生耦合方式"></a>1.3.1 原生耦合方式</h4><ol><li>创建接口Animal</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建具体实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一只小猫咪！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一只小狗狗！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>创建Service层，需要调用dao层的数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">getInfo</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getInfo</span><span class="hljs-params">()</span> &#123;<br>        animal.info();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>测试类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        userService.getInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/image3.png" style="zoom: 80%;"><p>分析：假设测试类是我们目前的用户（客户端），我们需要得到猫的信息，需要去Service层创建一个猫的实例出来；如果我们需要得到狗的信息，需要去Service层创建一个狗的实例出来！这样代码耦合性太高，用户的需求被耦合在源码中！</p><h4 id="1-3-2-SpringIOC创建容器"><a href="#1-3-2-SpringIOC创建容器" class="headerlink" title="1.3.2 SpringIOC创建容器"></a>1.3.2 SpringIOC创建容器</h4><ol><li>原来的实现类中构建set方法！</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br><br>    <span class="hljs-keyword">private</span> Animal animal;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAnimal</span><span class="hljs-params">(Animal animal)</span> &#123;<br>        <span class="hljs-built_in">this</span>.animal = animal;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getInfo</span><span class="hljs-params">()</span> &#123;<br>        animal.info();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建bean容器管理文件<code>beans.xml</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.amx.dao.Cat&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.amx.dao.Dog&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userservice&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.amx.service.UserServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;animal&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;cat&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>进入测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">// 通过类路径获取beans容器的上下文环境context</span><br>       <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>       <span class="hljs-comment">// 获取beans容器中的userservice对象</span><br>       <span class="hljs-type">UserService</span> <span class="hljs-variable">userservice</span> <span class="hljs-operator">=</span> (UserService) context.getBean(<span class="hljs-string">&quot;userservice&quot;</span>);<br>       userservice.getInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：如果我们想要获取Cat的信息，只要用户去beans.xml文件中修改一下即可！如果我们想要过去Dog的信息，只要用户去beans.xml文件中修改为dog就行了！所有的主动权交给了用户手中！需要什么我们去容器中拿就行了~</p><h3 id="1-4-IOC容器、控制反转、依赖注入"><a href="#1-4-IOC容器、控制反转、依赖注入" class="headerlink" title="1.4 IOC容器、控制反转、依赖注入"></a>1.4 IOC容器、控制反转、依赖注入</h3><img src="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/image-20230531000336367.png" alt="image-20230531000336367" style="zoom:80%;"><img src="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/image-20230531000351949.png" alt="image-20230531000351949" style="zoom:80%;"><img src="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/image-20230531000408614.png" alt="image-20230531000408614" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓内部存储和外部存储</title>
    <link href="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/"/>
    <url>/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓内部存储和外部存储"><a href="#安卓内部存储和外部存储" class="headerlink" title="安卓内部存储和外部存储"></a>安卓内部存储和外部存储</h1><blockquote><p>声明：以下内容摘录自各大神的博客，用于自己学习备忘，十分感激！</p><ul><li><a href="https://www.jianshu.com/p/a39bc4b3a1a6">https://www.jianshu.com/p/a39bc4b3a1a6</a></li></ul></blockquote><h2 id="1-内部存储"><a href="#1-内部存储" class="headerlink" title="1.内部存储"></a>1.内部存储</h2><p>内部存储，其实是手机ROM上的一块存储区域，主要用于存储系统以及应用程序的数据。内部存储在Android系统对应的根目录是 &#x2F;data&#x2F;data&#x2F;，这个目录普通用户是无权访问的，用户需要root权限才可以查看。不过我们可以通过Android Studio的View—-Tool Windows—-Device File Explorer工具来查看该目录，内部存储目录的大致结构如下所示。</p><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/webp.webp" alt="img" style="zoom: 80%;"><p>从上图可以看到，&#x2F;data&#x2F;data目录是按照应用的包名来组织的，每个应用都是属于自己的内部存储目录，而且目录的名称就是该应用的包名，这个目录是在安装应用的时候自动创建的，当应用被卸载后，该目录也会被系统自动删除。所以，如果你将数据存储于内部存储中，其实就是把数据存储到自己应用包名对应的内部存储目录中。每个应用的内部存储目录都是私有的，也就是说内部存储目录下的文件只能被应用自己访问到，其他应用是没有权限访问的。应用访问自己的内部存储目录时不需要申请任何权限。</p><p>一个应用典型的内部存储目录结构如下所示。</p><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/webp-1685371597396-3.webp" alt="img" style="zoom:80%;"><p>相信很多人看到内部存储的目录结构，都有似曾相识的感觉，没错我们平常经常和内部存储打交道，只不过我们不知道罢了，下面我们来看下内部存储目录下各个子目录的作用。</p><ul><li><strong>app_webview</strong>：主要用于存储webview加载过程中的数据，例如Cookie，LocalStorage等。</li><li><strong>cache</strong>：主要用于存储使用应用过程中产生的缓存数据。</li><li><strong>databases</strong>：主要用于存储数据库类型的数据。我们平常创建的数据库文件就是存储在这里。</li><li><strong>files</strong>：可以在该目录下存储配置文件，敏感数据等。</li><li><strong>shared_prefs</strong>：用于存储SharedPreference文件。我们使用SharedPreference的时候只指定了文件名，并没有指定存储路径，其实SP的文件就是保存到了这个目录下。</li></ul><p>那么有哪些API可以获取到内部存储目录呢，我们主要是使用Context类提供的接口来访问内部存储目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>getDataDir()  <span class="hljs-comment">//获取的目录是/data/user/0/package_name，即应用内部存储的根目录</span><br><span class="hljs-number">2.</span>getFilesDir() <span class="hljs-comment">//获取的目录是/data/user/0/package_name/files，即应用内部存储的files目录</span><br><span class="hljs-number">3.</span>getCacheDir() <span class="hljs-comment">//获取的目录是/data/user/0/package_name/cache，即应用内部存储的cache目录</span><br><span class="hljs-number">4.</span>getDir(String name, <span class="hljs-type">int</span> mode) <span class="hljs-comment">//获取的目录是/data/user/0/package_name/app_name，如果该目录不存在，系统会自动创建该目录。</span><br></code></pre></td></tr></table></figure><p>获取到对应的目录后，我们就可以对目录下的文件进行读写。细心的同学可能会发现代码中获取的内部存储根目录是 &#x2F;data&#x2F;user&#x2F;0，并不是前面提到的&#x2F;data&#x2F;data，这是怎么回事呢？因为在Android4.2以后增加了多用户的功能，为了适应多用户的功能，原来的&#x2F;data&#x2F;data&#x2F;相当于直接链接到当前用户文件夹的，变成了&#x2F;data&#x2F;user&#x2F;0&#x2F;，所以我们代码中打印出来的路径是&#x2F;data&#x2F;user&#x2F;0，而不是&#x2F;data&#x2F;data，<strong>说白了&#x2F;data&#x2F;data和&#x2F;data&#x2F;user&#x2F;0&#x2F;是一个东西</strong>。</p><p>内部存储空间容量有限，如果内部存储空间被用完，系统会报内存不足。所以，不要把所有的数据都放到内部存储中。在开发应用过程中，我们可以把较敏感的应用数据放在内部存储中，而其他的数据可以放在外部存储中。那外部存储又是什么呢？下面我们接着来学习外部存储。</p><h2 id="2-外部存储"><a href="#2-外部存储" class="headerlink" title="2.外部存储"></a>2.外部存储</h2><p>我们知道内部存储中的数据对应用来说是私密的，用户和其他应用都没有访问权限，而外部存储中的数据是可以被其他应用或用户访问甚至删除的，用户可以通过USB方式和PC之间交互外部存储中的数据。我们平常在Android手机的文件管理工具下看到的目录其实就是外部存储。在Android4.4以前，外部存储就是指SD卡，手机自带的存储就是内部存储；但是在Android4.4以后，随着手机机身存储越来越大，手机的机身存储已经可以满足大多数用户的需求，所以很多手机都不需要再安装SD卡。此时外部存储和内部存储都位于手机机身存储上，他们只是同一个存储介质上的不同存储区域。但是很多手机还是保留了SD卡插槽，方便用户自行拓展。如果手机安装了SD卡，那么很显然SD卡目录也属于外部存储目录。这时手机都有了两个外部存储空间，一个位于手机机身存储上，一个位于SD卡上。但是随着机身存储越累越大，SD卡一般可能只适用于转移文件，对于一般应用来说应该也不会把数据写到外置的SD卡上了，所以这里主要以机身存储为例来分析外部存储。</p><h3 id="2-1-外部私有存储目录"><a href="#2-1-外部私有存储目录" class="headerlink" title="2.1 外部私有存储目录"></a>2.1 外部私有存储目录</h3><p>通常来说，应用涉及到的持久化数据一般分为两类：应用相关数据和应用无关数据。前者是指应用使用的数据信息，比如一些配置信息，调试信息，缓存文件等。当应用被卸载，这些信息也应该被随之删除，避免占用不必要的存储空间。例如下面两种场景。</p><ul><li>在用户使用应用过程中，产生的文件，图片，视频，音频等数据，这些数据不太敏感但是占用空间比较大，卸载App时不希望这些数据继续保留在用户手机中。</li><li>当应用发生闪退时，希望把一些闪退信息保存下来，让用户获取闪退信息文件后通过特定渠道发送给开发人员进行问题定位。同样的，这些信息在卸载App后也不希望继续留在用户手机中。</li></ul><p>对于问题一，我们可以直接把数据存储在内部存储中，但是考虑到内部存储空间有限，把这些数据存储到内部存储会浪费内部存储的空间。对于问题二，普通用户（指没有root权限的用户）无法直接查看其中的文件，把数据直接存储在内部存储中是行不通的。这些数据有一个共同点就是他们的生命周期和应用是一致的，而且不太适合于放在内部存储中。为了存储这种类型的数据，Android规定来一个专门的存储空间，这个空间被称为外部私有存储空间。外部私有存储空间属于外部存储，对于某个应用来说，外部私有存储的根目录（这里暂时不考虑SD卡）是 &#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;package_name，这个目录有点类似于内部存储目录，都是以包名来命名私有存储空间的。外部私有存储空间有以下特点</p><ul><li>内部私有存储中的数据会随着App的卸载一起删除</li><li>仅仅安装应用不会在&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;目录下生成该应用的外部私有存储目录，只有在应用中调用API访问外部私有存储目录时，才会创建以package_name命名的私有存储目录。</li><li>App在访问自己的外部私有存储目录时不需要任何权限</li><li>自 Android 7.0 开始，系统对外部存储目录中 应用私有目录的访问权限进一步限制。其他 App 无法通过 file:&#x2F;&#x2F; 这种形式的 Uri 直接读写其他应用的外部私有存储目录，而是需要通过 FileProvider 访问</li></ul><p>在代码中我们可以通过以下方式来获取外部私有存储目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>getExternalCacheDir() <br><span class="hljs-comment">/*获取到的目录是/storage/emulated/0/Android/data/package_name/cache，如果该目录不存在，调用这个方法会自动创建该目录。*/</span><br><span class="hljs-number">2.</span>getExternalFilesDir(String type) <br><span class="hljs-comment">/* 1.如果type为&quot;&quot;，那么获取到的目录是 /storage/emulated/0/Android/data/package_name/files</span><br><span class="hljs-comment">   2.如果type不为空，则会在/storage/emulated/0/Android/data/package_name/files目录下创建一个以传入的type值为名称的目录，例如你将type设为了test，那么就会创建/storage/emulated/0/Android/data/package_name/files/test目录，这个其实有点类似于内部存储getDir方法传入的name参数。但是android官方推荐使用以下的type类型</span><br><span class="hljs-comment">   public static String DIRECTORY_MUSIC = &quot;Music&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_PODCASTS = &quot;Podcasts&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_RINGTONES = &quot;Ringtones&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_ALARMS = &quot;Alarms&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_NOTIFICATIONS = &quot;Notifications&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_PICTURES = &quot;Pictures&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_MOVIES = &quot;Movies&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_DOWNLOADS = &quot;Download&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_DCIM = &quot;DCIM&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_DOCUMENTS = &quot;Documents&quot;;*/</span><br></code></pre></td></tr></table></figure><h3 id="2-2-外部共有存储目录"><a href="#2-2-外部共有存储目录" class="headerlink" title="2.2 外部共有存储目录"></a>2.2 外部共有存储目录</h3><p>外部存储目录还有一个存储空间就是外部共有存储目录，顾名思义，外部共有存储目录存储的数据无论对应用还是用户都是可见的应用只要有外部访问权限，就可以读取外部公共目录下的文件。外部公共目录主要存放和应用无关的数据，这些数据在卸载App的时候不会被删除。外部共有存储目录有以下特点。</p><ul><li>当卸载App时，共有存储目录下的文件不会被删除</li><li>应用在访问外部公有目录之前，首先要申请外部存储权限，在Android6.0以后，外部存储权限还要动态申请。</li><li>任何应用只要有外部存储权限，都可以访问共有存储目录下的数据。</li></ul><p>在代码中，我们可以通过以下方式来访问外部公共存储目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>Environment.getExternalStorageDirectory() <br><span class="hljs-comment">//获取到的目录是/storage/emulated/0,这个也是外部存储的根目录。</span><br><span class="hljs-number">2.</span>Environment.getExternalStoragePublicDirectory(String type) <br><span class="hljs-comment">/* 1.如果type为&quot;&quot;，那么获取到的目录是外部存储的根目录即  /storage/emulated/0</span><br><span class="hljs-comment">   2.如果type不为空，则会在/storage/emulated/0目录下创建一个以传入的type值为名称的目录，例如你将type设为了test，那么就在外部存储根目录下创建test目录，这个方法和getExternalFilesDir的用法一样。android官方推荐使用以下的type类型，我们在SK卡的根目录下也经常可以看到下面的某些目录。</span><br><span class="hljs-comment">   public static String DIRECTORY_MUSIC = &quot;Music&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_PODCASTS = &quot;Podcasts&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_RINGTONES = &quot;Ringtones&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_ALARMS = &quot;Alarms&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_NOTIFICATIONS = &quot;Notifications&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_PICTURES = &quot;Pictures&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_MOVIES = &quot;Movies&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_DOWNLOADS = &quot;Download&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_DCIM = &quot;DCIM&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_DOCUMENTS = &quot;Documents&quot;;*/</span><br></code></pre></td></tr></table></figure><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/v2-76c6e06d688756944ccba4a85236dd7b_r.jpg" alt="img" style="zoom:67%;"><blockquote><p>图片来源：<a href="https://zhuanlan.zhihu.com/p/165140637%EF%BC%8C%E4%BD%9C%E8%80%85%EF%BC%9A[Bgwan](https://www.zhihu.com/people/qydq)">https://zhuanlan.zhihu.com/p/165140637，作者：[Bgwan](https://www.zhihu.com/people/qydq)</a></p></blockquote><h2 id="3-外部存储和内部存储对比"><a href="#3-外部存储和内部存储对比" class="headerlink" title="3.外部存储和内部存储对比"></a>3.外部存储和内部存储对比</h2><p>要区分外部存储和内部存储，我们最好从逻辑上来理解这两个概念，而不是从物理上。虽然在Android4.4以前，逻辑上和物理上是统一的，但是Android4.4以后，随着外置SD卡的使用越来越少，内部存储和外部存储和物理介质的内外就没有任何关系了。</p><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/webp-1685373896034-6.webp" alt="img" style="zoom:67%;"><h2 id="4-疑惑解答"><a href="#4-疑惑解答" class="headerlink" title="4.疑惑解答"></a>4.疑惑解答</h2><h3 id="4-1-内置的外部存储和SD卡有啥区别"><a href="#4-1-内置的外部存储和SD卡有啥区别" class="headerlink" title="4.1 内置的外部存储和SD卡有啥区别"></a>4.1 内置的外部存储和SD卡有啥区别</h3><p>在4.4以后的系统中，API提供了这样一个方法来遍历手机的外部存储路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">File[] files;<br><span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;<br>    files = getExternalFilesDirs(Environment.MEDIA_MOUNTED);<br>    <span class="hljs-keyword">for</span>(File file:files)&#123;<br>        Log.e(<span class="hljs-string">&quot;main&quot;</span>,file);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你的手机插了SD卡的话，那么它打印的路径就有两条了，例如我的华为荣耀7插了SD卡，它的结果如下：</p><ul><li>&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;packname&#x2F;files&#x2F;mounted</li><li>&#x2F;storage&#x2F;B3E4-1711&#x2F;Android&#x2F;data&#x2F;packname&#x2F;files&#x2F;mounted</li></ul><p>其中&#x2F;storage&#x2F;emulated&#x2F;0目录就是机身存储的外部存储路径，而&#x2F;storage&#x2F;B3E4-1711&#x2F;就是SD卡的路径，他们统称为外部存储</p><h3 id="4-2-主存储是什么"><a href="#4-2-主存储是什么" class="headerlink" title="4.2 主存储是什么"></a>4.2 主存储是什么</h3><blockquote><p>来源：<a href="https://fqzhanghao.github.io/post/android-cun-chu-wa-keng-ji/">https://fqzhanghao.github.io/post/android-cun-chu-wa-keng-ji/</a></p></blockquote><p>这个Primary和Secondary是怎么来的呢？实际上最开始Android也没有考虑这个区分，但是后来有一个情况发生了，就是上面所说到的：</p><p>后来部分手机开始将最初定义的“Internal Storage”，即内置存储，分成Internal和External两部分。</p><p>那么如果这个时候手机再插入sd卡，那不是有多个External Storage了吗？</p><p>这个时候，<strong>从Internal Storage里面分出来的那块“External Storage”我们称之为主存储(Primary Storage)，插入的外置储存称之为副存储(Secondary Storage)。</strong></p><p>主存储路径的获取方式非常简单，可以通过Environment.getExternalStorageDirectory()或者Context.getExternalFilesDir(null)来获取。</p><p>副存储路径在4.4及以上的Android系统中，可以使用Context.getExternalFilesDirs(null)(注意最后多了一个’s’)，它返回的是一个字符串数组。第0个就是主存储路径，第1个是副存储路径（如果有的话）。从4.1也可以证明！！！</p><h3 id="4-3-Adoptable-Storage"><a href="#4-3-Adoptable-Storage" class="headerlink" title="4.3 Adoptable Storage"></a>4.3 Adoptable Storage</h3><p>由于External Storage的缺点（有时不可用，存储内容没有被保护），在6.0之后多出了<code>Adoptable</code>存储方式。</p><p>当Android系统<code>Adopt</code>了一块External存储区域的时候，它会被视为Internal Storage，同时会被格式化与加密。格式化之后是GPT分区，存储上线为9ZB。</p><p>当你在一个支持<code>Adoptable Storage</code>的手机上插入一个sd卡，它会提示你是否将这个sd卡格式化并用作Internal Storage，或者正常作为External Storage使用。</p><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/731da63df8dcd100f5e720dd758b4710b8122f29.jpg" alt="img" style="zoom:67%;"><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/d7e7c1dcd100baa19d579f474010b912c9fc2e29.jpg" alt="img" style="zoom:67%;"><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/f27bf411728b4710ea542530c4cec3fdfd032329.jpg" alt="img" style="zoom:67%;"><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/85cb4b8b4710b9129cba2e02c4fdfc0393452229.jpg" alt="img" style="zoom:67%;"><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/3a517e10b912c8fc96882e31fb039245d7882129.jpg" alt="img" style="zoom: 67%;"><h3 id="4-4-私有卷PrivateVolume"><a href="#4-4-私有卷PrivateVolume" class="headerlink" title="4.4 私有卷PrivateVolume"></a>4.4 私有卷PrivateVolume</h3><p><a href="https://blog.csdn.net/woai110120130/article/details/107701932">https://blog.csdn.net/woai110120130/article/details/107701932</a></p><p>PrivateVolume分区用于将外置存储转为内置存储使用的，并且PrivateVolume是使用全盘加密的。所以PrivateVolume是和Android设备强相关的，把包含PrivateVolume的磁盘介质拿到其他手机上是无法解密挂载的。所以PrivateVolume必然是在Android设备上来进行格式化的。每个PrivateVolume还对应一个EmulatedVolume分区，这个EmulatedVolume可以作为主分区挂载。 <strong>对于&#x2F;data分区的挂载不由Vold服务来管理</strong>，所以MountService会主动添加一个PrivateVolume来对应&#x2F;data分区，Vold服务会主动添加一个EmulatedVolume来对应&#x2F;data这个PrivateVolume分区。</p><ul><li>当没有其他设备被格式化为PrivateVolume且要求使用Private分区来作为主存储的时候，就使用&#x2F;data分区对应的EmulatedVolume来作为主外置存储。</li><li>当我们格式化了一个PrivateVolume的时候，我们可以选择将主分区移动到新增的这个PrivateVolume对应的EmulatedVolume上。</li></ul><p>EmulatedVolume 为主分区的时才会被挂载，一个EmulatedVolume一般使用PrivateVolume挂载的根目录下的media目录，作为fuse的后端使用，使用fuse主要方便存储权限的管理，提供更灵活的权限管理机制。我们会在后面还分析fuse实现的存储目录。下面我们来分析下磁盘的格式化过程。</p>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑卷管理LVM</title>
    <link href="/2023/05/28/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86LVM/"/>
    <url>/2023/05/28/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86LVM/</url>
    
    <content type="html"><![CDATA[<h1 id="逻辑卷管理LVM"><a href="#逻辑卷管理LVM" class="headerlink" title="逻辑卷管理LVM"></a>逻辑卷管理LVM</h1><h2 id="1-为什么会出现逻辑卷"><a href="#1-为什么会出现逻辑卷" class="headerlink" title="1.为什么会出现逻辑卷"></a>1.为什么会出现逻辑卷</h2><p>每个Linux使用者在安装Linux时 都会遇到这样的困境：在为系统分区时，如何精确评估和分配各个硬盘分区的容量，因为系统管理员不但要考虑到当前某个分区需要的容量，还要预见该分区以后可能需要的容量的最大值。因为如果估计不准确，当遇到某个分区不够用时管理员可能甚至要备份整个系统、清除硬盘、重新对硬盘分区，然后恢复数据到新分区。</p><p>虽然现在有很多动态调整磁盘的工具可以使用，例如Partation Magic等等，但是它并不能完全解决问题，因为某个分区可能会再次被耗尽；另外一个方面这需要重新引导系统才能实现，对于很多关键的服务器，停机是不可接受的，而且对于添加新硬盘，希望一个能跨越多个硬盘驱动器的文件系统时，分区调整程序就不能解决问题。</p><p>因此完美的解决方法应该是在零停机前提下可以自如对文件系统的大小进行调整，可以方便实现文件系统跨越不同磁盘和分区。那么我们可以通过逻辑盘卷管理（LVM，Logical Volume Manager）的方式来非常完美的实现这一功能。</p><p>LVM是逻辑盘卷管理（Logical Volume Manager）的简称，他是磁盘管理的另一种工具，就目前基本上所有操作系统均支持，LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。通过LVM系统管理员可以轻松管理磁盘分区，如：将若干个磁盘分区连接为一个整块的卷组（volume group），形成一个存储池。管理员可以在卷组上随意创建逻辑卷组（logical volumes），并进一步在逻辑卷组上创建文件系统。管理员通过LVM可以方便的调整存储卷组的大小，并且可以对磁盘存储按照组的方式进行命名、管理和分配，例如按照使用用途进行定义：“DBdata”和“DBSoft”，而不是使用物理磁盘名“sda”和“sdb”或”hda”和”hdb”。而且当系统添加了新的磁盘，通过LVM管理员就不必将磁盘的文件移动到新的磁盘上以充分利用新的存储空间，而是直接扩展文件系统跨越磁盘即可，架构可以参考如下图：</p><img src="/2023/05/28/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86LVM/5f6824ed3294480aa7d2d13a293a3cdf.jpeg" alt="磁盘、分区、物理卷、卷组、逻辑卷关系" style="zoom:67%;"><h2 id="2-LVM基本结构"><a href="#2-LVM基本结构" class="headerlink" title="2.LVM基本结构"></a>2.LVM基本结构</h2><p><strong>物理存储介质（The physical media）</strong></p><p>这里指系统的存储设备：硬盘，如：&#x2F;dev&#x2F;hda、&#x2F;dev&#x2F;sda等等，是存储系统最低层的存储单元。</p><p><strong>物理卷（physicalvolume）</strong></p><p>物理卷就是指硬盘分区或从逻辑上与磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有与LVM相关的管理参数。</p><p><strong>卷组（Volume Group）</strong></p><p>LVM卷组类似于非LVM系统中的物理硬盘，其由物理卷组成。可以在卷组上创建一个或多个“LVM分区”（逻辑卷），LVM卷组由一个或多个物理卷组成。</p><p><strong>逻辑卷（logicalvolume）</strong></p><p>LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷之上可以建立文件系统(比如&#x2F;home或者&#x2F;usr等)。</p><p><strong>PE（physical extent）</strong></p><p>每一个物理卷被划分为称为PE(Physical Extents)的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是可配置的，默认为4MB。</p><p><strong>LE（logical extent）</strong></p><p>逻辑卷也被划分为被称为LE(Logical Extents) 的可被寻址的基本单位。在同一个卷组中，LE的大小和PE是相同的，并且一一对应。</p><img src="/2023/05/28/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86LVM/image-20230528220753173.png" alt="image-20230528220753173" style="zoom:67%;"><p>🤖<strong>注意：一个逻辑卷只能来自于一个卷组</strong></p><h2 id="3-LVM管理命令"><a href="#3-LVM管理命令" class="headerlink" title="3.LVM管理命令"></a>3.LVM管理命令</h2><img src="/2023/05/28/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86LVM/980b51f31966e6d9d5e5245f04c1cedcf46905.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom:67%;"><p><img src="https://dl-harmonyos.51cto.com/images/202101/980b51f31966e6d9d5e5245f04c1cedcf46905.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区"></p><p>主要命令的用法<br>（1）pvcreate 设备名<br>（2）vgcreate -s 8M 卷组名 物理卷名1 物理卷名2<br>（3）lvcreate -L 大小 -n 逻辑卷名 卷组名<br>（4）lvextend -L +大小 &#x2F;dev&#x2F;卷组名&#x2F;逻辑卷名<br>（5）lvreduce –L +大小 &#x2F;dev&#x2F;卷组名&#x2F;逻辑卷名</p><p>其余操作见：<a href="https://www.cnblogs.com/cloudos/p/9348315.html">https://www.cnblogs.com/cloudos/p/9348315.html</a></p><h2 id="4-LVM应用示例"><a href="#4-LVM应用示例" class="headerlink" title="4.LVM应用示例"></a>4.LVM应用示例</h2><p><strong>需求描述：</strong></p><blockquote><p>公司的邮件服务器由于用户数量众多，邮件存储需要大量的空间，考虑到动态扩容的需要，计划增加两块SCSI硬盘并构建LVM逻辑卷，挂载到“&#x2F;mail”目录专门用于存放邮件数</p></blockquote><p><strong>推荐步骤：</strong></p><blockquote><p>PV -&gt; VG -&gt; LV -&gt; 格式化-&gt;挂载使用文件系统</p></blockquote><img src="https://dl-harmonyos.51cto.com/images/202101/55f57c1699f0f7186137194b65b95fb109435f.png" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom:67%;"><p>第一步：转化物理卷<br>（1）使用fdisk命令规划两个分区，类型设置为“8e”：&#x2F;dev&#x2F;sdb1、&#x2F;dev&#x2F;sdc1<br>（2）使用pvcreate命令转换上述分区为物理卷</p><img src="/2023/05/28/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86LVM/04457b6915ed6816e27022c660e5ff0520395e.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom:67%;"><p>第二步：创建卷组<br>（1）使用vgcreate命令创建卷组mail_store（包括物卷：&#x2F;dec&#x2F;sdb1、&#x2F;dev&#x2F;sdc1）</p><img src="https://dl-harmonyos.51cto.com/images/202101/11476c03152237e8f1a533caa7b1aeaecaf618.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom: 67%;"><p>第三步：创建逻辑卷<br>（1）使用lvcreate命令创建逻辑卷mail， 从卷组mail_store上划出60GB空间<br>（2）使用mkfs命令创建ext4文件系统</p><img src="https://dl-harmonyos.51cto.com/images/202101/094608f00cd07bc6ae6632a3d6eec1b17f5b25.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom:67%;"><p>为逻辑卷扩容：<br>（1）使用lvextend命令为逻辑卷mail扩充容量， 从卷组mail_store上再划出10GB给逻辑卷mail<br>（2）使用resize2fs命令更新系统识别的文件系统大小</p><img src="https://dl-harmonyos.51cto.com/images/202101/838bfd311007d0d077f1443f83161fdc7833db.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom:67%;"><p>为逻辑卷缩减<br>（1）使用lvreduce命令为逻辑卷 mail缩减容量,必须先卸载， 从卷组 mail_store 上缩小逻辑卷mail到10G<br>（2）使用resize2fs命令更新系统识别的文件系统大小<br>（3）使用fsck 命令清理文件系统数据结构</p><img src="https://dl-harmonyos.51cto.com/images/202101/471b8156850e604a8f9098ea07c682d086fee4.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom:67%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>哈工大刘宏伟老师计算机组成原理</title>
    <link href="/2023/05/22/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%88%98%E5%AE%8F%E4%BC%9F%E8%80%81%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2023/05/22/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%88%98%E5%AE%8F%E4%BC%9F%E8%80%81%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="哈工大刘宏伟老师计算机组成原理"><a href="#哈工大刘宏伟老师计算机组成原理" class="headerlink" title="哈工大刘宏伟老师计算机组成原理"></a>哈工大刘宏伟老师计算机组成原理</h1><ul><li><a href="https://anmuxixixi.github.io/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/">计算机组成原理(一)计算机系统概论_</a></li><li><a href="https://anmuxixixi.github.io/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/">计算机组成原理(三)总线_</a></li><li><a href="https://anmuxixixi.github.io/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/">计算机组成原理(四)存储器</a></li><li><a href="https://anmuxixixi.github.io/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/">计算机组成原理(五)输入输出系统</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理(六)计算机的运算方法</title>
    <link href="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <url>/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-六-计算机的运算方法"><a href="#计算机组成原理-六-计算机的运算方法" class="headerlink" title="计算机组成原理(六)计算机的运算方法"></a>计算机组成原理(六)计算机的运算方法</h1><h2 id="1-无符号数和有符号数"><a href="#1-无符号数和有符号数" class="headerlink" title="1.无符号数和有符号数"></a>1.无符号数和有符号数</h2><p>在计算机中参与运算的数有两大类：<strong>无符号数、有符号数</strong></p><h3 id="1-1-无符号数"><a href="#1-1-无符号数" class="headerlink" title="1.1 无符号数"></a>1.1 无符号数</h3><p>计算机中的数均放在寄存器中,通常称寄存器的位数为机器字长。所谓无符号数,即没有符号的数,在寄存器中的每一位均可用来存放数值。当存放有符号数时,则需留出位置存放符号。因此,在机器字长相同时,无符号数与有符号数所对应的数值范围是不同的。以机器字长为16位为例,无符号数的表示范围为0 ~65535,而有符号数的表示范围为– 32768 ~ +32767。</p><h3 id="1-2-有符号数"><a href="#1-2-有符号数" class="headerlink" title="1.2 有符号数"></a>1.2 有符号数</h3><h4 id="1-2-1-机器数与真值"><a href="#1-2-1-机器数与真值" class="headerlink" title="1.2.1 机器数与真值"></a>1.2.1 机器数与真值</h4><p>对于有符号数而言，在计算机中用0-&gt;正，1-&gt;负，相当于符号被数字化了，并规定放在有效数字的前面，即组成了有符号数。</p><p>例如，<strong>有符号数的小数</strong>表示：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/20190814152551628.png" alt="在这里插入图片描述" style="zoom: 67%;"><p><strong>有符号数的整数</strong>表示：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/20190814152625574.png" alt="在这里插入图片描述" style="zoom:67%;"><p><strong>把符号数字化</strong>的数称为机器数，而把带”+”,”-“符号的数称为真值，一旦符号数字化后，符号的数值就形成了一种新的编码。</p><p><strong>在运算过程中，</strong><br>符号位能否和数值部分一起参加运算？<br>如果参加运算，符号位又需作哪些处理？<br>这些问题都与符号位和数值位所构成的编码有关，<strong>这些编码就是原码、反码、补码、移码。</strong></p><h4 id="1-2-2-原码"><a href="#1-2-2-原码" class="headerlink" title="1.2.2 原码"></a>1.2.2 原码</h4><p>原码表示法又称为<strong>带符号的绝对值表示</strong>，规定<strong>整数的符号位与数值之间用逗号隔开</strong>，<strong>小数的符号位与数值位之间用小数点隔开</strong>。</p><p>例如：<br>+0.1011 原码:0.1011<br>-0.1011 原码:1.1011<br>+1100 原码:0,1100<br>-1100 原码:1,1100</p><p><strong>整数原码的定义为：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA4Nzky,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom: 80%;"><p><strong>小数原码的定义为：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/20190814154044718.png" alt="在这里插入图片描述" style="zoom:80%;"><p><strong>举例说明：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/7d202230edd82e99eb5c7c0c0916473a.png" alt="image-20220508105918404" style="zoom:67%;"><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/23cdcb021ddac4aba19ef6bb50b35b20.png" alt="image-20220508110018469" style="zoom: 67%;"><p>原码表示简单明了,并易于和真值转换。但用原码进行加减运算时,却带来了许多麻烦。例如,当两个操作数符号不同且要作加法运算时,先要判断两数绝对值大小,然后将绝对值大的数减去绝对值小的数,结果的符号以绝对值大的数为准。运算步骤既复杂又费时,而且本来是加法运算却要用减法器实现。那么能否在计算机中只设加法器,只作加法操作呢?如果能找到一个与负数等价的正数来代替该负数,就可把减法操作用加法代替。而机器数采用补码时,就能满足此要求。</p><h4 id="1-2-3-补码"><a href="#1-2-3-补码" class="headerlink" title="1.2.3 补码"></a>1.2.3 补码</h4><p>在日常生活中，常会遇到“补数”的概念。例如，时钟指示6点，欲使它指示3点，既可按照顺时针方向将分钟转9圈，又可按照逆时针方向就分针转3圈，结果是一致。假设顺时针方向转为正，逆时针方向为负，则有</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/4b97c15569cc6ba39a00760b724a322e.png" alt="img" style="zoom: 50%;"><p>由于时钟的时针转一圈能指示12个小时,这“12”在时钟里是不被显示而自动丢失的,即15 -12&#x3D;3,故15点和3点均显示3点。这样-3和+9对时钟而言其作用是一致的。在数学上称12为模,写作mod 12,而称＋9是-3以12为模的补数,记作</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522225611392.png" alt="image-20230522225611392" style="zoom:67%;"><p>或者说，对模12而言，-3和+9是互为补数的。同理有：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522225718188.png" alt="image-20230522225718188" style="zoom: 67%;"><p>即对模12而言，+8和+7分为-4和-5的补数。可见，只要确定了“模”，就可找到一个与负数等价的正数（该正数即为负数的补数）来代替此负数，这样就可把减法运算用加法实现。例如：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA4Nzky,size_16,color_FFFFFF,t_70-1684767570485-15.png" alt="在这里插入图片描述" style="zoom:67%;"><ul><li>一个负数可用它的正补数来代替，而这个正补数可以用模加上负数本身求得</li><li>一个正数和一个负数互为补数时，它们绝对值之和即为模数</li><li>正数的补数即该补数本身。</li></ul><p>⭐<strong>补数的定义为：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/2800eed80de4eb89b325dd35c9a6991c.png" alt="img" style="zoom:40%;"><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/08a761ee8df15187290b436eac2f6fb6.png" alt="img" style="zoom: 40%;"><p>💟<strong>求补码的快捷方式</strong>【<strong>补码的模&#x3D;数值位数+1</strong>】</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522230946615.png" alt="image-20230522230946615" style="zoom:50%;"><blockquote><p>对于小数而言，就是符号位不变，后面的原码取反+1</p></blockquote><p>下面举几个例子：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522231029116.png" alt="image-20230522231029116" style="zoom: 48%;"><img src="https://img-blog.csdnimg.cn/img_convert/49174e17be37f264204c5e97f817887b.png" alt="img" style="zoom: 33%;"><h4 id="1-2-4-反码"><a href="#1-2-4-反码" class="headerlink" title="1.2.4 反码"></a>1.2.4 反码</h4><p><strong>正数的定义：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522234349056.png" alt="image-20230522234349056" style="zoom: 33%;"><p><strong>小数的定义：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522234404699.png" alt="image-20230522234404699" style="zoom:33%;"><p>举例：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/fb57719b0df2edf16e0b203e7e4db511.png" alt="img" style="zoom: 33%;"><blockquote><ul><li>对正数而言，反码是其本身</li><li>对负数而言，符号位不变，数值位每一位取反</li></ul></blockquote><p>实际上,反码也可看做是mod (2-2^(-n))(对于小数)或mod (2^(n+1)-1)(对于整数)的补码。<strong>与补码相比,仅在末位差1</strong>,因此有些书上称小数的补码为2的补码,而称小数的反码为1的补码。</p><h4 id="1-2-5-三种机器数的小结"><a href="#1-2-5-三种机器数的小结" class="headerlink" title="1.2.5 三种机器数的小结"></a>1.2.5 三种机器数的小结</h4><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522234915110.png" alt="image-20230522234915110" style="zoom:50%;"><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522234927867.png" alt="image-20230522234927867" style="zoom:50%;"><p><strong>下面这个规律要记住：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522234938601.png" alt="image-20230522234938601" style="zoom:50%;"><h4 id="1-2-6-移码"><a href="#1-2-6-移码" class="headerlink" title="1.2.6 移码"></a>1.2.6 移码</h4><p>补码通常你很难判断真值的带下，所以我们要把补码平移成都是从0开始，这样都就可以比较大小了。</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/e62a7bfd020380910a42d7f8faec3c2f.png" alt="image-20220510154451727" style="zoom: 67%;"><p>移码的定义如下：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/b4bf63a93c2fefa9f650653801862921-1684770839332-39.png" alt="image-20220510161827115" style="zoom:33%;"><p>其实移码就是在真值上加一个常数2^n。在数轴上移码所表示的范围恰好对应于真值在数轴上的范围向轴的正方向移动2^n个单元,如上图所示,由此而得移码之称。</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA4Nzky,size_16,color_FFFFFF,t_70-1684770798778-36.png" alt="在这里插入图片描述" style="zoom:80%;"><p>进一步观察发现,<strong>同一个真值的移码和补码仅差一个符号位</strong>,若将补码的符号位由“0”改为“1”,或从“1”改为“O”,即可得该真值的移码。下表列出了真值、补码和移码的对应关系。</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522235250588.png" alt="image-20230522235250588" style="zoom:50%;"><p><strong>移码的特点：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/861c855d1c3690b159db2e1136862ac7.png" alt="image-20220510164307143" style="zoom: 50%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理(五)输入输出系统</title>
    <link href="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-五-输入输出系统"><a href="#计算机组成原理-五-输入输出系统" class="headerlink" title="计算机组成原理(五)输入输出系统"></a>计算机组成原理(五)输入输出系统</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1-发展概况"><a href="#1-1-发展概况" class="headerlink" title="1.1 发展概况"></a>1.1 发展概况</h3><p><strong>（1）早期阶段</strong></p><p>早期的I&#x2F;O设备种类较少，I&#x2F;O设备与主存交换信息都必须通过CPU：、</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/57eed5f957a849f9ac5ab2be50107f64.png" alt="在这里插入图片描述" style="zoom:67%;"><ul><li>每个I&#x2F;O设备都必须配有一套独立的逻辑电路与CPU相连，<strong>线路十分散乱、庞杂</strong>。</li><li>输入输出过程是穿插在CPU执行程序过程之中进行的，<strong>工作效率低</strong>。</li><li>每个I&#x2F;0设备的逻辑控制电路与CPU的控制器紧密构成一个不可分割的整体，<strong>可扩展性低</strong>。</li></ul><p><strong>（2）接口模块和DMA阶段</strong></p><p>这个阶段I&#x2F;O设备通过接口模块与主机连接，计算机系统采用了总线结构：</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/b1988599f220489cb0da4cc73805a1ea.png" alt="在这里插入图片描述" style="zoom:67%;"><ul><li>数据经过接口既起到缓冲作用，又可完成串并变换。</li><li>接口能满足中断请求处理的要求，使I&#x2F;O设备与CPU可按并行方式工作，大大地提高了CPU的工作效率。</li><li>接口技术还可以使多台I&#x2F;O设备分时占用总线，使多台I&#x2F;O设备互相之间也可实现并行工作方式，有利于整机工作效率的提高。</li></ul><p>为了进一步提高CPU的工作效率，又出现了直接存储器存取(Direct Memory Access,DMA)技术：</p><ul><li>I&#x2F;O设备与主存之间有一条直接数据通路；</li><li>I&#x2F;O设备可以与主存直接交换信息，使CPU在I&#x2F;O设备与主存交换信息时能继续完成自身的工作，故资源利用率得到了进一步提高。</li></ul><p><strong>（3）具有通道结构的阶段</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/d3f62d3e4e79426c9eefbd41ee0955af.png" alt="在这里插入图片描述" style="zoom:67%;"><ul><li>通道是用来负责管理I&#x2F;O设备以及实现主存与I&#x2F;O设备之间交换信息的部件。</li><li>通道有专用的通道指令，能独立地执行用通道指令所编写的输入输出程序，是从属于CPU的一个专用处理器。</li><li>依赖通道管理的I&#x2F;O设备在与主机交换信息时，CPU不直接参与管理，故提高了CPU的资源利用率。</li></ul><p><strong>（4）具有I&#x2F;O处理机的阶段</strong></p><p>输入输出系统发展到第四阶段，出现了I&#x2F;O处理机：</p><ul><li>I&#x2F;O处理机又称为外围处理机(Peripheral Processor)；</li><li>它基本独立于主机工作，既可完成I&#x2F;O通道要完成的I&#x2F;O控制，又可完成码制变换、格式处理、数据块检错、纠错等操作。</li><li>具有I&#x2F;O处理机的输入输出系统与CPU工作的并行性更高，这说明I&#x2F;O系统对主机来说具有更大的独立性。</li></ul><h3 id="1-2-输入输出系统的组成"><a href="#1-2-输入输出系统的组成" class="headerlink" title="1.2 输入输出系统的组成"></a>1.2 输入输出系统的组成</h3><p>输入输出系统：</p><ul><li>I&#x2F;O软件</li><li>I&#x2F;O硬件</li></ul><p><strong>（1）I&#x2F;O 软件</strong></p><p>输入输出系统软件的主要任务如下：</p><ul><li>将用户编制的程序（或数据）输入主机内。</li><li>将运算结果输送给用户。</li><li>实现输入输出系统与主机工作的协调等。</li></ul><p>组成：</p><ul><li>I&#x2F;O指令：机器指令的一类，其设备码相当于设备的地址，用于选择某台设备与主机交换信息。</li><li>通道指令：又称为通道控制字(Channel Control Word,CCW)，是通道自身的指令，用来执行I&#x2F;O操作，如读、写、磁带走带及磁盘找道等。</li></ul><p><strong>（2）I&#x2F;O 硬件</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/cff0204f4b7149fab529243358674241.png" alt="在这里插入图片描述" style="zoom: 50%;"><p>输入输出系统的硬件组成是多种多样的，在带有接口的I&#x2F;O系统中，一般包括：</p><ul><li>接口模块</li><li>I&#x2F;O设备</li></ul><p>如上图所示：</p><ul><li>具有通道的I&#x2F;O系统；</li><li>一个通道可以和一个以上的设备控制器相连，一个设备控制器又可以控制若干台同一类型的设备。</li></ul><h3 id="1-3-I-x2F-O设备与主机的联系方式"><a href="#1-3-I-x2F-O设备与主机的联系方式" class="headerlink" title="1.3 I&#x2F;O设备与主机的联系方式"></a>1.3 I&#x2F;O设备与主机的联系方式</h3><p>I&#x2F;O 设备与主机交换信息时，共有5种控制方式：</p><ul><li>程序查询方式：程序查询方式是由CPU通过程序不断查询I&#x2F;O设备是否已做好准备，从而控制I&#x2F;O设备与主机交换信息。</li><li>程序中断方式：当I&#x2F;O设备准备就绪并向 CPU发出中断请求后才予以响应。</li><li>直接存储器存取方式(DMA)：主存与I&#x2F;O设备之间有一条数据通路，主存与I&#x2F;0设备交换信息时，无须调用中断服务程序。</li><li>I&#x2F;O 通道方式；</li><li>I&#x2F;O处理机方式。</li></ul><h2 id="2-I-x2F-O设备"><a href="#2-I-x2F-O设备" class="headerlink" title="2.I&#x2F;O设备"></a>2.I&#x2F;O设备</h2><h3 id="2-1-I-x2F-O设备概述"><a href="#2-1-I-x2F-O设备概述" class="headerlink" title="2.1 I&#x2F;O设备概述"></a>2.1 I&#x2F;O设备概述</h3><p>I&#x2F;O设备大致可分为三类：</p><ul><li>人机交互设备：·实现操作者与计算机之间互相交流信息的设备。</li><li>计算机信息的存储设备：系统软件和各种计算机的有用信息，其信息量极大，需存储保留起来。</li><li>机——机通信设备：实现一台计算机与其他计算机或与其他系统之间完成通信任务的设备。</li></ul><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/dcc5b2d6616f4681ae293a882871ea68.png" alt="在这里插入图片描述" style="zoom: 40%;"><p>下面是《深入理解计算机系统》中的“一个典型系统的硬件组成”</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20230520203459094-1684586104268-1.png" alt="image-20230520203459094" style="zoom:80%;"><p>每一个I&#x2F;O涉笔都是通过一个控制器或适配器与I&#x2F;O总线连接起来耳朵。控制器和适配器的区别在于他们的组成方式。控制器是I&#x2F;O设备本身中或是系统的主印刷电路（通常称为主板）上的芯片组，而适配器则是一块插在主板插槽上的卡。无论如何，他们的功能否是在I&#x2F;O总线和I&#x2F;O设备之间传递信息。</p><blockquote><p>以图形适配器为例，说的其实就是显卡。显卡全称显示接口卡，又称显示适配器。</p></blockquote><p>我们再看一下杨一涛老师在操作系统课程讲解的图片</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/1684586383766-3.png" alt="img" style="zoom: 67%;"><h3 id="2-2-输入设备"><a href="#2-2-输入设备" class="headerlink" title="2.2 输入设备"></a>2.2 输入设备</h3><p>输入设备完成输入程序、数据和操作命令等功能：</p><ul><li>键盘：通过键盘上的各个键，按某种规范向主机输入各种信息，如汉字、外文、数字等。</li><li>鼠标：手持式的定位设备，由于它拖着一根长线与接口相连，外形有点像老鼠，故取名为鼠标。</li><li>触摸屏：是一种对物体的接触或靠近能产生反应的定位设备。按原理的不同，触摸屏大致可分为5类：电阻式、电容式、表面超声波式、扫描红外线式和压感式。</li><li>其他输人设备：<ul><li>光笔：外形与钢笔相似，头部装有一个透镜系统，能把进入的光会聚成一个光点。光笔的后端用导线连到计算机输入电路上。</li><li>画笔与图形板：画笔(Stylus)同样为笔状，但必须配合图形板(Tablet)使用。</li><li>图像输入设备：最直接的图像输入设备是摄像机(Camera)，它能被拍摄物经数字量化后变成数字图像存入磁带或磁盘。</li></ul></li></ul><h3 id="2-3-输出设备"><a href="#2-3-输出设备" class="headerlink" title="2.3 输出设备"></a>2.3 输出设备</h3><h4 id="2-3-1-显示设备"><a href="#2-3-1-显示设备" class="headerlink" title="2.3.1 显示设备"></a>2.3.1 显示设备</h4><hr><ul><li>字符显示器：<ul><li>显示存储器（刷新存储器）VRAM：显示存储器存放欲显示字符的ASCII码，其容量与显示屏能显示的字符个数有关。</li><li>字符发生器：将每个ASCII字符码转变为一组5×7或7×9的光点矩阵信息。</li><li>CRT控制器：可接收来自CPU的数据和控制信号，并给出访问显示存储器的地址和访问字符发生器的光栅地址，还能给出CRT所需的水平同步和垂直同步信号。</li></ul></li><li>图形显示器：图形显示器是用点、线（直线和曲线）、面（平面和曲面）组合成平面或立体图形的显示设备；</li><li>图像显示器：图形显示器所显示的图形是由计算机用一定的算法形成的点、线、面、阴影等，来自主观世界，故又称为主观图像或计算机图像。</li><li>IBM PC系列微型计算机的显示标准：<ul><li>MDA(Monochrome Display Adapter)标准： MDA是单色字符显示标准，采用9×14点阵的字符窗口，满屏显示80列、25行字符，对应分辨率为720×350像素。MDA不能兼容图形显示。</li><li>CGA(Color Graphics Adapter)标准： CGA是彩色图形&#x2F;字符显示标准，可兼容字符和图形两种显示方式。在字符方式下，字符窗口为8×8点阵，故字符质量不如MDA,但字符的背景可以选择颜色。</li><li>EGA(Enhanced Graphics Adapter)标准： EGA标准集中了MDA和CGA两个显示标准的优点，并有所增强。其字符窗口为8×14点阵，字符显示质量优于CGA而接近MDA。</li><li>VGA(Video Graphics Array)标准： VGA标准在字符方式下，字符窗口为9×16点阵，在图形方式下分辨率为640×480像素、 16种颜色，或320×200像素、256种颜色，还有720×400像素的文本模式。</li></ul></li></ul><h4 id="2-3-2-打印设备"><a href="#2-3-2-打印设备" class="headerlink" title="2.3.2 打印设备"></a>2.3.2 打印设备</h4><hr><ul><li>点阵针式打印机：结构简单、体积小、重量轻、价格低、字符种类不受限制、较易实现汉字打印，还可打印图形和图像。</li><li>激光打印机：采用了激光技术和照相技术，印字质量好，应用广泛。</li><li>喷墨打印机：是串行非击打式打印机，印字原理是将墨水喷射到普通打印纸上。若采用红、绿、蓝三色喷墨头，便可实现彩色打印。</li></ul><h2 id="3-I-x2F-O接口"><a href="#3-I-x2F-O接口" class="headerlink" title="3.I&#x2F;O接口"></a>3.I&#x2F;O接口</h2><h3 id="3-1-I-x2F-O接口概述"><a href="#3-1-I-x2F-O接口概述" class="headerlink" title="3.1 I&#x2F;O接口概述"></a>3.1 I&#x2F;O接口概述</h3><p>接口可以看做是两个系统或两个部件之间的交接部分，它<strong>既可以是两种硬设备之间的连接电路，也可以是两个软件之间的共同逻辑边界。</strong></p><p>设置接口理由如下：</p><ul><li>一台机器通常配有多台I&#x2F;O设备，它们各自有设备号（地址），通过接口可实现I&#x2F;0设备的选择。</li><li>I&#x2F;O设备种类繁多，速度不一，与CPU速度相差可能很大，通过接口可实现数据缓冲.</li><li>有些I&#x2F;O设备可能串行传送数据，而CPU一般为并行传送，通过接口可实现数据串——并格式的转换。</li><li>I&#x2F;O设备的输人输出电平可能与CPU的输入输出电平不同，通过接口可实现电平转换。</li><li>CPU启动I&#x2F;O设备工作，要向I&#x2F;O设备发各种控制信号，通过接口可传送控制命令。</li><li>I&#x2F;O设备需将其工作状态及时向CPU报告，通过接口可监视设备的工作状态，并可保存状态信息，供CPU查询。</li></ul><h3 id="3-2-接口的功能和组成"><a href="#3-2-接口的功能和组成" class="headerlink" title="3.2 接口的功能和组成"></a>3.2 接口的功能和组成</h3><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/fa24e287e4d14e29bc4f22bfb527a47a.png" alt="在这里插入图片描述" style="zoom:60%;"><p>如上图所示为总线结构的计算机，每一台I&#x2F;O设备都是通过I&#x2F;O接口挂到系统总线上的。图中的I&#x2F;O总线包括数据线、设备选择线、命令线和状态线。</p><p>根据上述设置接口的理由，可归纳出接口通常应具有以下几个功能以及相应的硬件配置：</p><ul><li>选址功能：当设备选择线上的设备码与本设备码相符时，应发出设备选中信号SEL；</li><li>传送命令的功能：通常在I&#x2F;O接口中设有存放命令的命令寄存器以及命令译码器，来对CPU的命令进行响应。</li><li>传送数据的功能：接口中通常设有数据缓冲寄存器(Data Buffer Register,DBR)，它用来暂存I&#x2F;O设备与主机准备交换的信息，与I&#x2F;O总线中的数据线是相连的。</li><li>反映I&#x2F;0设备工作状态的功能：为了使CPU能及时了解各I&#x2F;O设备的工作状态，接口内必须设置一些反映设备工作状态的触发器。</li></ul><h3 id="3-3-接口类型"><a href="#3-3-接口类型" class="headerlink" title="3.3 接口类型"></a>3.3 接口类型</h3><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/4439606cc51d4233a82533a8a4638525.png" alt="在这里插入图片描述" style="zoom: 50%;"><ul><li>按数据传送方式分类：<ul><li>并行接口：将一个字节（或一个字）的所有位同时传送；</li><li>串行接口：在设备与接口间一位一位传送，由于接口与主机之间是按字节或字并行传送，因此对串行接口而言，其内部还必须设有串——并转换装置。</li></ul></li><li>按功能选择的灵活性分类：<ul><li>可编程接口：其功能及操作方式可用程序来改变或选择；</li><li>不可编程接口：不能由程序来改变其功能，但可通过硬连线逻辑来实现不同的功能。</li></ul></li><li>按通用性分类：<ul><li>通用接口：可供多种I&#x2F;O设备使用；</li><li>专用接口：为某类外设或某种用途专门设计的。</li></ul></li><li>按数据传送的控制方式分类：<ul><li>程序型接口：用于连接速度较慢的I&#x2F;O设备，如显示终端、键盘、打印机等；</li><li>DMA型接口：用于连接高速I&#x2F;0设备，如磁盘、磁带等。</li></ul></li></ul><h2 id="4-程序中断方式"><a href="#4-程序中断方式" class="headerlink" title="4.程序中断方式"></a>4.程序中断方式</h2><h3 id="4-1-I-x2F-O中断的概念"><a href="#4-1-I-x2F-O中断的概念" class="headerlink" title="4.1 I&#x2F;O中断的概念"></a>4.1 I&#x2F;O中断的概念</h3><p><strong>中断</strong>：计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回到现行程序的间断处，继续执行原程序。</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/134f67493baa806ed044c2370cbfdd3d.png" alt="img" style="zoom:67%;"><h3 id="4-2-I-x2F-O中断的产生"><a href="#4-2-I-x2F-O中断的产生" class="headerlink" title="4.2 I&#x2F;O中断的产生"></a>4.2 I&#x2F;O中断的产生</h3><p>在I&#x2F;O设备与主机交换信息时，由于设备本身机电特性的影响，其工作速度较低，与CPU无法匹配，因此，CPU启动设备后，往往需要等待一段时间才能实现主机与I&#x2F;O设备之间的信息交换。</p><p>如果在设备准备的同时，CPU不作无谓的等待，而继续执行现行程序，<strong>只有当I&#x2F;O设备准备就绪向CPU提出请求后，再暂时中断CPU现行程序转入I&#x2F;O服务程序，这便产生了I&#x2F;O中断。</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/8c07a6229bc94849683b1ef307305055.png" alt="img" style="zoom:75%;"><h3 id="4-3-程序中断方式的接口电路"><a href="#4-3-程序中断方式的接口电路" class="headerlink" title="4.3 程序中断方式的接口电路"></a>4.3 程序中断方式的接口电路</h3><p>本文关于电路部分不做研究，故省略</p><h2 id="5-DMA方式"><a href="#5-DMA方式" class="headerlink" title="5.DMA方式"></a>5.DMA方式</h2><h3 id="5-1-DMA科普"><a href="#5-1-DMA科普" class="headerlink" title="5.1 DMA科普"></a>5.1 DMA科普</h3><p>首先我们要明确一点，<strong>MDA接口就是第3节中所说的I&#x2F;O接口中的一种</strong>。</p><p>有一种特殊的IO接口-DMA接口，它可以用DMA总线与主存直接相连，只要CPU告诉DMA接口要把数据存在主存中的哪个地址DMA接口就会根据地址把数据放进主存。</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20230521114406266.png" alt="image-20230521114406266" style="zoom:67%;"><p>对于DMA接口而言，CPU还需要告诉它主存地址，如果有多个DMA接口，CPU依旧会很忙碌。为了进一步解放CPU，<strong>通道</strong>可以接替CPU做一些基础操作。</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20230521114538376.png" alt="image-20230521114538376" style="zoom:67%;"><p>它就像一个低级CPU，有自己的指令系统——<strong>通道指令</strong>，能够执行一些有限的操作。当它接收到CPU发出的IO指令后，可以按照要求启动IO设备，或者执行通道指令——就像CPU的小弟。</p><h3 id="5-2-DMA的特点"><a href="#5-2-DMA的特点" class="headerlink" title="5.2 DMA的特点"></a>5.2 DMA的特点</h3><img src="https://img-blog.csdnimg.cn/img_convert/fbff124410ee60a4d3b5fa33c1c8b7ed.png" alt="img" style="zoom: 75%;"><p>由图中可见，由于<strong>主存和DMA接口之间有一条数据通路</strong>，因此主存和设备交换信息时，不通过CPU，也不需要CPU暂停现行程序为设备服务，省去了保护现场和恢复现场，因此工作速度比程序中断方式的工作速度高。</p><p>在DMA方式中，由于DMA接口与CPU共享主存，这就有可能出现两者争用主存的冲突。为了有效地分时使用主存，通常DMA与主存交换数据时采用如下三种方法：</p><p><strong>（1）停止CPU访问主存</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/b50da7fe2155210fc105496e47127184.png" alt="img" style="zoom:67%;"><ul><li>方式：当外设要求传送一批数据时，由DMA接口向CPU发一个停止信号，要求CPU放弃地址线数据线和有关控制线的使用权。DMA接口获得总线控制权后，开始进行数据传送，在数据传送结束后，DMA接口通知CPU可以使用主存，并把总线控制权交回给CPU。</li><li>优点：控制简单，适用于数据传输率很高的I&#x2F;O设备实现成组数据的传送。</li><li>缺点：DMA接口在访问主存时，CPU基本上处于不工作状态或保持原状态。</li></ul><p><strong>（2）周期挪用（或周期窃取）</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/cf3ecee8377f2043ddbbde12a780665e.png" alt="img" style="zoom:67%;"><ul><li>方式：在这种方法中，每当I&#x2F;O设备发出DMA请求时，I&#x2F;O设备便挪用或窃取总线占用权一个或几个主存周期，而DMA不请求时，CPU仍继续访问主存。</li><li>优点：这种方式既实现了I&#x2F;O传送，又较好地发挥了主存与CPU的效率，是一种广泛采用的方法。</li><li>缺点：比较适合于I&#x2F;O设备的读&#x2F;写周期大于主存周期的情况，其他情况不推荐使用。</li></ul><p><strong>（3）DMA和CPU交替访问</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/90cdfcdc9f8fd6dd18da25ddd3c15f60.png" alt="img" style="zoom: 67%;"><ul><li>方式：不需要总线使用权的申请、建立和归还过程，总线使用权是通过C1和C2分别控制的。 CPU与DMA接口各自有独立的访存地址寄存器、数据寄存器和读&#x2F;写信号。</li><li>优点：CPU既不停止主程序的运行也不进入等待状态，即完成了 DMA的数据传送，效率较高。</li><li>缺点：相应的硬件逻辑复杂。</li></ul><h3 id="5-3-DMA接口的功能和组成"><a href="#5-3-DMA接口的功能和组成" class="headerlink" title="5.3 DMA接口的功能和组成"></a>5.3 DMA接口的功能和组成</h3><h4 id="5-3-1-DMA接口功能"><a href="#5-3-1-DMA接口功能" class="headerlink" title="5.3.1 DMA接口功能"></a>5.3.1 DMA接口功能</h4><p>利用DMA方式传送数据时，DMA接口应具有如下几个功能：</p><ul><li>向CPU申请DMA传送。</li><li>在CPU允许DMA工作时，处理总线控制权的转交，避免因进入DMA工作而影响CPU正常活动或引起总线竞争。</li><li>在DMA期间管理系统总线，控制数据传送。</li><li>确定数据传送的起始地址和数据长度，修正数据传送过程中的数据地址和数据长度。</li><li>在数据块传送结束时，给出DMA操作完成的信号。</li></ul><h4 id="5-3-2-DMA接口基本组成"><a href="#5-3-2-DMA接口基本组成" class="headerlink" title="5.3.2 DMA接口基本组成"></a>5.3.2 DMA接口基本组成</h4><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/daa49d98c2cb0b40b1e8ead9503f8cd0.png" alt="img" style="zoom:67%;"><ul><li>主存地址寄存器(AR) ：用于存放主存中需要交换数据的地址。</li><li>字计数器(WC) ：用于记录传送数据的总字数，通常以交换字数的补码值预置。</li><li>数据缓冲寄存器(BR) ：用于暂存每次传送的数据。</li><li>DMA控制逻辑： 负责管理DMA的传送过程，由控制电路、时序电路及命令状态控制寄存器等组成。</li><li>中断机构：当字计数器溢出（全“0”）时，表示一批数据交换完华，由“溢出信号”通过中断机构向CPU提出中断请求，请求CPU作DMA操作的后处理。</li><li>设备地址寄存器(DAR) ：存放I&#x2F;O设备的设备码或表示设备信息存储区的寻址信息，如磁盘数据所在的区号盘面号和柱面号。</li></ul><h3 id="5-4-DMA的工作过程"><a href="#5-4-DMA的工作过程" class="headerlink" title="5.4 DMA的工作过程"></a>5.4 DMA的工作过程</h3><p>DMA的数据传送过程分为三个阶段：</p><ul><li>预处理</li><li>数据传送</li><li>后处理</li></ul><h4 id="5-4-1-预处理"><a href="#5-4-1-预处理" class="headerlink" title="5.4.1 预处理"></a>5.4.1 预处理</h4><ul><li>给DMA控制逻辑指明数据传送方向是输入（写主存）还是输出（读主存）。</li><li>向DMA设备地址寄存器送入设备号，并启动设备。</li><li>向DMA主存地址寄存器送入交换数据的主存起始地址。</li><li>对字计数器赋予交换数据的个数。</li></ul><h4 id="5-4-2-数据传送"><a href="#5-4-2-数据传送" class="headerlink" title="5.4.2 数据传送"></a>5.4.2 数据传送</h4><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/a6000fe130974f4789bb1051dc38156c.png" alt="在这里插入图片描述" style="zoom: 50%;"><p><strong>以输入为例：</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20230521124247578.png" alt="image-20230521124247578" style="zoom: 25%;"><ol><li>IO设备将数据存储到数据存储寄存器BR</li><li>存入数据后，IO设备通过设备请求信号DREQ告诉DMA接口已经准备好了</li><li>DMA控制逻辑向CPU申请总线控制</li><li>CPU发出信号告诉DMA控制逻辑此时已经放弃了总线的占用和控制</li><li>此时进行数据传输，就要给出主存的地址。地址寄存器AR存放了要访问主存的地址，使得系统总线中的地址总线有效</li><li>DMA控制器给出设备应答信号，此时已经开始传输数据了</li><li>DMA控制器发出对内存的读写控制指令， 同时BR寄存器把数据通过传输线送到数据总线上</li><li>此过程AR+1，WC+1</li><li>….</li><li>当WC溢出，传输结束</li></ol><hr><p><strong>以输出为例：</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/7ae608e212abd526ea9e3611cdbf51bb.png" alt="img" style="zoom:67%;"><ol><li>把BR中数据送到设备中</li><li>设备发出DREQ告诉DMA控制器此时BR已经空了，可以接收下一个数据了</li><li>DMA向CPU发出对总线和内存的控制请求</li><li>CPU向DMA控制器发出应答信号【此时系统总线和内存的控制权都转移到了DMA接口】</li><li>AR通过地址线告诉内存访问地址</li><li>DMA控制器向设备发出DACK应答信号，告诉设备已经开始新的数据传输了</li><li>主存中的数据通过数据线再次写入到BR中</li><li>同时修改AR+1，WC+1</li><li>…【判断传输是否结束，如果没有结束，继续循环执行】</li><li>WC溢出，传输结束</li></ol><hr><h4 id="5-4-3-后处理"><a href="#5-4-3-后处理" class="headerlink" title="5.4.3 后处理"></a>5.4.3 后处理</h4><p>当DMA的中断请求得到响应后，CPU停止原程序的执行，转去执行中断服务程序，执行DMA的结束工作：</p><ul><li>校验送入主存的数据是否正确；</li><li>决定是否继续用DMA传送其他数据块，若继续传送，则又要对DMA接口进行初始化，若不需要传送，则停止外设；</li><li>测试在传送过程中是否发生错误，若出错，则转错误诊断及处理错误程序。</li></ul><h3 id="5-5-DMA接口类型"><a href="#5-5-DMA接口类型" class="headerlink" title="5.5 DMA接口类型"></a>5.5 DMA接口类型</h3><h4 id="5-5-1-选择型DMA接口"><a href="#5-5-1-选择型DMA接口" class="headerlink" title="5.5.1 选择型DMA接口"></a>5.5.1 选择型DMA接口</h4><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/102fc43b2c1c4a7b9709c59811da028e.png" alt="在这里插入图片描述" style="zoom: 50%;"><p><strong>特点</strong>：</p><ul><li>在物理上可连接多个设备，在逻辑上只允许连接一个设备，即在某一段时间内，DMA接口只能为一个设备服务；</li><li>关键是在预处理时将所选设备的设备号送入设备地址寄存器。</li></ul><h4 id="5-5-2-多路型DMA接口"><a href="#5-5-2-多路型DMA接口" class="headerlink" title="5.5.2 多路型DMA接口"></a>5.5.2 多路型DMA接口</h4><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/22f2e2f319714d9193b6c95807f6ab9d.png" alt="在这里插入图片描述" style="zoom: 50%;"><p><strong>特点</strong>：</p><ul><li>多路型DMA接口不仅在物理上可以连接多个设备，而且在逻辑上也允许多个设备同时工作，各个设备采用字节交叉的方式通过DMA接口进行数据传送。</li><li>这类接口特别适合于同时为多个数据传输率不十分高的设备服务。</li></ul><h3 id="5-6-DMA方式和程序中断方式比较"><a href="#5-6-DMA方式和程序中断方式比较" class="headerlink" title="5.6 DMA方式和程序中断方式比较"></a>5.6 DMA方式和程序中断方式比较</h3><table><thead><tr><th></th><th>中断方式</th><th>DMA方式</th></tr></thead><tbody><tr><td>数据传送</td><td>程序</td><td>硬件</td></tr><tr><td>响应时间</td><td>指令执行结束</td><td>存取周期结束</td></tr><tr><td>处理异常情况</td><td>能</td><td>不能</td></tr><tr><td>中断请求</td><td>传送数据</td><td>后处理</td></tr><tr><td>优先级</td><td>低</td><td>高</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机配置一本通</title>
    <link href="/2023/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%B8%80%E6%9C%AC%E9%80%9A/"/>
    <url>/2023/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%B8%80%E6%9C%AC%E9%80%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机配置一本通"><a href="#计算机配置一本通" class="headerlink" title="计算机配置一本通"></a>计算机配置一本通</h1><h2 id="1-CPU"><a href="#1-CPU" class="headerlink" title="1.CPU"></a>1.CPU</h2><ul><li><strong>Intel CPU后缀含义</strong></li></ul><img src="https://p9-pc-sign.douyinpic.com/tos-cn-i-0813c001/af34b36a37414833bf81b018a9e195ce~tplv-dy-aweme-images:q75.webp?biz_tag=aweme_images&from=3213915784&s=PackSourceEnum_AWEME_DETAIL&se=false&x-expires=1685278800&x-signature=kDK0s0slMixNx4xlTdNnYhwRjpk%3D" alt="img" style="zoom: 33%;"><h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2.内存"></a>2.内存</h2><ul><li>⭐<a href="https://www.bilibili.com/video/BV1vP411c7pt/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">探索主内存，以DDR5为例</a></li><li><a href="https://zhuanlan.zhihu.com/p/113187707">DDR4寻址原理</a></li><li><a href="https://www.bilibili.com/video/BV1Yg4y1E786/?spm_id_from=333.880.my_history.page.click&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">你的内存是马甲条吗？你知道马甲有什么作用吗？</a></li></ul><h2 id="3-主板"><a href="#3-主板" class="headerlink" title="3.主板"></a>3.主板</h2><ul><li><a href="https://www.douyin.com/user/self?modal_id=7085253674473180447&showTab=like">华硕主板怎么划分</a></li></ul><h2 id="4-硬盘"><a href="#4-硬盘" class="headerlink" title="4.硬盘"></a>4.硬盘</h2><ul><li><a href="https://www.douyin.com/video/7180506336273173792">机械硬盘的结构原理</a></li><li><a href="https://www.douyin.com/video/7180231042966506785">机械硬盘的工作原理</a></li><li><a href="https://www.douyin.com/video/7223806080290196792">机械硬盘是如何制造的</a></li><li><a href="https://www.douyin.com/user/self?modal_id=7163175761438919973&showTab=like">固态硬盘的工作原理</a></li><li>⭐<a href="https://www.bilibili.com/video/BV1Qv411t7ZL/?spm_id_from=333.999.0.0&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">硬盘的SATA M.2 NGFF NVME是什么意思，详解硬盘的总线协议与接口</a></li><li>【PCIe系列一】<a href="https://www.bilibili.com/video/BV1n4411m7HX/?spm_id_from=333.999.0.0&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">PCIe到底是个什么东西？他在电脑里是干什么的？</a></li><li>【PCIe系列二】<a href="https://www.bilibili.com/video/BV1cJ411K7HW/?spm_id_from=333.788&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">详解主板南桥芯片组的功能和作用</a></li></ul><h2 id="5-电源"><a href="#5-电源" class="headerlink" title="5.电源"></a>5.电源</h2><ul><li><a href="https://www.bilibili.com/video/BV1mD4y1D77y/?spm_id_from=333.999.0.0&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">什么是模组电源？他和普通电源有什么区别？模组电源定制线又是什么东西</a></li><li><a href="https://www.bilibili.com/video/BV1bT4y1E777/?spm_id_from=333.788&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">电源的金银铜牌指的是什么参数？金牌电源比铜牌好吗？详解电源80PLUS认证</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>硬盘的接口、协议、总线</title>
    <link href="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/"/>
    <url>/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="硬盘的接口、协议、总线"><a href="#硬盘的接口、协议、总线" class="headerlink" title="硬盘的接口、协议、总线"></a>硬盘的接口、协议、总线</h1><p>当我们购买固态硬盘的时候，常常会看到以下的内容：</p><img src="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/image-20230509225117077-1683643878529-1.png" alt="image-20230509225117077" style="zoom:67%;"><p>M.2固态硬盘 NVMe协议，PCIe4.0 ×4到底是什么？</p><img src="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/image-20230509225501897.png" alt="image-20230509225501897" style="zoom:80%;"><p>又或者自己在DIY电脑配置的时候硬盘会选择上述配置</p><h2 id="1-总线、协议、接口"><a href="#1-总线、协议、接口" class="headerlink" title="1.总线、协议、接口"></a>1.总线、协议、接口</h2><h3 id="1-1-总线"><a href="#1-1-总线" class="headerlink" title="1.1 总线"></a>1.1 总线</h3><p>总线是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束。总线是一种内部结构，它是CPU、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。</p><p>总线有一定的承载能力上限，我们把总线在单位时间内传输的数据量称为总线的带宽。常见的三种总线及其理论最大带宽如下表所示：</p><table><thead><tr><th>总线名称</th><th>应用场合</th><th>传输速率</th><th>说明</th></tr></thead><tbody><tr><td>SATA总线</td><td>民用</td><td>600MB&#x2F;s</td><td>目前SATA总线的版本为SATA3.0</td></tr><tr><td>PCIe总线</td><td>民用</td><td>见下表</td><td>目前PCIe总线的版本为PCIe3.0和PCIe4.0</td></tr><tr><td>SAS总线</td><td>服务器</td><td>1.2GB&#x2F;s</td><td>主要用于服务器硬盘，消费级市场不常见</td></tr></tbody></table><p>当前高端的M.2固态硬盘已经支持PCIe 5.0</p><img src="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/6b2e06dd569540b1ab30437a4581b00e.jpeg" alt="img" style="zoom:67%;"><h3 id="1-2-协议"><a href="#1-2-协议" class="headerlink" title="1.2 协议"></a>1.2 协议</h3><p>协议是物理设备之间进行通信时的“规则”，其内容主要包括设备间如何相互识别、如何建立链接、使用的讯号类型、数据的编码解码方式、数据传输的类型、数据传 输的方式以及物理层面上的电压、电流、保持时间和截止时间等。</p><p>只有当两个设备之间的协议相同或者相容时，才可以正常进行通讯。不同协议能够支持的最大传输速率也不同。</p><p>目前市场上硬盘所使用的的协议主要有四种，如下表所示：</p><table><thead><tr><th>协议名称</th><th>应用场合</th><th>说明</th></tr></thead><tbody><tr><td>IDE</td><td>民用</td><td>早期硬盘所使用的协议，目前基本见不到了</td></tr><tr><td>AHCI</td><td>民用</td><td>机械硬盘、SATA固态硬盘和极少数PCIe固态硬盘使用此协议</td></tr><tr><td>NVMe</td><td>民用</td><td>目前主流的PCIe固态硬盘使用此协议，也是消费级市场上最常见的</td></tr><tr><td>SCSI</td><td>服务器</td><td>常见于企业级固态硬盘，消费级市场不常见</td></tr></tbody></table><h3 id="1-3-接口"><a href="#1-3-接口" class="headerlink" title="1.3 接口"></a>1.3 接口</h3><p>相对于前面较难理解的总线与协议，接口顾名思义，就是硬盘与主板连接的物理接口。目前硬盘接口种类较多，在这里比较主要的三种分别为SATA接口、M.2接口和U.2接口，其他接口类型仅做了解即可。各种接口及其规格由下表给出：</p><table><thead><tr><th>物理接口</th><th>通信通道</th><th>传输数据协议</th><th>体积</th><th>描述</th></tr></thead><tbody><tr><td>SATA3</td><td>SATA</td><td>AHCI或者ATA</td><td>大</td><td>主流，速度6Gbps，不支持NVMe标准，体积也比较大，就是技术成熟，但是速度慢</td></tr><tr><td>mSATA（被淘汰）</td><td>SATA</td><td>AHCI或者ATA</td><td>小</td><td>就是为了SATA小型化，但是还是SATA通道，所以需要SATA主控<br>Tips：物理接口上和mini PCI-E接口一样</td></tr><tr><td>SATA - E (不咋地)</td><td>PCI-E x2</td><td>NVMe协议</td><td>大</td><td>为了解决上面mSATA的后继问题，就直接采用了PCI-E通道，但是用的很少</td></tr><tr><td>U.2</td><td>SATA + PCI-E x2, x4</td><td>NVMe协议</td><td>大</td><td>上面的SATA-E再升级，支持了NVMe协议，带宽也达到了32Gbps，但是由于现在很多主板上没有U.2接口，所以很多都是用的U.2转M.2的转接卡</td></tr><tr><td><strong>M.2</strong></td><td>SATA + PCI-E x2, x4</td><td>NVMe协议</td><td>小</td><td>取代mSATA，<strong>同时兼容SATA和PCI-E通道</strong>，非常的主流，现在全面转向PCIe 3.0 x4 通道，理论带宽达到了32Gbps</td></tr><tr><td>PCI-E</td><td>PCI-E x2, x4</td><td>NVMe协议</td><td>大</td><td>跟显卡类似，规格大小也有多种，目前直接走PCI-E接口的硬盘还不是很多，属于高端</td></tr></tbody></table><h2 id="2-M-2接口真实的样子"><a href="#2-M-2接口真实的样子" class="headerlink" title="2.M.2接口真实的样子"></a>2.M.2接口真实的样子</h2><p>现在的主板上一般M.2固态都散热片，需要我们拆开散热片</p><img src="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/image-20230509232115580.png" alt="image-20230509232115580" style="zoom: 33%;"><p>拆开散热片后，就可以看到真实的M.2接口了</p><img src="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/image-20230509232202877.png" alt="image-20230509232202877" style="zoom:50%;"><p>将M.2固态的金手指对准M.2接口，插入后即可：</p><img src="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/image-20230509232344100.png" alt="image-20230509232344100" style="zoom: 50%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理(四)存储器</title>
    <link href="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-四-存储器"><a href="#计算机组成原理-四-存储器" class="headerlink" title="计算机组成原理(四)存储器"></a>计算机组成原理(四)存储器</h1><blockquote><p>声明：本文大部分内容转载自<strong>不断前进的皮卡丘</strong>，感谢辛苦整理的成果</p><p>原文地址：<a href="https://blog.csdn.net/qq_52797170/article/details/124472835">https://blog.csdn.net/qq_52797170/article/details/124472835</a></p></blockquote><p>[TOC]</p><h3 id="1-1-存储器分类"><a href="#1-1-存储器分类" class="headerlink" title="1.1 存储器分类"></a>1.1 存储器分类</h3><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/3b068c358f4340b580f7f0727c2e0804.png" alt="在这里插入图片描述" style="zoom:67%;"><h4 id="1-1-1-按存储介质分类"><a href="#1-1-1-按存储介质分类" class="headerlink" title="1.1.1 按存储介质分类"></a>1.1.1 按存储介质分类</h4><ul><li>半导体存储器 TTL、MOS 易失</li><li>磁表面存储器 磁头、载磁体 非易失</li><li>磁芯存储器 硬磁材料、环状元件 非易失</li><li>光盘存储器 激光、磁光材料 非易失</li></ul><h4 id="1-1-2-按读取方式分类"><a href="#1-1-2-按读取方式分类" class="headerlink" title="1.1.2 按读取方式分类"></a>1.1.2 按读取方式分类</h4><p>①存取时间和存取单元位置无关(随机访问)</p><ul><li>随机存储器(RAM)<ul><li>存储器中任何存储单元的内容都能被随机存取，和存取时间和存储单元的物理位置无关，这种存储器叫做随机存储器</li><li>随机存储器在程序的执行过程中可读可写</li></ul></li><li>只读存储器(ROM)<ul><li>在程序的执行过程中只读</li></ul></li></ul><p>②存取时间和存取单元位置有关(串行访问)</p><ul><li>顺序存取存储器 磁带<ul><li>存储器只能按照某种顺序来存取，那么这种存储器就是顺序存取存储器，它的存取周期较长</li></ul></li><li>直接存取存储器 磁盘<ul><li>沿着磁道方向顺序存取，垂直半径方向随机存取</li></ul></li></ul><p>③按照在计算机中的作用分类<br><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/878f6fcb0db84f4890a7e594f3cb6786.png" alt="在这里插入图片描述" style="zoom: 50%;"></p><h3 id="1-2-存储器的层次结构"><a href="#1-2-存储器的层次结构" class="headerlink" title="1.2 存储器的层次结构"></a>1.2 存储器的层次结构</h3><h4 id="1-2-1-存储器的三个主要特性的关系"><a href="#1-2-1-存储器的三个主要特性的关系" class="headerlink" title="1.2.1 存储器的三个主要特性的关系"></a>1.2.1 存储器的三个主要特性的关系</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/340ca3c5d3554a91b7e48c5998e9cbe6.png" alt="在这里插入图片描述" style="zoom: 80%;"><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/332deb6cf51f4ad39270d8e96a1c18c3.png" alt="在这里插入图片描述" style="zoom:50%;"><h4 id="1-2-2-缓存-主存层次和主存-辅存层次"><a href="#1-2-2-缓存-主存层次和主存-辅存层次" class="headerlink" title="1.2.2 缓存-主存层次和主存-辅存层次"></a>1.2.2 缓存-主存层次和主存-辅存层次</h4><p>计算机的主机由CPU和主存储器构成<br>CPU可以从主存中读取信息，也可以把信息存到主存中，但是主存的容量是有限的，如果程序足够大的话，主存是存不下的，需要辅助存储器帮忙存储，不过程序的运行还是得通过主存</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/04816fd2fb45456baf26a7dafd1430dd.png" alt="在这里插入图片描述" style="zoom:50%;"><h2 id="2-主存储器"><a href="#2-主存储器" class="headerlink" title="2.主存储器"></a>2.主存储器</h2><h3 id="2-1-主存储器概述"><a href="#2-1-主存储器概述" class="headerlink" title="2.1 主存储器概述"></a>2.1 主存储器概述</h3><h4 id="2-1-1-主存的基本组成"><a href="#2-1-1-主存的基本组成" class="headerlink" title="2.1.1 主存的基本组成"></a>2.1.1 主存的基本组成</h4><p>从前面的只是来看，存储器的基本组成如下所示：</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230505235435737.png" alt="image-20230505235435737" style="zoom: 67%;"><ul><li>基本上主存由三部分组成 存储体 地址寄存器 数据寄存器</li><li>寄存器也是存储器 用来存放数据</li><li>一个读取操作就像是从菜鸟驿站拿快递一样，我需要提供取件码给店员（数据地址），然后从货架（存储体）中找到快递，放在柜台（数据寄存器中）我来取走</li><li>一个写入操作则和取快递稍微不同，我们需要先给地址寄存器一个地址，然后把数据给数据寄存器，这样主存就会帮我们把数据写入存储体。</li></ul><p>这一章节我们将详细介绍主存储器的结构：</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230506000027708.png" alt="image-20230506000027708" style="zoom: 40%;"><p>主存由存储体(程序，指令，数据都是存储在存储体中)，MAR，MDR构成。</p><p>MAR当中保存了我们要访问的那个存储单元的地址，必须要进行译码器译码以后，我们才可以选定指定的存储单元；MDR中保存了我们读出或者写入的数据，这个数据是读出还是写入需要通过读写电路和控制电路来控制</p><ul><li>如果是写入的话，则把数据从MDR送入指定的存储体的存储单元中</li><li>如果是读出的话，那么存储单元的内容就会被送到MDR中</li></ul><p>方向的控制是由读写电路来控制的。</p><h4 id="2-1-2-主存与CPU之间的关系"><a href="#2-1-2-主存与CPU之间的关系" class="headerlink" title="2.1.2 主存与CPU之间的关系"></a>2.1.2 主存与CPU之间的关系</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230506000218365.png" alt="image-20230506000218365" style="zoom: 40%;"><p>数据总线完成CPU和主存的信息传输<br>地址总线给出要访问的内存单元的地址</p><h4 id="2-1-3-主存中存储单元地址的分配"><a href="#2-1-3-主存中存储单元地址的分配" class="headerlink" title="2.1.3 主存中存储单元地址的分配"></a>2.1.3 主存中存储单元地址的分配</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/88abe0b5048349bdb560acdf4a42ff48.png" alt="在这里插入图片描述" style="zoom:80%;"><p>假设存储字长为32位(对存储器的某一个单元进行读或写的话，一次最多读或写32位0，1)，主存的编址单位是字节，每一个字节都有自己的地址。在这种情况下，一个存储字是32位，一个字节是八位，都有自己的地址。<br>那么12345678H这个数据怎么在主存储器中进行存储？</p><ul><li>一种方法是高位字节地址作为存储器的地址(字地址)，这种方式也叫大端方式</li><li>第二种方法是低位字节作为字地址，这种方式叫做小端方式</li></ul><h4 id="2-1-4-主存的技术指标"><a href="#2-1-4-主存的技术指标" class="headerlink" title="2.1.4 主存的技术指标"></a>2.1.4 主存的技术指标</h4><p>①存储容量：主存存放二进制代码的总位数<br>②存储速度</p><ul><li>存取时间(从存储器给出地址到获得稳定的输入输出) 存储器的访问时间<ul><li>读出时间 写入时间</li></ul></li><li>存取周期<ul><li>连续两次独立的存储器操作(读或写)所需的最小间隔时间</li><li>存取周期一般大于存取时间</li></ul></li></ul><p>③存储器带宽</p><ul><li>单位时间内存储器存取的信息量，用字&#x2F;秒、字节&#x2F;秒或位&#x2F;秒表示</li><li>衡量数据传输速率的重要指标，决定了以存储器为中心的计算机系统获得信息的速度，是改善机器性能瓶颈的一个关键因素</li></ul><h3 id="2-2-半导体存储芯片简介"><a href="#2-2-半导体存储芯片简介" class="headerlink" title="2.2 半导体存储芯片简介"></a>2.2 半导体存储芯片简介</h3><h4 id="2-2-1-半导体存储芯片的基本结构"><a href="#2-2-1-半导体存储芯片的基本结构" class="headerlink" title="2.2.1 半导体存储芯片的基本结构"></a>2.2.1 半导体存储芯片的基本结构</h4><ul><li>采用超大规模集成电路制造工艺，在一个芯片内集成具有记忆功能的存储矩阵、译码驱动电路和读&#x2F;写电路等</li><li>译码驱动：把地址总线送过来的地址信号翻译成对应存储单元的选择信号</li><li>读写电路：包括读写放大器和写入电路，用于完成读写操作</li></ul><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230507213936324.png" alt="image-20230507213936324" style="zoom:67%;"><p>存储芯片通过地址总线、数据总线和控制总线与外部连接</p><ul><li>地址线：单向输入，其位数与芯片容量有关</li><li>数据线：双向输入&#x2F;输出，其位数与芯片可一次读出或写入的数据有关</li></ul><blockquote><p>地址线和数据线的位宽，共同反应了存储芯片的容量。例如：地址线10根，数据线4根，则表示存储芯片的存储单元为2^10，每个单元的数据宽度为4位，则芯片的容量为2^10 * 4b &#x3D; 4Kb</p></blockquote><ul><li>控制线：主要有读写控制线和片选线2种：<ul><li>读写控制线：决定芯片进行读还是写，可以读写分开2根线，也可以合用一根</li><li>片选线：用来在存储矩阵中选择存储芯片，可能有多根线</li></ul></li></ul><h4 id="2-2-2-存储芯片片选线的作用"><a href="#2-2-2-存储芯片片选线的作用" class="headerlink" title="2.2.2 存储芯片片选线的作用"></a>2.2.2 存储芯片片选线的作用</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230507214503803.png" alt="image-20230507214503803" style="zoom:67%;"><p>半导体存储芯片它的片选线一般有2中标识方式，<br>$$<br>\overline{\text{CS}}、\overline{\text{CE}}<br>$$<br>上面的一横表示低电平有效，CS是芯片选择的缩写。</p><blockquote><p><strong>16K × 1位</strong>说明芯片的存储容量是16K，每一个存储单元保存1位信息。<br>如果我们用8个这样的芯片，对8个芯片同时进行读写，这8个芯片构成一组，这8个芯片就构成了16K × 8位的存储器<br>为了满足题目的需求，我们就应该布置4组这样的芯片。<br>每一组的8个芯片要同时进行工作<br>接下来对地址空间进行划分<br>第一组芯片: 0到16K-1<br>第二组芯片:16K到32K-1<br>第三组芯片:32K到48K-1<br>第四组芯片:48K到64K-1<br>如果我们要访问的地址是65535，也就是64K-1，按照我们划分的规则，它应该在第四组芯片，此8片的片选有效。片选信号看到这个地址后，就选择第四组芯片，其他三组芯片的片选信号是无效的，也就是高电平，最后一组对应的信号是低电平，也就是有效的。<br>片选信号的作用是让某个芯片或者某些芯片同时进行工作。</p></blockquote><h4 id="2-2-3-半导体存储芯片的译码驱动方式"><a href="#2-2-3-半导体存储芯片的译码驱动方式" class="headerlink" title="2.2.3 半导体存储芯片的译码驱动方式"></a>2.2.3 半导体存储芯片的译码驱动方式</h4><p>译码驱动方式就是说，给出存储单元的地址后，怎么找到指定的存储单元，可以有两种方式来找到指定的存储单元，</p><p><strong>（1）线选法</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/a2e5a6340fda4db982f1d4179089a578.png" alt="在这里插入图片描述" style="zoom:50%;"><p>给出A0到A3四位地址，说明有16个存储单元，每一个存储单元有多少位，就需要看数据线，数据线是从D0到D7，说明有8位，这个存储器是16×8</p><p>接下来看看工作过程：</p><p>如果给出的地址是全0，被译码后的信号只有0的这根线是有效的，其他的线是无效的。如果现在进行的是读操作，读信号会控制电路的通路打开，使数据可以从存储矩阵送到数据总线上，只有给定的单元才可以数据的输出</p><blockquote><p>这种方法对容量稍微大一点的芯片来说是不合适的</p></blockquote><p><strong>（2）重合法</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/db1d4fe8d41843e19a4d0ca6b8b53a79.png" alt="在这里插入图片描述" style="zoom:50%;"><p>线性法进行布局的时候，实际上是把它布局成线性数组，重合法进行布局的时候，实际上是把它布局成二维阵列</p><blockquote><p>行地址和列地址都只能有一条线是有效的，DDR4和DDR5的原理都是基于这个</p></blockquote><h3 id="2-3-随机存取存储器（RAM）"><a href="#2-3-随机存取存储器（RAM）" class="headerlink" title="2.3 随机存取存储器（RAM）"></a>2.3 随机存取存储器（RAM）</h3><p>RAM分为静态RAM(SRAM)和动态RAM(DRAM)：</p><ul><li>动态RAM是利用电容存储电荷的方式存储数据的；</li><li>静态RAM是利用触发器的稳态特性来存储数据的；</li></ul><hr><p>RAM 有点像“内存”，实际上涵盖了几种不同的类型。大多数人在讨论 RAM 或内存时，他们实际上谈论的内容在技术上是 DRAM（动态随机存取内存），或者更准确地说对于现代系统 <strong>SDRAM</strong>（同步动态随机存取内存）更为准确。除了技术性之外，术语并不重要，但知道这些术语通俗地说可以相互交换是有用的。</p><p>目前销售的最常见的 RAM 类型是 DDR4，尽管较旧的系统可能使用 DDR2 或 DDR3。这些简单地表示在特定系统中使用的 RAM 的生成，每个连续的系统通过更大的带宽提供更快的速度 – 更高的兆赫（MHz）等级。每代人都看到身体的变化，所以不能互换。</p><p>另一个常见术语，特别是在视频游戏领域是 VRAM 或视频 RAM。虽然 VRAM 本身就是一种技术，但它现在用于（技术上错误地）表示可用于图形芯片或内置于图形卡的内存。这实际上称为图形 DDR SDRAM，或更常见的 GDDR。大多数现代显卡都会使用 GDDR5，尽管有些使用更新的 GDDR5X 标准，而未来的几代甚至可能会搭配 GDDR6 内存。</p><p>一些小众图形卡采用称为高带宽内存（HBM 和 HBM2）的独特形式的内存 ，虽然它通常很昂贵，但供应问题意味着它没有被广泛采用，它具有一些独特的性能优势。</p><h3 id="2-4-只读存储器（ROM）"><a href="#2-4-只读存储器（ROM）" class="headerlink" title="2.4 只读存储器（ROM）"></a>2.4 只读存储器（ROM）</h3><p>ROM的发展历程：</p><ul><li>早期的只读存储器—–在厂家就写好了内容</li><li>改进1——–用户可以自己写，不过是一次性的，如果要修改程序就得重新买芯片，原有的芯片的数据不能够擦除</li><li>改进2——可以多次写——并且可以对信息进行擦除(早期的时候，那些可以擦除信息的芯片的设备要单独购买，不是很方便)</li><li>改进3——电可擦写—–需要特定设备</li><li>改进4——电可擦写——直接连接到计算机上</li></ul><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/bcf1404027e6445eb5a94b473f236bab.png" alt="在这里插入图片描述" style="zoom:100%;"><h4 id="2-4-1-掩膜ROM（MROM）——只可读"><a href="#2-4-1-掩膜ROM（MROM）——只可读" class="headerlink" title="2.4.1 掩膜ROM（MROM）——只可读"></a>2.4.1 掩膜ROM（MROM）——只可读</h4><p>这种ROM是由制造厂家利用一种掩膜技术写入程序的，掩膜ROM制成后，用户不能修改，根据制造工艺可以将它们分为MOS型和双极型两种。MOS型ROM功耗小、速度慢，适用于一般微机系统；而双极型则速度快、功耗大，适用于速度较高的计算机系统。</p><h4 id="2-4-2-PROM-一次性编程"><a href="#2-4-2-PROM-一次性编程" class="headerlink" title="2.4.2 PROM (一次性编程)"></a>2.4.2 PROM (一次性编程)</h4><p>可编程只读存储器 （英语：Programmable read-only memory），缩写为 PROM 或 FPROM，是一种电脑存储记忆晶片，它允许使用称为PROM编程器的硬件将数据写入设备中。在PROM被编程后，它就只能专用那些数据，并且不能被再编程，这种记忆体用作永久存放程式之用。通常会用于电子游戏机、或电子词典这类可翻译语言的产品之上。</p><p>采用破坏性编程，且只能编程一次，如果编程有错误，只能重新购买芯片。</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom:33%;"><h4 id="2-4-3-EPROM-多次性编程"><a href="#2-4-3-EPROM-多次性编程" class="headerlink" title="2.4.3 EPROM (多次性编程 )"></a>2.4.3 EPROM (多次性编程 )</h4><p>EPROM采用N型沟道浮动栅MOS电路，需要保存0，D端加正电压，形成浮动栅，需要保存1，D端不加正电压，不形成浮动栅。</p><p>编程完成后，EPROM只能用强紫外线照射来擦除。通过封装顶部能看见硅片的透明窗口，很容易识别EPROM，这个窗口同时用来进行紫外线擦除。可以将EPROM的玻璃窗对准阳光直射一段时间就可以擦除。</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70-1683468907249-13.png" alt="img" style="zoom: 33%;"><h4 id="2-4-4-EEPROM-多次性编程"><a href="#2-4-4-EEPROM-多次性编程" class="headerlink" title="2.4.4 EEPROM (多次性编程 )"></a>2.4.4 EEPROM (多次性编程 )</h4><p>EEPROM (Electrically Erasable Programmable read only memory)是指带电可擦可编程只读存储器。是一种掉电后数据不丢失的存储芯片。 EEPROM 可以在电脑上或专用设备上擦除已有信息，重新编程。一般用在即插即用。</p><p>常用在接口卡中，用来存放硬件设置数据。</p><p>也常用在防止软件非法拷贝的”硬件锁”上面。</p><p>EEPROM的特点：</p><ul><li>电可擦写</li><li>局部擦写</li><li>全部擦写</li></ul><h4 id="2-4-5-Flash-Memory-闪速型存储器"><a href="#2-4-5-Flash-Memory-闪速型存储器" class="headerlink" title="2.4.5 Flash Memory (闪速型存储器)"></a>2.4.5 Flash Memory (闪速型存储器)</h4><p>快闪存储器（英语：flash memory），是一种电子式可清除程序化只读存储器的形式，允许在操作中被多次擦或写的存储器。这种科技主要用于一般性数据存储，以及在计算机与其他数字产品间交换传输数据，如储存卡与U盘。</p><p>闪存是一种非易失性存储器，即断电数据也不会丢失。因为闪存不像RAM（随机存取存储器）一样以字节为单位改写数据，因此不能取代RAM。</p><p>闪存卡（Flash Card）是利用闪存（Flash Memory）技术达到存储电子信息的存储器，一般应用在数码相机，掌上电脑，MP3等小型数码产品中作为存储介质，所以样子小巧，有如一张卡片，所以称之为闪存卡。</p><h3 id="2-5-存储器与CPU的连接"><a href="#2-5-存储器与CPU的连接" class="headerlink" title="2.5 存储器与CPU的连接"></a>2.5 存储器与CPU的连接</h3><p>CPU执行的指令需要的数据都保存在主存储器中，运行的结果也保存在主存储器中，所以CPU和存储器要进行正确的连接，才能实现他们之间信息的交换</p><p>一般来说，CPU的地址线比较多，寻址范围也比较大。要构成主存储器，需要多个存储芯片共同组成。</p><h4 id="2-5-1-存储器容量的扩展"><a href="#2-5-1-存储器容量的扩展" class="headerlink" title="2.5.1 存储器容量的扩展"></a>2.5.1 存储器容量的扩展</h4><p>单片存储芯片的容量有限，需要将若干存储芯片连在一起组成具有足够容量的存储器，所需芯片数量的计算公式：</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/e17c0a8d820143eb953d6bf14339cffc.png" alt="在这里插入图片描述" style="zoom:50%;"><p>位扩展：增加存储器的横向容量<br>字扩展：增加存储器的纵向容量</p><p><strong>（1）位扩展(为了增加存储字长)</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230507230536721.png" alt="image-20230507230536721" style="zoom: 50%;"><p>用2片1K×4位的存储芯片组成1K×8位的存储器</p><p>两个芯片要能同时工作，也就是要把两个芯片的片选用相同信号连接</p><blockquote><p>地址线和控制线公用<br>数据线单独分开</p></blockquote><p><strong>（2）字扩展(增加存储字的数量)</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230507230753703.png" alt="image-20230507230753703" style="zoom:50%;"><blockquote><p>地址线和数据线公用<br>读写控制线公用<br>片选使能控制线独立，通过地址的高位字段进行译码决定</p></blockquote><p>对第一个芯片来说，它用的地址线是A0~A9，如果A10为0，我们就选择第一个芯片，A10如果为1.我们就选择第二个芯片，A10就是我们的片选信号</p><p>从00000000000 ~ 01111111111，这1K的存储空间分配给第一个芯片</p><p>从10000000000 ~ 11111111111 ，这1K的存储空间分配给第二个芯片</p><p><strong>（3）字、位扩展</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/fdfd8ac372a8451dade364a7eba263c9.png" alt="在这里插入图片描述" style="zoom: 67%;"><p>通过A10,A11来判断我们要访问的芯片是哪一组<br>00选择第一组芯片<br>01选择第二组芯片<br>10选择第三组芯片<br>11选择第四组芯片</p><h4 id="2-5-2-存储器与CPU的连接"><a href="#2-5-2-存储器与CPU的连接" class="headerlink" title="2.5.2 存储器与CPU的连接"></a>2.5.2 存储器与CPU的连接</h4><ul><li>存储芯片与CPU芯片相连，主要注意片与片之间的三种信号线的连接</li><li>地址线的连接<ul><li>CPU的地址线一般比存储芯片的地址线多</li><li>CPU地址线的低位线与存储芯片的地址线相连</li><li>CPU地址线的高位线或用于存储扩展，或用于片选等其他用途</li></ul></li><li>数据线的连接<ul><li>存储芯片的数据线应与CPU的数据线数量相同，若存储芯片数据线不够，需对其进行位扩展</li></ul></li><li>读写命令控制线的连接<ul><li>CPU的读写命令线一般可以直接连到存储芯片的读写控制器，通常高电平为读，低电平为写</li><li>若读写命令线分开，则分别连到对应的芯片控制端</li></ul></li><li>片选线的连接<ul><li>CPU与存储芯片正确工作的关键</li><li>片选有效信号与CPU的访存控制信号MREQ（低电平有效）有关，海域地址线（一般为高位线）有关</li><li>通常需要用到一些逻辑电路来产生片选信号，如译码器和门电路</li></ul></li><li>合理选择存储芯片<ul><li>存储芯片类型（RAM或ROM）和数量的选择</li><li>ROM：通常用于存放系统程序、标准函数库或各类常数等</li><li>RAM：用于用户程序使用，为用户编程而设置</li><li>考虑芯片数量时，应尽量使连线简单方便</li></ul></li><li>其他考虑，如时序配合、速度、负载等</li></ul><p>【<strong>例题1</strong>】</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/680eeb03576f492486b0aeddd407ada5.png" alt="在这里插入图片描述" style="zoom:90%;"><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/c4112880392d4101a60d444103db1470.png" alt="在这里插入图片描述" style="zoom:90%;"><p>①写出对应的二进制地址码【CPU低地址线对应存储器地址线】</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230508232722251.png" alt="image-20230508232722251" style="zoom: 50%;"><p>我们可以看成出A15到A11是固定的，A10到A0是连续的地址，从全0到全1，一共是2K×8位，这部分存放系统程序。</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230508232750023.png" alt="image-20230508232750023" style="zoom:50%;"><p>们可以看成出A15到A10是固定的，A9到A0是连续的地址，从全0到全1，一共是1K×8位，这部分存放用户程序，1K×8位我们可以用两个1K×4位的芯片。</p><p>②芯片的选择</p><ul><li>对应系统程序区，我们应该选择ROM,用1片2K×8</li><li>用户程序区要可读可写，选择RAM，用2片1K×4</li></ul><p>③分配地址线</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/1f00a8fe5b1b4e0db3a7d48a82f165f5.png" alt="在这里插入图片描述" style="zoom: 67%;"><p>④确定片选信号</p><p>根据74138译码逻辑关系，必须保证控制端G1为高电平，G2A和G2B为低电平，译码器才能正常工作</p><p>A15始终为低、A14始终为高，分别接G2A和G1；而MREQ低电平有效，接G2B<br>剩下A13、A12、A11，分别接译码器的输入端C、B、A译码结果为4（Y4有效），选中ROM；译码结果为5（Y5有效），与A10一起通过与门，都为低电平有效时，选中2片RAM。<br><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230508232909198.png" alt="image-20230508232909198" style="zoom: 67%;"></p><p>【<strong>例题2</strong>】</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/2ad6f7d4165b44b1b875a976a9977ca0.png" alt="在这里插入图片描述" style="zoom:67%;"><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/c8552a74c7cd4bedbb02d9d1e24f7400.png" alt="在这里插入图片描述" style="zoom: 67%;"><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/4d9d942d74874f0199486b4e71a2dad7.png" alt="在这里插入图片描述" style="zoom:67%;"><h3 id="2-6-存储器的校验"><a href="#2-6-存储器的校验" class="headerlink" title="2.6 存储器的校验"></a>2.6 存储器的校验</h3><p>编码的检测能力和纠错能力与任意两组合法代码之间二进制位的最少差异数有关</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/87a0b27134564de98358e5fa09ff5030.png" alt="在这里插入图片描述" style="zoom:80%;"><p>如果出错后的代码依然是合法代码，计算机压根检测不出出错的代码</p><blockquote><p>编码的最小距离就是指任意的两组合法代码之间二进制位数的最少差异</p><p>编码的纠错，校错能力和编码的最小距离有关</p></blockquote><h3 id="2-7-提高访存速度的措施"><a href="#2-7-提高访存速度的措施" class="headerlink" title="2.7 提高访存速度的措施"></a>2.7 提高访存速度的措施</h3><ul><li>采用高速器件，让内存速度更快</li><li>采用层次结构Cache-主存，把常用信息放在Cache中，Cache由静态RAM做的，速度快，集成度高，功耗低</li><li>调整主存结构</li><li>高性能存储芯片</li></ul><h4 id="2-7-1-调整主存结构"><a href="#2-7-1-调整主存结构" class="headerlink" title="2.7.1 调整主存结构"></a>2.7.1 调整主存结构</h4><p><strong>（1）单体多字系统</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/698fd0d23bc14441a2c0f2a3eb30bb8c.png" alt="在这里插入图片描述" style="zoom:67%;"><blockquote><p>关于存储字长，机器字长：<a href="https://blog.csdn.net/weixin_45609535/article/details/124323238">https://blog.csdn.net/weixin_45609535/article/details/124323238</a></p><ul><li>存储字长：一个存储单元中二进制代码的位数（通常和MDR位数相同）</li><li>机器字长：CPU进行一次整数运算所能处理的二进制数据的位数</li></ul><p>一般来说，单独说字或字长时，往往指的是 机器字，其字长即为计算机一次能直接处理的二进制数据的位数，这个主要取决于CPU内部数据总线的位宽，也就是说一次能传输多少数据到CPU中进行处理。比如8086的CPU内部数据总线的宽度为16位，即说明8086是16位机，所以其字长为16。同理，32位机其机器字长为32，64位机其机器字长为64.</p></blockquote><p>假设CPU是16位，存储器的存储字长是64位，CPU每一次访问存储器，都可以访问出4个机器字，这4个机器字，每一个都可以是一条机器指令，又或者是长度为16的数据。</p><p>CPU一次把这四个值取出放在数据寄存器中，下一次在用的时候，就可以直接把需要使用的指令或数据取走，用这种方法可以增加存储器的带宽。</p><p>但是这种方法也有问题，假设现在CPU要向存储器中某一共个存储单元写一共长度为16的字，它要先把字写到单字长寄存器中，然后再写入到4个字长的数据寄存器中，之后再写到存储器中。这样产生的问题就是，我们可能只需要写一个16位，但是其他的48位也会写到给定的存储单元中，这就会造成给定的存储字有48位被修改了，这个修改可能是错误的修改.</p><p>第二个问题，如果我们要取出的数据或指令不是连续的存放在相邻的指令中的，那么我们取出的指令可能就只有一条是有用的，其他的指令并没有用<br>出现这些问题的原因：虽然每一个存储单元包括四个机器字，但是这四个机器字存取的时候是以整体的方式进行存取的</p><p>为了解决这个问题，我们可以采用多体并行的方式</p><p><strong>（2）多体并行系统</strong> </p><ul><li>高位交叉 顺序编址</li></ul><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/3c693c78095844c6a4103cbada1d6208.png" alt="在这里插入图片描述" style="zoom:67%;"><p>高位交叉会造成一个问题，传进来的地址一直是连续的， 那么同一个存储体会很繁忙，其余的存储体会很闲。</p><ul><li>低位交叉 各个体轮流编址</li></ul><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/83d98363c63b4d0fb49bf0cb3832384f.png" alt="在这里插入图片描述" style="zoom:67%;"><p>低位交叉的特点：在不改变存取周期的前提下，增加存储器的带宽</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/d90eac5675564a52ba022f172125991e.png" alt="在这里插入图片描述" style="zoom: 50%;"><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/be5b2e83b30d4c498ed95023a22cfb4e.png" alt="在这里插入图片描述" style="zoom:67%;"><h4 id="2-7-2-高性能存储芯片"><a href="#2-7-2-高性能存储芯片" class="headerlink" title="2.7.2 高性能存储芯片"></a>2.7.2 高性能存储芯片</h4><p>（1）SDRAM（同步DRAM)</p><blockquote><p>在系统时钟的控制下进行读出和写入<br>CPU无需等待</p></blockquote><p>（2）RDRAM</p><blockquote><p>主要解决存储器带宽问题</p></blockquote><p>（3）带Cache的DRAM</p><blockquote><p>在DRAM的芯片内集成了一个由SRAM组成的Cache,有利于猝发式读取</p></blockquote><h2 id="3-高速缓冲存储器"><a href="#3-高速缓冲存储器" class="headerlink" title="3.高速缓冲存储器"></a>3.高速缓冲存储器</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><h4 id="3-1-1-使用的原因"><a href="#3-1-1-使用的原因" class="headerlink" title="3.1.1 使用的原因"></a>3.1.1 使用的原因</h4><p>Cache是为了避免CPU空等现象。</p><p>CPU空等现象：IO设备与cpu都需要访问内存，IO设备优先级较高，速度较慢，因此cpu需要等待IO访问内存从而出现空等现象。将热点数据缓存在Cache中可以有效避免cpu空等现象，直接从缓存中访问数据.</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/v2-56946c0f3d889d93bcf280f418abc75c_720w.webp" alt="img" style="zoom:67%;"><blockquote><p>CPU的频率也基本实现了每18个月翻一番，但是内存的速度一直都没怎么提高。下图曲线描述了20世纪后20年CPU速度和内存速度之间的“剪刀差”。</p></blockquote><h4 id="3-1-2-Cache的工作原理"><a href="#3-1-2-Cache的工作原理" class="headerlink" title="3.1.2 Cache的工作原理"></a>3.1.2 Cache的工作原理</h4><p><strong>(1)主存和缓存的编址</strong><br>我们把主存和Cache分成大小相等的块，主存有M块，Cache有C块。主存的容量远大于Cache的容量，即M&gt;&gt;C</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/a90bc042b0a24a77af0e8e842e189871.png" alt="在这里插入图片描述" style="zoom:80%;"><p>如果我们把主存和Cache分成若干块，那么CPU给出的内存地址就可以分成两个部分，一部分是块内偏移地址，它的位数决定块的大小，比如说一个块包含16个字节，并且内存的编址单位是字节，那么块内地址部分就是4位，剩余部分就是主存块号。<br>一个块在内存和Cache之间传送的时候，是整体进行传送，块内字节顺序不会发生变化。</p><p>所以，<strong>内存的块内地址部分和Cache的块内地址部分的值是完全相同的</strong>。</p><p>Cache中的标记，标记了主存块和Cache块之间的关系。如果一个主存块调入Cache块中，我们就可以把主存块号写到标记当中。将来CPU给出一个内存地址，它希望在Cache中访问到这个数据，它要首先确认这个块是否已经送到了Cache中，它就需要拿给出地址的主存块号和Cache中的标记进行比较。如果和某一个标记刚好相等，并且这个Cache块是有效的，这个块里面就保存了在内存中要访问的信息，它就可以直接从Cache中获取这些信息，它的速度就会大大提高</p><p>主存和缓存是按照块来存储的，<strong>块的大小相同</strong></p><p><strong>（2）命中和未命中</strong></p><p>缓存有C块，主存有M块，M&gt;&gt;C，主存中只能有部分块被缓存到了Cache中。</p><p>在CPU访问主存时，如果要访问的主存块已经调入缓存中，它的缓存能取到相应的数据，就说<strong>命中</strong><br>命中，就说明主存块和缓存块建立了对应关系，可以用标记记录与某缓存块建立了对应关系的主存块号</p><p>如果要访问的主存块没有调入缓存，那么就说未命中</p><p><strong>（3）Cache命中率</strong></p><p>命中率： 就是在Cache中访问到CPU要访问的字块的概率。设Nc表示访问Cache的总命中次数，Nm未访问主存的总次数，即未命中次数。命中率h&#x3D;Nc&#x2F;(Nc+Nm)<br>命中率与Cache的容量和块长有关。</p><p>一般每块可以取4~8个字<br>块长取一个存取周期内从主存调出的信息长度<br>Cache-主存系统的效率<br>效率e和命中率有关</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/b4e11ed8f331496d8c5dc3a04dcb1f4c.png" alt="在这里插入图片描述" style="zoom:67%;"><h4 id="3-1-3-Cache的基本结构"><a href="#3-1-3-Cache的基本结构" class="headerlink" title="3.1.3 Cache的基本结构"></a>3.1.3 Cache的基本结构</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/ffaf706f08dc479e9e20a0e117842888.png" alt="在这里插入图片描述" style="zoom:80%;"><p>CPU要访问内存的话，它要给出地址，包括块号和块内地址，由于Cache和主存之间是以块为基本单位传输数据的，所以主存的块内地址可以直接送到Cache的块内地址,或者形成Cache的块内地址</p><p>我们利用块号在Cache的地址映射变换机构中，去确认是否发生命中。如果发生命中的话，需要给出当前的内存块保存在哪一个Cache块中。如果没有命中，就需要查一下，Cache中是否还有空间可以存入主存块，如果有的话，就访问主存，把主存块装到Cache块中；如果没有空间的话，那么主存块装入的那些Cache块都是满的，我们就要启用Cache替换机构，由Cache的替换机构根据替换算法，来算出哪一些块要从Cache中退出，写回到主存，或者直接作废，并且把主存中要用的块写入到Cache块中，这就是Cache替换机构要做的</p><p><strong>地址映射:</strong></p><blockquote><p>主存中的一个块如果要放到Cache中，它可以被放到Cache的哪一个块或哪一些块中。</p></blockquote><p><strong>变换:</strong></p><blockquote><p>把主存的块号转变成相应的Cache块号，或者把主存的地址转变成相应的Cache的地址，然后在Cache中找到相应的主存块进行访问</p><p>在主存和Cache之间是有一条直接通路的，通过这条通路，可以完成主存和Cache之间的信息交换</p></blockquote><p>我们的信息<strong>以块为基本单位</strong>保存在Cache存储体中</p><h4 id="3-1-4-Cache的读写操作"><a href="#3-1-4-Cache的读写操作" class="headerlink" title="3.1.4 Cache的读写操作"></a>3.1.4 Cache的读写操作</h4><p><strong>（1）读操作</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/81fed2d01dfb457cbadd8f86bcff86cd.png" alt="在这里插入图片描述" style="zoom:67%;"><p>读操作是由CPU发出的，CPU发出这个访问地址，由Cache的地址映射和变换来确认是否发生命中。如果命中，就直接从Cache取出信息。若未命中，则需先判断，Cache是否已满，即是否可以直接将主存中对应的块装入Cache，若是，则访问主存，通过数据总线先将指令和数据传送给CPU，再通过直接通路，将指令和数据传送给Cache缓存。如果Cache已满，则需要通过Cache替换机构来访问主存并替换Cache中的某一个块。<br><strong>（2）写操作</strong></p><p>读操作是不会对内存中信息进行修改的，但是写操作可能造成<strong>主存和Cache中的信息不一致</strong>。</p><p>写操作需要解决Cache和主存的一致性问题，可以采用写直达法和写回法</p><ul><li>写直达法<ul><li>写操作时数据既写入Cache,又写入主存</li><li>写操作时间就是访问主存的时间,Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现</li></ul></li><li>写回法<ul><li>写操作时只把数据写入Cache而不写入主存</li><li>当Cache数据被替换出去时才写回主存</li></ul></li></ul><h4 id="3-1-5-Cache的改进"><a href="#3-1-5-Cache的改进" class="headerlink" title="3.1.5 Cache的改进"></a>3.1.5 Cache的改进</h4><ul><li>增加Cache的级数：离CPU比较近的在CPU内部集成L1缓，L2缓存，在主板上集成L3缓存</li><li>统一缓存和分立缓存：指令Cache和数据Cache分开</li></ul><h3 id="3-2-Cache-主存之间的地址映射"><a href="#3-2-Cache-主存之间的地址映射" class="headerlink" title="3.2 Cache-主存之间的地址映射"></a>3.2 Cache-主存之间的地址映射</h3><h4 id="3-2-1-什么是内存块"><a href="#3-2-1-什么是内存块" class="headerlink" title="3.2.1 什么是内存块"></a>3.2.1 什么是内存块</h4><p><strong>字</strong>：指存放在一个存储单元中的二进制代码组合</p><p><strong>字块：</strong>存储在连续的存储单元中而被看成一个单元的一组字</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514203908166.png" alt="image-20230514203908166" style="zoom: 33%;"><p>字的地址包含2个部分，前m位为指定字块的地址，后b位指定字在字块中的地址</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514204043280.png" alt="image-20230514204043280" style="zoom: 50%;">$$2^m = M，2^b = B$$<img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514204208280.png" alt="image-20230514204208280" style="zoom: 50%;"><p><strong>机器字长：</strong>CPU进行一次整数运算所能处理的二进制数据的位数。字长是由CPU的类型所决定，不同的计算机系统的字长是不同的，常见的有8位、16位、32位、64位等，字长越长，计算机一次处理的信息位就越多，精度就越高，</p><p><strong>存储字长：</strong>一个存储单元中二进制代码的位数（通常和MDR位数相同）</p><h4 id="3-2-2-直接映射"><a href="#3-2-2-直接映射" class="headerlink" title="3.2.2 直接映射"></a>3.2.2 直接映射</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514210212152.png" alt="image-20230514210212152" style="zoom: 50%;"><p>以<strong>字块</strong>为单位将内存和缓存分割为数组，内存向缓存形成多对一的直接映射关系，内存中的一个字块能够映射到缓存中的索引是确定的。如对于只有8个字块的缓存，21 号内存块内容在缓存块中的话，它一定在 5 号缓存块（21 mod 8 &#x3D; 5）中。</p><p>但是这种映射又重新带来一种问题，图中5,13,21,29都能映射到缓存5上，我们怎么确定我要21的时候拿到的不是其他呢？</p><p>通常我们会把缓存块的数量设置成 2 的 N 次方，那么内存的字块数量也一定是缓存的二次方倍，如8 个缓存字块，就是 2 的 3 次方，32个内存字块就是 2 的 5 次方，我们在通过内存地址的获取缓存数据时候，只需要拿到段地址的低三位，就能确定缓存索引，再根据字块中的偏移量就能拿到唯一对应的字节，道理就是这么个道理。</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514210350969.png" alt="image-20230514210350969" style="zoom:50%;"><p>那这个字是不是我们想要的，就需要引入另一个概念”组标记”</p><p>这个组标记会记录，当前缓存块内存储的数据对应的内存块，而缓存块本身的地址表示访问地址的低 N 位。就像上面的例子，21 的低 3 位 101，缓存块本身的地址已经涵盖了对应的信息、对应的组标记，我们只需要记录 21 剩余的高 2 位的信息，也就是 10 就可以了。</p><p>除了组标记信息之外，缓存块中还有两个数据。一个自然是从主内存中加载来的实际存放的数据，另一个是有效位用于存放缓存块中的数据是否有效的。如果有效位是 0，无论其中的组标记和 实际的数据内容是什么，CPU 都不会管这些数据，而要直接访问内存，重新加载数据。</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514210507419.png" alt="image-20230514210507419" style="zoom:50%;"><p><strong>重点来了，</strong>整体进行举例，比如一个64位的CPU，内存地址线宽度为40位，也就是说一个内存地址可以有40位，假设一个字块有64B，即64字节，内存大小为8G，缓存大小为8M。</p><p>由于内存大小为8G，即2的33次方字节，则最少需要33位地址可确定唯一字节。其中64B为一个字块，想要确定唯一字节需要6位地址，即2的6次方，所以偏移量需要6位；缓存大小是8M,即2的23次方字节，但是又因为一个字块是64B,所以缓存行数是2的23次方除以2的6次方，所以需要17位来确定唯一字块，即索引位数为17；缓存8M和内存8G相差2的10次方倍，所以组标记需要10位，高位补0。</p><p><strong>所以一个内存地址的访问，就会经历这样 4 个步骤：</strong></p><p><strong>1.根据内存地址中段地址(字块地址为段地址)的低位，计算在 缓存中的索引；</strong></p><p><strong>2.判断有效位，确认缓存中的数据是有效的；</strong></p><p><strong>3.对比内存访问地址的高位，和缓存中的组标记，确认缓存中的数据就是我们要访问的内存数据</strong></p><p><strong>4.根据内存地址的 偏移量，从字块中读取希望读取到的字节。</strong></p><p>如果在 2、3 这两个步骤中，CPU 发现，缓存中的数据并不是要访问的内存地址的数据，那 CPU 就会访问内存，并把对应的 内存中的数据字块更新到对应的缓存中，同时更新对应的有效位和组标记的数据。</p><h4 id="3-2-3-全相联映射"><a href="#3-2-3-全相联映射" class="headerlink" title="3.2.3 全相联映射"></a>3.2.3 全相联映射</h4><p>全相连映射方式比较灵活，主存的各块可以映射到缓存的任一块中，缓存的利用率高，字块冲突概率低，只要淘汰缓存中的某一块，即可调入主存的任一块。但是，由于缓存比较电路的设计和实现比较困难，这种方式只适合于小容量缓存采用。</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514211224104.png" alt="image-20230514211224104" style="zoom:50%;"><h4 id="3-2-4-组相联映射"><a href="#3-2-4-组相联映射" class="headerlink" title="3.2.4 组相联映射"></a>3.2.4 组相联映射</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/edc32409f52f4bb08f24ae66a214b1f4.png" alt="在这里插入图片描述" style="zoom: 67%;"><p>主存储器中的字块也进行分区，每个区的大小和Cache中的组数相同，Cache被分成几组，主存储器的每一个区就包含多少块</p><blockquote><p>例如主存中的字块0，可以存放到缓存中第0组的其他空余位置</p><p>例如字块2^(c-r)可以存放到缓存中第2^(c-r)-1组的其余空余位置</p></blockquote><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/9d7cf85354b64dd3bc0816759c0fb788.png" alt="在这里插入图片描述" style="zoom:67%;"><h3 id="3-3-置换算法"><a href="#3-3-置换算法" class="headerlink" title="3.3 置换算法"></a>3.3 置换算法</h3><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/2a1fc2de6ff347d5bdb50ab4a7603b13.png" alt="在这里插入图片描述">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理(三)总线</title>
    <link href="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/"/>
    <url>/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-三-总线"><a href="#计算机组成原理-三-总线" class="headerlink" title="计算机组成原理(三)总线"></a>计算机组成原理(三)总线</h1><h2 id="1-总线的基本概念"><a href="#1-总线的基本概念" class="headerlink" title="1.总线的基本概念"></a>1.总线的基本概念</h2><p>首先我们提出一个问题：那就是，我们为什么要使用总线？原因很简单，就是我们的计算机中有许多的设备，如果使用分散连接，也就是每两个设备之间互相连接，那样会造成大量的线路连接，而且还不利于添加删减设备。举个不恰当的例子，把我们的房子想成一个设备，公路想成线路，如果每家每户都一一连接，房子少的时候还好，但是一旦房子一多起来，就很麻烦了。所以我们设计出来了总线这样的方式，他就相当于一条靠近大家的大马路，每家每户通过这条马路去通信就好了，这样既简单，又便捷。</p><p>接下来我们来介绍一下有关总线的介绍：总线是连接多个部件的信息传输线，是各部件共享的传输介质，<u><strong>每一次只允许两个设备之间进行通信</strong></u>。而且在总线中，信息传递方式分为串行和并行两种，接下来我们会对其进行详细介绍。接下来我们来看一看一些总线结构。</p><p><strong>单总线</strong></p><p>顾名思义，就是只有一根总线。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/613fe30e19094fe4841a2557469a2846.png" alt="在这里插入图片描述" style="zoom: 67%;"><p><strong>双总线</strong></p><p>双总线呢，我们暂时展示两种，第一种是面向CPU，另外一种就是以寄存器为中心。我们一起来看看吧！</p><ul><li><strong>面向CPU</strong></li></ul><p>这种面向CPU的方式呢，虽然使得CPU与主存之间通信更快，但是还是有一个问题，就是设备与主存之间访问需要通过CPU，速度较慢，于是我们设计出来了以存储器为中心的结构。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/6354160da5894ff6acf183ababc24c79.png" alt="在这里插入图片描述" style="zoom: 67%;"><ul><li><strong>以存储器为中心</strong></li></ul><p>存储器为中心的结构是在单总线基础上又开辟出的一条 CPU 与主存之间的总线，称为存储总线。这组总线速度高，只供主存与 CPU 之间传输信息。这样既提高了传输效率，又减轻了系统总线的负担，还保留了 I&#x2F;0 设备与存储器交换信息时不经过 CPU 的特点</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/51fe1d5096414559a5b004cc6fb8ae7b.png" alt="在这里插入图片描述" style="zoom: 67%;"><h2 id="2-总线的分类"><a href="#2-总线的分类" class="headerlink" title="2.总线的分类"></a>2.总线的分类</h2><p>接下来我们来具体看一看总线的分类，当然了，根据不同的分类原则，也就能分成不同的种类，接下来我们是按照连接部件来进行分类的。</p><p><strong>片内总线</strong></p><p>这个比较好理解，片内总线是指芯片内部的总线，如在 CPU 芯片内部，寄存器与寄存器之间、寄存器与算逻单远 ALU 之间都由片内总线连接。</p><p><strong>系统总线</strong></p><p>系统总线是指 CPU 、主存、 I&#x2F;O 设备（通过 I&#x2F;O接口）各大部件之间的信息传输线。由于这些部件通常都安放在主板或各个插件板上，故又称板级总线或板间总线。按系统总线传输信息的不同，又可分为三类：数据总线、地址总线和控制总线。接下来我们来一一进行介绍。</p><p><strong>（1）数据总线</strong></p><p>顾名思义，数据总线就是用来传输数据的，并且它是双向传输总线，其位数与机器字长、存储字长有关。数据总线的位数称为数据总线宽度，它是衡量系统性能的一个重要参数。</p><p><strong>（2）地址总线</strong></p><p>地址总线主要用来指出数据总线上的源数据或目的数据在主存单元的地址或 I&#x2F;O 设备的地址。</p><p><strong>（3）控制总线</strong></p><p>由于数据总线、地址总线都是被挂在总线上的所有部件共享的，如何使各部件能在不同时刻占有总线使用权，需依靠控制总线来完成，因此控制总线是用来发出各种控制信号的传输线。通常对任一控制线而言，它的传输是单向的。而且控制信号既有输出，又有输入。常见的控制信号如：总线请求，中断请求等等。</p><p><strong>通信总线</strong></p><p>这类总线用于<strong>计算机系统之间</strong>或计算机系统与其他系统之间的通信。主要分为串行通信和并行通信。串行通信是指数据在单条位宽的传输线上，一位一位地按顺序分时传送。并行通信是指数据在多条并行位宽的传输线上，同时由源传送到目的地，适宜近距离的传输。</p><h2 id="3-总线特性及性能指标"><a href="#3-总线特性及性能指标" class="headerlink" title="3.总线特性及性能指标"></a>3.总线特性及性能指标</h2><p>接下来我们来介绍一下总线特性、性能指标和总线标准。</p><h3 id="3-1-总线特性"><a href="#3-1-总线特性" class="headerlink" title="3.1 总线特性"></a>3.1 总线特性</h3><p>我们现在将介绍一下关于总线的一些特性，首先我们来看一下总线的物理结构。</p><p>图中 CPU 、主存、 I&#x2F;O 这些插板（又称插卡）通过插头与水平方向总线插槽连接。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/773c1c371d2d4b739b9eb3114b54c52e.png" alt="在这里插入图片描述" style="zoom:80%;"><p><strong>机械特性</strong></p><blockquote><p>机械特性是指总线在机械连接方式上的一些性能，如插头与插座使用的标准，它们的<strong>几何尺寸</strong>、<strong>形状</strong>、<strong>管脚数</strong>以及<strong>排列的顺序</strong>，接头处的可靠接触等。</p></blockquote><p><strong>电气特性</strong></p><blockquote><p>电气特性主要是指总线的每一根传输线上信号的<strong>传递方向</strong>和<strong>有效的电平范围</strong>。</p></blockquote><p><strong>功能特性</strong></p><blockquote><p>功能特性是指总线中每根传输线的功能，主要包含<strong>数据、地址和控制总线</strong>等等。</p></blockquote><p><strong>时间特性</strong></p><blockquote><p>主要涉及的就是信号的时序关系，也可以说总线中的任一根线在什么时间内有效。</p></blockquote><p><strong>性能指标</strong></p><blockquote><p>性能指标的话，其实就是衡量总线能力的一个判断标准，具体我们就来看看吧！</p><ol><li>总线宽度：通常是指数据总线的根数。</li><li>总线带宽：总线带宽可理解为总线的数据传输速率，即单位时间内总线上传输数据的位数，通常用每秒传输信息的字节数来衡量，单位可用 MBps （兆字节每秒）表示。</li><li>时钟同步／异步：总线上的数据与时钟同步工作的总线称为同步总线，与时钟不同步工作 的总线称为异步总线。</li><li>总线复用：一条信号线上分时传送两种信号。</li><li>信号线数：地址总线、数据总线和控制总线三种总线数的总和。</li><li>总线控制方式：包括突发工作、自动配置、仲裁方式、逻辑方式、计数方式等。</li><li>其他指标：如负载能力、电源电压（是采用 5V 还是 3.3 V) 、总线宽度能否扩展等。</li></ol></blockquote><h3 id="3-2-总线标准"><a href="#3-2-总线标准" class="headerlink" title="3.2 总线标准"></a>3.2 总线标准</h3><p>总线标准的话，有许许多多标准，如：ISA 总线、 EISA 总线、 VESA总线、 PCI 总线、 AGP 总线、RS-232C 总线和USB 总线等等，我们呢，就不一一介绍，书上都有。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/image-20230503200015897.png" alt="image-20230503200015897" style="zoom:80%;"><h2 id="4-总线结构"><a href="#4-总线结构" class="headerlink" title="4.总线结构"></a>4.总线结构</h2><p><strong>单总线</strong></p><p>单总线是将 CPU 、主存、 I&#x2F;O 设备都挂在一组总线上，允许 I&#x2F;O 设备之间、 I&#x2F;O 设备与 CPU 之间或 I&#x2F;O 设备与主存之间直接交换信息。之前简单介绍过一下，在此就不再赘述了。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/613fe30e19094fe4841a2557469a2846.png" alt="在这里插入图片描述" style="zoom: 67%;"><p><strong>多总线</strong></p><p>对于多总线结构，主要包括双总线、三总线、四总线结构等等，我们来一一介绍吧！</p><ul><li><strong>双总线</strong></li></ul><p>双总线结构的特点是将速度较低的 I&#x2F;0 设备从单总线上分离出来，形成主存总线与 I&#x2F;0 线分开的结构。有点类似于面向CPU的双总线模式，但不是。通道可以说是具有特殊功能的处理器，由通道对I&#x2F;O统一管理。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/0202a9c954724fed9f996289f5a03aa3.png" alt="在这里插入图片描述" style="zoom: 67%;"><ul><li><strong>三总线</strong></li></ul><p>如果将速率不同的 I&#x2F;0 设备进行分类，然后将它们连接在不同的通道上，那么计算机系统的 工作效率将会更高，由此发展成多总线结构。接下来我们来介绍两种三总线模式。</p><p>这种就是将高速I&#x2F;O设备通过DMA挂接到主存上面，这样设备可以快速从主存里面获得数据。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/b4d4877086664979bd1a14f498780269.png" alt="在这里插入图片描述" style="zoom: 67%;"><p>另外一种结构就是通过一个Cache去保存CPU所需的数据。也可以达到高速存储的作用。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/e0ce68ecbb7f4051904205511ce2fb0c.png" alt="在这里插入图片描述" style="zoom: 67%;"><ul><li><strong>四总线</strong></li></ul><p>为了进一步提高 I&#x2F;0 设备的性能，使其更快地响应命令，又出现了四总线结构，这种结构对高速设备而言，其自身的工作可以很少依赖 CPU ，同时它们又比扩展总线上的设备更贴近 CPU ，可见对于高性能设备与 CPU 来说，各自的效率将获得更大的提高。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/8f75c6b3c9224a7abaf0609f512f52a3.png" alt="在这里插入图片描述" style="zoom:67%;"><h2 id="5-总线控制"><a href="#5-总线控制" class="headerlink" title="5.总线控制"></a>5.总线控制</h2><p>接下来我们介绍的就是关于总线控制的相关内容，主要包括判优控制和通信控制，而且这一部分内容就是我们的重难点，所以我也会着重进行讲解。</p><h3 id="5-1-总线判优控制"><a href="#5-1-总线判优控制" class="headerlink" title="5.1 总线判优控制"></a>5.1 总线判优控制</h3><p>首先我们根据设备是否对总线有控制权，我们把其分为主设备和从设备。主设备对总线有控制权，从设备只能响应从主设备发来的总线命令，对总线没有控制权。总线判优也分为集中式和分布式两种，接下来我们会一一进行介绍。</p><p><strong>（1）链式查询</strong></p><p>链式查询，顾名思义，就是跟一条链子一样，一个一个查询过去。控制总线中有3根线用于总线控制（BS 总线忙、 BR 总线请求、 BG 总线同意），其中总线同意信号 BG 是串行地从一个 I&#x2F;O 接口送到下 一个 I&#x2F;O 接口。</p><p>具体操作就是，BG一个一个去查询有没有设备发送总线请求BR，当发现了有之后，这个设备就会发送总线忙信号BS，这样就占有了总线，然后下一次也是如此循环。</p><p><strong>这样的话只需很少几根线就能按一定优先次序实现总线控制，并且很容易扩充设备，但对电路故障很敏感，且优先级别低的设备可能很难获得请求。</strong></p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/ab9830421e654f7e86135b64524d0819.png" alt="在这里插入图片描述" style="zoom:80%;"><p><strong>（2）计数器定时查询</strong></p><p>接下来介绍的是计数器定时查询，与链式查询相比，多了一组设备地址线，少了一根总线同意线 BG 。总线控制部件接到由 BR 送来的总线请求信号后，在总线未被使用 (BS&#x3D; 0) 的情况下，总线控制部件中的计数器开始计数，并通过设备地址线，向各设备发出一组地址信号。这样的好处是可以自己设定优先级，并且可以通过循环的方式去一一遍历设备（每此从中断点开始计数）。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/7ddaf3e0cf9c4b03b01f7c3dcfe28e65.png" alt="在这里插入图片描述" style="zoom:80%;"><p><strong>（3）独立请求方式</strong></p><p>独立请求方式就是每个设备都与总线控制部件相连，当设备要求使用总线时，便发出该设备的请求信号。总线控制部件中有一排队电路，可根据优先次序确定响应哪一台设备的请求。</p><p><strong>这种方式的特点是：响应速度快，优先次序控制灵活，但控制线数量多，总线控制更复杂</strong></p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/79ce24c525704529bfb267f452147ec7.png" alt="在这里插入图片描述" style="zoom:80%;"><h3 id="5-2-总线通信控制"><a href="#5-2-总线通信控制" class="headerlink" title="5.2 总线通信控制"></a>5.2 总线通信控制</h3><p>接下来我们要介绍的就是总线通信控制了，主要就是用来解决通信双方协调配合的问题的。一共分为4个阶段，<strong>申请分配、寻址、传输和结束</strong>阶段。通信方式也刚好是四种，分为同步、异步、半同步和分离式四种，好了，就让我们开始吧！</p><p><strong>同步通信</strong></p><p>通信双方由统一时标控制数据传送称为同步通信。时标通常由 CPU 的总线控制部件发出，送到总线上的所有部件；也可以由每个部件各自的时序发生器发出，但必须由总线控制部件发出的时钟信号对它们进行同步。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/1cba2e60495944e1bb4a6e3e8a5fc2a4.png" alt="在这里插入图片描述" style="zoom: 67%;"><p>对于读命令，其传输周期如下：</p><ol><li>T1主模块发地址。</li><li>T2主模块发读命令。</li><li>T3从模块提供数据。</li><li>T4主模块撤销读命令，从模块撤销数据。</li></ol><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/2e3ea8616cd84012ba6a804194bc61bb.png" alt="在这里插入图片描述" style="zoom: 67%;"><p>对于写命令，其传输周期如下：</p><ol><li>T1主模块发地址。</li><li>T1.5主模块发读命令。</li><li>T2从模块提供数据。</li><li>T4主模块撤销读命令，从模块撤销数据。</li></ol><p><strong>特点</strong></p><p>这种通信的优点是规定明确、统一，模块间的配合简单一致。其缺点是主、从模块时间配合属于强制性”同步”，必须在限定时间内完成规定的要求。并且对所有从模块都用同一限时，这就势必造成，对各不相同速度的部件而言，必须按最慢速度的部件来设计公共时钟，严重影响总线的工作效率，也给设计带来了局限性，缺乏灵活性。</p><p>所以同步通信一般用千总线长度较短、各部件存取时间比较一致的场合。而且，总线传输周期越短，数据线的位数越多，直接影响总线的数据传输率</p><p><strong>异步通信</strong></p><p>异步通信克服了同步通信的缺点，允许各模块速度的不一致性，给设计者充分的灵活性和选择余地。他是是采用应答方式（又称握手方式），即当主模块发出请求 (Request) 信号时，一直等待从模块反馈回来“响应 ”信号后才开始通信。应答方式可分为不互锁、半互锁和全互锁三种类型。</p><p>我们在这里采用出租车的例子去帮助大家理解这三种方式的区别，请大家想像自己在和出租车司机交流。</p><ul><li><strong>不互锁</strong></li></ul><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/7b92eb35ab61481b969a2ad6e55b5e91.png" alt="在这里插入图片描述" style="zoom:80%;"><p>这就是第一种情况，热情司机与高冷乘客，首先司机询问：你去哪啊？（请求信号）。但是乘客不回答，这个时候司机只能按照打车软件的地址将乘客安全送达，或者只能让他下车了。</p><ul><li><strong>半互锁</strong></li></ul><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/568e2b35a6504802b387c71e7fda1a3b.png" alt="在这里插入图片描述" style="zoom:80%;"><p>这个属于第二种情况，高冷司机与热情乘客，首先司机询问：你去哪啊？（请求信号）。乘客回答：机场（回答信号）。这个时候司机便不再回答。这种情况看起来不错，但是会照成一个情况，就是顾客怕司机没听清楚，便一直回答。</p><ul><li><strong>全互锁</strong></li></ul><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/c878e28825d349879bd6135713629034.png" alt="在这里插入图片描述" style="zoom: 80%;"><p>这个属于第三种情况，热情司机与热情乘客，首先司机询问：你去哪啊？（请求信号）。乘客回答：机场（回答信号）。这个时候司机便回答：好嘞。这种情况就比较完美了。</p><p><strong>半同步通信</strong></p><p>半同步通信既保留了同步通信的基本特点，如所有的地址、命令、数据信号的发出时间，都严格参照系统时钟的某个前沿开始，而接收方都采用系统时钟后沿时刻来进行判断识别；同时又像异步通信那样，允许不同速度的模块和谐地工作。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/c1283df227924e94a74ae78bd9062b45.png" alt="在这里插入图片描述" style="zoom:67%;"><p>其实就是加了一个等待信号，以便于不同速度的模块能一起工作。对于读命令，其传输周期如下：</p><ol><li>T1主模块发地址。</li><li>T2主模块发读命令。</li><li>TWAIT ~ TWAIT为低电平时，进入等待，八的宽度与 的宽度一致。</li><li>T3从模块提供数据。</li><li>T4主模块撤销读命令，从模块撤销数据。</li></ol><p>然后输出也是一样的，就不再赘述了。</p><p>我们总结一下上面三种通信的共同点，我们可以得到如下信息：</p><ul><li>主模块发地址、命令 占用总线</li><li>从模块准备数据 不占用总线</li><li>从模块向主模块发数据 占用总线</li></ul><p>于是在此基础上，我们设计出来了分离式通信。充分挖掘系统总线每个瞬间的潜力。</p><p><strong>分离式通信</strong></p><p>我们主要分为两个周期：</p><ul><li>主模块申请占用总线，使用完后既放弃总线的使用权。</li><li>从模块申请占用总线，将各类学习传输到总线上。</li></ul><p><strong>特点</strong></p><ol><li>各模块欲占用总线使用权都必须提出申请。</li><li>在得到总线使用权后，主模块在限定的时间内向对方传送信息，采用同步方式传送，不再等待对方的回答信号。</li><li>各模块在准备数据的过程中都不占用总线，使总线可接受其他模块的请求。</li><li>总线被占用时都在做有效工作，或者通过它发送命令，或者通过它传送数据，不存在空闲等待时间，充分地利用了总线的有效占用，从而实现了总线在多个主、从模块间进行信息交叉重叠并行式传送，这对大型计算机系统是极为重要的。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>车机MCU知识梳理</title>
    <link href="/2023/05/03/%E8%BD%A6%E6%9C%BAMCU%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <url>/2023/05/03/%E8%BD%A6%E6%9C%BAMCU%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="车机MCU知识梳理"><a href="#车机MCU知识梳理" class="headerlink" title="车机MCU知识梳理"></a>车机MCU知识梳理</h1><blockquote><p>声明：转载自<a href="https://www.eet-china.com/mp/a191448.html">https://www.eet-china.com/mp/a191448.html</a></p><p>仅做个人学习笔记使用</p></blockquote><p>一辆传统燃油车需要大约500到600颗芯片，轻混汽车大约需要1000颗，插电混动和纯电动汽车则需要至少2000颗芯片。这意味着，随着智能电动汽车的飞速发展，不但先进制程的芯片需求量越来越大，传统芯片的需求量也将继续提升。MCU就是这样，除了单车搭载的数量在不断增长，域控制器也带来了对高安全、高可靠、高算力MCU的新需求增长。</p><p>MCU，Microcontroller Unit，中文称单片微型计算机&#x2F;微控制器&#x2F;单片机，将CPU、存储器、外围功能整合在单一芯片上，形成具有控制功能的芯片级计算机，主要用于实现信号处理和控制，是智能控制系统的核心。</p><p>MCU与我们的生活工作息息相关，如汽车电子、工业、计算机与网络、消费电子、家电、物联网等，其中汽车电子是最大的市场，从全球角度看占比达到了33%。</p><h2 id="MCU结构"><a href="#MCU结构" class="headerlink" title="MCU结构"></a>MCU结构</h2><p>MCU主要由中央处理器CPU、存储器（ROM和RAM）、输入输出I&#x2F;O接口、串行口、计数器等构成。</p><img src="/2023/05/03/%E8%BD%A6%E6%9C%BAMCU%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/MBXY-CR-abdcd2d763896a6c675eba8495147cd2.png" alt="img" style="zoom: 60%;"><p><strong>CPU：</strong>Central Processing Unit，中央处理器，是 MCU 内部的核心部件，运算部件能完成数据的算术逻辑运算、位变量处理和数据传送操作，控制部件则按照一定时序协调工作，分析并执行指令。</p><p><strong>ROM：</strong>Read-Only Memory，是程序存储器，用来存放由制造厂家写好的程序，信息以非破坏方式读取，存储数据掉电后不消失，MCU按照事先编写好的程序执行。</p><p><strong>RAM：</strong>Random Access Memory，是数据存储器，与 CPU 直接进行数据交换，掉电后该数据不能保持。在程序运行过程中可以随时写入、读出，通常作为操作系统或其他正在运行中程序的临时数据存储介质。</p><p><strong>CPU和MCU的关系：</strong></p><p>CPU是运算控制的核心。MCU除了CPU之外，还包含ROM或RAM等，是芯片级芯片。常见的还有SoC（System on Chip），中文称片上系统，是系统级芯片，可存放并运行系统级别的代码，运行QNX、Linux 等操作系统，包含多个处理器单元（CPU+GPU+DSP+NPU+存储+接口单元）</p><h2 id="MCU的位数"><a href="#MCU的位数" class="headerlink" title="MCU的位数"></a>MCU的位数</h2><p>位数是指MCU每次处理数据的宽度，位数越高意味着MCU数据处理能力就越强，目前最主要的是8、16、32位三种，其中32位占比最多且增长迅速。</p><img src="/2023/05/03/%E8%BD%A6%E6%9C%BAMCU%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/MBXY-CR-705bbb7f06192297ec5f0fc5c931f0ae.png" alt="img" style="zoom:80%;"><p>在汽车电子应用中，8位MCU成本低、便于开发，目前主要应用在相对简单的控制领域，如照明、雨刷、车窗、座椅和车门等车身域控制。而对于相对复杂的领域，如仪表显示、车载娱乐信息系统、动力控制系统、底盘、驾驶辅助系统等，则以32位的为主，且随着汽车电动化、智能化、网联化的迭代进化，对MCU的运算能力要求也越来越高。</p><table><thead><tr><th>位数</th><th>车相关模块</th><th>时间</th><th>价格（美元）</th></tr></thead><tbody><tr><td>8位</td><td>低端控制功能：车体的各个次系统，如风扇控制、空调控制、雨刷、天窗、车窗升降、低阶仪表板、集线盒、座椅 控制、门控模块等低阶控制功能。</td><td>1980-1983年</td><td>&lt;1</td></tr><tr><td>16位</td><td>中端控制功能：① 动力传动系统，如引擎控制、齿轮与离合器控制，和电子式涡轮系统等；② 底盘机构，如悬吊系统、电子式动力方向盘、扭力分散控制、电子帮辅、电子刹车等</td><td>1983-80年代末</td><td>1 ~ 5</td></tr><tr><td>32位</td><td>高端控制功能：L1&#x2F;L2智能驾驶功能中扮演重要角色，如仪表盘控制、车身控制、多媒体信息系统、引擎控制，以及新兴的智能性和实时性的安全系统及动力系统（预碰撞、ACC、驾驶辅助系统、电子稳定程序、X-by-wire 等）</td><td>1990年代至今</td><td>5~10，部分&gt;10</td></tr></tbody></table><h2 id="MCU车规认证"><a href="#MCU车规认证" class="headerlink" title="MCU车规认证"></a>MCU车规认证</h2><p>MCU供应商在进入OEM的供应链体系前，一般需要完成三大认证：设计阶段要遵循功能安全标准 ISO 26262，流片和封装阶段要遵循AEC-Q001~004和IATF16949，以及在认证测试阶段要遵循AEC-Q100&#x2F;Q104。</p><p>其中，ISO 26262定义了ASIL四个安全等级，从低到高分别为A、B、C和D；AEC-Q100 分为四个可靠性等级，从低到高分别为 3、2、1和0。AEC-Q100 系列认证一般需要1-2年的时间，而ISO 26262的认证难度更大，周期更长。</p><h2 id="MCU在智能电动汽车产业的应用"><a href="#MCU在智能电动汽车产业的应用" class="headerlink" title="MCU在智能电动汽车产业的应用"></a>MCU在智能电动汽车产业的应用</h2><p>MCU在汽车产业中应用广泛，如前表，从车身附件、动力系统、底盘、车载信息娱乐到智能驾驶等板块都会用到。随着智能电动汽车时代的发展，MCU产品需求会越来越旺盛。</p><p><strong>电动化：</strong></p><p>1、电池管理系统BMS：BMS需要对充放电、温度、电池间均衡进行控制，主控板需要一颗MCU，每个从控板也需要一颗MCU；</p><p>2、整车控制器VCU：电动汽车能量管理需要增加一个整车控制器，同时需要配备32位高阶MCU，数量根据各厂的方案不同而不同；</p><p>3、引擎控制器&#x2F;变速箱控制器：存量替换，电动汽车逆变器控制MCU替代油车的引擎控制器，由于电机转速较高，需要经过减速器减速，其配备的MCU控制芯片替换了油车的变速箱控制器。</p><p><strong>智能化：</strong></p><p>1、目前国内汽车市场还是处于L2高速渗透的阶段，基于综合成本和性能的考量，OEM新增ADAS功能仍沿用分布式架构，随着装载率的提升，处理传感器信息的MCU随之增加。</p><p>2、由于座舱功能日益增多，更高新能的芯片作用越来越重要，对应的MCU地位有所下降。</p><h2 id="工艺制造"><a href="#工艺制造" class="headerlink" title="工艺制造"></a>工艺制造</h2><p>MCU本身对算力要求优先，对先进制程要求不高，同时其内置的嵌入式存储自身也限制了MCU制程的提升，因此当前车规MCU工艺节点主要是在40nm及以上的成熟制程，部分比较先进的车用MCU产品采用了28nm制程。车规芯片的规格主要是8英寸晶圆，部分厂商尤其IDM开始向12英寸平台迁移。</p><p><strong>目前28nm和40nm工艺是市场主流。</strong></p><h2 id="国内外典型车企"><a href="#国内外典型车企" class="headerlink" title="国内外典型车企"></a>国内外典型车企</h2><p>相较于消费和工业级MCU，车规级MCU对运行环境、可靠性和供货周期的要求较高，此外车规级MCU认证门槛比较高，认证时间长、进入难度大，所以整体看MCU市场格局较为集中，2021年世界前五名的MCU企业占比就达82%之多。</p><table><thead><tr><th>序号</th><th>企业</th><th>国别</th><th>2021年销售额（亿美元）</th><th>2021年市场份额</th></tr></thead><tbody><tr><td>1</td><td>NXP</td><td>荷兰</td><td>37.95</td><td>18.8%</td></tr><tr><td>2</td><td>微芯</td><td>美国</td><td>35.84</td><td>17.8%</td></tr><tr><td>3</td><td>瑞萨</td><td>日本</td><td>34.2</td><td>17%</td></tr><tr><td>4</td><td>ST</td><td>意大利</td><td>33.74</td><td>16.7%</td></tr><tr><td>5</td><td>英飞凌</td><td>德国</td><td>23.78</td><td>11.8%</td></tr></tbody></table><p>目前，中国车规级MCU还处在导入期，供应链本土化、国产替代化潜力巨大。</p><table><thead><tr><th>序号</th><th>企业</th><th>芯片</th><th>量产首款通过时间</th></tr></thead><tbody><tr><td>1</td><td>比亚迪半导体</td><td>车规级触控MCU、车规级通用MCU及电池管理MCU</td><td>2018年</td></tr><tr><td>2</td><td>杰发科技（四维图新子公司）</td><td>ABS、BMS等核心功能、车身控制</td><td>2018年</td></tr><tr><td>3</td><td>芯海科技</td><td>车身电子、智能座舱</td><td>2020年</td></tr><tr><td>4</td><td>航顺芯片</td><td>汽车前装</td><td>2019年</td></tr><tr><td>5</td><td>芯旺微电子</td><td>汽车照明、车窗控制、空调面板</td><td>2019年</td></tr><tr><td>6</td><td>国芯科技</td><td>车载T-BOX安全单元、车载诊断系统安全单元、C-V2X通信安全应用</td><td>2019年</td></tr><tr><td>7</td><td>芯驰科技</td><td>汽车显示类应用</td><td>2019年</td></tr><tr><td>8</td><td>赛腾微电子</td><td>尾灯流水灯、车载无线充电、车窗控制</td><td>2019年</td></tr></tbody></table><h2 id="SOC与MCU的区别"><a href="#SOC与MCU的区别" class="headerlink" title="SOC与MCU的区别"></a>SOC与MCU的区别</h2><ul><li><p>MCU</p></li><li><ul><li><p>&#x3D;Micro Control Unit&#x3D;&#x3D;Micro Controller&#x3D;Microcontroller&#x3D;Microcontroller Unit</p></li><li><p>特点</p></li><li><ul><li><p>复杂度</p></li><li><ul><li>比CPU高，比SoC低</li></ul></li><li><p>运行系统</p></li><li><ul><li>简单系统</li><li>一般不支持运行多任务的复杂系统（比如(嵌入式)Linux）</li></ul></li></ul></li></ul></li><li><p>SoC</p></li><li><ul><li><p>&#x3D;System On Chip&#x3D;System On a Chip&#x3D;系统级芯片&#x3D;片上系统</p></li><li><p>总结</p></li><li><ul><li><p>复杂度</p></li><li><ul><li>比CPU高，比MCU高</li></ul></li><li><p>运行系统</p></li><li><ul><li>能支持运行多任务的复杂系统（比如(嵌入式)Linux）</li></ul></li><li><p>总体复杂度&#x3D;集成功能的丰富程度</p></li><li><ul><li>CPU &lt; MCU &lt; SoC</li></ul></li><li><p>芯片平均价格</p></li><li><ul><li>CPU &lt; MCU &lt; SoC</li></ul></li></ul></li></ul></li></ul><blockquote><p>SOC是多了个简单的操作系统吗?</p></blockquote><p>如果仅仅是从 MCU和SoC所能支持的操作系统的角度来说，基本上说：是的。</p><ul><li><p>MCU：运行的往往是裸系统</p></li><li><ul><li><p>代码直接操作物理存储空间</p></li><li><ul><li>控制外部设备</li></ul></li></ul></li><li><p>SoC</p></li><li><ul><li><p>系统复杂度一般比较高</p></li><li><p>运行的典型如嵌入式Linux系统</p></li><li><ul><li>包括衍生出的Android系统等</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>车机扫盲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理(一)计算机系统概论</title>
    <link href="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    <url>/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-一-计算机系统概论"><a href="#计算机组成原理-一-计算机系统概论" class="headerlink" title="计算机组成原理(一)计算机系统概论"></a>计算机组成原理(一)计算机系统概论</h1><h2 id="1-计算机系统简介"><a href="#1-计算机系统简介" class="headerlink" title="1.计算机系统简介"></a>1.计算机系统简介</h2><h2 id="2-计算机的基本组成"><a href="#2-计算机的基本组成" class="headerlink" title="2.计算机的基本组成"></a>2.计算机的基本组成</h2><h3 id="2-0-冯诺依曼计算机历史"><a href="#2-0-冯诺依曼计算机历史" class="headerlink" title="2.0 冯诺依曼计算机历史"></a>2.0 冯诺依曼计算机历史</h3><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/a825a9ed08e2a58a5d9d462c5d8de1a4.png" alt="img" style="zoom:80%;"><p>冯诺依曼计算机简称为EDVAC(Electronic Discrete Variable Automatic Computer)也叫普林斯顿体系结构（Princetionarchitecture），因为冯诺依曼是普林斯顿大学教授。</p><p>EDVAC是世界上第一台存储程序计算机(也有说法是电子数字式计算机)，成为所有现代计算机的原型和范本，它被建造于 1940年.。它是最早的大型二进制系统中央处理器计算机，而不是十进制系统。建造于19世纪40年代,EDVAC 设计于1944年,在这之前它被安装在美国军队的弹道学研究实验室，该实验室建造于1940年８月，位于马里兰州。</p><p>作为一个二进制序列的计算机，EDVAC用于加工数学的计算，连续的大致内存容量是5.5kb，EDVAC被用于作为数据的媒介存贮磁带，每天运行时间超过２&#x3D;０个小时，EDVAC 于1960年被BRLESC（Ballistic Research Laboratories Electronic Scientific Computer）替换成更大的内存和更快的响应时间。</p><p>冯·诺依曼体制的主要思想包括：<br> （1）采用二进制代码形式表示信息（数据、指令）；<br> （2）采用存储程序工作方式（冯·诺依曼思想最核心的概念）；<br> （3）计算机硬件系统由五大部件（运算器、控制器、存储器、输入设备和输出设备）组成。</p><blockquote><p>🪶按照冯诺依曼体质的思想，运算器是冯诺依曼计算机的核心，计算器就是用来进行复杂的计算，至于运行哪一种计算是加法、减法、乘法等等取决于控制器，告诉控制器要执行什么指令由它去进行控制。那么运算的中间结果，运算的初始值，运算的最终结果需要有一个容器进行盛放就是存储器。</p></blockquote><h3 id="2-1-冯诺依曼计算机的特点"><a href="#2-1-冯诺依曼计算机的特点" class="headerlink" title="2.1 冯诺依曼计算机的特点"></a>2.1 冯诺依曼计算机的特点</h3><ol><li>计算机由五大部件组成（存储器、运算器、控制器、输入设备、输出设备）</li><li>指令和数据以同等地位存于存储器，可按地址寻址</li><li>指令和数据用二进制表示</li><li>指令由操作码和地址码组成</li><li>存储程序</li><li>以运算器为核心</li></ol><h3 id="2-2-现代计算机硬件框图"><a href="#2-2-现代计算机硬件框图" class="headerlink" title="2.2 现代计算机硬件框图"></a>2.2 现代计算机硬件框图</h3><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501225515506.png" alt="image-20230501225515506" style="zoom: 80%;"><blockquote><p>内存也被称为主存，而辅存指的是计算机的外部存储、例如，硬盘、U盘、软盘以及光盘等等</p></blockquote><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501224841832.png" alt="image-20230501224841832" style="zoom:80%;"><p>对于像冯诺依曼体系这种复杂的系统，需要有一个系统复杂性管理的方法（3’Y）</p><ul><li>层次化（Hierachy）：将被设计的系统划分为多个模块或子模块</li><li>系统化（Modularity）：有明确定义的功能和接口</li><li>规则性（regularity）：模块更容易被重用</li></ul><blockquote><p>这边的思想远远不止用于设计冯诺依曼体系，对于日常工作中各种框架的理解和设计意义也是非凡的。</p></blockquote><h3 id="2-3-计算机的工作步骤"><a href="#2-3-计算机的工作步骤" class="headerlink" title="2.3 计算机的工作步骤"></a>2.3 计算机的工作步骤</h3><h4 id="2-3-1-编程举例"><a href="#2-3-1-编程举例" class="headerlink" title="2.3.1 编程举例"></a>2.3.1 编程举例</h4><p>计算：ax^2 + bx + c 的值</p><p><strong>第一种方案：直接计算</strong></p><blockquote><p>取 x 到运算器中</p><p>乘以 x 在运算器中</p><p>乘以 a 在运算器中</p><p>存 ax^2 到存储器中</p><p>取 b 到运算器中</p><p>乘以 x 在运算器中</p><p>加 ax^2 在运算器中</p><p>加 c 在运算器中</p></blockquote><p><strong>第二种方案：变形后计算</strong>   <strong>(ax+b)x+c</strong></p><blockquote><p>取 x 到运算器中</p><p>乘以 a 在运算器中</p><p>加 b 在运算器中</p><p>乘以 x 在运算器中</p><p>加 c 在运算器中</p></blockquote><p>对于同一台计算机而言，第一种方案需要8条指令，第二种方案只需要5条指令，显然第二种方案是更快的，对于存储空间的要求也是更少的。</p><h4 id="2-3-2-指令格式"><a href="#2-3-2-指令格式" class="headerlink" title="2.3.2 指令格式"></a>2.3.2 指令格式</h4><p>以取数指令为例：</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501232421591.png" alt="image-20230501232421591" style="zoom:80%;"><p>其他的指令如下：</p><table><thead><tr><th>操作</th><th>表示</th></tr></thead><tbody><tr><td>取数 α</td><td>[α] -&gt; ACC</td></tr><tr><td>存数 β</td><td>[ACC] -&gt; β</td></tr><tr><td>加 γ</td><td>[ACC] + [γ] -&gt; ACC</td></tr><tr><td>乘 δ</td><td>[ACC] × [δ] -&gt; ACC</td></tr><tr><td>打印 σ</td><td>[σ] -&gt; 打印机</td></tr></tbody></table><p>那么我们计算ax^2 + bx  + c 的程序清单为：</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501232836557.png" alt="image-20230501232836557" style="zoom:80%;"><h4 id="2-3-3-存储器的基本组成"><a href="#2-3-3-存储器的基本组成" class="headerlink" title="2.3.3 存储器的基本组成"></a>2.3.3 存储器的基本组成</h4><p>主存储器由 <u>存储体、MAR、MDR</u> 组成：</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501232931011.png" alt="image-20230501232931011" style="zoom:80%;"><p><strong>存储体</strong>的组成与生活例子对应如下：</p><p>存储体 — 存储单元 — 存储元件</p><p> 大楼   —  房间        — 床位</p><ul><li>存储单元：存放一串二进制代码</li><li>存储字：存储单元中二进制代码的组合</li><li>存储字长：存储单元中二进制代码的位数，每个存储单元赋予一个地址号</li></ul><p><strong>MAR：</strong>全称 memory data register，主存数据寄存器，MDR用来保存要被写入地址单元或者从地址单元读入的数据。</p><p><strong>MDR：</strong>全称memory address register，主存地址寄存器，MAR用来保存数据被传输到的位置的地址或者数据来源位置的地址。</p><h4 id="2-3-4-运算器的基本组成及操作过程"><a href="#2-3-4-运算器的基本组成及操作过程" class="headerlink" title="2.3.4 运算器的基本组成及操作过程"></a>2.3.4 运算器的基本组成及操作过程</h4><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501235216541.png" alt="image-20230501235216541" style="zoom:80%;"><p>①加法操作过程</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501235302879.png" alt="image-20230501235302879" style="zoom: 67%;"><p>②减法操作过程</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501235446223.png" alt="image-20230501235446223" style="zoom:67%;"><p>③乘法操作过程</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501235504985.png" alt="image-20230501235504985" style="zoom: 67%;"><blockquote><p>高位存放于ACC寄存器，低位存放于MQ寄存器</p></blockquote><p>④除法操作过程</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501235547197.png" alt="image-20230501235547197" style="zoom: 67%;"><h4 id="2-3-5-控制器的基本组成"><a href="#2-3-5-控制器的基本组成" class="headerlink" title="2.3.5 控制器的基本组成"></a>2.3.5 控制器的基本组成</h4><p>控制器CU主要由IR寄存器、PC寄存器组成；完成一条指令需要有三步：PC取指令、IR分析指令、CU控制单元执行指令。</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501235624624.png" alt="image-20230501235624624" style="zoom: 67%;"><h4 id="2-3-6-主机完成一条指令的过程"><a href="#2-3-6-主机完成一条指令的过程" class="headerlink" title="2.3.6 主机完成一条指令的过程"></a>2.3.6 主机完成一条指令的过程</h4><p><strong>（1）以取指令为例</strong></p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230503150830396.png" alt="image-20230503150830396" style="zoom: 67%;"><ul><li><p>先要做的是拿到取数指令，PC中存储了下一条要执行指令的地址</p><ul><li><p>PC将指令的地址送给MAR</p></li><li><p>MAR再送给存储体</p></li><li><p>存储体将具体的指令送到MDR中</p></li><li><p>将取出来的指令送到IR进行分析</p></li><li><p>将指令的操作码部分交给CU控制单元</p></li></ul></li><li><p>然后拿到具体的数值，所以传递具体数值的地址</p><ul><li>因为IR分析指令后，里面有操作码和地址码，操作码表明了是取数指令，已经告诉了CU。现在要把具体数值的取出来。IR吧数值的地址传递到MAR</li><li>MAR再传给存储体</li><li>存储体将具体的数值取出来放到MDR中</li><li>MDR将数值传到ACC寄存器中</li></ul></li></ul><p><strong>（2）以存数指令为例</strong></p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230503151910628.png" alt="image-20230503151910628" style="zoom:67%;"><ul><li>PC中存储了下一条指令的地址<ul><li>PC将指令的地址传给MAR</li><li>MAR将地址传给存储体M</li><li>存储体M将具体的指令传给MDR</li><li>MDR将具体的指令传给IR进行分析</li><li>将指令的操作码部分交给CU控制单元</li></ul></li><li>然后就要存具体的数值了<ul><li>IR将要存的数值的具体地址传给MAR</li><li>MAR传给存储体</li><li>ACC寄存器将具体的数值传给MDR</li><li>MDR将数值传给存储体进行保存</li></ul></li></ul><p><strong>（3）ax^2+bx+c程序的运行过程</strong></p><ul><li>将程序通过输入设备送至计算机</li><li>程序首地址 -&gt; PC</li><li>启动程序运行</li><li>取指令 PC -&gt; MAR -&gt; M -&gt; MDR -&gt; IR， (PC)+1-&gt;PC</li><li>分析指令  OP(IR) -&gt; CU</li><li>执行指令  Ad(IR) -&gt; MAR -&gt; M -&gt; MDR -&gt; ACC</li><li>…</li><li>…</li><li>打印结果</li><li>停机</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DeviceMapper驱动</title>
    <link href="/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/"/>
    <url>/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="DeviceMapper驱动"><a href="#DeviceMapper驱动" class="headerlink" title="DeviceMapper驱动"></a>DeviceMapper驱动</h1><h2 id="1-驱动的ioctl接口"><a href="#1-驱动的ioctl接口" class="headerlink" title="1.驱动的ioctl接口"></a>1.驱动的ioctl接口</h2><h3 id="1-0-ioctl命令行扫盲"><a href="#1-0-ioctl命令行扫盲" class="headerlink" title="1.0 ioctl命令行扫盲"></a>1.0 ioctl命令行扫盲</h3><p>在进行ioctl时，我们会传递cmd，该cmd由32位组成：</p><blockquote><p>第一个分区：0-7，命令的编号，范围是0-255<br>第二个分区：8-15，命令的幻数<br>第三个分区：16-29，表示传递的数据的大小<br>第四分区：30-31，代表读写的方向</p><p>第一和第二分区，主要用来区分命令，不能有两个完全一样的“一+二”<br>第四分区：00：没有数据传递；10：用户从驱动读数据；01：用户向驱动写数据；11：先写数据到驱动再把数据读出来</p></blockquote><p>如果自己去组合这个cmd比较费事且容易搞错，所以Linux提供了相应的宏给我们去组合cmd：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">_IO(type,nr)   没有数据传递的命令<br>_IOR(type, nr, size)  从驱动中读取数据的命令<br>_IOW(type, nr, size)  向驱动中写入数据的命令<br>_IOWR(type, nr, size) 交换数据的命令<br><br>// type表示数据的幻数，8-15位<br>// nr命令的编号，0-7位<br>// size参数传递的大小，传递的是数据类型：如果传递4字节，可以写成int<br></code></pre></td></tr></table></figure><p>内核拿到这些cmd，首先要对组合后的cmd进行解析，才知道对应的动作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">_IOC_DIR(nr)   获得方向<br>_IOC_TYPE(nr)  获得幻数<br>_IOC_NR(nr)    获得编号<br>_IOC_SIZE(nr)  获得大小<br></code></pre></td></tr></table></figure><h3 id="1-1-内核空间ioctl空间定义"><a href="#1-1-内核空间ioctl空间定义" class="headerlink" title="1.1 内核空间ioctl空间定义"></a>1.1 内核空间ioctl空间定义</h3><p>先来看一下这个驱动的设备操作集</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> _<span class="hljs-title">ctl_fops</span> =</span> &#123;<br>.open = nonseekable_open,<br>.unlocked_ioctl = dm_ctl_ioctl,<br>.compat_ioctl = dm_compat_ctl_ioctl,<br>.owner = THIS_MODULE,<br>.llseek  = noop_llseek,<br>&#125;;<br></code></pre></td></tr></table></figure><p>用户空间调用ioctl接口，会调用驱动的<code>unlocked_ioctl</code>，对应的函数为<code>dm_ctl_ioctl</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dm_ctl_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, uint command, ulong u)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>)ctl_ioctl(command, (<span class="hljs-keyword">struct</span> dm_ioctl __user *)u);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctl_ioctl</span><span class="hljs-params">(uint command, <span class="hljs-keyword">struct</span> dm_ioctl __user *user)</span><br>&#123;<br>    <span class="hljs-comment">// 获得command的NR编号</span><br>    cmd = _IOC_NR(command);<br>    <br>fn = lookup_ioctl(cmd, &amp;ioctl_flags);<br>    <span class="hljs-comment">// 执行cmd对应的处理函数</span><br>    <span class="hljs-keyword">if</span> (!fn) &#123;<br>DMWARN(<span class="hljs-string">&quot;dm_ctl_ioctl: unknown command 0x%x&quot;</span>, command);<br><span class="hljs-keyword">return</span> -ENOTTY;<br>&#125;<br>&#125;<br><br><span class="hljs-type">static</span> ioctl_fn <span class="hljs-title function_">lookup_ioctl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">int</span> *ioctl_flags)</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> cmd;<br><span class="hljs-type">int</span> flags;<br>ioctl_fn fn;<br>&#125; _ioctls[] = &#123;<br>        <span class="hljs-comment">// ...</span><br>&#123;DM_DEV_CREATE_CMD, IOCTL_FLAGS_NO_PARAMS, dev_create&#125;,<br>&#123;DM_DEV_REMOVE_CMD, IOCTL_FLAGS_NO_PARAMS, dev_remove&#125;,<br>&#123;DM_DEV_RENAME_CMD, <span class="hljs-number">0</span>, dev_rename&#125;,<br>&#123;DM_DEV_SUSPEND_CMD, IOCTL_FLAGS_NO_PARAMS, dev_suspend&#125;,<br>&#123;DM_DEV_STATUS_CMD, IOCTL_FLAGS_NO_PARAMS, dev_status&#125;,<br>&#123;DM_DEV_WAIT_CMD, <span class="hljs-number">0</span>, dev_wait&#125;,<br><span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">return</span> _ioctls[cmd].fn;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会遍历ioctls里面定义的命令行，一个个进行查找对比，匹配到之后将对应的处理函数返回。例如匹配到 <strong>DM_DEV_CREATE_CMD</strong> 后，将<strong>dev_create</strong>返回，然后在 <strong>ctl_ioctl</strong> 执行 <strong>fn</strong> 也就是 <strong>dev_create</strong>。</p><h3 id="1-2-用户空间调用ioctl"><a href="#1-2-用户空间调用ioctl" class="headerlink" title="1.2 用户空间调用ioctl"></a>1.2 用户空间调用ioctl</h3><p>这是用户空间（init进程）向内核发送的创建设备的ioctl，其中cmd为DM_DEV_CREATE</p><img src="/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/image-20230425220018537.png" alt="image-20230425220018537" style="zoom:50%;"><p>我们研究一个这个DM_DEV_CREATE的组成：</p><img src="/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/image-20230425222337318.png" alt="image-20230425222337318" style="zoom: 67%;"><p>该cmd告诉内核我们是双向交互数据的，且NR号为3，传输数据的大小为struct dm_ioctl的大小。</p><h2 id="2-DeviceMapper中的数据结构"><a href="#2-DeviceMapper中的数据结构" class="headerlink" title="2.DeviceMapper中的数据结构"></a>2.DeviceMapper中的数据结构</h2><h3 id="2-1-hash-cell"><a href="#2-1-hash-cell" class="headerlink" title="2.1 hash_cell"></a>2.1 hash_cell</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// drivers\md\dm-ioctl.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash_cell</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">name_list</span>;</span>  <span class="hljs-comment">// 表示name的双向链表，同一个Hash值的形成一个双向链表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">uuid_list</span>;</span>  <span class="hljs-comment">// 表示uuid的双向链表，同一个Hash值的形成一个双向链表</span><br><br><span class="hljs-type">char</span> *name;   <span class="hljs-comment">// 当前mapped device的name</span><br><span class="hljs-type">char</span> *uuid;   <span class="hljs-comment">// 当前mapped device的uuid</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mapped_device</span> *<span class="hljs-title">md</span>;</span>  <span class="hljs-comment">// 具体的mapped_device</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dm_table</span> *<span class="hljs-title">new_map</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><img src="/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/image-20230425235406381.png" alt="image-20230425235406381" style="zoom:80%;"><h2 id="2-创建设备"><a href="#2-创建设备" class="headerlink" title="2.创建设备"></a>2.创建设备</h2><p>前面可以看到用户空间传递进来DM_DEV_CREATE想要创建dm设备，对应的处理函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dev_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dm_ioctl *param, <span class="hljs-type">size_t</span> param_size)</span><br>&#123;<br><span class="hljs-type">int</span> r, m = DM_ANY_MINOR;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mapped_device</span> *<span class="hljs-title">md</span>;</span><br><br>    <span class="hljs-comment">// 2.1节去检查传进来的参数中的name是否合法</span><br>r = check_name(param-&gt;name);<br>    <br>    <span class="hljs-comment">// 用户空间没有传递flag，所以m的值仍然是DM_ANY_MINOR</span><br>    <span class="hljs-comment">// 会影响到2.2.1节</span><br>    <span class="hljs-keyword">if</span> (param-&gt;flags &amp; DM_PERSISTENT_DEV_FLAG)<br>m = MINOR(huge_decode_dev(param-&gt;dev));<br><br>    <span class="hljs-comment">// 2.2节用来创建dm设备</span><br>r = dm_create(m, &amp;md);<br><span class="hljs-keyword">if</span> (r)<br><span class="hljs-keyword">return</span> r;<br><br>r = dm_hash_insert(param-&gt;name, *param-&gt;uuid ? param-&gt;uuid : <span class="hljs-literal">NULL</span>, md);<br><span class="hljs-keyword">if</span> (r) &#123;<br>dm_put(md);<br>dm_destroy(md);<br><span class="hljs-keyword">return</span> r;<br>&#125;<br><br>param-&gt;flags &amp;= ~DM_INACTIVE_PRESENT_FLAG;<br><br>__dev_status(md, param);<br><br>dm_put(md);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引用**<a href="https://blog.csdn.net/feelabclihu/article/details/120232172">内核工匠</a>**总结的图片：</p></blockquote><img src="/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/ec3e80a0f0a490eb7d77c6dbaa8f3df6.png" alt="img" style="zoom:80%;"><h3 id="2-1-checkname检查名字是否合法"><a href="#2-1-checkname检查名字是否合法" class="headerlink" title="2.1 checkname检查名字是否合法"></a>2.1 checkname检查名字是否合法</h3><p>首先我们确认一下param-&gt;name从何而来，在1.2中调用ioctl之前会初始化需要传递的数据，此时param-&gt;name也就是在初始化数据时的io-&gt;name，即类似system_a这种。</p><img src="/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/image-20230425225647715.png" alt="image-20230425225647715" style="zoom: 50%;"><p>只要传进来的分区名不含有<code>/</code>，那么名字就是合法的！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_name</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strchr</span>(name, <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>DMWARN(<span class="hljs-string">&quot;invalid device name&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-dm-create创建dm设备"><a href="#2-2-dm-create创建dm设备" class="headerlink" title="2.2 dm_create创建dm设备"></a>2.2 dm_create创建dm设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dm_create</span><span class="hljs-params">(<span class="hljs-type">int</span> minor, <span class="hljs-keyword">struct</span> mapped_device **result)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mapped_device</span> *<span class="hljs-title">md</span>;</span><br><br>md = alloc_dev(minor);<br><span class="hljs-keyword">if</span> (!md)<br><span class="hljs-keyword">return</span> -ENXIO;<br><br>dm_sysfs_init(md);<br><br>*result = md;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-2-1-alloc-dev分配设备"><a href="#2-2-1-alloc-dev分配设备" class="headerlink" title="2.2.1 alloc_dev分配设备"></a>2.2.1 alloc_dev分配设备</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> mapped_device *<span class="hljs-title function_">alloc_dev</span><span class="hljs-params">(<span class="hljs-type">int</span> minor)</span><br>&#123;<br>    <span class="hljs-comment">// 用户空间没有传递param-&gt;flags所以</span><br>    <span class="hljs-comment">// 前面没有设置minor号，所以这里是DM_ANY_MINOR</span><br><span class="hljs-keyword">if</span> (minor == DM_ANY_MINOR)<br>        <span class="hljs-comment">// minor值会依次往下运行</span><br>        <span class="hljs-comment">// 在next_free_minor里面idr机制会分配给minor一个未占用的最小值</span><br>        <span class="hljs-comment">// 从0开始</span><br>r = next_free_minor(&amp;minor);<br><span class="hljs-keyword">else</span><br>r = specific_minor(minor);<br>   <br>    <span class="hljs-comment">// 此处初始化MapperDevice各种mutex和list</span><br>    <br>    <span class="hljs-comment">// 调用blk_queue_make_request注册mapped device对应的请求队列dm_make_request</span><br>    dm_init_md_queue(md);<br>    <br>    <span class="hljs-comment">// </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-dm-hash-insert插入哈希痛"><a href="#2-3-dm-hash-insert插入哈希痛" class="headerlink" title="2.3 dm_hash_insert插入哈希痛"></a>2.3 dm_hash_insert插入哈希痛</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dm_hash_insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *uuid, <span class="hljs-keyword">struct</span> mapped_device *md)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash_cell</span> *<span class="hljs-title">cell</span>, *<span class="hljs-title">hc</span>;</span><br><br>cell = alloc_cell(name, uuid, md);<br><br>down_write(&amp;_hash_lock);<br>hc = __get_name_cell(name);<br><span class="hljs-keyword">if</span> (hc) &#123;<br>dm_put(hc-&gt;md);<br><span class="hljs-keyword">goto</span> bad;<br>&#125;<br><br>list_add(&amp;cell-&gt;name_list, _name_buckets + hash_str(name));<br><br><span class="hljs-keyword">if</span> (uuid) &#123;<br>hc = __get_uuid_cell(uuid);<br><span class="hljs-keyword">if</span> (hc) &#123;<br>list_del(&amp;cell-&gt;name_list);<br>dm_put(hc-&gt;md);<br><span class="hljs-keyword">goto</span> bad;<br>&#125;<br>list_add(&amp;cell-&gt;uuid_list, _uuid_buckets + hash_str(uuid));<br>&#125;<br>dm_get(md);<br><br>dm_set_mdptr(md, cell);<br><br>up_write(&amp;_hash_lock);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux驱动——platform设备驱动实验</title>
    <link href="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux驱动——platform设备驱动实验"><a href="#Linux驱动——platform设备驱动实验" class="headerlink" title="Linux驱动——platform设备驱动实验"></a>Linux驱动——platform设备驱动实验</h1><blockquote><p>本文为学习正点原子驱动所做笔记，仅供本人复习查阅使用，请勿商用</p><p>侵权删除！</p></blockquote><h2 id="1-Linux驱动的分离与分层"><a href="#1-Linux驱动的分离与分层" class="headerlink" title="1.Linux驱动的分离与分层"></a>1.Linux驱动的分离与分层</h2><h3 id="1-1-驱动的分隔和分离"><a href="#1-1-驱动的分隔和分离" class="headerlink" title="1.1 驱动的分隔和分离"></a>1.1 驱动的分隔和分离</h3><p>对于 Linux 这样一个成熟、庞大、复杂的操作系统，代码的重用性非常重要，否则的话就会在 Linux 内核中存在大量无意义的重复代码。尤其是驱动程序，因为驱动程序占用了 Linux 内核代码量的大头，如果不对驱动程序加以管理，任由重复的代码肆意增加，那么用不了多久 Linux 内核的文件数量就庞大到无法接受的地步。 </p><p>假如现在有三个平台 A、B 和 C，这三个平台(这里的平台说的是 SOC)上都有 MPU6050 这个 I2C接口的六轴传感器，按照我们写裸机 I2C 驱动的时候的思路，每个平台都有一个 MPU6050 的驱动，因此编写出来的最简单的驱动框架如图所示：</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422181633524.png" alt="image-20230422181633524" style="zoom:80%;"><p>每种平台下都有一个主机驱动和设备驱动，主机驱动肯定是必须要的，毕竟不同的平台其 I2C 控制器不同。但是右侧的设备驱动就没必要每个平台都写一个， 因为不管对于那个 SOC 来说，MPU6050 都是一样，通过 I2C 接口读写数据就行了，只需要一个 MPU6050 的驱动程序即可。如果再来几个 I2C 设备，比如 AT24C02、FT5206(电容触摸屏) 等，如果按照上图的写法，那么设备端的驱动将会重复的编写好几次。显然在 Linux 驱动程序中这种写法是不推荐的，最好的做法就是每个平台的 I2C 控制器都提供一个统一的接口 (也叫做主机驱动)，每个设备的话也只提供一个驱动程序(设备驱动)，每个设备通过统一的 I2C 接口驱动来访问，这样就可以大大简化驱动文件，比如上图中三种平台下的 MPU6050 驱动 框架就可以简化为： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422181657643.png" alt="image-20230422181657643" style="zoom:80%;"><p>这个就是驱动的分隔，也就是将主机驱动和设备驱动分隔开来，比如 I2C、SPI 等等都会采用驱动分隔的方式来简化驱动的开发。在实际的驱动开发中，一般 I2C 主机控制器驱动已经由半导体厂家编写好了，而设备驱动一般也由设备器件的厂家编写好了，我们只需要提供设备信息即可，比如 I2C 设备的话提供设备连接到了哪个 I2C 接口上，I2C 的速度是多少等等。相当于将设备信息从设备驱动中剥离开来，驱动使用标准方法去获取到设备信息(比如从设备树中获取到设备信息)，然后根据获取到的设备信息来初始化设备。 这样就相当于驱动只负责驱动，设备只负责设备，想办法将两者进行匹配即可。这个就是 Linux 中的总线(bus)、驱动(driver)和设备(device)模型，也就是常说的驱动分离。总线就是驱动和设备信息的月老，负责给两者牵线搭桥，如图所示</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422181717547.png" alt="image-20230422181717547" style="zoom:80%;"><p>当我们向系统注册一个驱动的时候，总线就会在右侧的设备中查找，看看有没有与之匹配的设备，如果有的话就将两者联系起来。同样的，当向系统中注册一个设备的时候，总线就会在左侧的驱动中查找看有没有与之匹配的设备，有的话也联系起来。Linux 内核中大量的驱动程序都采用总线、驱动和设备模式，我们一会要重点讲解的 platform 驱动就是这一思想下的产物。</p><h3 id="1-2-驱动的分层"><a href="#1-2-驱动的分层" class="headerlink" title="1.2 驱动的分层"></a>1.2 驱动的分层</h3><p>上一小节讲了驱动的分隔与分离，本节我们来简单看一下驱动的分层，大家应该听说过网络的 7 层模型，不同的层负责不同的内容。同样的，Linux 下的驱动往往也是分层的，分层的目的也是为了在不同的层处理不同的内容。以其他书籍或者资料常常使用到的input(输入子系统，后面会有专门的章节详细的讲解)为例，简单介绍一下驱动的分层。input 子系统负责管理所有跟输入有关的驱动，包括键盘、鼠标、触摸等，最底层的就是设备原始驱动，负责获取输入设备的原始值，获取到的输入事件上报给 input 核心层。input 核心层会处理各种 IO 模型，并且提供 file_operations 操作集合。我们在编写输入设备驱动的时候只需要处理好输入事件的上报即可，至于如何处理这些上报的输入事件那是上层去考虑的，我们不用管。可以看出借助分层模型可以极大的简化我们的驱动编写，对于驱动编写来说非常的友好。</p><h2 id="2-platform平台驱动模型简介"><a href="#2-platform平台驱动模型简介" class="headerlink" title="2.platform平台驱动模型简介"></a>2.platform平台驱动模型简介</h2><p>前面我们讲了设备驱动的分离，并且引出了总线(bus)、驱动(driver)和设备(device)模型，比如 I2C、SPI、USB 等总线。但是在 SOC 中有些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型该怎么办呢？为了解决此问题，Linux 提出了 platform 这个虚拟总线，相应的就有platform_driver 和 platform_device。</p><h3 id="2-1-platform总线"><a href="#2-1-platform总线" class="headerlink" title="2.1 platform总线"></a>2.1 platform总线</h3><p>Linux系统内核使用bus_type 结构体表示总线，此结构体定义在文件 include&#x2F;linux&#x2F;device.h， bus_type 结构体内容如下：</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422181844577.png" alt="image-20230422181844577" style="zoom: 80%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422181859954.png" alt="image-20230422181859954" style="zoom:80%;"><p>第 10 行，match 函数，此函数很重要，单词 match 的意思就是“匹配、相配”，因此此函数就是完成设备和驱动之间匹配的，总线就是使用 match 函数来根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备，因此每一条总线都必须实现此函数。match 函数有两个参数：dev 和 drv，这两个参数分别为 device 和 device_driver 类型，也就是设备和驱动。 </p><p>platform 总线是 bus_type 的一个具体实例，定义在文件 drivers&#x2F;base&#x2F;platform.c，platform 总线定义如下：</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422181937298.png" alt="image-20230422181937298" style="zoom:80%;"><p>platform_bus_type 就是 platform 平台总线，其中 platform_match 就是匹配函数。我们来看一下驱动和设备是如何匹配的，platform_match 函数定义在文件 drivers&#x2F;base&#x2F;platform.c 中，函数内容如下所示： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182023491.png" alt="image-20230422182023491" style="zoom: 50%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182043518.png" alt="image-20230422182043518" style="zoom:50%;"><p>驱动和设备的匹配有四种方法，我们依次来看一下： </p><ol><li>第 11~12 行，第一种匹配方式， OF 类型的匹配，也就是设备树采用的匹配方式， of_driver_match_device 函数定义在文件 include&#x2F;linux&#x2F;of_device.h 中。device_driver 结构体(表示设备驱动)中有个名为of_match_table的成员变量，此成员变量保存着驱动的compatible匹配表，设备树中的每个设备节点的 compatible 属性会和 of_match_table 表中的所有成员比较，查看是否有相同的条目，如果有的话就表示设备和此驱动匹配，设备和驱动匹配成功以后 probe 函数 就会执行。</li><li>第 15~16 行，第二种匹配方式，ACPI 匹配方式</li><li>第 19~20 行，第三种匹配方式，id_table 匹配，每个 platform_driver 结构体有一个 id_table成员变量，顾名思义，保存了很多 id 信息。这些 id 信息存放着这个 platformd 驱动所支持的驱动类型。</li><li>第 23 行，第四种匹配方式，如果第三种匹配方式的 id_table 不存在的话就直接比较驱动和设备的 name 字段，看看是不是相等，如果相等的话就匹配成功</li></ol><p>对于支持设备树的 Linux 版本号，一般设备驱动为了兼容性都支持设备树和无设备树两种匹配方式。也就是第一种匹配方式一般都会存在，第三种和第四种只要存在一种就可以，一般用的最多的还是第四种，也就是直接比较驱动和设备的 name 字段，毕竟这种方式最简单了。 </p><h3 id="2-2-platform驱动"><a href="#2-2-platform驱动" class="headerlink" title="2.2 platform驱动"></a>2.2 platform驱动</h3><p>platform_driver 结构体表示 platform驱动，此结构体定义在文件include&#x2F;linux&#x2F;platform_device.h 中，内容如下： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182124773.png" alt="image-20230422182124773" style="zoom: 50%;"><p>第 2 行，probe 函数，当驱动与设备匹配成功以后 probe 函数就会执行，非常重要的函数！！ 一般驱动的提供者会编写，如果自己要编写一个全新的驱动，那么 probe 就需要自行实现。 </p><p>第 7 行，driver 成员，为 device_driver 结构体变量，Linux 内核里面大量使用到了面向对象的思维，device_driver 相当于基类，提供了最基础的驱动框架。plaform_driver 继承了这个基类，然后在此基础上又添加了一些特有的成员变量。</p><p>第 8 行，id_table 表，也就是我们上一小节讲解 platform 总线匹配驱动和设备的时候采用的 第三种方法，id_table 是个表( 也就是数组) ，每个元素的类型为 platform_device_id， platform_device_id 结构体内容如下：</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182200143.png" alt="image-20230422182200143" style="zoom:50%;"><p>device_driver 结构体定义在 include&#x2F;linux&#x2F;device.h，device_driver 结构体内容如下： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182225859.png" alt="image-20230422182225859" style="zoom: 67%;"><p>第 10 行，of_match_table 就是采用设备树的时候驱动使用的匹配表，同样是数组，每个匹配项都为 of_device_id 结构体类型，此结构体定义在文件 include&#x2F;linux&#x2F;mod_devicetable.h 中，内容如下：</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182255603.png" alt="image-20230422182255603" style="zoom: 67%;"><p>第 4 行的 compatible 非常重要，因为对于设备树而言，就是通过设备节点的 compatible 属性值和 of_match_table 中每个项目的 compatible 成员变量进行比较，如果有相等的就表示设备和此驱动匹配成功。 </p><p>在编写 platform 驱动的时候，首先定义一个 platform_driver 结构体变量，然后实现结构体中的各个成员变量，重点是实现匹配方法以及 probe 函数。当驱动和设备匹配成功以后 probe函数就会执行，具体的驱动程序在 probe 函数里面编写，比如字符设备驱动等等。 当我们定义并初始化好 platform_driver 结构体变量以后，需要在驱动入口函数里面调用 platform_driver_register 函数向 Linux 内核注册一个 platform 驱动，platform_driver_register 函数原型如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">platform_driver_register</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_driver *driver)</span><br></code></pre></td></tr></table></figure><p><strong>driver</strong>：要注册的 platform 驱动。 </p><p><strong>返回值：</strong>负数，失败；0，成功。 </p><p>还需要在驱动卸载函数中通过 platform_driver_unregister 函数卸载 platform 驱动，platform_driver_unregister 函数原型如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">platform_driver_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_driver *drv)</span><br></code></pre></td></tr></table></figure><p><strong>drv</strong>：要卸载的 platform 驱动。 </p><p><strong>返回值：</strong>无。 </p><p>platform 驱动框架如下所示： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182725425.png" alt="image-20230422182725425" style="zoom:67%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182655339.png" alt="image-20230422182655339" style="zoom: 67%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182746084.png" alt="image-20230422182746084" style="zoom:67%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182802093.png" alt="image-20230422182802093" style="zoom:67%;"><p>第 1~27 行，传统的字符设备驱动，所谓的 platform 驱动并不是独立于字符设备驱动、块设备驱动和网络设备驱动之外的其他种类的驱动。platform 只是为了驱动的分离与分层而提出来 的一种框架，其驱动的具体实现还是需要字符设备驱动、块设备驱动或网络设备驱动。</p><p>第 33~39 行，xxx_probe 函数，当驱动和设备匹配成功以后此函数就会执行，以前在驱动入口 init 函数里面编写的字符设备驱动程序就全部放到此 probe 函数里面。比如注册字符设备驱动、添加 cdev、创建类等等。 </p><p>第 41~47 行，xxx_remove 函数，platform_driver 结构体中的 remove 成员变量，当关闭 platform 设备驱动的时候此函数就会执行，以前在驱动卸载 exit 函数里面要做的事情就放到此函数中来。 比如，使用 iounmap 释放内存、删除 cdev，注销设备号等等。 </p><p>第 50~53 行，xxx_of_match 匹配表，如果使用设备树的话将通过此匹配表进行驱动和设备的匹配。第 51 行设置了一个匹配项，此匹配项的 compatible 值为“xxx-gpio”，因此当设备树中设备节点的 compatible 属性值为“xxx-gpio”的时候此设备就会与此驱动匹配。第 52 行是一个标记，of_device_id 表最后一个匹配项必须是空的。 </p><p>第 58 ~ 65 行，定义一个 platform_driver 结构体变量 xxx_driver，表示 platform 驱动，第 59 ~ 62行设置 paltform_driver 中的 device_driver 成员变量的 name 和 of_match_table 这两个属性。其中name 属性用于传统的驱动与设备匹配，也就是检查驱动和设备的 name 字段是不是相同。of_match_table 属性就是用于设备树下的驱动与设备检查。对于一个完整的驱动程序，必须提供有设备树和无设备树两种匹配方法。最后 63 和 64 这两行设置 probe 和 remove 这两成员变量。 </p><p>第68~71行，驱动入口函数，调用platform_driver_register函数向Linux内核注册一个platform驱动，也就是上面定义的 xxx_driver 结构体变量。 </p><p>第 74~77 行，驱动出口函数，调用 platform_driver_unregister 函数卸载前面注册的 platform驱动。</p><p>总体来说，platform 驱动还是传统的字符设备驱动、块设备驱动或网络设备驱动，只是套上了一张“platform”的皮，目的是为了使用总线、驱动和设备这个驱动模型来实现驱动的分离与分层。</p><h3 id="2-3-platform设备"><a href="#2-3-platform设备" class="headerlink" title="2.3 platform设备"></a>2.3 platform设备</h3><p>platform 驱动已经准备好了，我们还需要 platform 设备，否则的话单单一个驱动也做不了什么。platform_device 这个结构体表示 platform 设备，这里我们要注意，如果内核支持设备树的话就不要再使用 platform_device 来描述设备了，因为改用设备树去描述了。当然了，你如果 一定要用 platform_device 来描述设备信息的话也是可以的。platform_device 结构体定义在文件 include&#x2F;linux&#x2F;platform_device.h 中，结构体内容如下： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182845233.png" alt="image-20230422182845233" style="zoom:67%;"><p>第 23 行，name 表示设备名字，要和所使用的 platform 驱动的 name 字段相同，否则的话设备就无法匹配到对应的驱动。比如对应的 platform 驱动的 name 字段为“xxx-gpio”，那么此 name字段也要设置为“xxx-gpio”。 </p><p>第 27 行，num_resources 表示资源数量，一般为第 28 行 resource 资源的大小。 </p><p>第 28 行，resource 表示资源，也就是设备信息，比如外设寄存器等。Linux 内核使用 resource结构体表示资源，resource 结构体内容如下： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182902179.png" alt="image-20230422182902179" style="zoom:67%;"><p>start 和 end 分别表示资源的起始和终止信息，对于内存类的资源，就表示内存起始和终止地址，name 表示资源名字，flags 表示资源类型，可选的资源类型都定义在了文件include&#x2F;linux&#x2F;ioport.h 里面，如下所示： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182933077.png" alt="image-20230422182933077" style="zoom:67%;"><p>在以前不支持设备树的Linux版本中，用户需要编写platform_device变量来描述设备信息， 然后使用 platform_device_register 函数将设备信息注册到 Linux 内核中，此函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">platform_device_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span> <br></code></pre></td></tr></table></figure><p><strong>pdev</strong>：要注册的 platform 设备。 </p><p><strong>返回值：</strong>负数，失败；0，成功</p><p>如果不再使用 platform 的话可以通过 platform_device_unregister 函数注销掉相应的 platform 设备，platform_device_unregister 函数原型如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">platform_device_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span><br></code></pre></td></tr></table></figure><p><strong>pdev</strong>：要注销的 platform 设备。 </p><p><strong>返回值：</strong>无。 </p><p>platform 设备信息框架如下所示： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422183014879.png" alt="image-20230422183014879" style="zoom:67%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422183030672.png" alt="image-20230422183030672" style="zoom:67%;"><p>第 7~18 行，数组 xxx_resources 表示设备资源，一共有两个资源，分别为设备外设 1 和外设 2 的寄存器信息。因此 flags 都为 IORESOURCE_MEM，表示资源为内存类型的。 </p><p>第 21~26 行，platform 设备结构体变量，注意 name 字段要和所使用的驱动中的 name 字段一致，否则驱动和设备无法匹配成功。num_resources 表示资源大小，其实就是数组 xxx_resources的元素数量，这里用 ARRAY_SIZE 来测量一个数组的元素个数。 </p><p>第 29~32 行，设备模块加载函数，在此函数中调用 platform_device_register 向 Linux 内核注册 platform 设备。</p><p>第 35~38 行，设备模块卸载函数，在此函数中调用 platform_device_unregister 从 Linux 内核中卸载 platform 设备。</p><p>示例代码主要是在不支持设备树的 Linux 版本中使用的，当 Linux 内核支持了设备树以后就不需要用户手动去注册 platform 设备了。因为设备信息都放到了设备树中去描述， Linux 内核启动的时候会从设备树中读取设备信息，然后将其组织成 platform_device 形式，至于设备树到 platform_device 的具体过程就不去详细的追究了，感兴趣的可以去看一下，网上也有很多博客详细的讲解了整个过程。</p><p>关于 platform 下的总线、驱动和设备就讲解到这里，我们接下来就使用 platform 驱动框架来编写一个 LED 灯驱动，本章我们不使用设备树来描述设备信息，我们采用自定义platform_device这种“古老”方式来编写LED的设备信息。下一章我们来编写设备树下的platform驱动，这样我们就掌握了无设备树和有设备树这两种 platform 驱动的开发方式。</p><h2 id="3-实验程序编写"><a href="#3-实验程序编写" class="headerlink" title="3.实验程序编写"></a>3.实验程序编写</h2><h3 id="3-1-无设备树的platform驱动编写"><a href="#3-1-无设备树的platform驱动编写" class="headerlink" title="3.1 无设备树的platform驱动编写"></a>3.1 无设备树的platform驱动编写</h3><p>新建名为 leddevice.c 和 leddriver.c 这两个文件，这两个文件分别为 LED 灯的 platform 设备文件和 LED 灯的 platform 的驱动文件</p><p><code>leddevice.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 寄存器地址定义</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CCM_CCGR1_BASE              (0X020C406C)        </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_MUX_GPIO1_IO03_BASE      (0X020E0068)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_PAD_GPIO1_IO03_BASE      (0X020E02F4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_DR_BASE               (0X0209C000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_GDIR_BASE             (0X0209C004)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REGISTER_LENGTH             4</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br>        printk(<span class="hljs-string">&quot;led device released!\r\n&quot;</span>);        <br>&#125;<br><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * 设备资源信息，也就是LED0所使用的所有寄存器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> <span class="hljs-title">led_resources</span>[] =</span> &#123;<br>        [<span class="hljs-number">0</span>] = &#123;<br>                .start         = CCM_CCGR1_BASE,<br>                .end         = (CCM_CCGR1_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<br>                .flags         = IORESOURCE_MEM,<br>        &#125;,        <br>        [<span class="hljs-number">1</span>] = &#123;<br>                .start        = SW_MUX_GPIO1_IO03_BASE,<br>                .end        = (SW_MUX_GPIO1_IO03_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<br>                .flags        = IORESOURCE_MEM,<br>        &#125;,<br>        [<span class="hljs-number">2</span>] = &#123;<br>                .start        = SW_PAD_GPIO1_IO03_BASE,<br>                .end        = (SW_PAD_GPIO1_IO03_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<br>                .flags        = IORESOURCE_MEM,<br>        &#125;,<br>        [<span class="hljs-number">3</span>] = &#123;<br>                .start        = GPIO1_DR_BASE,<br>                .end        = (GPIO1_DR_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<br>                .flags        = IORESOURCE_MEM,<br>        &#125;,<br>        [<span class="hljs-number">4</span>] = &#123;<br>                .start        = GPIO1_GDIR_BASE,<br>                .end        = (GPIO1_GDIR_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<br>                .flags        = IORESOURCE_MEM,<br>        &#125;,<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * platform设备结构体 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> <span class="hljs-title">leddevice</span> =</span> &#123;<br>        .name = <span class="hljs-string">&quot;imx6ul-amx-led&quot;</span>,<br>        .id = <span class="hljs-number">-1</span>,<br>        .dev = &#123;<br>                .release = &amp;led_release,<br>        &#125;,<br>        .num_resources = ARRAY_SIZE(led_resources),<br>        .resource = led_resources,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">leddevice_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-keyword">return</span> platform_device_register(&amp;leddevice);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">leddevice_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        platform_device_unregister(&amp;leddevice);<br>&#125;<br><br>module_init(leddevice_init);<br>module_exit(leddevice_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;anmuxixixi&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>leddriver.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_CNT      1           <span class="hljs-comment">/* 设备号长度         */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_NAME     <span class="hljs-string">&quot;platled&quot;</span>   <span class="hljs-comment">/* 设备名字         */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF          0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON           1</span><br><br><span class="hljs-comment">/* 寄存器名 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *IMX6U_CCM_CCGR1;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_MUX_GPIO1_IO03;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_PAD_GPIO1_IO03;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_DR;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_GDIR;<br><br><span class="hljs-comment">/* leddev设备结构体 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span>&#123;</span><br>        <span class="hljs-type">dev_t</span> devid;                        <span class="hljs-comment">/* 设备号 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>                <span class="hljs-comment">/* cdev */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>        <span class="hljs-comment">/* 类 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>        <span class="hljs-comment">/* 设备 */</span><br>        <span class="hljs-type">int</span> major;                                <span class="hljs-comment">/* 主设备号 */</span>                <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span> <span class="hljs-title">leddev</span>;</span>         <span class="hljs-comment">/* led设备 */</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">led0_switch</span><span class="hljs-params">(u8 sta)</span><br>&#123;<br>        u32 val = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(sta == LEDON)&#123;<br>                val = readl(GPIO1_DR);<br>                val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);        <br>                writel(val, GPIO1_DR);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sta == LEDOFF)&#123;<br>                val = readl(GPIO1_DR);<br>                val|= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);        <br>                writel(val, GPIO1_DR);<br>        &#125;        <br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>        filp-&gt;private_data = &amp;leddev; <span class="hljs-comment">/* 设置私有数据  */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>&#123;<br>        <span class="hljs-type">int</span> retvalue;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ledstat;<br><br>        retvalue = copy_from_user(databuf, buf, cnt);<br>        <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> -EFAULT;<br>        &#125;<br><br>        ledstat = databuf[<span class="hljs-number">0</span>];                <span class="hljs-comment">/* 获取状态值 */</span><br>        <span class="hljs-keyword">if</span>(ledstat == LEDON) &#123;<br>                led0_switch(LEDON);                <span class="hljs-comment">/* 打开LED灯 */</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ledstat == LEDOFF) &#123;<br>                led0_switch(LEDOFF);        <span class="hljs-comment">/* 关闭LED灯 */</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">led_fops</span> =</span> &#123;<br>        .owner = THIS_MODULE,<br>        .open = led_open,<br>        .write = led_write,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span><br>&#123;        <br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ressize[<span class="hljs-number">5</span>];<br>        u32 val = <span class="hljs-number">0</span>;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">ledsource</span>[5];</span><br><br>        printk(<span class="hljs-string">&quot;led driver and device has matched!\r\n&quot;</span>);<br>        <span class="hljs-comment">/* 1、获取资源 */</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                ledsource[i] = platform_get_resource(dev, IORESOURCE_MEM, i); <span class="hljs-comment">/* 依次MEM类型资源 */</span><br>                <span class="hljs-keyword">if</span> (!ledsource[i]) &#123;<br>                        dev_err(&amp;dev-&gt;dev, <span class="hljs-string">&quot;No MEM resource for always on\n&quot;</span>);<br>                        <span class="hljs-keyword">return</span> -ENXIO;<br>                &#125;<br>                ressize[i] = resource_size(ledsource[i]);        <br>        &#125;        <br><br>        <span class="hljs-comment">/* 2、初始化LED */</span><br>        <span class="hljs-comment">/* 寄存器地址映射 */</span><br>         IMX6U_CCM_CCGR1 = ioremap(ledsource[<span class="hljs-number">0</span>]-&gt;start, ressize[<span class="hljs-number">0</span>]);<br>        SW_MUX_GPIO1_IO03 = ioremap(ledsource[<span class="hljs-number">1</span>]-&gt;start, ressize[<span class="hljs-number">1</span>]);<br>          SW_PAD_GPIO1_IO03 = ioremap(ledsource[<span class="hljs-number">2</span>]-&gt;start, ressize[<span class="hljs-number">2</span>]);<br>        GPIO1_DR = ioremap(ledsource[<span class="hljs-number">3</span>]-&gt;start, ressize[<span class="hljs-number">3</span>]);<br>        GPIO1_GDIR = ioremap(ledsource[<span class="hljs-number">4</span>]-&gt;start, ressize[<span class="hljs-number">4</span>]);<br>        <br>        val = readl(IMX6U_CCM_CCGR1);<br>        val &amp;= ~(<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);                                <span class="hljs-comment">/* 清除以前的设置 */</span><br>        val |= (<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);                                <span class="hljs-comment">/* 设置新值 */</span><br>        writel(val, IMX6U_CCM_CCGR1);<br><br>        <span class="hljs-comment">/* 设置GPIO1_IO03复用功能，将其复用为GPIO1_IO03 */</span><br>        writel(<span class="hljs-number">5</span>, SW_MUX_GPIO1_IO03);<br>        writel(<span class="hljs-number">0x10B0</span>, SW_PAD_GPIO1_IO03);<br><br>        <span class="hljs-comment">/* 设置GPIO1_IO03为输出功能 */</span><br>        val = readl(GPIO1_GDIR);<br>        val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);                        <span class="hljs-comment">/* 清除以前的设置 */</span><br>        val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);                        <span class="hljs-comment">/* 设置为输出 */</span><br>        writel(val, GPIO1_GDIR);<br><br>        <span class="hljs-comment">/* 默认关闭LED1 */</span><br>        val = readl(GPIO1_DR);<br>        val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>) ;        <br>        writel(val, GPIO1_DR);<br>        <br>        <span class="hljs-comment">/* 注册字符设备驱动 */</span><br>        <span class="hljs-comment">/*1、创建设备号 */</span><br>        <span class="hljs-keyword">if</span> (leddev.major) &#123;                <span class="hljs-comment">/*  定义了设备号 */</span><br>                leddev.devid = MKDEV(leddev.major, <span class="hljs-number">0</span>);<br>                register_chrdev_region(leddev.devid, LEDDEV_CNT, LEDDEV_NAME);<br>        &#125; <span class="hljs-keyword">else</span> &#123;                                                <span class="hljs-comment">/* 没有定义设备号 */</span><br>                alloc_chrdev_region(&amp;leddev.devid, <span class="hljs-number">0</span>, LEDDEV_CNT, LEDDEV_NAME);        <span class="hljs-comment">/* 申请设备号 */</span><br>                leddev.major = MAJOR(leddev.devid);        <span class="hljs-comment">/* 获取分配号的主设备号 */</span><br>        &#125;<br>        <br>        <span class="hljs-comment">/* 2、初始化cdev */</span><br>        leddev.cdev.owner = THIS_MODULE;<br>        cdev_init(&amp;leddev.cdev, &amp;led_fops);<br>        <br>        <span class="hljs-comment">/* 3、添加一个cdev */</span><br>        cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);<br><br>        <span class="hljs-comment">/* 4、创建类 */</span><br>        leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);<br>        <span class="hljs-keyword">if</span> (IS_ERR(leddev.class)) &#123;<br>                <span class="hljs-keyword">return</span> PTR_ERR(leddev.class);<br>        &#125;<br><br>        <span class="hljs-comment">/* 5、创建设备 */</span><br>        leddev.device = device_create(leddev.class, <span class="hljs-literal">NULL</span>, leddev.devid, <span class="hljs-literal">NULL</span>, LEDDEV_NAME);<br>        <span class="hljs-keyword">if</span> (IS_ERR(leddev.device)) &#123;<br>                <span class="hljs-keyword">return</span> PTR_ERR(leddev.device);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span><br>&#123;<br>    <span class="hljs-comment">/* 取消虚拟地址映射 */</span><br>        iounmap(IMX6U_CCM_CCGR1);<br>        iounmap(SW_MUX_GPIO1_IO03);<br>        iounmap(SW_PAD_GPIO1_IO03);<br>        iounmap(GPIO1_DR);<br>        iounmap(GPIO1_GDIR);<br><br>        cdev_del(&amp;leddev.cdev); <span class="hljs-comment">/* 删除cdev */</span><br>        unregister_chrdev_region(leddev.devid, LEDDEV_CNT); <span class="hljs-comment">/* 注销设备号 */</span><br>        device_destroy(leddev.class, leddev.devid);<br>        class_destroy(leddev.class);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* platform驱动结构体 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">led_driver</span> =</span> &#123;<br>        .driver                = &#123;<br>                .name        = <span class="hljs-string">&quot;imx6ul-amx-led&quot;</span>,      <span class="hljs-comment">/* 驱动名字，用于和设备匹配 */</span><br>        &#125;,<br>        .probe                = led_probe,<br>        .remove                = led_remove,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">leddriver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-keyword">return</span> platform_driver_register(&amp;led_driver);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">leddriver_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        platform_driver_unregister(&amp;led_driver);<br>&#125;<br><br>module_init(leddriver_init);<br>module_exit(leddriver_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;anmuxixixi&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>platledAPP.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fcntl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF         0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON         1</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description          : main主程序</span><br><span class="hljs-comment"> * @param - argc         : argv数组元素个数</span><br><span class="hljs-comment"> * @param - argv         : 具体参数</span><br><span class="hljs-comment"> * @return               : 0 成功;其他 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>        <span class="hljs-type">int</span> fd, retvalue;<br>        <span class="hljs-type">char</span> *filename;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">2</span>];<br>        <br>        <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Usage!\r\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        filename = argv[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">/* 打开led驱动 */</span><br>        fd = open(filename, O_RDWR);<br>        <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file %s open failed!\r\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <br>        databuf[<span class="hljs-number">0</span>] = atoi(argv[<span class="hljs-number">2</span>]);        <span class="hljs-comment">/* 要执行的操作：打开或关闭 */</span><br>        retvalue = write(fd, databuf, <span class="hljs-keyword">sizeof</span>(databuf));<br>        <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LED Control Failed!\r\n&quot;</span>);<br>                close(fd);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        retvalue = close(fd); <span class="hljs-comment">/* 关闭文件 */</span><br>        <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file %s close failed!\r\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/f557da58-4767-47d8-8f40-51ff98a7debb.png" alt="image-20230422183030672" style="zoom:67%;"><h3 id="3-2-设备树下的platform驱动编写"><a href="#3-2-设备树下的platform驱动编写" class="headerlink" title="3.2 设备树下的platform驱动编写"></a>3.2 设备树下的platform驱动编写</h3><p><strong>1、在设备树中创建设备节点</strong></p><p>直接使用<code>7.4.1</code>中的设备树</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/267c8f85-c684-44e6-aacb-f3456432144d.png" alt="image-20230422183030672" style="zoom:67%;"><p>注意compatible 属性值为“fsl,gpioled”，因此一会在编写 platform 驱动的时候 of_match_table 属性表中要有“fsl,gpioled”。 </p><p><strong>2、编写 platform 驱动的时候要注意兼容属性</strong></p><p>上一章已经详细的讲解过了，在使用设备树的时候 platform 驱动会通过 of_match_table 来 保存兼容性值，也就是表明此驱动兼容哪些设备。所以，of_match_table 将会尤为重要，比如本例程的 platform 驱动中 platform_driver 就可以按照如下所示设置：</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422183516606.png" alt="image-20230422183516606" style="zoom:80%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422183536714.png" alt="image-20230422183536714" style="zoom:80%;"><p>第 1~4 行，of_device_id 表，也就是驱动的兼容表，是一个数组，每个数组元素为 of_device_id 类型。每个数组元素都是一个兼容属性，表示兼容的设备，一个驱动可以跟多个设备匹配。这里我们仅仅匹配了一个设备，那创建的 gpioled 这个设备。第 2 行的 compatible 值为“atkalpha-gpioled”，驱动中的 compatible 属性和设备中的 compatible 属性相匹配，因此驱动中对应的 probe 函数就会执行。注意第 3 行是一个空元素，在编写 of_device_id 的时候最后一个元素一定要为空！ </p><p>第 6 行，通过 MODULE_DEVICE_TABLE 声明一下 leds_of_match 这个设备匹配表。 </p><p>第 11 行，设置 platform_driver 中的 of_match_table 匹配表为上面创建的 leds_of_match，至此我们就设置好了 platform 驱动的匹配表了。</p><p><strong>3、编写 platform 驱动</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_CNT                 1               <span class="hljs-comment">/* 设备号长度 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_NAME                <span class="hljs-string">&quot;dtsplatled&quot;</span>    <span class="hljs-comment">/* 设备名字 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF                     0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON                      1</span><br><br><span class="hljs-comment">/* leddev设备结构体 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span>&#123;</span><br>        <span class="hljs-type">dev_t</span> devid;                                <span class="hljs-comment">/* 设备号 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>                        <span class="hljs-comment">/* cdev */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>                <span class="hljs-comment">/* 类 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>                <span class="hljs-comment">/* 设备 */</span><br>        <span class="hljs-type">int</span> major;                                        <span class="hljs-comment">/* 主设备号 */</span>        <br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">node</span>;</span>        <span class="hljs-comment">/* LED设备节点 */</span><br>        <span class="hljs-type">int</span> led0;                                        <span class="hljs-comment">/* LED灯GPIO标号 */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span> <span class="hljs-title">leddev</span>;</span>                 <span class="hljs-comment">/* led设备 */</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">led0_switch</span><span class="hljs-params">(u8 sta)</span><br>&#123;<br>        <span class="hljs-keyword">if</span> (sta == LEDON )<br>        gpio_set_value(leddev.led0, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sta == LEDOFF)<br>                gpio_set_value(leddev.led0, <span class="hljs-number">1</span>);        <br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>        filp-&gt;private_data = &amp;leddev; <span class="hljs-comment">/* 设置私有数据  */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>&#123;<br>        <span class="hljs-type">int</span> retvalue;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ledstat;<br><br>        retvalue = copy_from_user(databuf, buf, cnt);<br>        <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;<br><br>                printk(<span class="hljs-string">&quot;kernel write failed!\r\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> -EFAULT;<br>        &#125;<br>        <br>        ledstat = databuf[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (ledstat == LEDON) &#123;<br>                led0_switch(LEDON);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ledstat == LEDOFF) &#123;<br>                led0_switch(LEDOFF);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">led_fops</span> =</span> &#123;<br>        .owner = THIS_MODULE,<br>        .open = led_open,<br>        .write = led_write,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span><br>&#123;        <br>        printk(<span class="hljs-string">&quot;led driver and device was matched!\r\n&quot;</span>);<br>        <span class="hljs-comment">/* 1、设置设备号 */</span><br>        <span class="hljs-keyword">if</span> (leddev.major) &#123;<br>                leddev.devid = MKDEV(leddev.major, <span class="hljs-number">0</span>);<br>                register_chrdev_region(leddev.devid, LEDDEV_CNT, LEDDEV_NAME);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                alloc_chrdev_region(&amp;leddev.devid, <span class="hljs-number">0</span>, LEDDEV_CNT, LEDDEV_NAME);<br>                leddev.major = MAJOR(leddev.devid);<br>        &#125;<br><br>        <span class="hljs-comment">/* 2、注册设备 */</span><br>        cdev_init(&amp;leddev.cdev, &amp;led_fops);<br>        cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);<br><br>        <span class="hljs-comment">/* 3、创建类 */</span><br>        leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);<br>        <span class="hljs-keyword">if</span> (IS_ERR(leddev.class)) &#123;<br>                <span class="hljs-keyword">return</span> PTR_ERR(leddev.class);<br>        &#125;<br><br>        <span class="hljs-comment">/* 4、创建设备 */</span><br>        leddev.device = device_create(leddev.class, <span class="hljs-literal">NULL</span>, leddev.devid, <span class="hljs-literal">NULL</span>, LEDDEV_NAME);<br>        <span class="hljs-keyword">if</span> (IS_ERR(leddev.device)) &#123;<br>                <span class="hljs-keyword">return</span> PTR_ERR(leddev.device);<br>        &#125;<br><br>        <span class="hljs-comment">/* 5、初始化IO */</span><br>        leddev.node = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);<br>        <span class="hljs-keyword">if</span> (leddev.node == <span class="hljs-literal">NULL</span>)&#123;<br>                printk(<span class="hljs-string">&quot;gpioled node nost find!\r\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> -EINVAL;<br>        &#125; <br>        <br>        leddev.led0 = of_get_named_gpio(leddev.node, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (leddev.led0 &lt; <span class="hljs-number">0</span>) &#123;<br>                printk(<span class="hljs-string">&quot;can&#x27;t get led-gpio\r\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> -EINVAL;<br>        &#125;<br><br>        gpio_request(leddev.led0, <span class="hljs-string">&quot;led0&quot;</span>);<br>        gpio_direction_output(leddev.led0, <span class="hljs-number">1</span>); <span class="hljs-comment">/* led0 IO设置为输出，默认高电平        */</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span><br>&#123;<br>        printk(<span class="hljs-string">&quot;led remove\r\n&quot;</span>);<br>        gpio_set_value(leddev.led0, <span class="hljs-number">1</span>);         <span class="hljs-comment">/* 卸载驱动的时候关闭LED */</span><br>        gpio_free(leddev.led0);                                <span class="hljs-comment">/* 释放IO */</span><br><br>        cdev_del(&amp;leddev.cdev);                                <span class="hljs-comment">/*  删除cdev */</span><br>        unregister_chrdev_region(leddev.devid, LEDDEV_CNT); <span class="hljs-comment">/* 注销设备号 */</span><br>        device_destroy(leddev.class, leddev.devid);<br>        class_destroy(leddev.class);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 匹配列表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">led_of_match</span>[] =</span> &#123;<br>        &#123; .compatible = <span class="hljs-string">&quot;fsl,gpioled&quot;</span>&#125;,<br>        &#123; <span class="hljs-comment">/* Sentinel */</span> &#125;,<br>&#125;;<br><br><span class="hljs-comment">/* platform驱动结构体 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">led_driver</span> =</span> &#123;<br>        .driver = &#123;<br>                .name = <span class="hljs-string">&quot;imx6ul-amx-led&quot;</span>,      <span class="hljs-comment">/* 驱动名字，用于和设备匹配 */</span><br>                .of_match_table = led_of_match, <span class="hljs-comment">/* 设备树匹配表 */</span><br>        &#125;,<br>        .probe = led_probe,<br>        .remove = led_remove,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">dtsleddriver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-keyword">return</span> platform_driver_register(&amp;led_driver);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">dtsleddriver_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        platform_driver_unregister(&amp;led_driver);<br>&#125;<br><br>module_init(dtsleddriver_init);<br>module_exit(dtsleddriver_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;anmuxixixi&quot;</span>);<br></code></pre></td></tr></table></figure><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/fde6442f-8f21-42ad-9a4d-c5e7f2f9d54e.png" alt="image-20230422183030672" style="zoom:67%;">]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
      <category>linux驱动</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux设备模型之二:sysfs</title>
    <link href="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%BA%8C-sysfs/"/>
    <url>/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%BA%8C-sysfs/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux设备模型之二-sysfs"><a href="#Linux设备模型之二-sysfs" class="headerlink" title="Linux设备模型之二:sysfs"></a>Linux设备模型之二:sysfs</h1><blockquote><p>转载自：<a href="http://www.wowotech.net/device_model/dm_sysfs.html">http://www.wowotech.net/device_model/dm_sysfs.html</a></p><p>作为自己的学习笔记</p></blockquote><p><strong>Sysfs</strong> 是Linux 2.6所提供的一种虚拟文件系统。这个文件系统不仅可以把设备（devices）和驱动程序（drivers）的信息从内核输出到用户空间，也可以用来对设备和驱动程序做设置。</p><h2 id="1-初识sys-文件系统"><a href="#1-初识sys-文件系统" class="headerlink" title="1.初识sys 文件系统"></a>1.初识sys 文件系统</h2><p>简单的说，sysfs是一个基于内存的文件系统，它的作用是将内核信息以文件的方式提供给用户程序使用。</p><p>sysfs可以看成与proc,devfs和devpty同类别的文件系统，该文件系统是虚拟的文件系统，可以更方便对系统设备进行管理。它可以产生一个包含所有系统硬件层次视图，与提供进程和状态信息的proc文件系统十分类似。</p><p>sysfs把连接在系统上的设备和总线组织成为一个分级的文件，它们可以由用户空间存取，向用户空间导出内核的数据结构以及它们的属性。sysfs的一个目的就是展示设备驱动模型中各组件的层次关系，其顶级目录包括block,bus,drivers,class,power和firmware等.</p><p>sysfs提供一种机制，使得可以显式的描述内核对象、对象属性及对象间关系。sysfs有两组接口，一组针对内核，用于将设备映射到文件系统中，另一组针对用户程序，用于读取或操作这些设备。下表描述了内核中的sysfs要素及其在用户空间的表现：</p><img src="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%BA%8C-sysfs/image-20230416210112684.png" alt="image-20230416210112684" style="zoom:80%;"><h2 id="2-sysfs-与-x2F-sys"><a href="#2-sysfs-与-x2F-sys" class="headerlink" title="2.sysfs 与 &#x2F;sys"></a>2.sysfs 与 &#x2F;sys</h2><p>sysfs 文件系统总是被挂载在 &#x2F;sys 挂载点上。虽然在较早期的2.6内核系统上并没有规定 sysfs 的标准挂载位置，可以把 sysfs 挂载在任何位置，但较近的2.6内核修正了这一规则，要求 <strong>sysfs 总是挂载在 &#x2F;sys 目录</strong>上。</p><img src="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%BA%8C-sysfs/webp" alt="img" style="zoom:100%;"><h2 id="3-sysfs和Kobject的关系"><a href="#3-sysfs和Kobject的关系" class="headerlink" title="3.sysfs和Kobject的关系"></a>3.sysfs和Kobject的关系</h2><p>每一个Kobject，都会对应sysfs中的一个目录。因此在将Kobject添加到Kernel时，create_dir接口会调用sysfs文件系统的创建目录接口，创建和Kobject对应的目录，相关的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//lib/kobject.c </span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">create_dir</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobj)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span> *<span class="hljs-title">ktype</span> =</span> get_ktype(kobj);<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_ns_type_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">int</span> error;<br><br>error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj));<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br><br>error = populate_dir(kobj);<br><span class="hljs-keyword">if</span> (error) &#123;<br>sysfs_remove_dir(kobj);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br><br><span class="hljs-keyword">if</span> (ktype) &#123;<br>error = sysfs_create_groups(kobj, ktype-&gt;default_groups);<br><span class="hljs-keyword">if</span> (error) &#123;<br>sysfs_remove_dir(kobj);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @kobj-&gt;sd may be deleted by an ancestor going away.  Hold an</span><br><span class="hljs-comment"> * extra reference so that it stays until @kobj is gone.</span><br><span class="hljs-comment"> */</span><br>sysfs_get(kobj-&gt;sd);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If @kobj has ns_ops, its children need to be filtered based on</span><br><span class="hljs-comment"> * their namespace tags.  Enable namespace support on @kobj-&gt;sd.</span><br><span class="hljs-comment"> */</span><br>ops = kobj_child_ns_ops(kobj);<br><span class="hljs-keyword">if</span> (ops) &#123;<br>BUG_ON(ops-&gt;type &lt;= KOBJ_NS_TYPE_NONE);<br>BUG_ON(ops-&gt;type &gt;= KOBJ_NS_TYPES);<br>BUG_ON(!kobj_ns_type_registered(ops-&gt;type));<br><br>sysfs_enable_ns(kobj-&gt;sd);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-attribute"><a href="#4-attribute" class="headerlink" title="4.attribute"></a>4.attribute</h2><h3 id="4-1-attribute的功能概述"><a href="#4-1-attribute的功能概述" class="headerlink" title="4.1 attribute的功能概述"></a>4.1 attribute的功能概述</h3><p>在sysfs中，为什么会有attribute的概念呢？其实它是对应kobject而言的，指的是kobject的“属性”。我们知道，sysfs中的目录描述了kobject，而kobject是特定数据类型变量（如struct device）的体现。因此kobject的属性，就是这些变量的属性。它可以是任何东西，名称、一个内部变量、一个字符串等等。而attribute，在sysfs文件系统中是以文件的形式提供的，即：kobject的所有属性，都在它对应的sysfs目录下以文件的形式呈现。这些文件一般是可读、写的，而kernel中定义了这些属性的模块，会根据用户空间的读写操作，记录和返回这些attribute的值。</p><p><strong>总结一下：所谓的attibute，就是内核空间和用户空间进行信息交互的一种方法。例如某个driver定义了一个变量，却希望用户空间程序可以修改该变量，以控制driver的运行行为，那么就可以将该变量以sysfs attribute的形式开放出来。</strong></p><p>Linux内核中，attribute分为普通的attribute和二进制attribute，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//include/linux/sysfs.h </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;<br><span class="hljs-type">umode_t</span>mode;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="hljs-type">bool</span>ignore_lockdep:<span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span>*<span class="hljs-title">key</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span><span class="hljs-title">skey</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bin_attribute</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span><span class="hljs-title">attr</span>;</span><br><span class="hljs-type">size_t</span>size;<br><span class="hljs-type">void</span>*private;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *(*<span class="hljs-title">f_mapping</span>)(<span class="hljs-title">void</span>);</span><br><span class="hljs-type">ssize_t</span> (*read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> kobject *, <span class="hljs-keyword">struct</span> bin_attribute *,<br><span class="hljs-type">char</span> *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">size_t</span>);<br><span class="hljs-type">ssize_t</span> (*write)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> kobject *, <span class="hljs-keyword">struct</span> bin_attribute *,<br> <span class="hljs-type">char</span> *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">size_t</span>);<br><span class="hljs-type">int</span> (*mmap)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> kobject *, <span class="hljs-keyword">struct</span> bin_attribute *attr,<br>    <span class="hljs-keyword">struct</span> vm_area_struct *vma);<br>&#125;;<br></code></pre></td></tr></table></figure><p>struct attribute为普通的attribute，使用该attribute生成的sysfs文件，只能用字符串的形式读写（后面会说为什么）。而struct bin_attribute在struct attribute的基础上，增加了read、write等函数，因此它所生成的sysfs文件可以用任何方式读写。</p><p>说完基本概念，我们要问两个问题：</p><ul><li>Kernel怎么把attribute变成sysfs中的文件呢？</li><li>用户空间对sysfs的文件进行的读写操作，怎么传递给Kernel呢？</li></ul><p>下面来看看这个过程。</p><h3 id="4-2-attibute文件的创建"><a href="#4-2-attibute文件的创建" class="headerlink" title="4.2 attibute文件的创建"></a>4.2 attibute文件的创建</h3><p>在linux内核中，attibute文件的创建是由fs&#x2F;sysfs&#x2F;dir.c 中sysfs_create_dir_ns接口完成的，该接口的实现没有什么特殊之处，大多是文件系统相关的操作，和设备模型没有太多的关系，这里先略过不提。</p><h3 id="4-3-attibute文件的read和write"><a href="#4-3-attibute文件的read和write" class="headerlink" title="4.3 attibute文件的read和write"></a>4.3 attibute文件的read和write</h3><p>看到4.1章节struct attribute的原型时，也许我们会犯嘀咕，该结构很简单啊，name表示文件名称，mode表示文件模式，其它的字段都是内核用于debug Kernel Lock的，那文件操作的接口在哪里呢？</p><p>不着急，我们去fs&#x2F;sysfs目录下看看sysfs相关的代码逻辑。</p><p>所有的文件系统，都会定义一个struct file_operations变量，用于描述本文件系统的操作接口，sysfs也不例外：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* kernfs read callback for regular sysfs files with pre-alloc */</span><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sysfs_kf_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kernfs_open_file *of, <span class="hljs-type">char</span> *buf,</span><br><span class="hljs-params">     <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> pos)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span> *<span class="hljs-title">ops</span> =</span> sysfs_file_ops(of-&gt;kn);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> *<span class="hljs-title">kobj</span> =</span> of-&gt;kn-&gt;parent-&gt;priv;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If buf != of-&gt;prealloc_buf, we don&#x27;t know how</span><br><span class="hljs-comment"> * large it is, so cannot safely pass it to -&gt;show</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (pos || WARN_ON_ONCE(buf != of-&gt;prealloc_buf))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> ops-&gt;show(kobj, of-&gt;kn-&gt;priv, buf);<br>&#125;<br><br><span class="hljs-comment">/* kernfs write callback for regular sysfs files */</span><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sysfs_kf_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kernfs_open_file *of, <span class="hljs-type">char</span> *buf,</span><br><span class="hljs-params">      <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> pos)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span> *<span class="hljs-title">ops</span> =</span> sysfs_file_ops(of-&gt;kn);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> *<span class="hljs-title">kobj</span> =</span> of-&gt;kn-&gt;parent-&gt;priv;<br><br><span class="hljs-keyword">if</span> (!count)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span> ops-&gt;store(kobj, of-&gt;kn-&gt;priv, buf, count);<br>&#125;<br></code></pre></td></tr></table></figure><p>attribute文件的read操作，会由VFS转到sysfs_file_operations的read（也就是sysfs_read_file）接口上，让我们大概看一下该接口的处理逻辑。</p><h2 id="5-sysfs在设备模型中的应用总结"><a href="#5-sysfs在设备模型中的应用总结" class="headerlink" title="5.sysfs在设备模型中的应用总结"></a>5.sysfs在设备模型中的应用总结</h2><p>让我们通过设备模型class.c中有关sysfs的实现，来总结一下sysfs的应用方式。</p><p>首先，在class.c中，定义了Class所需的ktype以及sysfs_ops类型的变量，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//drivers/base/class.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span> <span class="hljs-title">class_sysfs_ops</span> =</span> &#123;<br>.show   = class_attr_show,<br>.store   = class_attr_store,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span> <span class="hljs-title">class_ktype</span> =</span> &#123;<br>.sysfs_ops= &amp;class_sysfs_ops,<br>.release= class_release,<br>.child_ns_type= class_child_ns_type,<br>&#125;;<br></code></pre></td></tr></table></figure><p>所有class_type的Kobject下面的attribute文件的读写操作，都会交给class_attr_show和class_attr_store两个接口处理。以class_attr_show为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//drivers/base/class.c </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> to_class_attr(_attr) container_of(_attr, struct class_attribute, attr)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">class_attr_show</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobj, <span class="hljs-keyword">struct</span> attribute *attr,</span><br><span class="hljs-params">       <span class="hljs-type">char</span> *buf)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">class_attribute</span> *<span class="hljs-title">class_attr</span> =</span> to_class_attr(attr);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subsys_private</span> *<span class="hljs-title">cp</span> =</span> to_subsys_private(kobj);<br><span class="hljs-type">ssize_t</span> ret = -EIO;<br><br><span class="hljs-keyword">if</span> (class_attr-&gt;show)<br>ret = class_attr-&gt;show(cp-&gt;class, class_attr, buf);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>该接口使用container_of从struct attribute类型的指针中取得一个class模块的自定义指针：struct class_attribute，该指针中包含了class模块自身的show和store接口。下面是struct class_attribute的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//include/linux/device/class.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">class_attribute</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> <span class="hljs-title">attr</span>;</span><br><span class="hljs-type">ssize_t</span> (*show)(<span class="hljs-keyword">struct</span> class *class, <span class="hljs-keyword">struct</span> class_attribute *attr,<br><span class="hljs-type">char</span> *buf);<br><span class="hljs-type">ssize_t</span> (*store)(<span class="hljs-keyword">struct</span> class *class, <span class="hljs-keyword">struct</span> class_attribute *attr,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> count);<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>因此，所有需要使用attribute的模块，都不会直接定义struct attribute变量，而是通过一个自定义的数据结构，该数据结构的一个成员是struct attribute类型的变量，并提供show和store回调函数。然后在该模块ktype所对应的struct sysfs_ops变量中，实现该本模块整体的show和store函数，并在被调用时，转接到自定义数据结构（struct class_attribute）中的show和store函数中。这样，每个atrribute文件，实际上对应到一个自定义数据结构变量中了。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux设备模型之一:Kobject</title>
    <link href="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%80-Kobject/"/>
    <url>/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%80-Kobject/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux设备模型之一-Kobject"><a href="#Linux设备模型之一-Kobject" class="headerlink" title="Linux设备模型之一:Kobject"></a>Linux设备模型之一:Kobject</h1><p>每一个kobject对象都会关联一个sysfs文件目录，本节重点关注如何将kobject对象与sysfs文件系统关联起来，关注kobject对象默认的属性文件操作接口</p><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h2><h3 id="1-1-kobject"><a href="#1-1-kobject" class="headerlink" title="1.1 kobject"></a>1.1 kobject</h3><ul><li>kobject代表内核对象，结构体本身不单独使用，而是嵌套在其他高层结构中，用于组织成拓扑关系；</li><li>sysfs文件系统中一个目录对应一个kobject</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/kobject.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;       <span class="hljs-comment">// 设备的名字</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">entry</span>;</span>   <span class="hljs-comment">// 用于链接目录</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span>*<span class="hljs-title">parent</span>;</span> <span class="hljs-comment">// 父亲节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span>*<span class="hljs-title">kset</span>;</span>       <span class="hljs-comment">// 所属的kset</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span>*<span class="hljs-title">ktype</span>;</span>  <span class="hljs-comment">// 对应的ktype操作</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kernfs_node</span>*<span class="hljs-title">sd</span>;</span>    <span class="hljs-comment">// 该kobject对象在sysfs文件系统中所对应的文件目录</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kref</span><span class="hljs-title">kref</span>;</span>       <span class="hljs-comment">// 引用计数</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">delayed_work</span><span class="hljs-title">release</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state_initialized:<span class="hljs-number">1</span>;   <span class="hljs-comment">// 是否初始化标志</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state_in_sysfs:<span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state_add_uevent_sent:<span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state_remove_uevent_sent:<span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uevent_suppress:<span class="hljs-number">1</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>kobject只是一个通用对象的表示（类似C++中的基类），它抽象出一些通用的属性（如引用计数）以及通用接口，它通常是被其他数据结构（结构体）所包含（继承kobject），而每个外围数据结构各自完成这些接口的内部实现，所以会表现出不同的属性，因此我们更关心kobject的外围数据接口。</p><h3 id="1-2-kset"><a href="#1-2-kset" class="headerlink" title="1.2 kset"></a>1.2 kset</h3><ul><li>kset是包含多个kobject的集合；</li><li>如果需要在sysfs的目录中包含多个子目录，那需要将它定义成一个kset；</li><li>kset结构体中包含struct kobject字段，可以使用该字段链接到更上一层的结构，用于构建更复杂的拓扑结构；</li><li>sysfs中的设备组织结构很大程度上根据kset组织的，&#x2F;sys&#x2F;bus目录就是一个kset对象，在Linux设备模型中，注册设备或驱动时就将kobject添加到对应的kset中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span> <span class="hljs-comment">//属于这个kset的kobject们的链表</span><br><span class="hljs-type">spinlock_t</span> list_lock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span> <span class="hljs-comment">//嵌入到该kset的kobject，该obj可以用于表示该kset对象</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset_uevent_ops</span> *<span class="hljs-title">uevent_ops</span>;</span> <span class="hljs-comment">//处理kobject的请求</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们想统一管理有些类似属性的kobjects时，可以将它们加入到一个集合中，方便进行管理，比如当热插拔事件发生时，可以同时通知到该集合中的所有kobjects；</p><hr><p>在linux系统中，当系统的环境发生变化时，如添加kset到系统，移动kobject都会从内核空间发送到用户控件，这个是热插拔事件，那么相应的处理程序会被调用，这个处理程序会调用加载驱动，创建设备节点等来响应。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset_uevent_ops</span> &#123;</span><br>    <span class="hljs-type">int</span> (* <span class="hljs-type">const</span> filter)(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *(* <span class="hljs-type">const</span> name)(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj);<br>    <span class="hljs-type">int</span> (* <span class="hljs-type">const</span> uevent)(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj,<br>         <span class="hljs-keyword">struct</span> kobj_uevent_env *env);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这三个函数有什么作用（优先级从高到低）</p><ol><li>filter:决定了是否会将热插拔事件传递到用户控件。返回0，不传递，返回1，传递</li><li>name:用于将字符串传递给用户控件的热插拔处理程序</li><li>uevent:将用户空间需要的参数添加到环境变量中。</li></ol><h3 id="1-3-ktype"><a href="#1-3-ktype" class="headerlink" title="1.3 ktype"></a>1.3 ktype</h3><ul><li>kobj_type用于表征kobject的类型，指定了删除kobject时要调用的函数，kobject结构体中有struct kref字段用于对kobject进行引用计数，<u>当计数值为0时，就会调用kobj_type中的release函数对kobject进行释放</u>，这个就有点类似于C++中的智能指针了；</li><li>kobj_type指定了通过sysfs显示或修改有关kobject的信息时要处理的操作，实际是调用show&#x2F;store函数；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*include/linux/kobject.h*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span> &#123;</span><br><span class="hljs-comment">/* 处理对象终结的回调函数。该接口应该由具体对象负责填充。 */</span><br><span class="hljs-type">void</span> (*release)(<span class="hljs-keyword">struct</span> kobject *kobj);<br><span class="hljs-comment">/* 该类型kobj的sysfs操作接口。 */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span> *<span class="hljs-title">sysfs_ops</span>;</span><br><span class="hljs-comment">/* 该类型kobj自带的缺省属性（文件），这些属性文件在注册kobj时，直接pop为该目录下的文件。 */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">default_groups</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_ns_type_operations</span> *(*<span class="hljs-title">child_ns_type</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> *<span class="hljs-title">kobj</span>);</span><br><span class="hljs-comment">/*child_ns_type/namespace 是 文件系统命名空间相关）略*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">void</span> *(*namespace)(<span class="hljs-keyword">struct</span> kobject *kobj);<br><span class="hljs-type">void</span> (*get_ownership)(<span class="hljs-keyword">struct</span> kobject *kobj, <span class="hljs-type">kuid_t</span> *uid, <span class="hljs-type">kgid_t</span> *gid);<br>&#125;;<br><br><span class="hljs-comment">/*include/linux/sysfs.h*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span> &#123;</span><br><span class="hljs-type">ssize_t</span>(*show)(<span class="hljs-keyword">struct</span> kobject *, <span class="hljs-keyword">struct</span> attribute *, <span class="hljs-type">char</span> *);<br><span class="hljs-type">ssize_t</span>(*store)(<span class="hljs-keyword">struct</span> kobject *, <span class="hljs-keyword">struct</span> attribute *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">size_t</span>);<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;<br><span class="hljs-type">umode_t</span>mode;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="hljs-type">bool</span>ignore_lockdep:<span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span>*<span class="hljs-title">key</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span><span class="hljs-title">skey</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-4-结构关系"><a href="#1-4-结构关系" class="headerlink" title="1.4 结构关系"></a>1.4 结构关系</h3><p>将上面的数据结构拿一张图来说明：</p><img src="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%80-Kobject/v2-be1ccc5fabbf8ff59e2838a48981f6ca_720w.webp" alt="img" style="zoom:100%;"><p>为了更形象的说明这几个结构体的关系，再来一张图：</p><img src="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%80-Kobject/490784b4d4adafe608af685e06803945519d316a.png@942w_596h_progressive.webp" alt="图片" style="zoom:80%;"><ul><li>kset既是kobject的集合，本身又是一个kobject，进而可以添加到其他的集合中，从而就可以构建成复杂的拓扑结构，满足&#x2F;sys文件夹下的文件组织需求；</li></ul><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h2><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/554838012">https://zhuanlan.zhihu.com/p/554838012</a></p></blockquote><h3 id="2-1-kobject示例"><a href="#2-1-kobject示例" class="headerlink" title="2.1 kobject示例"></a>2.1 kobject示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span>        <span class="hljs-comment">// module_init  module_exit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span>          <span class="hljs-comment">// __init   __exit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/string.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/sysfs.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/stat.h&gt;</span> </span><br><br><span class="hljs-comment">//MODULE_xxx这种宏作用是用来添加模块描述信息</span><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);                <span class="hljs-comment">// 描述模块的许可证</span><br>MODULE_AUTHOR(<span class="hljs-string">&quot;pp&quot;</span>);                  <span class="hljs-comment">// 描述模块的作者</span><br>MODULE_VERSION(<span class="hljs-string">&quot;0.1&quot;</span>);                <span class="hljs-comment">// 描述模块的版本</span><br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;module kobject&quot;</span>);   <span class="hljs-comment">// 描述模块的介绍信息</span><br>MODULE_ALIAS(<span class="hljs-string">&quot;alias kobject&quot;</span>);          <span class="hljs-comment">// 描述模块的别名信息</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">obj_test_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobject)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">kobj_test_show</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobject,<span class="hljs-keyword">struct</span> attribute *attr,<span class="hljs-type">char</span> *buf)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">kobj_test_store</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobject,<span class="hljs-keyword">struct</span> attribute *attr,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf,<span class="hljs-type">size_t</span> count)</span>;<br><br><br><span class="hljs-comment">//文件：文件名+文件权限</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> <span class="hljs-title">test_attr</span> =</span>&#123;<br>    .name = <span class="hljs-string">&quot;kobj_config&quot;</span>,<br>    .mode = S_IRWXUGO,<br>&#125;;<br><span class="hljs-comment">//属性(指针数组),一个指针代码一个文件，有几个代表几个文件</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> *<span class="hljs-title">def_attrs</span>[]=</span>&#123;<br>    &amp;test_attr,<br>    <span class="hljs-literal">NULL</span>,<br>&#125;;<br><br><span class="hljs-comment">//读写文件时会调用show/store方法</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span> <span class="hljs-title">obj_test_sysops</span> =</span> <br>&#123;<br>    .show = kobj_test_show,<br>    .store = kobj_test_store,<br>&#125;;<br><br><span class="hljs-comment">//important</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span> <span class="hljs-title">ktype</span> =</span><br>&#123;<br>    .release = obj_test_release,<br>    .sysfs_ops =&amp;obj_test_sysops,<br>    .default_attrs = def_attrs,<br>&#125;;<br><br><span class="hljs-comment">//release当计数为0时调用</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">obj_test_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobject)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;eric_test: release .\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//读</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">kobj_test_show</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobject,<span class="hljs-keyword">struct</span> attribute *attr,<span class="hljs-type">char</span> *buf)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;have show.\n&quot;</span>);<br>    printk(<span class="hljs-string">&quot;attrname:%s.\n&quot;</span>,attr-&gt;name);<br>    <span class="hljs-built_in">sprintf</span>(buf,<span class="hljs-string">&quot;%s\n&quot;</span>,attr-&gt;name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(attr-&gt;name)+<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//写</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">kobj_test_store</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobject,<span class="hljs-keyword">struct</span> attribute *attr,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf,<span class="hljs-type">size_t</span> count)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;have store\n&quot;</span>);<br>    printk(<span class="hljs-string">&quot;write:%s\n&quot;</span>,buf);<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">//</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  __init <span class="hljs-title function_">kobj_test_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;kobject test init.\n&quot;</span>);<br>    <span class="hljs-comment">//初始化kobect,并将其注册到linux系统</span><br>    <span class="hljs-comment">//ktype记录了kobject对象的属性和动作</span><br>    <span class="hljs-comment">//NULL表示在sys根目录创建一个目录，目录名为kobject_test</span><br>    kobject_init_and_add(&amp;kobj,&amp;ktype,<span class="hljs-literal">NULL</span>,<span class="hljs-string">&quot;kobject_test&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit  <span class="hljs-title function_">kobj_test_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;kobject test exit.\n&quot;</span>);<br>    kobject_del(&amp;kobj);<br>&#125;<br><br>module_init(kobj_test_init);<br>module_exit(kobj_test_exit);<br></code></pre></td></tr></table></figure><img src="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%80-Kobject/v2-7c44487b5c3c07dc7f2b0873c75836fc_720w.webp" alt="img" style="zoom: 100%;"><h3 id="2-2-kset示例"><a href="#2-2-kset示例" class="headerlink" title="2.2 kset示例"></a>2.2 kset示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span>        <span class="hljs-comment">// module_init  module_exit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span>          <span class="hljs-comment">// __init   __exit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/string.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/sysfs.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/stat.h&gt;</span> </span><br><br><span class="hljs-comment">//MODULE_xxx这种宏作用是用来添加模块描述信息</span><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);                <span class="hljs-comment">// 描述模块的许可证</span><br>MODULE_AUTHOR(<span class="hljs-string">&quot;pp&quot;</span>);                  <span class="hljs-comment">// 描述模块的作者</span><br>MODULE_VERSION(<span class="hljs-string">&quot;0.1&quot;</span>);                <span class="hljs-comment">// 描述模块的版本</span><br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;module kset&quot;</span>);   <span class="hljs-comment">// 描述模块的介绍信息</span><br>MODULE_ALIAS(<span class="hljs-string">&quot;alias kset&quot;</span>);          <span class="hljs-comment">// 描述模块的别名信息</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span> <span class="hljs-title">kset_p</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span> <span class="hljs-title">kset_c</span>;</span><br><br><span class="hljs-comment">//事件1：最先调用，若返回0则事件2,3不调用</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kset_filter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj)</span><br>&#123;<br>        printk(<span class="hljs-string">&quot;Filter: kobj %s.\n&quot;</span>,kobj-&gt;name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//事件2：返回buf到用户空间</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">kset_name</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj)</span><br>&#123;<br>        <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">20</span>];<br>        printk(<span class="hljs-string">&quot;Name: kobj %s.\n&quot;</span>,kobj-&gt;name);<br>        <span class="hljs-built_in">sprintf</span>(buf,<span class="hljs-string">&quot;%s&quot;</span>,<span class="hljs-string">&quot;kset_name&quot;</span>);<br>        <span class="hljs-keyword">return</span> buf;<br>&#125;<br><span class="hljs-comment">//事件3：返回事件到用户空间</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kset_uevent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj,<span class="hljs-keyword">struct</span> kobj_uevent_env *env)</span><br>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        printk(<span class="hljs-string">&quot;uevent: kobj %s.\n&quot;</span>,kobj-&gt;name);<br><br>        <span class="hljs-keyword">while</span>( i &lt; env-&gt;envp_idx)&#123;<br>                printk(<span class="hljs-string">&quot;%s.\n&quot;</span>,env-&gt;envp[i]);<br>                i++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//对基类目录进行绑定事件</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset_uevent_ops</span> <span class="hljs-title">uevent_ops</span> =</span> <br>&#123;<br>        .filter = kset_filter,<br>        .name   = kset_name,<br>        .uevent = kset_uevent,<br>&#125;;<br><br><span class="hljs-comment">////////////////////////</span><br><span class="hljs-comment">//基类目录创建、子目录创建</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kset_test_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        printk(<span class="hljs-string">&quot;kset test init.\n&quot;</span>);<br>        kobject_set_name(&amp;kset_p.kobj,<span class="hljs-string">&quot;kset_p&quot;</span>);<br>        <span class="hljs-comment">//该父目录添加事件ops，当在该目录下有操作时依次调用:filter、name、uevent</span><br>        kset_p.uevent_ops = &amp;uevent_ops; <br>        kset_register(&amp;kset_p);<br><br>        kobject_set_name(&amp;kset_c.kobj,<span class="hljs-string">&quot;kset_c&quot;</span>);<br>        <span class="hljs-comment">//核心:kset_c的目录是kset_p,该行为由于对父目录有结构的变化会触发热插拔事件</span><br>        kset_c.kobj.kset = &amp;kset_p;<br>        kset_register(&amp;kset_c);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kset_test_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>        <span class="hljs-title function_">printk</span><span class="hljs-params">(<span class="hljs-string">&quot;kset test exit.\n&quot;</span>)</span>;<br>        kset_unregister(&amp;kset_p);<br>        kset_unregister(&amp;kset_c);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>module_init(kset_test_init);<br>module_exit(kset_test_exit);<br></code></pre></td></tr></table></figure><img src="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%80-Kobject/v2-2d811337bd84748619c45bce0df52082_720w.webp" alt="img" style="zoom:100%;">]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kconfig学习笔记</title>
    <link href="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Kconfig学习笔记"><a href="#Kconfig学习笔记" class="headerlink" title="Kconfig学习笔记"></a>Kconfig学习笔记</h1><h2 id="1-menuconfig配置界面"><a href="#1-menuconfig配置界面" class="headerlink" title="1.menuconfig配置界面"></a>1.menuconfig配置界面</h2><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2021051320123770.png" alt="内核选项配置界面" style="zoom: 67%;"><p><strong>1、子菜单 —&gt;</strong></p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210513201339224.png" alt=" " style="zoom:80%;"><p>表示有子菜单，按下回车可以进入子菜单。</p><p><strong>2、中括号 []</strong></p><p>在每一个选项前都有个括号，有的是中括号，有的是尖括号，还有的是圆括号。</p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210513201528165.png" alt=" " style="zoom:80%;"><p>[] 表示该选项只有两种选项，中括号中要么是空，要么是“*”；</p><blockquote><p>使用 “空格” 键进行切换</p></blockquote><p><strong>3、尖括号 &lt;&gt;</strong></p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210513201546900.png" alt=" " style="zoom:80%;"><p>&lt;&gt;选择相应的配置时，有3种选择，它们代表的含义分别如下。</p><blockquote><ul><li>*：将该功能编译进内核。 </li><li>空：不将该功能编译进内核。 </li><li>M：将该功能编译成可以在需要时动态插入到内核中的模块。</li></ul></blockquote><blockquote><p> 使用 “空格” 键进行切换</p></blockquote><p><strong>4、模块配置圆括号 ()</strong></p><p>而圆括号的内容是要你在所提供的几个选项中选择一项。</p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210513202030189.png" alt=" " style="zoom:80%;"><h2 id="2-Kconfig语法"><a href="#2-Kconfig语法" class="headerlink" title="2.Kconfig语法"></a>2.Kconfig语法</h2><h3 id="2-1-Kconfig类型"><a href="#2-1-Kconfig类型" class="headerlink" title="2.1 Kconfig类型"></a>2.1 Kconfig类型</h3><p>配置选项的类型：”bool”&#x2F;“tristate”&#x2F;“string”&#x2F;“hex”&#x2F;“int”</p><p>每个config菜单项都要有类型定义</p><ul><li>bool：布尔类型</li><li>tristate三态：内建、模块、移除</li><li>string：字符串</li><li>hex：十六进制</li><li>int：整型</li></ul><h3 id="2-2-mainmenu"><a href="#2-2-mainmenu" class="headerlink" title="2.2 mainmenu"></a>2.2 mainmenu</h3><p>顾名思义 mainmenu 就是主菜单，也就是输入“make menuconfig”以后打开的默认界面，在顶层 Kconfig 中有如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">mainmenu <span class="hljs-string">&quot;Linux/$ARCH $KERNELVERSION Kernel Configuration&quot;</span><br></code></pre></td></tr></table></figure><p>上述代码就是定义了一个名为<code>Linux/$ARCH $KERNELVERSION Kernel Configuration</code>的主菜单，其中$ARCH为我们自己export或者写死在顶层Makefile中的为<code>arm</code>，$KERNELVERSION&#x3D;4.1.15，因此主菜单名为<code>Linux/arm 4.1.15 Kernel Configuration</code></p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230409165121922.png" alt="image-20230409165121922" style="zoom:80%;"><h3 id="2-3-调用其他目录下的Kconfig文件"><a href="#2-3-调用其他目录下的Kconfig文件" class="headerlink" title="2.3 调用其他目录下的Kconfig文件"></a>2.3 调用其他目录下的Kconfig文件</h3><p>和 makefile 一样，Kconfig 也可以调用其他子目录中的 Kconfig 文件，调用方法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">source <span class="hljs-string">&quot;xxx/Kconfig&quot;</span> //xxx 为具体的目录名，相对路径<br></code></pre></td></tr></table></figure><p>在顶层 Kconfig 中有如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">source <span class="hljs-string">&quot;drivers/amx_drivers/Kconfig&quot;</span><br><br>source <span class="hljs-string">&quot;arch/$SRCARCH/Kconfig&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-menu-x2F-endemenu条目"><a href="#2-4-menu-x2F-endemenu条目" class="headerlink" title="2.4 menu&#x2F;endemenu条目"></a>2.4 menu&#x2F;endemenu条目</h3><p>menu 用于生成菜单，endmenu 就是菜单结束标志，这两个一般是成对出现的。在顶层<code>init/Kconfig</code> 中有如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile">menu <span class="hljs-string">&quot;General setup&quot;</span><br><br>config BROKEN<br>bool<br><br>config BROKEN_ON_SMP<br>bool<br>depends on BROKEN || !SMP<br>default y<br><br><span class="hljs-comment"># ....</span><br><br>endmenu<br></code></pre></td></tr></table></figure><p>这个代码块就是一个子菜单，第1行的<code>menu &quot;General setup</code>表示自菜单<code>General Setup</code></p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230409165838486.png" alt="image-20230409165838486" style="zoom:80%;"><h3 id="2-5-config条目"><a href="#2-5-config条目" class="headerlink" title="2.5 config条目"></a>2.5 config条目</h3><p>在一些<code>menu/endmenu</code> 代码块中有大量的 <strong>config xxx</strong> 代码块，也就是config条目。</p><p>config基本结构为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">config option<br>    type <span class="hljs-string">&quot;xxx&quot;</span>       //简单描述<br>    depends on xxx //依赖选项，可选<br>    default xxx      //初始值<br>    help              //帮助信息<br>        xxxxxxxxxxxxxxx<br></code></pre></td></tr></table></figure><p>我们以下面的config为例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile">config LOCALVERSION<br>string <span class="hljs-string">&quot;Local version - append to kernel release&quot;</span><br>help<br>  Append an extra string to the end of your kernel version.<br>  This will show up when you type uname, for example.<br>  The string you set here will be appended after the contents <br>  of any files with a filename matching localversion* in your<br>  object and source tree, in that order.  Your total string <br>  can be a maximum of 64 characters.<br>  <br>config LOCALVERSION_AUTO<br>bool <span class="hljs-string">&quot;Automatically append version information to the version string&quot;</span><br>default y<br></code></pre></td></tr></table></figure><p>config后面跟着 <strong>LOCALVERSION</strong> 就是配置项名字。假如我们是能了LOCALVERSION 这个功能，那么就会在.config 文件中生成 LOCALVERSION。</p><p>config 关键字下面的这几行是配置项属性。属性里面描述了配置项的类型、输入提示、依赖关系、帮助信息和默认值等。</p><ul><li>第一行表示LOCALVERSION的变量类型为 string</li><li>第二行help表示帮助信息，告诉我们配置项的含义，当我们按下“h”或“?”弹出来的帮助界面就是 help 的内容。</li><li>LOCALVERSION_AUTO的第一行表示LOCALVERSION_AUTO是bool类型，可以通过空格键 <strong>使能</strong> 或 <strong>禁止</strong> LOCALVERSION_AUTO。</li><li>default y 表示 LOCALVERSION_AUTO的默认值为 <strong>y</strong>，所以上一行会默认选中</li></ul><h3 id="2-6-depends-on-和-select"><a href="#2-6-depends-on-和-select" class="headerlink" title="2.6 depends on 和 select"></a>2.6 depends on 和 select</h3><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs make">config USER_RETURN_NOTIFIER<br>bool<br>depends on HAVE_USER_RETURN_NOTIFIER<br><br>config GPIO_ALTERA<br>tristate <span class="hljs-string">&quot;Altera GPIO&quot;</span><br>depends on OF_GPIO<br>select GPIO_GENERIC<br>select GPIOLIB_IRQCHIP<br></code></pre></td></tr></table></figure><ul><li>depend on 说明 USER_RETURN_NOTIFIER 依赖于 HAVE_USER_RETURN_NOTIFIER。也就是说 HAVE_USER_RETURN_NOTIFIER选中以后 USER_RETURN_NOTIFIER 才能被选中</li><li>select 表示方向依赖，当选中 GPIO_ALTERA 以后，GPIO_GENERIC、GPIOLIB_IRQCHIP 这两个选中也会被选中</li></ul><h3 id="2-7-choice-x2F-endchoice"><a href="#2-7-choice-x2F-endchoice" class="headerlink" title="2.7 choice&#x2F;endchoice"></a>2.7 choice&#x2F;endchoice</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># arch\arm\Kconfig</span><br><br>choice<br>prompt <span class="hljs-string">&quot;ARM system type&quot;</span><br>default ARCH_VERSATILE if !MMU<br>default ARCH_MULTIPLATFORM if MMU<br><br>config ARCH_MULTIPLATFORM<br>bool <span class="hljs-string">&quot;Allow multiple platforms to be selected&quot;</span><br>depends on MMU<br>select ARCH_WANT_OPTIONAL_GPIOLIB<br>select ARM_HAS_SG_CHAIN<br><span class="hljs-comment"># ...</span><br><br>config ARCH_REALVIEW<br>bool <span class="hljs-string">&quot;ARM Ltd. RealView family&quot;</span><br>select ARCH_WANT_OPTIONAL_GPIOLIB<br>select PLAT_VERSATILE_SCHED_CLOCK<br><span class="hljs-comment"># ...</span><br>help<br>  This enables support for ARM Ltd RealView boards.<br>  <br>  <span class="hljs-comment">#.....</span><br>endchoice<br></code></pre></td></tr></table></figure><p>choice&#x2F;endchoice 代码段定义了一组可选择项，将多个类似的配置项组合在一起，供用户单选或者多选。上面的类型就是让用户选择处理器架构，可以从 ARCH_MULTIPLATFORM、ARCH_REALVIEW中进行选择。</p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230409172626588.png" alt="image-20230409172626588" style="zoom:80%;"><h3 id="2-8-menuconfig"><a href="#2-8-menuconfig" class="headerlink" title="2.8 menuconfig"></a>2.8 menuconfig</h3><p>menuconfig 和 menu 很类似，但是 menuconfig 是个带选项的菜单，其一般用法为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">menuconfig MODULES<br>bool <span class="hljs-string">&quot;菜单&quot;</span><br>if MODULEs<br>...<br><span class="hljs-keyword">endif</span> <span class="hljs-comment"># MODULES</span><br></code></pre></td></tr></table></figure><p>第 1 行，定义了一个可选的菜单 MODULES，只有选中了 MODULES 第 3~5 行 if 到 endif 之间的内容才会显示。在顶层 Kconfig 中有如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs makefile">menuconfig INPUT_TOUCHSCREEN<br>bool <span class="hljs-string">&quot;Touchscreens&quot;</span><br>help<br>  Say Y here, and a list of supported touchscreens will be &#x27;<br>  displayed.This option doesn&#x27;t affect the kernel.<br>  If unsure, say Y.<br><br>if INPUT_TOUCHSCREEN<br><br>config OF_TOUCHSCREEN<br>def_tristate INPUT<br>depends on INPUT &amp;&amp; OF<br><br>config TOUCHSCREEN_88PM860X<br>tristate <span class="hljs-string">&quot;Marvell 88PM860x touchscreen&quot;</span><br>depends on MFD_88PM860X<br>help<br>  Say Y here if you have a 88PM860x PMIC and want to enable<br>  support for the built-in touchscreen.<br><span class="hljs-comment"># ...</span><br><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230409173721763.png" alt="image-20230409173721763" style="zoom:80%;"><p>Touchscreens前面有[]，说明这个菜单是可选的，当选中这个菜单以后就可以进入到子选项中。</p><h3 id="2-6-comment"><a href="#2-6-comment" class="headerlink" title="2.6 comment"></a>2.6 comment</h3><p>comment用于注释，也就是在图形化界面中显示一行注释</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># arch\arm\Kconfig</span><br><br>comment <span class="hljs-string">&quot;CPU Core family selection&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到该注释独占一行</p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230409174046599.png" alt="image-20230409174046599" style="zoom:80%;"><h2 id="3-Kconfig键盘操作"><a href="#3-Kconfig键盘操作" class="headerlink" title="3.Kconfig键盘操作"></a>3.Kconfig键盘操作</h2><ol><li>两下 <code>ESC</code> 返回上一级</li><li>按<code>H</code> 或者 <code>?</code> 可以查看提示信息</li><li>按 <code>空格</code> 可以切换状态</li><li>按 <code>/</code> 可以快速搜索CONFIG宏</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核编译make defconfig</title>
    <link href="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/"/>
    <url>/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux内核编译make-defconfig"><a href="#Linux内核编译make-defconfig" class="headerlink" title="Linux内核编译make defconfig"></a>Linux内核编译make defconfig</h1><blockquote><p><strong>声明：</strong>本文部分内容引自正点原子，其资料完整，讲解清晰，非常感谢！</p></blockquote><p>在内核编译时，有各种配置方式可供进行选择，常见的有图形化界面<code>make menuconfig</code>，有<code>make XXX_defconfig</code>。今天以NXP官方的内核为例，记录一下编译默认配置文件<strong>make imx_v7_mfg_defconfig</strong></p><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/v2-28887f831d79f4d3abf8b153616528d0_720w.webp" alt="img" style="zoom:80%;"><h2 id="1-make-defconfig在Makefile匹配过程"><a href="#1-make-defconfig在Makefile匹配过程" class="headerlink" title="1.make defconfig在Makefile匹配过程"></a>1.make defconfig在Makefile匹配过程</h2><h3 id="1-1-顶层Makefile匹配"><a href="#1-1-顶层Makefile匹配" class="headerlink" title="1.1 顶层Makefile匹配"></a>1.1 顶层Makefile匹配</h3><p>当我们执行 <strong>make imx_v7_mfg_defconfig</strong> 时，对应于顶层makefile中的<code>%config</code>目标：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%config: scripts_basic outputmakefile FORCE</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=scripts/kconfig <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>“%config”依赖scripts_basic、outputmakefile 和 FORCE，“%config”真正有意义的依赖就只有 scripts_basic，</p><p>scripts_basic 的规则如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">scripts_basic:</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=scripts/basic<br><span class="hljs-variable">$(Q)</span>rm -f .tmp_quiet_recordmcount<br></code></pre></td></tr></table></figure><p>build 定义在文件 scripts&#x2F;Kbuild.include 中，值为 build :&#x3D; -f $(srctree)&#x2F;scripts&#x2F;Makefile.build obj，因此展开就是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">scripts_basic:</span><br>    @make -f ./scripts/Makefile.build obj=scripts/basic  //也可以没有@，视配置而定<br>    @rm -f . tmp_quiet_recordmcount //也可以没有@<br></code></pre></td></tr></table></figure><p>接着回到目标“%config”处，内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%config: scripts_basic outputmakefile FORCE</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=scripts/kconfig <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>将命令展开就是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">@make -f ./scripts/Makefile.build obj=scripts/kconfig imx_v7_mfg_defconfig<br></code></pre></td></tr></table></figure><h3 id="1-2-Makefile-build脚本解析"><a href="#1-2-Makefile-build脚本解析" class="headerlink" title="1.2 Makefile.build脚本解析"></a>1.2 Makefile.build脚本解析</h3><p>从上一小节可知，“make xxx_defconfig“配置 Linux 的时候如下两行命令会执行脚本scripts&#x2F;Makefile.build：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">@make -f ./scripts/Makefile.build obj=scripts/basic<br>@make -f ./scripts/Makefile.build obj=scripts/kconfig xxx_defconfig<br></code></pre></td></tr></table></figure><h4 id="1-2-1-scripts-basic"><a href="#1-2-1-scripts-basic" class="headerlink" title="1.2.1 scripts_basic"></a>1.2.1 scripts_basic</h4><p>scripts_basic 目标对应的命令为：@make -f .&#x2F;scripts&#x2F;Makefile.build obj&#x3D;scripts&#x2F;basic。打开文件 scripts&#x2F;Makefile.build，有如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># The filename Kbuild has precedence over Makefile</span><br>kbuild-dir := <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">filter</span> /%,<span class="hljs-variable">$(src)</span>)</span>,<span class="hljs-variable">$(src)</span>,<span class="hljs-variable">$(srctree)</span>/<span class="hljs-variable">$(src)</span>)<br>kbuild-file := <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">wildcard</span> $(kbuild-<span class="hljs-built_in">dir</span>)</span>/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)<br><span class="hljs-keyword">include</span> $(kbuild-file)<br></code></pre></td></tr></table></figure><p>将 kbuild-dir 展开后为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">kbuild-dir=./scripts/basic<br></code></pre></td></tr></table></figure><p>将 kbuild-file 展开后为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">kbuild-file= ./scripts/basic/Makefile<br></code></pre></td></tr></table></figure><p>最后一行展开：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">include</span> ./scripts/basic/Makefile<br></code></pre></td></tr></table></figure><p>继续分析 scripts&#x2F;Makefile.build，如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">__build: $(if <span class="hljs-variable">$(KBUILD_BUILTIN)</span>,$(builtin-target) $(lib-target) $(extra-y)) \</span><br> <span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(KBUILD_MODULES)</span>,$(obj-m)</span> $(modorder-target)) \<br> $(subdir-ym) <span class="hljs-variable">$(always)</span><br>@:<br></code></pre></td></tr></table></figure><p>__build 是默认目标，因为命令“@make -f .&#x2F;scripts&#x2F;Makefile.build obj&#x3D;scripts&#x2F;basic”没有指定目标，所以会使用到默认目标__build。在顶层 Makefile 中，KBUILD_BUILTIN 为 1，KBUILD_MODULES 为空，因此展开后目标__build 为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">__build:$(builtin-target) $(lib-target) $(extra-y)) $(subdir-ym) <span class="hljs-variable">$(always)</span></span><br>@:<br></code></pre></td></tr></table></figure><p>可以看出目标__build 有 5 个依赖：builtin-target、lib-target、extra-y、subdir-ym 和 always。这 5 个依赖的具体内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">builtin-target =<br>lib-target =<br>extra-y =<br>subdir-ym =<br>always = scripts/basic/fixdep scripts/basic/bin2c<br></code></pre></td></tr></table></figure><p>只有 always 有效，因此__build 最终为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">__build: scripts/basic/fixdep scripts/basic/bin2c</span><br>@<br></code></pre></td></tr></table></figure><p>__build 依赖于 scripts&#x2F;basic&#x2F;fixdep 和 scripts&#x2F;basic&#x2F;bin2c，所以要先将 scripts&#x2F;basic&#x2F;fixdep 和 scripts&#x2F;basic&#x2F;bin2c.c 这两个文件编译成 fixdep 和 bin2c。</p><p>🐘 综上所述，scripts_basic 目标的作用就是编译出 <strong>scripts&#x2F;basic&#x2F;fixdep</strong> 和 <strong>scripts&#x2F;basic&#x2F;bin2c</strong> 这两个软件。</p><h4 id="1-2-2-config"><a href="#1-2-2-config" class="headerlink" title="1.2.2 %config"></a>1.2.2 %config</h4><p>%config 目标 对应的命令为 ： @make -f .&#x2F;scripts&#x2F;Makefile.build obj&#x3D;scripts&#x2F;kconfig xxx_defconfig，此命令会使用到的各个变量值如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src= scripts/kconfig<br>kbuild-dir = ./scripts/kconfig<br>kbuild-file = ./scripts/kconfig/Makefile<br><span class="hljs-keyword">include</span> ./scripts/kconfig/Makefile<br></code></pre></td></tr></table></figure><p>可以看出，Makefile.build 会读取 scripts&#x2F;kconfig&#x2F;Makefile 中的内容，此文件有如下所示内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%_defconfig: <span class="hljs-variable">$(obj)</span>/conf</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(silent)</span> --defconfig=arch/<span class="hljs-variable">$(SRCARCH)</span>/configs/<span class="hljs-variable">$@</span> <span class="hljs-variable">$(Kconfig)</span><br></code></pre></td></tr></table></figure><p>目标%_defconfig 与 xxx_defconfig 匹配，所以会执行这条规则，将其展开就是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%_defconfig: scripts/kconfig/conf</span><br>@scripts/kconfig/conf --defconfig=arch/arm/configs/%_defconfig Kconfig<br></code></pre></td></tr></table></figure><p><code>%__defconfig</code> 会依赖于scripts&#x2F;kconfig&#x2F;conf，所以会先编译scripts&#x2F;kconfig&#x2F;conf，然后调用这个二进制，生成最终的<code>.config</code>文件，这就是第二章的内容。</p><h2 id="2-最终调用conf二进制，生成-config文件"><a href="#2-最终调用conf二进制，生成-config文件" class="headerlink" title="2.最终调用conf二进制，生成.config文件"></a>2.最终调用conf二进制，生成.config文件</h2><p>当执行<strong>make imx_v7_mfg_defconfig</strong>时，最后一步就是调用二进制conf，去生成.config文件</p><p>🎨 <strong>conf二进制是由conf.c编译而来</strong></p><blockquote><p>所以最终调用的命令为<code>scripts/kconfig/conf --defconfig=arch/../configs/imx_v7_mfg_defconfig Kconfig</code>，就是调用<strong>conf.c</strong>文件的main函数。我们可以发现传递给conf.c时的main函数的<strong>argv[0]&#x3D;scripts&#x2F;kconfig&#x2F;conf</strong>，<strong>argv[1]&#x3D;–defconfig&#x3D;arch&#x2F;arm&#x2F;configs&#x2F;imx_v7_mfg_defconfig</strong>，<strong>argv[2]&#x3D;Kconfig</strong>。</p></blockquote><p>因此，我们接下来分析一下conf.c的main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// scripts/kconfig/conf.c</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">option</span> <span class="hljs-title">long_opts</span>[] =</span> &#123;<br>&#123;<span class="hljs-string">&quot;oldaskconfig&quot;</span>,    no_argument,       <span class="hljs-literal">NULL</span>, oldaskconfig&#125;,<br>&#123;<span class="hljs-string">&quot;oldconfig&quot;</span>,       no_argument,       <span class="hljs-literal">NULL</span>, oldconfig&#125;,<br>&#123;<span class="hljs-string">&quot;silentoldconfig&quot;</span>, no_argument,       <span class="hljs-literal">NULL</span>, silentoldconfig&#125;,<br>&#123;<span class="hljs-string">&quot;defconfig&quot;</span>,       optional_argument, <span class="hljs-literal">NULL</span>, defconfig&#125;,<br>&#123;<span class="hljs-string">&quot;savedefconfig&quot;</span>,   required_argument, <span class="hljs-literal">NULL</span>, savedefconfig&#125;,<br>&#123;<span class="hljs-string">&quot;allnoconfig&quot;</span>,     no_argument,       <span class="hljs-literal">NULL</span>, allnoconfig&#125;,<br>&#123;<span class="hljs-string">&quot;allyesconfig&quot;</span>,    no_argument,       <span class="hljs-literal">NULL</span>, allyesconfig&#125;,<br>&#123;<span class="hljs-string">&quot;allmodconfig&quot;</span>,    no_argument,       <span class="hljs-literal">NULL</span>, allmodconfig&#125;,<br>&#123;<span class="hljs-string">&quot;alldefconfig&quot;</span>,    no_argument,       <span class="hljs-literal">NULL</span>, alldefconfig&#125;,<br>&#123;<span class="hljs-string">&quot;randconfig&quot;</span>,      no_argument,       <span class="hljs-literal">NULL</span>, randconfig&#125;,<br>&#123;<span class="hljs-string">&quot;listnewconfig&quot;</span>,   no_argument,       <span class="hljs-literal">NULL</span>, listnewconfig&#125;,<br>&#123;<span class="hljs-string">&quot;olddefconfig&quot;</span>,    no_argument,       <span class="hljs-literal">NULL</span>, olddefconfig&#125;,<br>&#123;<span class="hljs-string">&quot;oldnoconfig&quot;</span>,     no_argument,       <span class="hljs-literal">NULL</span>, olddefconfig&#125;,<br>&#123;<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>&#125;<br>&#125;;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> ac, <span class="hljs-type">char</span> **av)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *progname = av[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> opt;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, *defconfig_file = <span class="hljs-literal">NULL</span> <span class="hljs-comment">/* gcc uninit */</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">tmpstat</span>;</span><br><br>    <span class="hljs-comment">// 通过getopt_long去解析传进来的参数</span><br>    <span class="hljs-comment">// 传进来时有一个--defconfig，所以从option列表里面匹配到的是defconfig(枚举值为8)</span><br><span class="hljs-keyword">while</span> ((opt = getopt_long(ac, av, <span class="hljs-string">&quot;s&quot;</span>, long_opts, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">-1</span>) &#123;<br>input_mode = (<span class="hljs-keyword">enum</span> input_mode)opt;<br><span class="hljs-keyword">switch</span> (opt) &#123;<br>            <span class="hljs-keyword">case</span> defconfig:<br>            <span class="hljs-keyword">case</span> savedefconfig:<br>                defconfig_file = optarg;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>&#125;<br><br>name = av[optind];  <span class="hljs-comment">// 名字为Kconfig</span><br>conf_parse(name);  <span class="hljs-comment">// 解析Kconfig</span><br><br><span class="hljs-keyword">switch</span> (input_mode) &#123;<br>        <span class="hljs-keyword">case</span> defconfig:<br>            <span class="hljs-comment">// 前面在while循环解析参数时， defconfig_file为arch/arm/configs/imx_v7_mfg_defconfig</span><br>            <span class="hljs-keyword">if</span> (!defconfig_file)<br>                defconfig_file = conf_get_default_confname();<br>         <br>            <span class="hljs-keyword">if</span> (conf_read(defconfig_file)) &#123;<br>                <span class="hljs-built_in">printf</span>(_(<span class="hljs-string">&quot;***\n&quot;</span><br>                    <span class="hljs-string">&quot;*** Can&#x27;t find default configuration \&quot;%s\&quot;!\n&quot;</span><br>                    <span class="hljs-string">&quot;***\n&quot;</span>), defconfig_file);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">switch</span> (input_mode) &#123;<br>        <span class="hljs-keyword">case</span> defconfig:<br>            conf_set_all_new_symbols(def_default);<br>            <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (sync_kconfig) &#123;<br>        <span class="hljs-comment">// ....</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input_mode != listnewconfig) &#123;<br><span class="hljs-keyword">if</span> (conf_write(<span class="hljs-literal">NULL</span>)) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, _(<span class="hljs-string">&quot;\n*** Error during writing of the configuration.\n\n&quot;</span>));<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-conf-parse解析Kconfig"><a href="#2-1-conf-parse解析Kconfig" class="headerlink" title="2.1 conf_parse解析Kconfig"></a>2.1 conf_parse解析Kconfig</h3><p>调用<code>conf_parse(name)</code>从<code>$(srctree)</code>目录下依次查找名为<code>Kconfig</code>的文件，然后将取得的信息存放到链表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// scripts\kconfig\zconf.tab.c_shipped</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">conf_parse</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> *<span class="hljs-title">sym</span>;</span><br><span class="hljs-type">int</span> i;<br><br>zconf_initscan(name);<br><br>sym_init();<br>_menu_init();<br>rootmenu.prompt = menu_add_prompt(P_MENU, <span class="hljs-string">&quot;Linux Kernel Configuration&quot;</span>, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">if</span> (getenv(<span class="hljs-string">&quot;ZCONF_DEBUG&quot;</span>))<br>zconfdebug = <span class="hljs-number">1</span>;<br>zconfparse();<br><span class="hljs-keyword">if</span> (zconfnerrs)<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!modules_sym)<br>modules_sym = sym_find( <span class="hljs-string">&quot;n&quot;</span> );<br><br>rootmenu.prompt-&gt;text = _(rootmenu.prompt-&gt;text);<br>rootmenu.prompt-&gt;text = sym_expand_string_value(rootmenu.prompt-&gt;text);<br><br>menu_finalize(&amp;rootmenu);<br><br>sym_set_change_count(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-conf-read-defconfig-file-读取配置文件"><a href="#2-2-conf-read-defconfig-file-读取配置文件" class="headerlink" title="2.2 conf_read(defconfig_file)读取配置文件"></a>2.2 conf_read(defconfig_file)读取配置文件</h3><h3 id="2-3-conf-write往-config写配置"><a href="#2-3-conf-write往-config写配置" class="headerlink" title="2.3 conf_write往.config写配置"></a>2.3 conf_write往.config写配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">conf_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>FILE *out;<br>    <br>dirname[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (name &amp;&amp; name[<span class="hljs-number">0</span>]) &#123;<br><span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span><br>basename = conf_get_configname();<br><br><span class="hljs-built_in">sprintf</span>(newname, <span class="hljs-string">&quot;%s%s&quot;</span>, dirname, basename);  <span class="hljs-comment">// newname为.config</span><br>env = getenv(<span class="hljs-string">&quot;KCONFIG_OVERWRITECONFIG&quot;</span>);  <span class="hljs-comment">// 获取KCONFIG_OVERWRITECONFIG失败</span><br><span class="hljs-keyword">if</span> (!env || !*env) &#123;<br><span class="hljs-built_in">sprintf</span>(tmpname, <span class="hljs-string">&quot;%s.tmpconfig.%d&quot;</span>, dirname, (<span class="hljs-type">int</span>)getpid());  <span class="hljs-comment">// 临时文件为.tmpconfig.[@pid]</span><br>out = fopen(tmpname, <span class="hljs-string">&quot;w&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>*tmpname = <span class="hljs-number">0</span>;<br>out = fopen(newname, <span class="hljs-string">&quot;w&quot;</span>);<br>&#125;<br><br>    <span class="hljs-comment">// 2.3.1节</span><br>conf_write_heading(out, &amp;kconfig_printer_cb, <span class="hljs-literal">NULL</span>);<br><br><br>    <span class="hljs-comment">// 获取rootmenu首页的menu.list</span><br>    <span class="hljs-comment">// 就是我们make_menuconfig看到的首页所有项</span><br>menu = rootmenu.<span class="hljs-built_in">list</span>;<br><span class="hljs-keyword">while</span> (menu) &#123;<br>        <span class="hljs-comment">// sym就是解析后Symbol</span><br>sym = menu-&gt;sym;<br><span class="hljs-keyword">if</span> (!sym) &#123;<br><span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(sym-&gt;flags &amp; SYMBOL_CHOICE)) &#123;<br>sym_calc_value(sym);<br>sym-&gt;flags &amp;= ~SYMBOL_WRITE;<br><span class="hljs-comment">// 2.3.2节</span><br>conf_write_symbol(out, sym, &amp;kconfig_printer_cb, <span class="hljs-literal">NULL</span>);<br>&#125;<br>&#125;<br>fclose(out);<br><br>    <span class="hljs-comment">// 将tmpname重命名为.config</span><br>    <span class="hljs-comment">// 2.3.4节</span><br><span class="hljs-keyword">if</span> (*tmpname) &#123;<br><span class="hljs-built_in">strcat</span>(dirname, basename);<br><span class="hljs-built_in">strcat</span>(dirname, <span class="hljs-string">&quot;.old&quot;</span>);<br>rename(newname, dirname);<br><span class="hljs-keyword">if</span> (rename(tmpname, newname))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br>conf_message(_(<span class="hljs-string">&quot;configuration written to %s&quot;</span>), newname);  <span class="hljs-comment">// 在编译日志里面打印configuration written to .config</span><br><br>sym_set_change_count(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-0-真正发挥写文件的函数kconfig-printer-cb"><a href="#2-3-0-真正发挥写文件的函数kconfig-printer-cb" class="headerlink" title="2.3.0 真正发挥写文件的函数kconfig_printer_cb"></a>2.3.0 真正发挥写文件的函数kconfig_printer_cb</h4><p>kconfig_printer_cb中有两个成员变量，一个用来写注释，一个用来写配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">conf_printer</span> <span class="hljs-title">kconfig_printer_cb</span> =</span><br>&#123;<br>.print_symbol = kconfig_print_symbol,   <span class="hljs-comment">// 写配置的函数</span><br>.print_comment = kconfig_print_comment, <span class="hljs-comment">// 写注释的函数</span><br>&#125;;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">kconfig_print_symbol</span><span class="hljs-params">(FILE *fp, <span class="hljs-keyword">struct</span> symbol *sym, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *value, <span class="hljs-type">void</span> *arg)</span><br>&#123;<br><br><span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br><span class="hljs-keyword">case</span> S_BOOLEAN:<br><span class="hljs-keyword">case</span> S_TRISTATE:<br>        <span class="hljs-comment">// 如果值为n</span><br><span class="hljs-keyword">if</span> (*value == <span class="hljs-string">&#x27;n&#x27;</span>) &#123;<br><span class="hljs-type">bool</span> skip_unset = (arg != <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">// 往.config里面写# CONFIG_XXX is not set</span><br><span class="hljs-keyword">if</span> (!skip_unset)<br><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;# %s%s is not set\n&quot;</span>,<br>    CONFIG_, sym-&gt;name);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;%s%s=%s\n&quot;</span>, CONFIG_, sym-&gt;name, value);  <span class="hljs-comment">// 往.config中写配置，格式为CONFIG_XXX=XXX</span><br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">kconfig_print_comment</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *value, <span class="hljs-type">void</span> *arg)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = value;<br><span class="hljs-type">size_t</span> l;<br><br><span class="hljs-keyword">for</span> (;;) &#123;<br>l = <span class="hljs-built_in">strcspn</span>(p, <span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;#&quot;</span>);<br><span class="hljs-keyword">if</span> (l) &#123;<br><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot; &quot;</span>);<br>xfwrite(p, l, <span class="hljs-number">1</span>, fp);<br>p += l;<br>&#125;<br><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">if</span> (*p++ == <span class="hljs-string">&#x27;\0&#x27;</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409212854271.png" alt="image-20230409212854271" style="zoom:80%;"><p>我们举个例子：</p><p>假如我们在<strong>Kconfig</strong>中设置<code>AMX_FONT</code>为y，而在<strong>imx_v7_mfg_defconig</strong>设置为n</p><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409212629006.png" alt="image-20230409212629006" style="zoom:50%;"><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409212745735.png" alt="image-20230409212745735" style="zoom:50%;"><p>通过<code>make imx_v7_mfg_defconig</code>后在<code>.config</code>中最终为 <strong># CONFIG_AMX_FONT is not set</strong></p><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409212910588.png" alt="image-20230409212910588" style="zoom:67%;"><h4 id="2-3-1-conf-write-heading函数向-config写头部注释"><a href="#2-3-1-conf-write-heading函数向-config写头部注释" class="headerlink" title="2.3.1 conf_write_heading函数向.config写头部注释"></a>2.3.1 conf_write_heading函数向.config写头部注释</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">conf_write_heading:<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">conf_write_heading</span><span class="hljs-params">(FILE *fp, <span class="hljs-keyword">struct</span> conf_printer *printer, <span class="hljs-type">void</span> *printer_arg)</span><br>&#123;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>];<br><br><span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span>(buf),<br>    <span class="hljs-string">&quot;\n&quot;</span><br>    <span class="hljs-string">&quot;Automatically generated file; DO NOT EDIT.\n&quot;</span><br>    <span class="hljs-string">&quot;%s\n&quot;</span>,<br>    rootmenu.prompt-&gt;text);<br><br>printer-&gt;print_comment(fp, buf, printer_arg);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这边的rootmenu就是根目录下的<strong>Kconfig</strong>，其prompt值为<code>Linux/$ARCH $KERNELVERSION Kernel Configuration</code></p><p>因此最终写入的注释如下：</p><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409152128232.png" alt="image-20230409152128232" style="zoom: 67%;"><h4 id="2-3-2-conf-write-symbol函数向-config写配置项"><a href="#2-3-2-conf-write-symbol函数向-config写配置项" class="headerlink" title="2.3.2 conf_write_symbol函数向.config写配置项"></a>2.3.2 conf_write_symbol函数向.config写配置项</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">conf_write_symbol:<br>    <br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">conf_write_symbol</span><span class="hljs-params">(FILE *fp, <span class="hljs-keyword">struct</span> symbol *sym,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> conf_printer *printer, <span class="hljs-type">void</span> *printer_arg)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str;<br><br>    <span class="hljs-comment">// 判断写入的Symbol值</span><br><span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br><span class="hljs-keyword">case</span> S_OTHER:<br><span class="hljs-keyword">case</span> S_UNKNOWN:<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> S_STRING:<br>str = sym_get_string_value(sym);<br>str = sym_escape_string_value(str);<br>printer-&gt;print_symbol(fp, sym, str, printer_arg);<br><span class="hljs-built_in">free</span>((<span class="hljs-type">void</span> *)str);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>str = sym_get_string_value(sym);<br>        <span class="hljs-comment">// 按照2.3.0中的规则往.config中写内容</span><br>printer-&gt;print_symbol(fp, sym, str, printer_arg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果输入的是string类型，直接获取string类型的值，然后写入config中</li></ul><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409213953366.png" alt="image-20230409213953366" style="zoom:67%;"><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409213825095.png" alt="image-20230409213825095" style="zoom: 50%;"><ul><li>如果是其他类型，比如bool类型和tristate，获取值然后写入.config</li></ul><h4 id="2-3-4-重命名-config"><a href="#2-3-4-重命名-config" class="headerlink" title="2.3.4 重命名.config"></a>2.3.4 重命名.config</h4><p>其实前面一直是往<code>.tmpconfig.[@pid]</code>里面写配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (*tmpname) &#123;<br>    <span class="hljs-built_in">strcat</span>(dirname, basename);<br>    <span class="hljs-built_in">strcat</span>(dirname, <span class="hljs-string">&quot;.old&quot;</span>);<br>    rename(newname, dirname);<br>    <span class="hljs-keyword">if</span> (rename(tmpname, newname))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>dirname为 <code>.config.old</code></p></li><li><p>将之前的 <strong>.config</strong> 文件重命名为 <strong>.config.old</strong></p></li><li><p>将<strong>tmpname</strong> 重命名为新的config为 <strong>.config</strong></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统——链接</title>
    <link href="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/"/>
    <url>/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解计算机系统——链接"><a href="#深入理解计算机系统——链接" class="headerlink" title="深入理解计算机系统——链接"></a>深入理解计算机系统——链接</h1><blockquote><p>声明：本文为学习计算机系统的笔记，供自己复习使用；按照<strong>yaaangmin</strong>的github声明，请勿进行商用</p><p>所有内容均整理自：<strong>yaaangmin</strong></p><p>其github地址为：<a href="https://github.com/yangminz/bcst_csapp">https://github.com/yangminz/bcst_csapp</a></p></blockquote><h2 id="1-可执行可链接格式"><a href="#1-可执行可链接格式" class="headerlink" title="1.可执行可链接格式"></a>1.可执行可链接格式</h2><p>首先，我们考虑什么是文件系统（File System)上的文件。我们知道，文件都是持久地储存在磁盘等设备上的，但它的实质仍然是二进制序列。只要我们对序列进行恰当的描述，我们就可以获得想要的全部信息。为了将某一文件的二进制串与其他文件的二进制串区别开，我们需要指定这一文件的类型与大小等信息，这些信息存放在文件二进制串的起始地址，也即首部（Header)。</p><h3 id="1-1-ELF-Header"><a href="#1-1-ELF-Header" class="headerlink" title="1.1 ELF Header"></a>1.1 ELF Header</h3><p>对于ELF，首部的信息包括文件类型、机器类型等信息。在Linux读取ELF文件时，Linux将ELF Header从Byte翻译为内存中的数据结构：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405210514169.png" alt="image-20230405210514169" style="zoom:80%;"><p>数据结构<strong>Elf64_Ehdr</strong>包含了很多信息，但对我们而言，我们只需要知道Header 是如何定位到节头表( Section Header Table,SHT)的。Header中的 Elf64_Ehdr.e_shoff 是SHT对ELF起始地址的Byte偏置，Elf64_Ehdr.e_shentsize描述SHT每一项的Byte大小，Elf64_Ehdr.e_shentnum 描述 SHT描述表项的数量，这样，我们就可以通过后两项计算出SHT的大小。Header中的Elf64_Ehdr.e_shstrndx则是SHT中一个特殊节<strong>字符串</strong>表的段索引，Header可以借此计算ELF中每一项的字符串。</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405210554302.png" alt="image-20230405210554302" style="zoom: 80%;"><p>我们举一个例子，使我们洞见ELF文件的数据结构，考虑如下的elf.c源文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> data1 = <span class="hljs-number">0xdddddddd11111111</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> data2 = <span class="hljs-number">0xdddddddd22222222</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span> &#123;&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><p>使用gcc编译得到它的ELF文件：<code>gcc -c elf.c -o elf.o</code>，其中-c的含义是仅编译源文件生成ELF文件，但不对ELF文件进行链接。生成ELF文件以后，利用hexdump查看ELF文件<code>elf.o</code>的内容。</p><p>hexdump获得elf.o的二进制内容后，按照Elf64_Ehdr的结构格式，我们可以解读ELF的Header。首先，我们可以计算得到sizeof(Elf64_Ehdr) &#x3D; 64Byte，因此Header占据ELF文件的低64Byte。这样我们就得到了elf.o的Header：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405211548347.png" alt="image-20230405211548347" style="zoom:80%;"><p>起始位置的16Bytes为 Magic Number,在这之后偏移2+2+4+8+8&#x3D;24Bytes,大小为8Bytes的数据为Elf64_Ehdr.e_shoff，也即SHT起始地址对ELF文件的偏移，数值为 0x00000000000002b0。在这之后，对Elf64_Ehdr.e_shoff偏移为4Bytes 的位置储存了ELF文件Header的大小：Elf64_Ehdr.e_ehsize &#x3D;0x0040。再之后2+2&#x3D;4 Bytes即 Elf64_Ehdr.e_shentsize，也即为SHT每一项的大小，数值为0x0040。最后两个2Bytes的数分别是 Elf64_Ehdr.e_shnum &#x3D; 0x000b以及Elf64_Ehdr.e_shstrndx &#x3D; 0x000a。</p><h3 id="1-2-节头表SHT"><a href="#1-2-节头表SHT" class="headerlink" title="1.2 节头表SHT"></a>1.2 节头表SHT</h3><p>SHT描述了ELF中不同的<strong>节(Section)<strong>，包括</strong>数据节(.data)<strong>、</strong>代码节(.text）</strong>等。这些Section中的数据是由编译器生成的，按照Section 的组织写入到磁盘上的ELF文件中。SHT的每一项可以被数据结构Elf64_Shdr所描：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405212130069.png" alt="image-20230405212130069" style="zoom: 80%;"><p>这样，我们可以通过SHT找到ELF内的任一Section，常见的Section有.text，.data，.rodata，.bss，.symtab，.rel.txt，.rel.data，.strtab，它们可以被Elf64_Shdr.sh_name确定：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405212311898.png" alt="image-20230405212311898" style="zoom:80%;"><p>在elf.o的Header中，我们可以发现SHT距离ELF文件的起始位置偏移为688Byte，并且每一项的大小为64Byte，共11项，那么我们可以找到SHT对应的二进制段。但由于这段代码太长了，因此只截取了.text和.data这两节：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405212446493.png" alt="image-20230405212446493"><p>和解析Header一样，对于SHT的每一个表项，按照结构Elf64_Shdr 逐个 Byte解析，我们就得到了.text对 ELF文件的偏移: .sh_offset &#x3D; 0x0000000000000040【.data对ELF文件的偏移为0x0000000000000050】。回忆起我们先前得知Header 的大小就是0x40，也即64 Bytes，因此.text所处的位置正是Header之后。并且，它的大小为.sh_size &#x3D;0x000000000000000e【实际上为了对齐，会进行补零】，就说明func1()与 func2()两个函数占据了14 Bytes(但目前我们并不知道每一个函数的真正位置)。对于.data，我们可以同样进行解析。readelf -s elf.o 会给我们相同的结论（我们省略了其他表项)。</p><p>值得一提的是，SHT中总存在[o]项，它被视为未定义的符号所在Section，SHN_UNDEF，也就是0。同时，这一SHT表项的值总是64 Bytes的0:</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405212718033.png" alt="image-20230405212718033" style="zoom:80%;"><h3 id="1-3-符号表"><a href="#1-3-符号表" class="headerlink" title="1.3 符号表"></a>1.3 符号表</h3><p>最后，我们要定位到每一个符号在ELF中所处的位置，这就需要一个特别的Section，<code>symtab</code>，也就是<strong>符号表</strong>(Symbol Table)。符号表被用来描述.c源文件中可以<strong>被其他ELF使用的符号</strong>。对于什么是符号Symbol，其实有必要先从编译器的角度去观察.c源文件。这部分工作主要是编译中语义分析(Semantic Analysis)的过程，通过语法中的环境(Environment)和范围(Scope)来进行管理。其中Environment映射在编译器中也被称为符号表，我们很快便能发现<strong>编译和链接语境下的符号表其实是含义相同的</strong>。</p><p>考虑赋值语句<code>int a = 0xaaaaaaaa</code>，在这里，终结符a就是我们通常所说的左值，其实它会被处理为一个字符串；终结符0xaaaaaaaa是我们所说的右值，被处理为数值。当我们在在.c源文件中引用终结符a时，其实做了两部映射(Two-Stage Mapping)；</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405192412069.png" alt="image-20230405192412069" style="zoom:67%;"><p>在C语言中，每一个对象（函数、变量）有它可见的Scope，也就是说在Scope内，这个对象是可以被引用的。而在不同的Scope内，Environment未必相同。我们仔细考虑C语言的语法，很容易发现源文件可以被区分为不同的**块(Block)**，它们通常被一组花括号<code>&#123;&#125;</code>所包围，天然地对应一颗有关Block的树（考虑最外层为根节点）。</p><p>假设当前有一个<code>.c</code>文件，其源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> g_var_init = <span class="hljs-number">0xffffffff</span>;<br><span class="hljs-type">int</span> g_var_uninit;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_undef</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func_def</span><span class="hljs-params">(<span class="hljs-type">int</span> func_param)</span><br>&#123;<br>    <span class="hljs-type">int</span> func_var = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> <br>    &#123;<br>        <span class="hljs-type">int</span> loop_var = <span class="hljs-number">1</span>;<br>        func_var += <span class="hljs-number">1</span>;<br>        g_var_init += <span class="hljs-number">1</span>;<br>        <br>        func_undef();<br>    &#125; <span class="hljs-keyword">while</span> (func_var &lt; func_param)<br>&#125;<br><br>voud <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    func_def();<br>&#125;<br></code></pre></td></tr></table></figure><p>相应的，考虑它的Block树，以及每一个Block内可见的对象：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405193201163.png" alt="image-20230405193201163" style="zoom: 80%;"><p>我们可以发现，每当进入一个sub-block以前，sub-block会复制当前block的environment，同时，在sub-block以内，新定义的变量、传入函数的参数，也都会被视为在sub-block内新的映射。因此，我们在进入新的sub-block时，可以更新Environment，从而实现了对Environment的维护。</p><p>我们已知<strong>C语言不允许在函数内定义函数</strong>，这个简单的事实将整个.c源文件分为扁平的两层：<strong>函数内部（Internal）、函数外部（External）</strong>，如下图。我们已知函数Scope内的数据实在Run-Time Stack上分配的，因此函数内Scope的Enviroment映射到栈。而函数外部，也就是函数本身以及全局变量，他们的Environment需要我们额外维护，这也就是编译器在ELF文件中生成的符号表。</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405193923601.png" alt="image-20230405193923601" style="zoom:80%;"><p>因此,<strong>外部</strong>的函数与变量是<strong>对链接可见的</strong>，也因此它们能够被其他ELF文件所引用。这就是我们在链接时所说的符号——一个函数(Function)，一个全局变量(Global Variable)，或一个静态变量(Static Variable)。</p><p>根据我们对符号的理解，按照定义和引用，可以将符号分为以下三种类型。假定source1.c是我们当前可见的源文件，source2.c是被链接的ELF的源文件。</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405195017042.png" alt="image-20230405195017042" style="zoom:80%;"><p>其中被static修饰的，被称为局部符号(Local Symbol〉或静态符号(Static Symbol)，只对同一源文件中的函数可见。在本地有定义，但没有被static修饰的，是普通的全局符号(Global Symbol)，对链接中所有的源文件可见。被<strong>extern</strong>修饰的，说明在当前的源文件中没有定义，而只在 extern 处有声明，方便当前源文件中的函数对它进行引用。</p><p>全局符号  我们考察elf.o中的例子，data1与data2是作为变量的符号，func1与func2是作为函数的符号，它们是典型的全局符号。我们来观察全局符号是怎样在ELF被找到的。从ELF Header计算偏移量到Section Header Table，当我们读取到表项为<code>.symtab</code>时，就开始处理符号表，符号表表项的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include\uapi\linux\elf.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf64_sym</span> &#123;</span><br>  Elf64_Word st_name;<span class="hljs-comment">/* Symbol name, index in string tbl */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_info;<span class="hljs-comment">/* Type and binding attributes */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_other;<span class="hljs-comment">/* No defined meaning, 0 */</span><br>  Elf64_Half st_shndx;<span class="hljs-comment">/* Associated section index */</span><br>  Elf64_Addr st_value;<span class="hljs-comment">/* Value of the symbol */</span><br>  Elf64_Xword st_size;<span class="hljs-comment">/* Associated symbol size */</span><br>&#125; Elf64_Sym;<br></code></pre></td></tr></table></figure><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405195558160.png" alt="image-20230405195558160" style="zoom: 80%;"><p>查看SHT</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405195628645.png" alt="image-20230405195628645" style="zoom:60%;"><p><code>.symtab</code>时elf.o SHT中的 [8] 表项，它对于ELF文件的偏移为 0x000000e0，占据0x120Byte，并且.symtab中的每一个元素都有固定的大小，Elf64_Shdr.sh_entrsize &#x3D; 0x0000000000000018。</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405195923966.png" alt="image-20230405195923966" style="zoom: 67%;"><p>这样，我们可以计算得到.symtab一共有12项。并且四项关于data1，data2，func1，func2：</p><p>通过<code>hexdump -C elf.o</code>后，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs shell">00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|<br>00000010  01 00 3e 00 01 00 00 00  00 00 00 00 00 00 00 00  |..&gt;.............|<br>00000020  00 00 00 00 00 00 00 00  a8 02 00 00 00 00 00 00  |................|<br>00000030  00 00 00 00 40 00 00 00  00 00 40 00 0b 00 0a 00  |....@.....@.....|<br>00000040  55 48 89 e5 90 5d c3 55  48 89 e5 90 5d c3 00 00  |UH...].UH...]...|<br>00000050  11 11 11 11 dd dd dd dd  22 22 22 22 dd dd dd dd  |........&quot;&quot;&quot;&quot;....|<br>00000060  00 47 43 43 3a 20 28 55  6f 73 20 38 2e 33 2e 30  |.GCC: (Uos 8.3.0|<br>00000070  2e 33 2d 33 2b 72 65 62  75 69 6c 64 29 20 38 2e  |.3-3+rebuild) 8.|<br>00000080  33 2e 30 00 00 00 00 00  14 00 00 00 00 00 00 00  |3.0.............|<br>00000090  01 7a 52 00 01 78 10 01  1b 0c 07 08 90 01 00 00  |.zR..x..........|<br>000000a0  1c 00 00 00 1c 00 00 00  00 00 00 00 07 00 00 00  |................|<br>000000b0  00 41 0e 10 86 02 43 0d  06 42 0c 07 08 00 00 00  |.A....C..B......|<br>000000c0  1c 00 00 00 3c 00 00 00  00 00 00 00 07 00 00 00  |....&lt;...........|<br>000000d0  00 41 0e 10 86 02 43 0d  06 42 0c 07 08 00 00 00  |.A....C..B......|<br>000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>000000f0  00 00 00 00 00 00 00 00  01 00 00 00 04 00 f1 ff  |................|<br>00000100  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000110  00 00 00 00 03 00 01 00  00 00 00 00 00 00 00 00  |................|<br>00000120  00 00 00 00 00 00 00 00  00 00 00 00 03 00 02 00  |................|<br>00000130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000140  00 00 00 00 03 00 03 00  00 00 00 00 00 00 00 00  |................|<br>00000150  00 00 00 00 00 00 00 00  00 00 00 00 03 00 05 00  |................|<br>00000160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000170  00 00 00 00 03 00 06 00  00 00 00 00 00 00 00 00  |................|<br>00000180  00 00 00 00 00 00 00 00  00 00 00 00 03 00 04 00  |................|<br>00000190  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>000001a0  07 00 00 00 11 00 02 00  00 00 00 00 00 00 00 00  |................|<br>000001b0  08 00 00 00 00 00 00 00  0d 00 00 00 11 00 02 00  |................|<br>000001c0  08 00 00 00 00 00 00 00  08 00 00 00 00 00 00 00  |................|<br>000001d0  13 00 00 00 12 00 01 00  00 00 00 00 00 00 00 00  |................|<br>000001e0  07 00 00 00 00 00 00 00  19 00 00 00 12 00 01 00  |................|<br>000001f0  07 00 00 00 00 00 00 00  07 00 00 00 00 00 00 00  |................|<br>00000200  00 65 6c 66 2e 63 00 64  61 74 61 31 00 64 61 74  |.elf.c.data1.dat|<br>00000210  61 32 00 66 75 6e 63 31  00 66 75 6e 63 32 00 00  |a2.func1.func2..|<br>00000220  20 00 00 00 00 00 00 00  02 00 00 00 02 00 00 00  | ...............|<br>00000230  00 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  |........@.......|<br>00000240  02 00 00 00 02 00 00 00  07 00 00 00 00 00 00 00  |................|<br>00000250  00 2e 73 79 6d 74 61 62  00 2e 73 74 72 74 61 62  |..symtab..strtab|<br>00000260  00 2e 73 68 73 74 72 74  61 62 00 2e 74 65 78 74  |..shstrtab..text|<br>00000270  00 2e 64 61 74 61 00 2e  62 73 73 00 2e 63 6f 6d  |..data..bss..com|<br>00000280  6d 65 6e 74 00 2e 6e 6f  74 65 2e 47 4e 55 2d 73  |ment..note.GNU-s|<br>00000290  74 61 63 6b 00 2e 72 65  6c 61 2e 65 68 5f 66 72  |tack..rela.eh_fr|<br>000002a0  61 6d 65 00 00 00 00 00  00 00 00 00 00 00 00 00  |ame.............|<br>000002b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>000002e0  00 00 00 00 00 00 00 00  1b 00 00 00 01 00 00 00  |................|<br>000002f0  06 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000300  40 00 00 00 00 00 00 00  0e 00 00 00 00 00 00 00  |@...............|<br>00000310  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>00000320  00 00 00 00 00 00 00 00  21 00 00 00 01 00 00 00  |........!.......|<br>00000330  03 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000340  50 00 00 00 00 00 00 00  10 00 00 00 00 00 00 00  |P...............|<br>00000350  00 00 00 00 00 00 00 00  08 00 00 00 00 00 00 00  |................|<br>00000360  00 00 00 00 00 00 00 00  27 00 00 00 08 00 00 00  |........&#x27;.......|<br>00000370  03 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000380  60 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |`...............|<br>00000390  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>000003a0  00 00 00 00 00 00 00 00  2c 00 00 00 01 00 00 00  |........,.......|<br>000003b0  30 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |0...............|<br>000003c0  60 00 00 00 00 00 00 00  24 00 00 00 00 00 00 00  |`.......$.......|<br>000003d0  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>000003e0  01 00 00 00 00 00 00 00  35 00 00 00 01 00 00 00  |........5.......|<br>000003f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000400  84 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000410  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>00000420  00 00 00 00 00 00 00 00  4a 00 00 00 01 00 00 00  |........J.......|<br>00000430  02 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000440  88 00 00 00 00 00 00 00  58 00 00 00 00 00 00 00  |........X.......|<br>00000450  00 00 00 00 00 00 00 00  08 00 00 00 00 00 00 00  |................|<br>00000460  00 00 00 00 00 00 00 00  45 00 00 00 04 00 00 00  |........E.......|<br>00000470  40 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |@...............|<br>00000480  20 02 00 00 00 00 00 00  30 00 00 00 00 00 00 00  | .......0.......|<br>00000490  08 00 00 00 06 00 00 00  08 00 00 00 00 00 00 00  |................|<br>000004a0  18 00 00 00 00 00 00 00  01 00 00 00 02 00 00 00  |................|<br>000004b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>000004c0  e0 00 00 00 00 00 00 00  20 01 00 00 00 00 00 00  |........ .......|<br>000004d0  09 00 00 00 08 00 00 00  08 00 00 00 00 00 00 00  |................|<br>000004e0  18 00 00 00 00 00 00 00  09 00 00 00 03 00 00 00  |................|<br>000004f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000500  00 02 00 00 00 00 00 00  1f 00 00 00 00 00 00 00  |................|<br>00000510  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>00000520  00 00 00 00 00 00 00 00  11 00 00 00 03 00 00 00  |................|<br>00000530  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000540  50 02 00 00 00 00 00 00  54 00 00 00 00 00 00 00  |P.......T.......|<br>00000550  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>*<br>00000568<br></code></pre></td></tr></table></figure><p><strong>以data1为例，介绍其在符号表中的各种含义：</strong></p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405200137407.png" alt="image-20230405200137407" style="zoom:80%;"><ul><li>根据Elf64_Sym.st_name可以查到符号在字符表中的名字，st_name&#x3D;0x7，从字符串表偏移0x7Byte，直到遇到第一个字符串终结符00(<code>\0</code>)，所得到的字符串为：<u>64 61 74 61 31 00</u>，转译为ASCII码的字符为’d’,’a’,’t’,’a’,’1’,’\0’。</li></ul><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405200642983.png" alt="image-20230405200642983" style="zoom:80%;"><ul><li>符号data1的Section索引为Elf64_Sym.st_index &#x3D; 0x2，那么在SHT中，编号为[2] 的表项是 <code>.data</code>节，因此我们确定了data1所在的Section。再根据Elf64_Sym.st_value&#x3D;0x0，我们知道data1对<code>.data</code>节的偏移为0，到此为止是Environment映射。由符号表，我们得到data1占据Elf64_Sym.st_size &#x3D; 0x8 Byte。至此，我们也完成了Type的映射，可以获得data1的数值了：【.data节的偏移量为0x50，且data1对.data偏移为0，data1数值占据8字节】</li></ul><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405201014924.png" alt="image-20230405201014924" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>操作系统,编译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux模块加载时的版本检查机制</title>
    <link href="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux模块加载时的版本检查机制"><a href="#Linux模块加载时的版本检查机制" class="headerlink" title="Linux模块加载时的版本检查机制"></a>Linux模块加载时的版本检查机制</h1><blockquote><p>参考：<a href="https://www.jb51.cc/python/3860648.html">https://www.jb51.cc/python/3860648.html</a></p></blockquote><p>Linux 的迅速发展致使相邻版本的内核之间亦存在较大的差异，即在版本补丁号（Patch Level，即内核版本号的第四位数）相邻的内核之间。为此 Linux 的开发者为了保证内核的稳定，Linux 在加载模块到内核时对模块采用了版本校验机制。当被期望加载模块的系统环境与模块的构建环境相左时，通常会出现如清单 1 所示的装载模块失败。</p><h2 id="1-模块加载校验失败"><a href="#1-模块加载校验失败" class="headerlink" title="1.模块加载校验失败"></a>1.模块加载校验失败</h2><p>首先，我们看一下当模块加载时候的报错信息：</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402204428316.png" alt="image-20230402204428316" style="zoom:100%;"><p>模块 hello.ko 构建时的环境与当前系统不一致，导致工具 insmod 在尝试装载模块 hello.ko 到内核时失败。hello.ko 是一个仅使用了函数 printk 的普通模块（。我们通过命令 dmesg获取模块装载失败的具体原因。从日志打印的<code>disagree about version of sysmbol module layout</code>可以看出，模块 hello.ko 装载失败是由于<strong>模块中 module_layout 的导出符号的版本信息与当前内核中的不符</strong>。</p><p>函数 module_layout 被定义在内核模块版本选项 MODVERSIONS（即内核可装载模块的版本校验选项）之后。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># kernel\module.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MODVERSIONS</span><br><span class="hljs-comment">/* Generate the signature for all relevant module structures here.</span><br><span class="hljs-comment"> * If these change, we don&#x27;t want to try to parse the module. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">module_layout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> module *mod,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> modversion_info *ver,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> kernel_param *kp,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> kernel_symbol *ks,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> tracepoint * <span class="hljs-type">const</span> *tp)</span><br>&#123;<br>&#125;<br>EXPORT_SYMBOL(module_layout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>那么我们如何比对内核的module_layout 和 外部模块的module_layout值呢？</p><h3 id="1-1-比对内核与模块module-layout的CRC"><a href="#1-1-比对内核与模块module-layout的CRC" class="headerlink" title="1.1 比对内核与模块module_layout的CRC"></a>1.1 比对内核与模块module_layout的CRC</h3><p>内核的<code>module_layout</code>的CRC值，我们可以通过内核编译的<code>Module.symvers</code>文件进行查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat Module.symvers | grep module_layout<br></code></pre></td></tr></table></figure><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402194808674.png" alt="image-20230402194808674" style="zoom:100%;"><p>外部模块<code>module_layout</code>的CRC值，我们可以通过modprode查看编译出的ko文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">modprobe --dump-versions xxx.ko | grep module_layout<br></code></pre></td></tr></table></figure><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402194909699.png" alt="image-20230402194909699" style="zoom:100%;"><blockquote><p>可以看到内核与外部模块的module_layout值是一样的，所以我们可以通过<strong>insmod或者modprobe加载chrdevbase.ko</strong></p></blockquote><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/8d71df88-4caa-436c-b5eb-72d2a53f2b31.png"><h3 id="1-2-Linux对于模块的两层检验"><a href="#1-2-Linux对于模块的两层检验" class="headerlink" title="1.2 Linux对于模块的两层检验"></a>1.2 Linux对于模块的两层检验</h3><p>inux 对可装载模块采取了两层验证：<strong>模块的 CRC 值校验</strong>和 <strong>vermagic 的检查</strong>。</p><p>其中模块 CRC 值校验针对模块（内核）导出符号，是一种简单的 ABI（即 Application Binary Interface）一致性检查，第一节开头的 hello.ko 加载失败的根本原因就是没有通过 CRC 值校验（即 module_layout 的 CRC 值与当前内核中的不符）。</p><p>而模块 vermagic（即 Version Magic String）则保存了模块编译时的内核版本以及 SMP 等配置信息，当模块 vermagic 与主机信息不相符时亦将终止模块的加载。</p><h2 id="2-模块的CRC值校验"><a href="#2-模块的CRC值校验" class="headerlink" title="2.模块的CRC值校验"></a>2.模块的CRC值校验</h2><p>首先我们了解一下CTC值校验在哪里添加，又是如何进行校验的</p><h3 id="2-1-添加模块的CRC值"><a href="#2-1-添加模块的CRC值" class="headerlink" title="2.1 添加模块的CRC值"></a>2.1 添加模块的CRC值</h3><p>当我们在编译内核模块时，会生成许多的中间文件：</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402205606535.png" alt="image-20230402205606535" style="zoom:80%;"><p>其中<strong>chrdevbase.mod.c</strong>是在模块源文件chrdevbase.c基础上进行的扩展，其内容如下：</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402205711705.png" alt="image-20230402205711705" style="zoom:67%;"><blockquote><p>🤺 <strong>注意</strong>：这里红色圈出来的就是各个符号，前面的16进制数字就是每个符号对应的CRC值。可以看到，module_layout对应的CRC值就是0xfa985410，与1.1节看到的是一样的！</p></blockquote><p>那么chrdevbase.mod.c在生成的过程中， 会调用modpost添加各种信息，其中有一步就是添加版本值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// scripts\mod\modpost.h</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">for</span> (mod = modules; mod; mod = mod-&gt;next) &#123;<br>err |= add_versions(&amp;buf, mod);<br>&#125;<br><br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add_versions</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buffer *b, <span class="hljs-keyword">struct</span> module *mod)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> *<span class="hljs-title">s</span>, *<span class="hljs-title">exp</span>;</span><br><span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (s = mod-&gt;unres; s; s = s-&gt;next) &#123;<br><span class="hljs-built_in">exp</span> = find_symbol(s-&gt;name);<br>s-&gt;module = <span class="hljs-built_in">exp</span>-&gt;module;<br>s-&gt;crc_valid = <span class="hljs-built_in">exp</span>-&gt;crc_valid;<br>s-&gt;crc = <span class="hljs-built_in">exp</span>-&gt;crc;<br>&#125;<br><br>buf_printf(b, <span class="hljs-string">&quot;\n&quot;</span>);<br>buf_printf(b, <span class="hljs-string">&quot;static const struct modversion_info ____versions[]\n&quot;</span>);<br>buf_printf(b, <span class="hljs-string">&quot;__used\n&quot;</span>);<br>buf_printf(b, <span class="hljs-string">&quot;__attribute__((section(\&quot;__versions\&quot;))) = &#123;\n&quot;</span>);<br><br><span class="hljs-keyword">for</span> (s = mod-&gt;unres; s; s = s-&gt;next) &#123;<br><span class="hljs-keyword">if</span> (!s-&gt;module)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (!s-&gt;crc_valid) &#123;<br>warn(<span class="hljs-string">&quot;\&quot;%s\&quot; [%s.ko] has no CRC!\n&quot;</span>,<br>s-&gt;name, mod-&gt;name);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>        <span class="hljs-comment">// 添加各个符号SYSBOL对应的CRC值</span><br>buf_printf(b, <span class="hljs-string">&quot;\t&#123; %#8x, __VMLINUX_SYMBOL_STR(%s) &#125;,\n&quot;</span>, s-&gt;crc, s-&gt;name);<br>&#125;<br><br>buf_printf(b, <span class="hljs-string">&quot;&#125;;\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>哇哦，从这里可以清晰的看到，最终生成的chrdevbase.mod.c【或chrdevbase.ko】是通过add_version添加的。</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402210324480.png" alt="image-20230402210324480" style="zoom:80%;"><h3 id="2-2-通过objdump反汇编后查看versions的值"><a href="#2-2-通过objdump反汇编后查看versions的值" class="headerlink" title="2.2 通过objdump反汇编后查看versions的值"></a>2.2 通过objdump反汇编后查看versions的值</h3><p>我们在上述<code>cat chrdevbase.mod.c</code>中可以看到几个section，如 .modinfo、.gnu.linkonce.this_module 和 __versions。<u>Linux 使用 GCC 中的声明函数属性 <code>__attribute__ </code>完成对模块的版本信息附加</u>。</p><p>通过<code>objdump --section=__versions -s chrdevbase.ko</code>的值查看当前模块的版本version值</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402211313240.png" alt="image-20230402211313240" style="zoom:50%;"><p>可以看到当前模块的module_layout也匹配上了，另外的几个值，如<code>__unregister_chrdev</code>也对应了上述的CRC值</p><h3 id="2-3-加载模块的过程中何时检验CRC"><a href="#2-3-加载模块的过程中何时检验CRC" class="headerlink" title="2.3 加载模块的过程中何时检验CRC"></a>2.3 加载模块的过程中何时检验CRC</h3><p>🥇🥈🥉 <strong>模块 CRC 值校验查看的是就是模块 __versions 小节的内容，模块的 CRC 校验过程在函数 setup_load_info 中完成</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel\module.c</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> module *<span class="hljs-title function_">setup_load_info</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> load_info *info, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-comment">/* Check module struct version now, before we try to use module. */</span><br><span class="hljs-keyword">if</span> (!check_modstruct_version(info-&gt;sechdrs, info-&gt;index.vers, mod))<br><span class="hljs-keyword">return</span> ERR_PTR(-ENOEXEC);<br><br><span class="hljs-keyword">return</span> mod;<br>&#125;<br><br><span class="hljs-comment">//--------------------------------------------------------</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_modstruct_version</span><span class="hljs-params">(Elf_Shdr *sechdrs, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> versindex, <span class="hljs-keyword">struct</span> module *mod)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *crc;<br><br><span class="hljs-keyword">if</span> (!find_symbol(VMLINUX_SYMBOL_STR(module_layout), <span class="hljs-literal">NULL</span>,&amp;crc, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>))<br>        BUG();<br><span class="hljs-keyword">return</span> check_version(sechdrs, versindex, VMLINUX_SYMBOL_STR(module_layout), mod, crc, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">//--------------------------------------------------------</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_version</span><span class="hljs-params">(Elf_Shdr *sechdrs, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> versindex, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *symname, <span class="hljs-keyword">struct</span> module *mod, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *crc, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> module *crc_owner)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i, num_versions;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">modversion_info</span> *<span class="hljs-title">versions</span>;</span><br><br><br>versions = (<span class="hljs-type">void</span> *) sechdrs[versindex].sh_addr;<br>num_versions = sechdrs[versindex].sh_size / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> modversion_info);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_versions; i++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(versions[i].name, symname) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-keyword">if</span> (versions[i].crc == maybe_relocated(*crc, crc_owner))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>pr_debug(<span class="hljs-string">&quot;Found checksum %lX vs module %lX\n&quot;</span>,<br>       maybe_relocated(*crc, crc_owner), versions[i].crc);<br><span class="hljs-keyword">goto</span> bad_version;<br>&#125;<br><br>pr_warn(<span class="hljs-string">&quot;%s: no symbol version for %s\n&quot;</span>, mod-&gt;name, symname);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>bad_version:<br>pr_warn(<span class="hljs-string">&quot;%s: disagrees about version of symbol %s\n&quot;</span>,<br>       mod-&gt;name, symname);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我的天，终于看到了第1节报错的报错的来源啦！</strong></p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402213008474.png" alt="image-20230402213008474" style="zoom:80%;"><h3 id="2-4-为什么module-layout导出的符号会发生变化"><a href="#2-4-为什么module-layout导出的符号会发生变化" class="headerlink" title="2.4 为什么module_layout导出的符号会发生变化"></a>2.4 为什么module_layout导出的符号会发生变化</h3><p>根据附录2，我们知道了导出的符号如果是函数时，如果CRC值发生了改变，可能是<strong>参数变化</strong>或者<strong>返回值变化</strong>。</p><p>因此，我们将<strong>module_layout</strong>的参数进行变化，编译后查看其CRC值</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230405235046404.png" alt="image-20230405235046404" style="zoom: 50%;"><blockquote><p>我们在参数中添加了<code>int num</code>，发现值变化成了<code>0x5d01a2ac</code></p></blockquote><p>将<strong>module_layout</strong>的参数恢复成原样，重新编译</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230405235204648.png" alt="image-20230405235204648" style="zoom:50%;"><blockquote><p>可以看到又恢复成了原来的1.1节中的值</p></blockquote><h3 id="2-5-module-layout-完全一样的两份kernel代码，生成CRC值不一样？"><a href="#2-5-module-layout-完全一样的两份kernel代码，生成CRC值不一样？" class="headerlink" title="2.5 module_layout 完全一样的两份kernel代码，生成CRC值不一样？"></a>2.5 module_layout 完全一样的两份kernel代码，生成CRC值不一样？</h3><p>当我们在module.c中<code>EXPORT_SYMBOL(module_layout)</code>之后，在编译阶段，宏会被替换成下面的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include\linux\export.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __CRC_SYMBOL(sym, sec)\</span><br><span class="hljs-meta">extern __visible void *__crc_##sym __attribute__((weak));\</span><br><span class="hljs-meta">static const unsigned long __kcrctab_##sym\</span><br><span class="hljs-meta">__used\</span><br><span class="hljs-meta">__attribute__((section(<span class="hljs-string">&quot;___kcrctab&quot;</span> sec <span class="hljs-string">&quot;+&quot;</span> #sym), unused))\</span><br><span class="hljs-meta">= (unsigned long) &amp;__crc_##sym;</span><br><br><span class="hljs-comment">/* For every exported symbol, place a struct in the __ksymtab section */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __EXPORT_SYMBOL(sym, sec)\</span><br><span class="hljs-meta">extern typeof(sym) sym;\</span><br><span class="hljs-meta">__CRC_SYMBOL(sym, sec)\</span><br><span class="hljs-meta">static const char __kstrtab_##sym[]\</span><br><span class="hljs-meta">__attribute__((section(<span class="hljs-string">&quot;__ksymtab_strings&quot;</span>), aligned(1))) \</span><br><span class="hljs-meta">= VMLINUX_SYMBOL_STR(sym);\</span><br><span class="hljs-meta">extern const struct kernel_symbol __ksymtab_##sym;\</span><br><span class="hljs-meta">__visible const struct kernel_symbol __ksymtab_##sym\</span><br><span class="hljs-meta">__used\</span><br><span class="hljs-meta">__attribute__((section(<span class="hljs-string">&quot;___ksymtab&quot;</span> sec <span class="hljs-string">&quot;+&quot;</span> #sym), unused))\</span><br><span class="hljs-meta">= &#123; (unsigned long)&amp;sym, __kstrtab_##sym &#125;</span><br></code></pre></td></tr></table></figure><p>EXPORT_SYMBOL(sym)的这一段代码，其实就是针对模块版本校验机制，生成了某个符号相应的3个段的值。段<code>__ksymtab</code>保存了符号的地址和名字，段<code>__ksymtab_strings</code>是段名字的实际存储位置，段<code>__kcrctab</code>保存了符号crc值的地址。</p><p>可见EXPORT_SYMBOL(sym)宏声明以后，符号的地址名字和CRC值都有了，已经符合版本校验的需要了。可还有一个疑问，符号实际的crc值是怎么生成的呢？宏中引用了一个外部变量<code>extern void *__crc_##sym attribute((weak));</code>，<code>__crc##sym</code>是怎么来的？</p><p>__crc##sym是在编译.o时候做的，查看内核的makefile，makefile.build文件定义了.o的生成规则：<br><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230406225635425.png" alt="image-20230405235204648" style="zoom: 67%;"></p><p>而当CONFIG_MODVERSIONS&#x3D;y 时， cmd_cc_o_c 会将file.c 编译成.tmp_file.o而不是file.o 。cmd_modversions 会检查.tmp_file.o 是否包含<code>__ksymtab</code> ，也就是说file.c 是否包含EXPORT_SYMBOL(xxx)；如果没有__ksymtab ， cmd_modversions 会将.tmp_file.o 直接更名为file.o 。如果确实包含__ksymtab ， cmd_modversions 会通过genksyms 产生xxxx ( export symbol )的符号签名( checksum )，然后调用linker 重新把这些符号以及这些符号的checksum链接进file.o。</p><p>可见符号的CRC值_crc##sym，是在编译.o时，由genksyms脚本生成的。</p><p>通过readelf命令可以，查看内核中关于版本检查的三个段<code>__ksymtab</code>、<code>__ksymtab_strings</code>、<code>__kcrctab</code>：</p><p><img src="/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230406231443917.png" alt="image-20230406231443917"></p><p>如果module_layout在符号表中地址不同，则编译生成后期对应的CRC值是不同的！！</p><p>🤖 <strong>如果两份完全一样的module_layout代码，但是生成的CRC值不同</strong>  -&gt; 那么，必定是module_layout在符号表中的位置不同，也就是在module_layout之前肯定EXPORT_SYMBOL了其他的符号，导致module_layout在对应的符号表中位置不同</p><h2 id="3-模块的vermagic检验"><a href="#3-模块的vermagic检验" class="headerlink" title="3.模块的vermagic检验"></a>3.模块的vermagic检验</h2><h3 id="3-1-内核版本是如何生成的"><a href="#3-1-内核版本是如何生成的" class="headerlink" title="3.1 内核版本是如何生成的"></a>3.1 内核版本是如何生成的</h3><p>inux版本：在<code>include/generated/utsrelease.h</code>中定义，文件中的内容如下：**#define UTS_RELEASE “4.1.15”**，utsrelease.h是kernel编译后自动生成的，用户更改里面的内容不会有效果。</p><h3 id="3-2-模块的vermagic是如何生成的"><a href="#3-2-模块的vermagic是如何生成的" class="headerlink" title="3.2 模块的vermagic是如何生成的"></a>3.2 模块的vermagic是如何生成的</h3><p>在<code>include/linux/vermagic.h</code>中定义有VERMAGIC_STRING，VERMAGIC_STRING不仅包含内核版本号，还包含有 内核使用的gcc版本，SMP与PREEMPT等配置信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> VERMAGIC_STRING \</span><br><span class="hljs-meta">UTS_RELEASE <span class="hljs-string">&quot; &quot;</span>\</span><br><span class="hljs-meta">MODULE_VERMAGIC_SMP MODULE_VERMAGIC_PREEMPT \</span><br><span class="hljs-meta">MODULE_VERMAGIC_MODULE_UNLOAD MODULE_VERMAGIC_MODVERSIONS\</span><br><span class="hljs-meta">MODULE_ARCH_VERMAGIC</span><br></code></pre></td></tr></table></figure><p>模块在编译时，我们可以看到屏幕上会显示”MODPOST”。在此阶段，VERMAGIC_STRING会添加到模块的modinfo段。在内核源码目录下scripts\mod\modpost.c文件中可以看到模块后续处理部分的代码。</p><p>模块编译生成后，通过<code>modinfo xxx.ko</code>命令可以查看此模块的vermagic等信息。</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230406233259580.png" alt="image-20230406233259580" style="zoom: 80%;"><h3 id="3-3-如何校验模块的vermagic"><a href="#3-3-如何校验模块的vermagic" class="headerlink" title="3.3 如何校验模块的vermagic"></a>3.3 如何校验模块的vermagic</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* kernel/module.c */</span> <br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_modinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> module *mod,<span class="hljs-keyword">struct</span> load_info *info)</span> <br>&#123; <br> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *modmagic = get_modinfo(info,<span class="hljs-string">&quot;vermagic&quot;</span>); <br> ... <br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!same_magic(modmagic,vermagic,info-&gt;index.vers)) &#123; <br>   ... <br> &#125; <br> ... <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="附录1：module-symvers-文件的内容"><a href="#附录1：module-symvers-文件的内容" class="headerlink" title="附录1：module.symvers 文件的内容"></a>附录1：module.symvers 文件的内容</h2><p>如果打开该文件后看到的符号CRC值都是0x00000000，那是因为你在配置的时并没有设置 <code>CONFIG_MODVERSIONS</code>。一旦设置过这个配置选项，就意味着打开了内核的 <strong>Module versioning</strong>功能。Module versioning 功能应用在我们使用模块的场合。</p><p>如果Module versioning功能被打开的话，它会以每个导出符号的C原型声明作为输入，计算出对应的CRC校验值，保存在文件 Module.symvers 中。如此一来，内核在后面要加载使用模块的时候，会两相比较模块中的CRC值和保存下来的CRC值，如果发现不相等，内核就拒绝加载这个模块。</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230403230704333.png" alt="image-20230403230704333" style="zoom:100%;"><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230403231013373.png" alt="image-20230403231013373" style="zoom:100%;"><h2 id="附录2：CRC机制"><a href="#附录2：CRC机制" class="headerlink" title="附录2：CRC机制"></a>附录2：CRC机制</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/414290127?utm_id=0">https://zhuanlan.zhihu.com/p/414290127?utm_id=0</a></p></blockquote><p>内核模块符号CRC生成相关代码在scripts&#x2F;genksyms&#x2F;目录下面，注意其中除了c代码会进行解析之外，lex.l和parse.y也会进行初步的解析。CRC即cyclic redundancy check，用于错误检查。只有当内容保持不变的时候，CRC才会保持不变。内核模块主要对导出的符号（EXPORT_SYMBOL）做检查，要求保持两个一致性：</p><ol><li>接口一致：变量、函数参数、函数返回值类型名没有变化，若是结构体，其内部所有成员也没有变化；</li><li>语义一致：结构体成员变量名不能发生变化，函数参数名无需保持一致。</li></ol><h3 id="CRC基本函数"><a href="#CRC基本函数" class="headerlink" title="CRC基本函数"></a>CRC基本函数</h3><p>linux预先定义了256个（0xff）crctab，即用于异或操作的基，并以32位为单位来做CRC操作，相关内核源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">partial_crc32_one</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> crc)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> crctab32[(crc ^ c) &amp; <span class="hljs-number">0xff</span>] ^ (crc &gt;&gt; <span class="hljs-number">8</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">partial_crc32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> crc)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (*s)<br>        crc = partial_crc32_one(*s++, crc);<br>    <span class="hljs-keyword">return</span> crc;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">crc32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> partial_crc32(s, <span class="hljs-number">0xffffffff</span>) ^ <span class="hljs-number">0xffffffff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大致流程是从初始字符开始到最后一个字符，每个字符串都用相同的操作计算crc值，直到字符串结束，得到最终的CRC值。</p><p>对EXPORT_SYMBOL的符号进行crc调用并不由scripts&#x2F;genksyms&#x2F;中的c代码直接发起，而是在编译期的语法生成时由bison的semantic actions发起，相关生成规则如下（在scripts&#x2F;genksyms&#x2F;parse.y）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">export_definition:<br>    EXPORT_SYMBOL_KEYW <span class="hljs-string">&#x27;(&#x27;</span> IDENT <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span><br>        &#123; export_symbol((*$<span class="hljs-number">3</span>)-&gt;<span class="hljs-built_in">string</span>); $$ = $<span class="hljs-number">5</span>; &#125;<br>    ;<br></code></pre></td></tr></table></figure><p>即碰到EXPROT_SYMBOL关键词时，调用genksyms.c里的export_symbol，生成crc值。</p><h3 id="CRC计算举例"><a href="#CRC计算举例" class="headerlink" title="CRC计算举例"></a>CRC计算举例</h3><p><strong>基本类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> abcde;<br>EXPORT_SYMBOL(abcde);<br></code></pre></td></tr></table></figure><p>对于符号abcde，计算过程是：</p><ol><li>partial_crc32(“unsigned”, 0xffffffff) ⇒ 0xa9df1ba</li><li>partial_crc32_one(“ “, 0xa9df1ba) ⇒ 0x10d0e7ab</li><li>partial_crc32(“int”, 0x10d0e7ab) ⇒ 0xa9d106cd</li><li>partial_crc32_one(“ “, 0xa9d106cd) ⇒ 0xde124fc3</li><li>partial_crc32(“abcde”, 0xde124fc3) ⇒ 0x2e7e6a97</li><li>partial_crc32_one(“ “, 0x2e7e6a97) ⇒ 0x552b5845</li><li>0x552b5845 ^ 0xffffffff ⇒ 0xaad4a7ba</li></ol><p>最终，abcde的crc值即为0xaad4a7ba，可以通过Module.symvers查看得到。</p><p>可以发现，以上每步相当于把变量声明的每个符号依次计算了一遍crc32值，且每个符号计算后，都会与空格的crc哈希值做异或，最后将结果的值取0xffffffff的异或，即是最终符号的crc值，即如下过程：</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230405234653884.png" alt="image-20230405234653884" style="zoom:80%;"><p>如果变量是个数组或者指针，则对于分号前的所有符号进行如上计算，包括数组大小等。</p><p>对于导出的基本类型，会产生CRC值不同的原因有：</p><ul><li>变量的类型发生改变</li><li>数组变量的大小发生改变</li></ul><p><strong>函数</strong></p><p>若定义如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">test_fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> b)</span>;<br>EXPORT_SYMBOL(test_fun);<br></code></pre></td></tr></table></figure><p>那么CRC计算如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> -&gt; test_fun -&gt; ( -&gt;<br>    <span class="hljs-type">int</span> -&gt; , -&gt;<br>    <span class="hljs-type">char</span> -&gt; , -&gt;<br>)<br></code></pre></td></tr></table></figure><p>此处变量类型使用基础变量以便理解，如果是符合变量，则需要按照需求展开。</p><p>对于导出的函数，会产生CRC值不同的原因有：</p><ul><li>函数的返回值类型发生变化；</li><li>参数的类型发生变化；</li><li>参数名字发生变化不影响CRC值。</li></ul><p><strong>结构体</strong></p><p>若定义如下复合结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_struct</span> &#123;</span><br>        <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> my_int;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_struct</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_struct</span> <span class="hljs-title">bb</span>;</span><br>        my_int cc;<br>&#125;;<br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_struct</span> *<span class="hljs-title">abcde</span>;</span><br></code></pre></td></tr></table></figure><p>对于abcde，其类型struct test_struct包含另一个结构体struct my_struct和typedef后的变量，则计算的时候，需要依次对如下变量进行计算：\</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> → <span class="hljs-title">test_struct</span> → &#123;</span> → <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> → <span class="hljs-title">my_struct</span> → &#123;</span> → <br>        <span class="hljs-type">int</span> → a → ; → <br>    &#125; → bb → ; → <br>        <span class="hljs-keyword">typedef</span> → <span class="hljs-type">int</span> → my_int → cc → ; → <br>&#125; → * → abcde<br></code></pre></td></tr></table></figure><p>也就是关于struct或者typedef后的类型，其不直接利用类型名来进行计算，而是递归展开该类型的定义，对定义中的所有元素进行再次计算，最后得出计算的结果。</p><p>需要注意的是，typedef计算与基本类型类似，但是struct计算时，其中的每个变量后的分号都纳入计算范围。</p><p>对于导出的结构体，会产生CRC值不同的原因有：</p><ul><li>结构体内变量发生变化，包括变量类型、变量名字；</li><li>结构体内成员的顺序发生改变</li><li>若有typedef，其对应的名字或者类型发生变化。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile中的include关键字</title>
    <link href="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile中的include关键字"><a href="#Makefile中的include关键字" class="headerlink" title="Makefile中的include关键字"></a>Makefile中的include关键字</h1><blockquote><p>🪶 <strong>摘录自</strong>：<a href="https://juejin.cn/post/7150700142817968158#heading-2">https://juejin.cn/post/7150700142817968158#heading-2</a></p></blockquote><h2 id="include-的概念"><a href="#include-的概念" class="headerlink" title="include 的概念"></a>include 的概念</h2><p>makefile 中可以使用 <code>include</code> 指令来包含另一个文件。 当 <code>make</code> 识别到 <code>include</code> 指令时，<u>会暂停读入当前的 makefile 文件</u>，并转而读入 <code>include</code> 指定的文件，之后再继续读取本文件的剩余内容。</p><h2 id="include的使用"><a href="#include的使用" class="headerlink" title="include的使用"></a>include的使用</h2><p>本小节实验涉及到的文件包括：</p><ul><li>inc_a</li><li>inc_b</li><li>makefile</li></ul><p><code>inc_a</code> 的内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#this is a include file for makefile</span><br><br>vari_c=<span class="hljs-string">&quot;vari_c from inc_a&quot;</span><br></code></pre></td></tr></table></figure><p><code>makefile</code> 文件的内容如下：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Make"><span class="hljs-comment"># this is a basic makefile</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:all clean</span><br><br>vari_a=<span class="hljs-string">&quot;original vari a&quot;</span><br>vari_b=<span class="hljs-string">&quot;original vari b&quot;</span><br><br><span class="hljs-keyword">include</span> inc_a<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(vari_a)</span><br>    @echo <span class="hljs-variable">$(vari_b)</span><br>    @echo <span class="hljs-variable">$(vari_c)</span><br><br><span class="hljs-section">clean:</span><br></code></pre></td></tr></table></figure><p>在 Terminal 中执行 <code>make</code> 命令并观察输出结果。</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330234842191.png" alt="image-20230330234842191" style="zoom:80%;"><p>从输出结果可以看出来 makefile 已经成功包含了 <code>inc_a</code> 文件，并且正确获取到了 <code>vari_c</code> 变量。 值得一提的是 <code>include</code> 指示符所指示的文件名可以是任何 shell 能够识别的文件名，这表明 <code>include</code> 还可以支持包含通配符的文件名。我们将在下面的实验中进行验证。</p><p><code>inc_b</code>，文件内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#this is a include file for makefile</span><br><br>vari_d=<span class="hljs-string">&quot;vari_d from inc_b&quot;</span><br></code></pre></td></tr></table></figure><p>修改 makefile，使用通配符同时包含 <code>inc_a</code> 和 <code>inc_b</code> 文件。 修改后的 makefile 内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># this is a basic makefile</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:all clean</span><br><br>vari_a=<span class="hljs-string">&quot;original vari a&quot;</span><br>vari_b=<span class="hljs-string">&quot;original vari b&quot;</span><br><br><span class="hljs-keyword">include</span> inc_*<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(vari_a)</span><br>    @echo <span class="hljs-variable">$(vari_b)</span><br>    @echo <span class="hljs-variable">$(vari_c)</span><br>    @echo <span class="hljs-variable">$(vari_d)</span><br><br><span class="hljs-section">clean:</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：makefile 中修改了两处，第一处是 <code>inc_a</code> 修改为了 <code>inc_*</code>，第二处是在 <code>all</code> 中新增了 <code>@echo $(vari_d)</code> 。因为在 <code>inc_b</code> 中我们定义了变量 <code>vari_d</code>，在 makefile 中我们需要对其值进行输出。</p></blockquote><p>执行 <code>make</code> 命令,输出结果如图：</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235057222.png" alt="image-20230330235057222" style="zoom:80%;"><p>由此说明 <code>inc_a</code> 与 <code>inc_b</code> 都被包含进了 makefile 文件中。</p><h2 id="include-文件的查找路径"><a href="#include-文件的查找路径" class="headerlink" title="include 文件的查找路径"></a>include 文件的查找路径</h2><p>当 include 指示符包含的文件不包含绝对路径，且在当前路径下也无法寻找到时，make 会按以下优先级寻找文件：</p><ol><li><code>-I</code> 指定的目录</li><li><code>/usr/gnu/include</code></li><li><code>/usr/local/include</code></li><li><code>/usr/include</code></li><li>指定 makefile 的 include 路径</li></ol><p>修改 <code>makefile</code>，不再指定 <code>inc_a</code> 和 <code>inc_b</code> 的相对路径，此时 makefile 文件的内容是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># this is a basic makefile</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:all clean</span><br><br>vari_a=<span class="hljs-string">&quot;original vari a&quot;</span><br>vari_b=<span class="hljs-string">&quot;original vari b&quot;</span><br><br><span class="hljs-keyword">include</span> inc_*<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(vari_a)</span><br>    @echo <span class="hljs-variable">$(vari_b)</span><br>    @echo <span class="hljs-variable">$(vari_c)</span><br>    @echo <span class="hljs-variable">$(vari_d)</span><br><span class="hljs-section">clean:</span><br></code></pre></td></tr></table></figure><p>当前目录结构为：</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235800533.png" alt="image-20230330235800533" style="zoom:80%;"><p>执行 <code>make</code> 命令，观察输出结果，如果发现有错误产生。</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235517959.png" alt="image-20230330235517959" style="zoom:80%;"><p>可以看到 makefile 无法找到 <code>inc_a</code> 和 <code>inc_b</code> 文件。</p><p>接下来使用 <code>make -I</code> 命令来指定搜寻路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -I ./include_demo/<br></code></pre></td></tr></table></figure><p>Terminal 输出结果如下图：</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235727451.png" alt="image-20230330235727451" style="zoom:80%;"><p>发现输出结果依然是错误的。因为从输出结果可以看出 <code>make</code> 是在查找名为 <code>inc_*</code> 的文件。现在我们修改 makefile 文件中的 <code>include</code> 行。</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs M">include inc_a inc_b<br></code></pre></td></tr></table></figure><p>Terminal 的输出结果如图所示：</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235905294.png" alt="image-20230330235905294" style="zoom:80%;"><p>说明程序得到了正确的执行。</p><blockquote><p>可见不使用通配符的情况下<code>include</code>配合<code>-I</code>选项才能得到预期效果。</p></blockquote><h2 id="include的处理细节"><a href="#include的处理细节" class="headerlink" title="include的处理细节"></a>include的处理细节</h2><p>前面提到 <code>make</code> 读入 makefile 时遇见 <code>include</code> 指示符会暂停读入当前文件，转而读入 <code>include</code> 指定的文件，之后才继续读入当前文件。</p><p>makefile 文件的内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#this makefile is test for include process</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:all clean</span><br><br>vari_a=<span class="hljs-string">&quot;vari_a @ 1st&quot;</span><br><br><span class="hljs-keyword">include</span> ./include_demo/c_inc<br><br>vari_a += <span class="hljs-string">&quot; @2nd ...&quot;</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(vari_a)</span><br><br><span class="hljs-section">clean:</span><br></code></pre></td></tr></table></figure><p>从 makefile 内容上可以看出 makefile 规则的执行过程是先定义变量 <code>vari_a</code>，然后再引入文件 <code>c_inc</code>，最后修改变量 <code>vari_a</code>。</p><p><code>c_inc</code> 文件的内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#this is a include file for include process</span><br><br>vari_a=<span class="hljs-string">&quot;vari_a from c_inc&quot;</span><br></code></pre></td></tr></table></figure><p>从中可以看出在 <code>c_inc</code> 文件中也对 <code>vari_a</code> 变量进行了定义。</p><p>执行 <code>make</code> 命令观察输出结果。</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230331000240966.png" alt="image-20230331000240966" style="zoom:80%;"><p>这说明 <code>vari_a</code> 在 <code>include</code> 过程中被修改了，并且在其后添加了字符串 <code>@2nd ...</code>，结果与预期中 <code>make</code> 处理 <code>include</code> 指示符的行为一致</p>]]></content>
    
    
    <categories>
      
      <category>Makefile学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile的执行顺序</title>
    <link href="/2023/03/30/Makefile%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2023/03/30/Makefile%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile的执行顺序"><a href="#Makefile的执行顺序" class="headerlink" title="Makefile的执行顺序"></a>Makefile的执行顺序</h1><blockquote><p>🪶 摘录自：<a href="https://blog.csdn.net/qq_35524916/article/details/77131555?spm=1001.2014.3001.5506">https://blog.csdn.net/qq_35524916/article/details/77131555?spm=1001.2014.3001.5506</a></p></blockquote><p><strong>在linux下，makefile的执行实际上分为两个阶段进行</strong></p><ul><li>第一阶段：读取所有的makefile文件（包括“MAKEFILES”变量指定的、指示符“include”指定的、以及命令行选项“-f（–file）”指定的makefile文件），内建的变量、明确规则和隐含规则，并建立所有目标和依赖之间的依赖关系结构链表。</li><li>第二阶段：根据第一阶段已经建立的依赖关系结构链表决定哪些目标需要更新，并使用对应的规则来重建这些目标。</li></ul><p><strong>make的执行过程如下：</strong></p><ol><li>依次读取变量“MAKEFILES”定义的makefile文件列表</li><li>读取工作目录下的makefile文件（缺省的是根据命名的查找顺序“GNUmakefile”，“makefile”，“Makefile”，首先找到那个就读取那个）</li><li>依次读取工作目录makefile文件中使用指示符“include”包含的文件</li><li>查找重建所有已读取的makefile文件的规则（如果存在一个目标是当前读取的某一个makefile文件，则执行此规则重建此makefile文件，完成以后从第一步开始重新执行）</li><li>初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支</li><li>根据“终极目标”以及其他目标的依赖关系建立依赖关系链表</li><li>执行除“终极目标”以外的所有的目标的规则（规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件）</li><li>执行“终极目标”所在的规则</li></ol>]]></content>
    
    
    <categories>
      
      <category>Makefile学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile中的shell函数</title>
    <link href="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/"/>
    <url>/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile中的shell函数"><a href="#Makefile中的shell函数" class="headerlink" title="Makefile中的shell函数"></a>Makefile中的shell函数</h1><p>shell函数不同于除“wildcard”函数之外的其它函数。make可以使用它来和外部通信。</p><p>函数功能：函数“shell”所实现的功能和shell中的引用（&#96;&#96;）相同，实现对命令的扩展。这就意味着需要一个shell 命令作为此函数的参数，函数的返回结果是此命令在shell中的执行结果。make仅仅对它的返回结果进行处理；make将函数返回结果中的所有换行符（“\n”）或者一对“\n\r”替换为单空格；并去掉末尾的回车符号（“\n”）或者“\n\r”。进行函数展开式时，它所调用的命令（它的参数）得到执行。除对它的引用出现在规则的命令行和递归变量的定义中以外，其它决大多数情况下，make是在读取解析Makefile时完成对函数shell的展开。</p><p>🤺 <strong>返回值</strong>：函数“shell”的参数（一个shell命令）在<strong>shell环境中的执行结果</strong>。</p><p>函数说明：注意，这个函数会新生成一个 Shell 程序来执行命令，所以你要注意其运行性能，如果你的 Makefile 中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是 Makefile 的隐晦的规则可能会让你的 shell 函数执行的次数比你想像的多得多。</p><p>🐼 <strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">contents := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> cat foo.txt)</span><br><span class="hljs-variable">$(info <span class="hljs-variable">$(contents)</span>)</span><br><span class="hljs-section">all:</span><br>@echo <span class="hljs-string">&quot;make all&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">foo.txt</span><br>hello amx!<br>I love codiing.<br></code></pre></td></tr></table></figure><img src="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/image-20230329222716788.png" alt="image-20230329222716788" style="zoom:80%;"><blockquote><p>将换行符当做空格进行连接</p></blockquote><p>🐼 <strong>示例2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">contents := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> echo *.c)</span><br><span class="hljs-variable">$(info <span class="hljs-variable">$(contents)</span>)</span><br><span class="hljs-section">all:</span><br>@echo <span class="hljs-string">&quot;make all&quot;</span><br></code></pre></td></tr></table></figure><img src="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/image-20230329222846872.png" alt="image-20230329222846872" style="zoom:90%;"><img src="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/image-20230329222921766.png" alt="image-20230329222921766" style="zoom:80%;"><p>🐼 <strong>示例3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">contents := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> sh test.sh hello)</span><br><span class="hljs-variable">$(info <span class="hljs-variable">$(contents)</span>)</span><br><span class="hljs-section">all:</span><br>@echo <span class="hljs-string">&quot;make all&quot;</span><br></code></pre></td></tr></table></figure><p>其中<code>test.sh</code>如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>name=&quot;amx&quot;<br>echo $&#123;name&#125;<br>echo $0<br>echo $1<br>echo &quot;ChatGpt4.0&quot;<br></code></pre></td></tr></table></figure><img src="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/image-20230329224038930.png" alt="image-20230329224038930" style="zoom:90%;">]]></content>
    
    
    <categories>
      
      <category>Makefile学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kernel中__attribute__属性</title>
    <link href="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/"/>
    <url>/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="kernel中-attribute-属性"><a href="#kernel中-attribute-属性" class="headerlink" title="kernel中__attribute__属性"></a>kernel中__attribute__属性</h1><blockquote><p>🐧 <strong>参考</strong>：<a href="https://www.eet-china.com/mp/a192020.html">https://www.eet-china.com/mp/a192020.html</a></p></blockquote><h2 id="1-实验程序"><a href="#1-实验程序" class="headerlink" title="1.实验程序"></a>1.实验程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __attribute__ ((constructor)) beforeMain(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before main...\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Main!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：<code>gcc test.c -o test</code></p><p>输出结果：</p><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328225545088.png" alt="image-20230328225545088" style="zoom:80%;"><blockquote><p>为什么最开始执行的不是main函数？怎么和我们刚开始学习C程序时说的不一样呢？从运行结果中，我们可以看出来beforeMain是在进入main函数之前被调用的，这对于C语言的初学者来说似乎有点难以理解。究竟是谁调用的beforeMain呢？怎么还没有进入main就可以有代码被执行呢？</p></blockquote><p>带着以上问题，我们先用-v参数来显示编译过程输出结果<code>gcc test.c -o test -v</code>：，其中输出部分如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/8/:/usr/lib/gcc/x86_64-linux-gnu/8/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/8/:/usr/lib/gcc/x86_64-linux-gnu/<br>LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/8/:/usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/8/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/8/../../../:/lib/:/usr/lib/<br>COLLECT_GCC_OPTIONS=&#x27;-o&#x27; &#x27;test&#x27; &#x27;-v&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=x86-64&#x27;<br> /usr/lib/gcc/x86_64-linux-gnu/8/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/8/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/8/lto-wrapper -plugin-opt=-fresolution=/tmp/ccxW7QBR.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o test /usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/8 -L/usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/8/../../.. /tmp/ccboZUZT.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/crtn.o<br>COLLECT_GCC_OPTIONS=&#x27;-o&#x27; &#x27;test&#x27; &#x27;-v&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=x86-64&#x27;<br></code></pre></td></tr></table></figure><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328225732402.png" alt="image-20230328225732402" style="zoom:100%;"><p>从输出结果可以看出，在链接生成最后的可执行文件时，有很多的C库二进制文件参与进来。而最终的可执行文件除了我们编写的这个简单的C代码以外，还有大量的C库文件参与了链接，并包含在了最终的可执行文件中。这个链接的过程，是由链接器ld的链接脚本来决定的。如果我们没有指定链接脚本，会默认使用ld的默认脚本。</p><p>通过<strong>ld -verbose</strong>命令来查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">using internal linker script:<br>==================================================<br>/* Script for -z combreloc -z separate-code: combine and sort reloc sections with separate code segment */<br>/* Copyright (C) 2014-2018 Free Software Foundation, Inc.<br>   Copying and distribution of this script, with or without modification,<br>   are permitted in any medium without royalty provided the copyright<br>   notice and this notice are preserved.  */<br>OUTPUT_FORMAT(&quot;elf64-x86-64&quot;, &quot;elf64-x86-64&quot;,<br>              &quot;elf64-x86-64&quot;)<br>OUTPUT_ARCH(i386:x86-64)<br>ENTRY(_start)<br>SEARCH_DIR(&quot;=/usr/local/lib/x86_64-linux-gnu&quot;); SEARCH_DIR(&quot;=/lib/x86_64-linux-gnu&quot;); SEARCH_DIR(&quot;=/usr/lib/x86_64-linux-gnu&quot;); SEARCH_DIR(&quot;=/usr/lib/x86_64-linux-gnu64&quot;); SEARCH_DIR(&quot;=/usr/local/lib64&quot;); SEARCH_DIR(&quot;=/lib64&quot;); SEARCH_DIR(&quot;=/usr/lib64&quot;); SEARCH_DIR(&quot;=/usr/local/lib&quot;); SEARCH_DIR(&quot;=/lib&quot;); SEARCH_DIR(&quot;=/usr/lib&quot;); SEARCH_DIR(&quot;=/usr/x86_64-linux-gnu/lib64&quot;); SEARCH_DIR(&quot;=/usr/x86_64-linux-gnu/lib&quot;);<br></code></pre></td></tr></table></figure><p>从上面输出可以看出这里定义了输出的文件格式、目标机器的类型，以及重要的信息和程序的入口ENTRY（_start）。</p><blockquote><p>我们的例子中beforeMain函数使用的gcc扩展属性<code>__attribute__（（constructor））</code>就是将函数对应的指令归属于.ctors section部分。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">.ctors          :<br>&#123;<br>  /* gcc uses crtbegin.o to find the start of<br>     the constructors, so we make sure it is<br>     first.  Because this is a wildcard, it<br>     doesn&#x27;t matter if the user does not<br>     actually link against crtbegin.o; the<br>     linker won&#x27;t look for a file to match a<br>     wildcard.  The wildcard also means that it<br>     doesn&#x27;t matter which directory crtbegin.o<br>     is in.  */<br>  KEEP (*crtbegin.o(.ctors))<br>  KEEP (*crtbegin?.o(.ctors))<br>  /* We don&#x27;t want to include the .ctor section from<br>     the crtend.o file until after the sorted ctors.<br>     The .ctor section from the crtend file contains the<br>     end of ctors marker and it must be last */<br>  KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))<br>  KEEP (*(SORT(.ctors.*)))<br>  KEEP (*(.ctors))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-attribute-constructor-属性"><a href="#2-attribute-constructor-属性" class="headerlink" title="2._attribute_((constructor))属性"></a>2._<em>attribute</em>_((constructor))属性</h2><blockquote><p>The constructor attribute causes the function to be called automatically before execution enters main (). 构造函数属性使函数在执行进入main（）之前自动被调用</p></blockquote><p>GNU C的一大特色就是<code>__attribute__</code>机制。<code>__attribute__</code>可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute ）。<code>__attribute__</code>写法是<code>__attribute__</code>前后都有两个下划线，并且后面会紧跟一对原括弧，括弧里面是相应的<code>__attribute__</code>参数。<code>__attribute__</code>格式为<code>__attribute__((attribute-list))</code></p><p>就是指在函数上方加上<code>__attribute__((constructor))</code>可以让这个函数在main函数执行前运行</p><p><strong>作用：<code>__attribute__((constructor))</code>可以提前初始化一些在main函数中用到的东西，便于我们做一些准备工作。</strong></p><p><strong>带有优先级的参数</strong></p><p>我们还可以给属性设置优先级，看下面示例代码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span><br><br>static void __attribute__ ((constructor(101))) beforeMain1(void)<br>&#123;<br>    printf(&quot;Before main...1\n&quot;);<br>&#125;<br>static void __attribute__ ((constructor(102))) beforeMain2(void)<br>&#123;<br>    printf(&quot;Before main...2\n&quot;);<br>&#125;<br>static void __attribute__ ((constructor(103))) beforeMain3(void)<br>&#123;<br>    printf(&quot;Before main...3\n&quot;);<br>&#125;<br><br>int main(void)<br>&#123;<br>    printf(&quot;Main!\n&quot;);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328230224517.png" alt="image-20230328230224517" style="zoom:100%;"><h2 id="3-attribute-destructor-属性"><a href="#3-attribute-destructor-属性" class="headerlink" title="3._attribute_((destructor))属性"></a>3._<em>attribute</em>_((destructor))属性</h2><p>查阅了GNU的文档你还会发现有提及这么一个写法<code>__attribute__((destructor))</code>，文档中关于这两个用法的说明如下:</p><blockquote><p>The constructor attribute causes the function to be called automatically before execution enters main (). Similarly, the destructor attribute causes the function to be called automatically after main () completes or exit () is called. Functions with these attributes are useful for initializing data that is used implicitly during the execution of the program.</p></blockquote><blockquote><p>同理, destructor让系统在main()函数退出或者调用了exit()之后,调用我们的函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __attribute__ ((constructor)) beforeMain(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before main...\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __attribute__ ((destructor)) afterMain(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After main...\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Main!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328230504826.png" alt="image-20230328230504826" style="zoom:100%;"><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>C程序中<code>__attribute__ ((constructor))</code>和<code>__attribute__ ((destructor))</code>类似于C++类中构造函数和析构函数。在main函数之前，执行一个函数，便于我们做一些准备工作；在main()函数退出或者调用了exit()之后调用。多个函数时，GCC为我们提供了一个参数叫优先级，constructor按从小到大，destructor函数相反<code> void __attribute__((constructor(5)) initFunction1(void); void __attribute__((constructor(10)) initFunction2(void);</code></p><h2 id="5-attribute用于加载动态库"><a href="#5-attribute用于加载动态库" class="headerlink" title="5.attribute用于加载动态库"></a>5.attribute用于加载动态库</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">Shared objects may <span class="hljs-keyword">export</span> functions using the<br><br>__attribute__((constructor)) and __attribute__((destructor))<br>function attributes.  Constructor functions are executed before<br>dlopen() returns, and destructor functions are executed before<br>dlclose() returns.  A shared object may <span class="hljs-keyword">export</span> multiple<br>constructors and destructors, and priorities can be associated<br>with each function to determine the order in which they are<br>executed.  See the gcc info pages (under <span class="hljs-string">&quot;Function attributes&quot;</span>)<br>for further information.<br></code></pre></td></tr></table></figure><p>函数设置__attribute__((constructor))属性，在dlopen时，会先调用该方法。</p><p>设置__attribute__((destructor))属性，在dlclose时会调用该方法。</p><p>实验程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br>__attribute__((constructor)) <span class="hljs-type">void</span> <span class="hljs-title function_">test_init</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>&#125;<br><br>__attribute__((destructor)) <span class="hljs-type">void</span> <span class="hljs-title function_">test_fini</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bye world\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -fPIC -shared test.c -o  libtest.so<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span><span class="hljs-params">(*testFunc)</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">void</span> *handle = dlopen(<span class="hljs-string">&quot;./libtest.so&quot;</span>, RTLD_LAZY);<br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;handle is null, %s\n&quot;</span>, dlerror());<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------\n&quot;</span>);<br>    testFunc f = (testFunc)dlsym(handle, <span class="hljs-string">&quot;test&quot;</span>);<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;f is null\n&quot;</span>);<br>    &#125;<br><br>    f();<br>    dlclose(handle);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc main.c -ldl -O0 -g -o main<br></code></pre></td></tr></table></figure><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328234128499.png" alt="image-20230328234128499" style="zoom:100%;">]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓init进程系列(1)ctl.interface_start</title>
    <link href="/2023/03/24/%E5%AE%89%E5%8D%93init%E8%BF%9B%E7%A8%8B%E7%B3%BB%E5%88%97-1-ctl-interface-start/"/>
    <url>/2023/03/24/%E5%AE%89%E5%8D%93init%E8%BF%9B%E7%A8%8B%E7%B3%BB%E5%88%97-1-ctl-interface-start/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓init进程系列-1-ctl-interface-start"><a href="#安卓init进程系列-1-ctl-interface-start" class="headerlink" title="安卓init进程系列(1)ctl.interface_start"></a>安卓init进程系列(1)ctl.interface_start</h1><blockquote><p>🤖 <strong>背景</strong>：为什么会有ctl.interface_start这个属性，因为安卓有了动态HAL的概念，具体可以参见我的另外一篇<a href="https://anmuxixixi.github.io/2023/03/24/%E5%8A%A8%E6%80%81%E5%8F%AF%E7%94%A8%E7%9A%84-HAL/">博客</a></p></blockquote><h2 id="1-哪里会去调用ctl-interface-start"><a href="#1-哪里会去调用ctl-interface-start" class="headerlink" title="1.哪里会去调用ctl.interface_start"></a>1.哪里会去调用ctl.interface_start</h2><p>为什么一直强调背景的重要性，如果脱离的背景，看代码的实现是痛苦的，是梦游的，是无用功🐖</p><p>就好比这里，如果不知道ctl.interface_start出现的背景，就不知道哪里调用了<code>ctl.interface_start</code>，也不知道为什么在某一个Android版本里面突然出现了它。</p><p>好了，从背景来看是为了实现HAL的动态启动，比如WIFI我们不用的时候，WIFI相应的HAL需要自动关闭，这样就实现了一个HAL的动态启动，用的时候开，最大程度的节省系统资源。</p><blockquote><p>🎨 <strong>声明</strong>：那我们以CameraHAL为例，进行分析！【本人不是专业搞Camera的，故参考<a href="https://blog.csdn.net/liujun3512159/article/details/124702217%E3%80%91">https://blog.csdn.net/liujun3512159/article/details/124702217】</a></p><p>另外，关于HAL的启动流程，我也会写一篇详尽的博客供自己复习和大家参考！</p></blockquote><p>client需要获取hal服务，一般都会调用servicemanager去getservice</p><img src="/2023/03/24/%E5%AE%89%E5%8D%93init%E8%BF%9B%E7%A8%8B%E7%B3%BB%E5%88%97-1-ctl-interface-start/image-20230324225335198-1679669618537-1-1679669619970-3.png" alt="image-20230324225335198" style="zoom:80%;"><p>当client向hwservicemanager获取服务的时候，发现找不到该服务，那么会去调用<strong>tryStartService</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\hwservicemanager\ServiceManager.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">tryStartService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; fqName, <span class="hljs-type">const</span> std::string&amp; name)</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> ::android::base::SetProperty;<br><br>    <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Since &quot;</span> &lt;&lt; fqName &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; name<br>              &lt;&lt; <span class="hljs-string">&quot; is not registered, trying to start it as a lazy HAL.&quot;</span>;<br><br>    std::<span class="hljs-built_in">thread</span>([=] &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetProperty</span>(<span class="hljs-string">&quot;ctl.interface_start&quot;</span>, fqName + <span class="hljs-string">&quot;/&quot;</span> + name)) &#123;<br>            <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Tried to start &quot;</span> &lt;&lt; fqName &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; name<br>                      &lt;&lt; <span class="hljs-string">&quot; as a lazy service, but was unable to. Usually this happens when a &quot;</span><br>                         <span class="hljs-string">&quot;service is not installed, but if the service is intended to be used as a &quot;</span><br>                         <span class="hljs-string">&quot;lazy service, then it may be configured incorrectly.&quot;</span>;<br>        &#125;<br>    &#125;).<span class="hljs-built_in">detach</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>设置属性值，key为<code>ctl.interface_start</code>，value为<code>fqName + &quot;/&quot; + name</code>，我们都知道init进行捕获到系统属性值变化以后会调用<strong>HandlePropertySet</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">HandlePropertySet</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> std::string&amp; value,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-type">const</span> std::string&amp; source_context, <span class="hljs-type">const</span> ucred&amp; cr,</span></span><br><span class="hljs-params"><span class="hljs-function">                           SocketConnection* socket, std::string* error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">StartsWith</span>(name, <span class="hljs-string">&quot;ctl.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SendControlMessage</span>(name.<span class="hljs-built_in">c_str</span>() + <span class="hljs-number">4</span>, value, cr.pid, socket, error);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当属性值以ctl.开头，调用SendControlMessage</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\property_service.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">SendControlMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg, <span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">pid_t</span> pid,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   SocketConnection* socket, std::string* error)</span> </span>&#123;<br>    <span class="hljs-comment">// 调用QueueControlMessage</span><br>    <span class="hljs-type">bool</span> queue_success = <span class="hljs-built_in">QueueControlMessage</span>(msg, name, pid, fd);<br><br>    <span class="hljs-keyword">return</span> PROP_SUCCESS;<br>&#125;<br><br><span class="hljs-comment">// system\core\init\init.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QueueControlMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message, <span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    pending_control_messages.<span class="hljs-built_in">push</span>(&#123;message, name, pid, fd&#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里往<code>pending_control_messages</code>放了<code>message, name, pid, fd</code>这些重要的信息！！！</p><p>按照init的设计思想，类似于rc文件中service的处理方式！既然向pending_control_messages放了一条信息待处理，那么必然有一个地方专门消费pending_control_messages中的信息，我理解这里运用了<strong>生产者-消费者</strong>设计模式，🐧答案在第3节！</p><h2 id="2-init进程启动后续"><a href="#2-init进程启动后续" class="headerlink" title="2.init进程启动后续"></a>2.init进程启动后续</h2><p>Android S从宏观来看，init进程总共分为3个阶段，最后一个阶段也就是<strong>SecondStageMain</strong>，当SecondStageMain所有代码执行结束，init进程基本就结束了，但不代表init进程啥也不干了，里面有一个关键的<u><strong>while循环</strong></u>，会一直监听是否收到ctlMsg信息！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\init.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SecondStageMain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsShuttingDown</span>()) &#123;<br>            <span class="hljs-built_in">HandleControlMessages</span>();<br>            <span class="hljs-built_in">SetUsbController</span>();<br>        &#125;<br>    &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们看看怎么处理CtlMsg信息的，这里我们暂时不用理会与ctl.interface_start的联系.</p><h2 id="3-HandleControlMessages-怎么处理CtlMsg"><a href="#3-HandleControlMessages-怎么处理CtlMsg" class="headerlink" title="3.HandleControlMessages:怎么处理CtlMsg"></a>3.HandleControlMessages:怎么处理CtlMsg</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\init.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleControlMessages</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 当pending_control_messages不为空的时候</span><br>    <span class="hljs-keyword">if</span> (!pending_control_messages.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> control_message = pending_control_messages.<span class="hljs-built_in">front</span>();<br>        pending_control_messages.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 关键看这里，这里回去调用HandleControlMessage处理相关的信息</span><br>        <span class="hljs-type">bool</span> success = <span class="hljs-built_in">HandleControlMessage</span>(control_message.message, control_message.name,<br>                                            control_message.pid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最为关键的是HandleControlMessage，它负责处理每一条具体的CtlMsg</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">HandleControlMessage</span><span class="hljs-params">(std::string_view message, <span class="hljs-type">const</span> std::string&amp; name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">pid_t</span> from_pid)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取进程的的cmdline_path，这里camerahal传进来的应该是hwservicemanager对应的pid</span><br>    <span class="hljs-comment">// 同时获取的cmdline_path就是hwservicemanger这个字符串</span><br>    std::string cmdline_path = <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;proc/%d/cmdline&quot;</span>, from_pid);<br>    std::string process_cmdline;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ReadFileToString</span>(cmdline_path, &amp;process_cmdline)) &#123;<br>        std::<span class="hljs-built_in">replace</span>(process_cmdline.<span class="hljs-built_in">begin</span>(), process_cmdline.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>);<br>        process_cmdline = <span class="hljs-built_in">Trim</span>(process_cmdline);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        process_cmdline = <span class="hljs-string">&quot;unknown process&quot;</span>;<br>    &#125;<br><br>    Service* service = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> action = message;<br>    <span class="hljs-comment">// 如果action以interface_开头，就去ServiceList中寻找</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ConsumePrefix</span>(&amp;action, <span class="hljs-string">&quot;interface_&quot;</span>)) &#123;<br>        service = ServiceList::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">FindInterface</span>(name);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        service = ServiceList::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">FindService</span>(name);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取我们要执行sigstop_on,oneshot_on,....,start,stop,...中的一种</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; map = <span class="hljs-built_in">GetControlMessageMap</span>();<br>    <span class="hljs-comment">// 显然这里找到的是start</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">find</span>(action);<br><span class="hljs-comment">// start对应的处理函数为DoControlStart</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; function = it-&gt;second;<br><br>    <span class="hljs-comment">// 调用DoControlStart执行这个服务</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">function</span>(service); !result.<span class="hljs-built_in">ok</span>()) &#123;<br>        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Control message: Could not ctl.&quot;</span> &lt;&lt; message &lt;&lt; <span class="hljs-string">&quot; for &#x27;&quot;</span> &lt;&lt; name<br>                   &lt;&lt; <span class="hljs-string">&quot;&#x27; from pid: &quot;</span> &lt;&lt; from_pid &lt;&lt; <span class="hljs-string">&quot; (&quot;</span> &lt;&lt; process_cmdline<br>                   &lt;&lt; <span class="hljs-string">&quot;): &quot;</span> &lt;&lt; result.<span class="hljs-built_in">error</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Control message: Processed ctl.&quot;</span> &lt;&lt; message &lt;&lt; <span class="hljs-string">&quot; for &#x27;&quot;</span> &lt;&lt; name<br>              &lt;&lt; <span class="hljs-string">&quot;&#x27; from pid: &quot;</span> &lt;&lt; from_pid &lt;&lt; <span class="hljs-string">&quot; (&quot;</span> &lt;&lt; process_cmdline &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> std::map&lt;std::string, ControlMessageFunction, std::less&lt;&gt;&gt;&amp; <span class="hljs-built_in">GetControlMessageMap</span>() &#123;<br>    <span class="hljs-comment">// clang-format off</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::map&lt;std::string, ControlMessageFunction, std::less&lt;&gt;&gt; control_message_functions = &#123;<br>        &#123;<span class="hljs-string">&quot;sigstop_on&quot;</span>,        [](<span class="hljs-keyword">auto</span>* service) &#123; service-&gt;<span class="hljs-built_in">set_sigstop</span>(<span class="hljs-literal">true</span>); <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-type">void</span>&gt;&#123;&#125;; &#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;sigstop_off&quot;</span>,       [](<span class="hljs-keyword">auto</span>* service) &#123; service-&gt;<span class="hljs-built_in">set_sigstop</span>(<span class="hljs-literal">false</span>); <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-type">void</span>&gt;&#123;&#125;; &#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;oneshot_on&quot;</span>,        [](<span class="hljs-keyword">auto</span>* service) &#123; service-&gt;<span class="hljs-built_in">set_oneshot</span>(<span class="hljs-literal">true</span>); <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-type">void</span>&gt;&#123;&#125;; &#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;oneshot_off&quot;</span>,       [](<span class="hljs-keyword">auto</span>* service) &#123; service-&gt;<span class="hljs-built_in">set_oneshot</span>(<span class="hljs-literal">false</span>); <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-type">void</span>&gt;&#123;&#125;; &#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;start&quot;</span>,             DoControlStart&#125;,<br>        &#123;<span class="hljs-string">&quot;stop&quot;</span>,              DoControlStop&#125;,<br>        &#123;<span class="hljs-string">&quot;restart&quot;</span>,           DoControlRestart&#125;,<br>    &#125;;<br>    <span class="hljs-comment">// clang-format on</span><br><br>    <span class="hljs-keyword">return</span> control_message_functions;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态可用的 HAL</title>
    <link href="/2023/03/24/%E5%8A%A8%E6%80%81%E5%8F%AF%E7%94%A8%E7%9A%84-HAL/"/>
    <url>/2023/03/24/%E5%8A%A8%E6%80%81%E5%8F%AF%E7%94%A8%E7%9A%84-HAL/</url>
    
    <content type="html"><![CDATA[<h1 id="动态可用的-HAL"><a href="#动态可用的-HAL" class="headerlink" title="动态可用的 HAL"></a>动态可用的 HAL</h1><blockquote><p>🤖 全部来自<a href="https://source.android.com/docs/core/architecture/hal/dynamic-lifecycle?hl=zh-cn">安卓官网</a></p></blockquote><p>Android 9 支持在不使用或不需要 Android 硬件子系统时动态关停这些子系统。例如，如果用户未使用 Wi-Fi，Wi-Fi 子系统就不应占用内存、耗用电量或使用其他系统资源。早期版本的 Android 中，在 Android 手机启动的整个期间，Android 设备上的 HAL&#x2F;驱动程序都会保持开启状态。</p><p>实现动态关停涉及连接数据流以及执行动态进程，下文对此进行了详细介绍。</p><h2 id="对-HAL-定义所做的更改"><a href="#对-HAL-定义所做的更改" class="headerlink" title="对 HAL 定义所做的更改"></a>对 HAL 定义所做的更改</h2><p>要实现动态关停，不仅需要有关于哪些进程为哪些 HAL 接口提供服务的信息（此类信息之后在其他情况中也可能很有用），还需要确保设备启动时不启动进程，而且在进程退出后，直到系统再次请求启动它们之前，都不重新启动它们。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># some init.rc script associated with the HAL</span><br>service vendor.some-service-name /vendor/bin/hw/some-binary-service<br>    <span class="hljs-comment"># init language extension, provides information of what service is served</span><br>    <span class="hljs-comment"># if multiple interfaces are served, they can be specified one on each line</span><br>    interface android.hardware.light@2.0::ILight default<br>    <span class="hljs-comment"># restarted if hwservicemanager dies</span><br>    <span class="hljs-comment"># would also cause the hal to start early during boot if disabled wasn&#x27;t set</span><br>    class hal<br>    <span class="hljs-comment"># will not be restarted if it exits until it is requested to be restarted</span><br>    oneshot<br>    <span class="hljs-comment"># will only be started when requested</span><br>    disabled<br>    <span class="hljs-comment"># ... other properties</span><br></code></pre></td></tr></table></figure><h2 id="对-init-和-hwservicemanager-所做的更改"><a href="#对-init-和-hwservicemanager-所做的更改" class="headerlink" title="对 init 和 hwservicemanager 所做的更改"></a>对 init 和 hwservicemanager 所做的更改</h2><p>为了实现动态关停，还需要让 <code>hwservicemanager</code> 告知 <code>init</code> 启动所请求的服务。在 Android 9 中，<code>init</code> 包含三个额外的控制消息（例如，<code>ctl.start</code>）：<code>ctl.interface_start</code>、<code>ctl.interface_stop</code> 和 <code>ctl.interface_restart</code>。这些消息可用于指示 <code>init</code> 打开或关闭特定硬件接口。如果系统请求使用某个服务但该服务未注册，<code>hwservicemanager</code> 会请求启动该服务。不过，动态 HAL 不需要使用以上任何消息。</p><h2 id="确定-HAL-退出"><a href="#确定-HAL-退出" class="headerlink" title="确定 HAL 退出"></a>确定 HAL 退出</h2><p>在 Android 9 中，必须手动确定 HAL 退出。对于 Android 10 及更高版本，还可以使用自动生命周期确定 HAL 退出。</p><p>为了实现动态关停，需要多个策略来决定何时启动和关停 HAL。如果 HAL 出于任何原因决定退出，当系统再次需要用到它时，它将使用以下信息和基础架构自动重新启动：HAL 定义中提供的信息，以及更改后的 <code>init</code> 和 <code>hwservicemanager</code> 提供的基础架构。这可能会涉及多个不同的策略，包括：</p><ul><li>如果有人对 HAL 调用关闭命令或类似的 API，则 HAL 可能会选择自行调用退出命令。此行为必须在相应的 HAL 接口中指定。</li><li>HAL 可在任务完成后关停（记录在 HAL 文件中）。</li></ul><h2 id="自动生命周期"><a href="#自动生命周期" class="headerlink" title="自动生命周期"></a>自动生命周期</h2><p>Android 10 为内核和 hwservicemanager 添加了更多支持，可让 HAL 在没有任何客户端时自动关停。如需使用此功能，请根据“对 HAL 定义所做的更改”这一部分完成其中所有步骤，并执行以下操作：</p><ul><li>使用 <code>LazyServiceRegistrar</code> 而不是成员函数 <code>registerAsService</code> 通过 C++ 注册服务，例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// only one instance of LazyServiceRegistrar per process</span><br>LazyServiceRegistrar registrar;<br>registrar.<span class="hljs-built_in">registerAsService</span>(myHidlService <span class="hljs-comment">/* , &quot;default&quot; */</span>);<br></code></pre></td></tr></table></figure><ul><li>验证 HAL 客户端是否仅在使用时保留对顶级 HAL（通过 <code>hwservicemanager</code> 注册的接口）的引用。为了避免出现延迟，如果该引用在继续执行的 hwbinder 线程上被丢弃，客户端还应该在丢弃引用后调用 <code>IPCThreadState::self()-&gt;flushCommands()</code>，以确保 binder 驱动程序在相关引用计数发生变化时收到通知。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习笔记</title>
    <link href="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="git学习笔记"><a href="#git学习笔记" class="headerlink" title="git学习笔记"></a>git学习笔记</h1><h2 id="git下载安装"><a href="#git下载安装" class="headerlink" title="git下载安装"></a>git下载安装</h2><p>下载地址：<a href="https://git-scm.com/download">Git - Downloads</a></p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1679585116661-4.png" alt="img"><p>以得到如下安装文件：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1679585140689-7.png" alt="img"><p>双击下载的安装文件来安装Git。安装完成后在电脑桌面（也可以是其他目录）点击右键，如果能够看</p><p>到如下两个菜单则说明Git安装成功</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230323232638131.png" alt="image-20230323232638131" style="zoom: 70%;"><p>备注：</p><ul><li>Git GUI：Git提供的图形界面工具</li><li>Git Bash：Git提供的命令行工具</li></ul><p>当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><h2 id="git三个区"><a href="#git三个区" class="headerlink" title="git三个区"></a>git三个区</h2><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/e38fd405-7e6a-4cc7-b576-a991af1d9cd5.png" alt="在这里插入图片描述"><ul><li><code>Workspace</code>：工作区，就是你平时存放项目代码的地方</li><li><code>Index / Stage</code>：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息,一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）</li><li><code>Repository</code>：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li><code>Remote</code>：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><hr><p><strong>命令如下：</strong></p><ol><li>clone（克隆）: 从远程仓库中克隆代码到本地仓库</li><li>checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订</li><li>add（添加）: 在提交前先将代码提交到暂存区</li><li>commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本</li><li>fetch (抓取) ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li><li>pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge</li><li>push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</li></ol><h2 id="git-config配置作者信息"><a href="#git-config配置作者信息" class="headerlink" title="git config配置作者信息"></a>git config配置作者信息</h2><blockquote><p>后盾人：<a href="https://www.bilibili.com/video/BV1WW4y1b78T">https://www.bilibili.com/video/BV1WW4y1b78T</a></p></blockquote><p>配置文件为<code>~/.gitconfig</code>，执行任何Git配置命令后文件将自动创建。</p><p>第一个要配置的是你个人的用户名称和电子邮件地址，这两条配置很重要，每次Git提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name “OneAmxixixi”<br>git config --global user.email “842629356@qq.com&quot;<br></code></pre></td></tr></table></figure><ul><li>如果我们要在特定的项目仓中修改提交人信息：</li></ul><p>当我们git init初始化本地仓库后，会出现.git文件，我们进入里面的配置文件<code>config</code>。</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325224813424.png" alt="image-20230325224813424" style="zoom:70%;"><p>此时config文件如下：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325224941049.png" alt="image-20230325224941049" style="zoom: 67%;"><p>修改当前仓库提交人信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">Administrator@WBX-20220621BRZ MINGW64 /g/git强化学习/android12 (master)<br>$ git config user.name <span class="hljs-string">&quot;baitaowulong&quot;</span><br></code></pre></td></tr></table></figure><p>此时当前仓库的<code>.git/config</code>就出现了新的提交人</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325225038843.png" alt="image-20230325225038843" style="zoom:67%;"><h2 id="gitignore添加文件至忽略列表"><a href="#gitignore添加文件至忽略列表" class="headerlink" title=".gitignore添加文件至忽略列表"></a>.gitignore添加文件至忽略列表</h2><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为<code>.gitignore</code> 的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略所有以.a结尾的文件</span><br>*.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略所有以.a结尾的文件，除了lib.a</span><br>!lib.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅仅忽略当前目录下的TODO文件夹，但不忽略当前路径子文件的TODO文件夹，例如./subdir/TODO</span><br>/TODO<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略build/目录下所有文件</span><br>build/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略doc目录下以.txt结尾的文件，但不忽略doc子目录下以txt文件的文件，比如doc/server/arch.txt不会忽略</span><br>doc/*.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略doc文件下所有以pdf结尾的文件，包括子目录</span><br>doc/**/*.pdf<br></code></pre></td></tr></table></figure><ol><li>我们创建了两个文件，一个以<code>.java</code>结尾，一个以<code>.c</code>结尾</li></ol><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325231753957.png" alt="image-20230325231753957" style="zoom:80%;"><ol start="2"><li>在<code>.gitignore</code>中设置被忽略的规则</li></ol><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325231903931.png" alt="image-20230325231903931" style="zoom:80%;"><ol start="3"><li>此时本地仓库就不会跟踪<code>.gitignore</code>中的内容</li></ol><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325231922326.png" alt="image-20230325231922326" style="zoom: 80%;"><h2 id="git-rm删除文件"><a href="#git-rm删除文件" class="headerlink" title="git rm删除文件"></a>git rm删除文件</h2><h3 id="git-rm基本用法"><a href="#git-rm基本用法" class="headerlink" title="git rm基本用法"></a>git rm基本用法</h3><p><strong>作用：</strong>  <strong>同时从工作区和索引中删除文件</strong>。即本地的文件也被删除了。</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326104602205.png" alt="image-20230326104602205" style="zoom:80%;"><h3 id="git-rm-–cache后悔药"><a href="#git-rm-–cache后悔药" class="headerlink" title="git rm –cache后悔药"></a>git rm –cache后悔药</h3><blockquote><p>场景：假设我们手快了，将一些文件添加到了本地版本库里面，现在想删除它，但是又不希望本地的文件丢失。</p></blockquote><p><strong>作用：</strong> <strong>从索引中删除文件。但是本地文件还存在</strong>， 只是不希望这个文件被版本控制</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326105155871.png" alt="image-20230326105155871" style="zoom:80%;"><h2 id="git-mv修改文件名"><a href="#git-mv修改文件名" class="headerlink" title="git mv修改文件名"></a>git mv修改文件名</h2><blockquote><p>场景：发现版本库里面的文件需要修改，例如我们要将版本库里面的binder.c改成bind.c</p></blockquote><p><strong>作用：</strong></p><ul><li><p>git mv 命令用于移动或重命名一个文件、目录或软连接。</p></li><li><p>它会将内容从工作区和暂存区中重命名，手动重命名需要执行两步操作，git mv 一步即可</p></li></ul><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326110457377.png" alt="image-20230326110457377" style="zoom:80%;"><p>如果不采取git mv，需要两步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv led_t286.c led_q385.c<br>git add led_t286.c led_t286<br></code></pre></td></tr></table></figure><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326111013402.png" alt="image-20230326111013402" style="zoom:80%;"><h2 id="git-log查看版本变动信息"><a href="#git-log查看版本变动信息" class="headerlink" title="git log查看版本变动信息"></a>git log查看版本变动信息</h2><p><strong>作用：</strong>查看版本变动信息</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326112521485.png" alt="image-20230326112521485" style="zoom:80%;"><p>如果想看查看更加详细一点的信息可以使用<code>git log -p</code></p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326112631990.png" alt="image-20230326112631990" style="zoom:80%;"><p>如果想要日志以某种格式输出可以使用<code>git log --pretty=format</code></p><blockquote><p>详细可参考：<a href="https://blog.csdn.net/u011106915/article/details/105836289/">https://blog.csdn.net/u011106915/article/details/105836289/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --pretty=format:&quot;SHA-1:%h - 创建人:%an 时间:%ad 提交信息:%s&quot; --date=format:&quot;%y-%m-%d %H:%M:%S&quot; --shortstat --since=2.weeks &gt; log.txt<br></code></pre></td></tr></table></figure><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326112833997.png" alt="image-20230326112833997" style="zoom:67%;"><h2 id="git-amend修改最近一次提交"><a href="#git-amend修改最近一次提交" class="headerlink" title="git amend修改最近一次提交"></a>git amend修改最近一次提交</h2><blockquote><p>场景：假如刚刚有一笔提交，需要重新修改后提交，但是我们又不想生成新的commitId重新提交</p></blockquote><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326113641189.png" alt="image-20230326113641189" style="zoom:80%;"><h2 id="git命令创建别名"><a href="#git命令创建别名" class="headerlink" title="git命令创建别名"></a>git命令创建别名</h2><p>Linux：在home目录下，编辑<code>.gitconfig</code>文件</p><p>WIndow：在 <code>$HOME</code> 目录下（一般情况下是 <code>C:\Users\$USER</code> ）的 <code>.gitconfig</code> 文件</p><p>添加以下内容：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326210601688.png" alt="image-20230326210601688" style="zoom:80%;"><p>接下来我们就可以使用简短的命令表示以前繁琐的命令</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326210430079.png" alt="image-20230326210430079" style="zoom: 80%;"><p>如果我们想更简短一点，在Linux下，编辑<code>~/.bashrc</code>【Window编辑<code>C:\Users\$USER\.bash_profile</code>】，添加以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias gs=&#x27;git status&#x27;<br>alias gss=&#x27;git status |grep modified&#x27;<br>alias gd=&#x27;git diff &#x27;<br>alias gds=&#x27;git diff --staged&#x27;<br>alias gsh=&#x27;git show &#x27;<br>alias ga=&#x27;git add .&#x27;<br>alias gcm=&#x27;git commit .&#x27;<br>alias gc=&#x27;git checkout -- &#x27;<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">alias</span> gl=<span class="hljs-string">&#x27;git log --pretty=oneline  --abbrev-commit&#x27;</span></span><br>alias gl=&#x27;git lg&#x27;<br>alias glh=&#x27;git lg --graph&#x27;<br>alias gls=&#x27;git lg --author=panfei&#x27;<br>alias gb=&#x27;git branch -v&#x27;<br></code></pre></td></tr></table></figure><p>就可以使用<code>gs</code>表示<code>git status</code>…</p><h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><blockquote><p>🐌 <strong>参考</strong>：<a href="https://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html">阮一峰博客</a></p></blockquote><p>对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。</p><p>这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（<code>git merge</code>）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>git cherry-pick</code>命令的作用，就是将指定的提交（commit）应用于其他分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick &lt;commitHash&gt;<br></code></pre></td></tr></table></figure><p>上面命令就会将指定的提交<code>commitHash</code>，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。</p><p>举例来说，代码仓库有<code>master</code>和<code>feature</code>两个分支。</p><blockquote><p>a - b - c - d   Master<br>     <br>       e - f - g Feature</p></blockquote><p>现在将提交<code>f</code>应用到<code>master</code>分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到 master 分支</span><br>$ git checkout master<br><br><span class="hljs-comment"># Cherry pick 操作</span><br>$ git cherry-pick f<br></code></pre></td></tr></table></figure><p>上面的操作完成以后，代码库就变成了下面的样子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">a - b - c - d - f   Master<br>     \<br>       e - f - g Feature<br></code></pre></td></tr></table></figure><p>从上面可以看到，<code>master</code>分支的末尾增加了一个提交<code>f</code>。</p><p><code>git cherry-pick</code>命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bas">$ git cherry-pick feature<br></code></pre></td></tr></table></figure><p>上面代码表示将<code>feature</code>分支的最近一次提交，转移到当前分支。</p><h3 id="转移多个提交"><a href="#转移多个提交" class="headerlink" title="转移多个提交"></a>转移多个提交</h3><p>Cherry pick 支持一次转移多个提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;<br></code></pre></td></tr></table></figure><p>上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。</p><p>如果想要转移一系列的连续提交，可以使用下面的简便语法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick A..B <br></code></pre></td></tr></table></figure><p>上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。</p><p>注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick A^..B <br></code></pre></td></tr></table></figure><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><p><code>git cherry-pick</code>命令的常用配置项如下。</p><p><strong>（1）<code>-e</code>，<code>--edit</code></strong></p><p>打开外部编辑器，编辑提交信息。</p><p><strong>（2）<code>-n</code>，<code>--no-commit</code></strong></p><p>只更新工作区和暂存区，不产生新的提交。</p><p><strong>（3）<code>-x</code></strong></p><p>在提交信息的末尾追加一行<code>(cherry picked from commit ...)</code>，方便以后查到这个提交是如何产生的。</p><p><strong>（4）<code>-s</code>，<code>--signoff</code></strong></p><p>在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</p><p><strong>（5）<code>-m parent-number</code>，<code>--mainline parent-number</code></strong></p><p>如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。</p><p><code>-m</code>配置项告诉 Git，应该采用哪个分支的变动。它的参数<code>parent-number</code>是一个从<code>1</code>开始的整数，代表原始提交的父分支编号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick -m 1 &lt;commitHash&gt;<br></code></pre></td></tr></table></figure><p>上面命令表示，Cherry pick 采用提交<code>commitHash</code>来自编号1的父分支的变动。</p><p>一般来说，1号父分支是接受变动的分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from）。</p><h3 id="代码冲突"><a href="#代码冲突" class="headerlink" title="代码冲突"></a>代码冲突</h3><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p><p><strong>（1）<code>--continue</code></strong></p><p>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（<code>git add .</code>），第二步使用下面的命令，让 Cherry pick 过程继续执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure><p><strong>（2）<code>--abort</code></strong></p><p>发生代码冲突后，放弃合并，回到操作前的样子。</p><p><strong>（3）<code>--quit</code></strong></p><p>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。</p><h3 id="转移到另一个代码库"><a href="#转移到另一个代码库" class="headerlink" title="转移到另一个代码库"></a>转移到另一个代码库</h3><p>Cherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add target git://gitUrl<br></code></pre></td></tr></table></figure><p>上面命令添加了一个远程仓库<code>target</code>。</p><p>然后，将远程代码抓取到本地。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bas">$ git fetch target<br></code></pre></td></tr></table></figure><p>上面命令将远程代码仓库抓取到本地。</p><p>接着，检查一下要从远程仓库转移的提交，获取它的哈希值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> target/master<br></code></pre></td></tr></table></figure><p>最后，使用<code>git cherry-pick</code>命令转移提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick &lt;commitHash&gt;<br></code></pre></td></tr></table></figure><h2 id="Git-中-HEAD、工作树和索引之间的区别"><a href="#Git-中-HEAD、工作树和索引之间的区别" class="headerlink" title="Git 中 HEAD、工作树和索引之间的区别"></a>Git 中 HEAD、工作树和索引之间的区别</h2><blockquote><p>参考：<a href="http://fanyouf.gitee.io/interview/git/02.html#%E7%AE%80%E7%89%88">http://fanyouf.gitee.io/interview/git/02.html#%E7%AE%80%E7%89%88</a></p></blockquote><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2de056a0-fa40-11eb-991d-334fd31f0201.png" alt="img" style="zoom:80%;"><p>在<code>git</code>中，可以存在很多分支，其本质上是一个指向<code>commit</code>对象的可变指针，而<code>Head</code>是一个特别的指针，是一个指向你正在工作中的本地分支的指针</p><p>简单来讲，就是你现在在哪儿，HEAD 就指向哪儿</p><p>例如当前我们处于<code>master</code>分支，所以<code>HEAD</code>这个指针指向了<code>master</code>分支指针</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/36cb0da0-fa40-11eb-991d-334fd31f0201.png" alt="img" style="zoom:80%;"><p>然后通过调用<code>git checkout test</code>切换到<code>test</code>分支，那么<code>HEAD</code>则指向<code>test</code>分支，如下图：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3e86ba80-fa40-11eb-991d-334fd31f0201.png" alt="img" style="zoom:80%;"><p>但我们在<code>test</code>分支再一次<code>commit</code>信息的时候，<code>HEAD</code>指针仍然指向了<code>test</code>分支指针，而<code>test</code>分支指针已经指向了最新创建的提交，如下图：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/439839b0-fa66-11eb-991d-334fd31f0201.png" alt="img" style="zoom: 50%;"><p>这个<code>HEAD</code>存储的位置就在<code>.git/HEAD</code>目录中，查看信息可以看到<code>HEAD</code>指向了另一个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> .git/HEAD</span><br>ref: refs/heads/master<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> .git/refs/heads/master</span><br>7406a10efcc169bbab17827aeda189aa20376f7f<br></code></pre></td></tr></table></figure><p>这个文件的内容是一串哈希码，而这个哈希码正是<code>master</code>分支上最新的提交所对应的哈希码</p><p>所以，当我们切换分支的时候，<code>HEAD</code>指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</p><p>所以，HEAD 指针 ——–&gt; 分支指针 ——–&gt; 最新提交</p><h3 id="工作树和索引"><a href="#工作树和索引" class="headerlink" title="工作树和索引"></a>工作树和索引</h3><p>在<code>Git</code>管理下，大家实际操作的目录被称为<strong>工作树</strong>，也就是<strong>工作区域</strong></p><p>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域</p><p><code>Git</code>在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库</p><p>因此，要提交文件，首先需要把文件加入到索引区域中。</p><p>所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交</p><blockquote><p>工作树就是工作区，索引就是暂存区，数据库就是本地仓库</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>从所在的位置来看：</p><ul><li>HEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</li><li>工作树是查看和编辑的（源）文件的实际内容</li><li>索引是放置你想要提交给 git 仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过 git commit 则将索引区域的文件提交到 git 仓库中</li></ul><h2 id="如何理解git-checkout-–-file和git-reset-HEAD-–-file"><a href="#如何理解git-checkout-–-file和git-reset-HEAD-–-file" class="headerlink" title="如何理解git checkout – file和git reset HEAD – file"></a>如何理解git checkout – file和git reset HEAD – file</h2><blockquote><p>参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897889638509536">https://www.liaoxuefeng.com/wiki/896043488029600/897889638509536</a></p></blockquote><p>git checkout – file：撤销对工作区修改；这个命令是以最新的存储时间节点（add和commit）为参照，覆盖工作区对应文件file；这个命令改变的是<strong>工作区</strong>【使用场景：当需要撤回工作区的内容到上一个版本，<strong>但是还没有</strong>git add添加到暂存区】</p><p>git reset HEAD – file：清空add命令向暂存区提交的关于file文件的修改（Ustage）；这个命令仅改变<strong>暂存区</strong>，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何改变【使用场景：当需要撤回工作区的内容到上一个版本，<strong>但是已经</strong>git add添加到暂存区】</p><p>🍭 <strong>总结：</strong></p><blockquote><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Git学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核编译</title>
    <link href="/2023/03/22/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"/>
    <url>/2023/03/22/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux内核编译"><a href="#Linux内核编译" class="headerlink" title="Linux内核编译"></a>Linux内核编译</h1><h2 id="1-linux内核中Makefile、Kconfig、-config的关系"><a href="#1-linux内核中Makefile、Kconfig、-config的关系" class="headerlink" title="1.linux内核中Makefile、Kconfig、.config的关系"></a>1.linux内核中Makefile、Kconfig、.config的关系</h2><p><strong>三者的作用：</strong></p><ul><li>Makefile：一个文本形式的文件，编译源文件的方法。</li><li>Kconfig：一个文本形式的文件，内核的配置菜单。</li><li>.config：编译所依据的配置</li></ul><p><strong>三者的关系：</strong></p><p>简单来说就是去饭店点菜：Kconfig是菜单，Makefile是做法，.config就是你点的菜。在运行make menuconfig后在配置界面中出现的就是Kconfig中的选项，在界面中看到的已经配置好的选项就是从.config中读取出来的，当配置完成后就会将配置重新保存到.config中，编译时makefile会读取.config中配置来对内核进行编译。</p><blockquote><ol><li>如果.config不存在，运行make config&#x2F;menuconfig时的缺省设置由固化在各个Kconfig文件中各项目的缺省值决定。</li><li>如果.config存在，运行make config&#x2F;menuconfig时的缺省设置即是当前.config的设置，若对设置进行了修改，<code>.config</code>将被更新。</li><li>arch&#x2F;arm&#x2F;defconfig是一个缺省的配置文件，make defconfig时会根据这个文件生成当前的.config。</li><li>arch&#x2F;arm&#x2F;configs文件夹中有许多命名为xxx_defconfig的配置文件，如果运行make xxx_defconfig，当前.config文件会由xxx_defconfig文件生成。</li></ol></blockquote><p>🐼 <strong>总结一下</strong></p><p>执行<code>make xxx_defconfig</code>生成.config文件</p><p>执行<code>make menuconfig</code>可以修改.config文件。</p><h2 id="2-模块编译时obj-y和obj-m的区别"><a href="#2-模块编译时obj-y和obj-m的区别" class="headerlink" title="2.模块编译时obj-y和obj-m的区别"></a>2.模块编译时obj-y和obj-m的区别</h2><p>在进行模块编译时，主要有两个选项，obj-m和obj-y，而与内核密切相关的是obj-y选项，下面对两者之间的区别简单总结一下。</p><p>以test.c文件为例：</p><p>obj-m +&#x3D; test.o</p><p>obj-y  +&#x3D; test.o</p><p>其中:</p><ul><li><p>obj-m表示把文件test.o作为”模块”进行编译，不会编译到内核，但是会生成一个独立的 “test.ko” 文件。</p></li><li><p>obj-y表示把test.o文件编译进内核</p></li></ul><h2 id="3-Kernel中Makefile的语法"><a href="#3-Kernel中Makefile的语法" class="headerlink" title="3.Kernel中Makefile的语法"></a>3.Kernel中Makefile的语法</h2><p>1）直接编译</p><p>obj-y &#x3D; led.o</p><p>2）条件编译</p><p>obj-$(CONFIG_RAPIDIO) +&#x3D; rapidio.o</p><p>3）编译目录：</p><p>obj-$(CONFIG_ISCSI_TARGET)  +&#x3D; iscsi&#x2F;</p><h2 id="4-Kernel中Kconfig的语法"><a href="#4-Kernel中Kconfig的语法" class="headerlink" title="4.Kernel中Kconfig的语法"></a>4.Kernel中Kconfig的语法</h2><blockquote><p> 参考：<a href="https://mp.weixin.qq.com/s/crXt-6EvKtWg9QX7SM90Sw">https://mp.weixin.qq.com/s/crXt-6EvKtWg9QX7SM90Sw</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android S创建逻辑分区</title>
    <link href="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/"/>
    <url>/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-S创建逻辑分区"><a href="#Android-S创建逻辑分区" class="headerlink" title="Android S创建逻辑分区"></a>Android S创建逻辑分区</h1><p>从安卓模拟器看来，super设备对应的真实块设备为<code>/dev/block/vda2</code></p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230318233940020.png" alt="image-20230318233940020" style="zoom:80%;"><p>从真实模拟器运行环境来看，super总共分为了四个分区system、vendor、product、system_ext【其中<strong>system</strong>分区由于<strong>system as root</strong>机制作为了rootfs进行挂载】</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230318234134317.png" alt="image-20230318234134317" style="zoom: 80%;"><p>另外从网上找到一份真实Android S启动日志：</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230322203850415.png" alt="image-20230322203850415" style="zoom:80%;"><p>🤖从真实启动日志来看，那么<strong>为什么这个dm设备怎么来的？为什么dm-0是system_a而不是vendor_a呢？</strong></p><p>我们要带着这些问题去思考，一步步阅读源码，解决自己的疑惑……</p><h2 id="1-整体认知——LpMetadata"><a href="#1-整体认知——LpMetadata" class="headerlink" title="1.整体认知——LpMetadata"></a>1.整体认知——LpMetadata</h2><blockquote><p>这里引用<strong>洛奇看世界</strong>大哥画的精美示意图：<a href="https://blog.csdn.net/guyongqiangx/article/details/123899602">https://blog.csdn.net/guyongqiangx/article/details/123899602</a></p></blockquote><ul><li>super整体分区布局示意图如下：</li></ul><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/086bef9593e0494a90d27eef2e071bae.png" alt="image-20230318234134317" style="zoom: 80%;"><ul><li>super分区中的metadata如下：</li></ul><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/4ff675e237df41ed9c7d4809bed4d758.png" alt="image-20230318234134317" style="zoom: 67%;"><p>metadata对应的数据结构为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\liblp\include\liblp\liblp.h</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadata</span> &#123;<br>    LpMetadataGeometry geometry;<br>    LpMetadataHeader header;<br>    std::vector&lt;LpMetadataPartition&gt; partitions;<br>    std::vector&lt;LpMetadataExtent&gt; extents;<br>    std::vector&lt;LpMetadataPartitionGroup&gt; groups;<br>    std::vector&lt;LpMetadataBlockDevice&gt; block_devices;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面配合具体从super分区中抓取的数据解析。</p><p>命令：<code>dd if=/dev/block/platform/soc/7824900.sdhci/by-name/super bs=4096 count=1048576 of=/data/super.data</code></p><blockquote><p>下面引用：<a href="https://blog.csdn.net/weixin_43899302/article/details/119343835?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_43899302/article/details/119343835?spm=1001.2014.3001.5506</a></p></blockquote><h3 id="1-1-LpMetadataGeometry"><a href="#1-1-LpMetadataGeometry" class="headerlink" title="1.1 LpMetadataGeometry"></a>1.1 LpMetadataGeometry</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\liblp\include\liblp\metadata_format.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataGeometry</span> &#123;<br>    <span class="hljs-type">uint32_t</span> magic;<br>    <span class="hljs-type">uint32_t</span> struct_size;<br>    <span class="hljs-type">uint8_t</span> checksum[<span class="hljs-number">32</span>];<br>    <span class="hljs-type">uint32_t</span> metadata_max_size;<br>    <span class="hljs-type">uint32_t</span> metadata_slot_count;<br>    <span class="hljs-type">uint32_t</span> logical_block_size;<br>&#125; __attribute__((packed)) LpMetadataGeometry;<br></code></pre></td></tr></table></figure><p>因为metadata.img前面预留了4KB（4096Byte），所以偏移位置为<strong>0x1000h</strong></p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/28872ef9b62844a5b49c0caa07658ff6.png" alt="在这里插入图片描述" style="zoom:100%;"><blockquote><p>前32位（4字节）为MetadataGeometry的Magic，在代码中会进行校验魔术字LP_METADATA_GEOMETRY_MAGIC</p><p>☃️<strong>一定注意：看镜像的16进制都是小端模式</strong></p><p>依次类推，后面0x0000034表示32位的变量struct_size</p><p>所以最终这些<strong>metadata.img</strong>中的数据都会一一按位读取到结构体LpMetadataGeometry</p></blockquote><p>在创建super分区的时候，会调用<strong>ParseGeometry</strong>去进行解析<strong>LpMetadataGeometry</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\liblp\include\liblp\metadata_format.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LP_METADATA_GEOMETRY_MAGIC 0x616c4467</span><br><br><span class="hljs-comment">// system\core\fs_mgr\liblp\reader.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParseGeometry</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* buffer, LpMetadataGeometry* geometry)</span> </span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(*geometry) &lt;= LP_METADATA_GEOMETRY_SIZE);<br>    <span class="hljs-built_in">memcpy</span>(geometry, buffer, <span class="hljs-built_in">sizeof</span>(*geometry));<br><br>    <span class="hljs-keyword">if</span> (geometry-&gt;magic != LP_METADATA_GEOMETRY_MAGIC) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has invalid geometry magic signature.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (geometry-&gt;struct_size &gt; <span class="hljs-built_in">sizeof</span>(LpMetadataGeometry)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has unrecognized fields.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    &#123;<br>        LpMetadataGeometry temp = *geometry;<br>        <span class="hljs-built_in">memset</span>(&amp;temp.checksum, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(temp.checksum));<br>        <span class="hljs-built_in">SHA256</span>(&amp;temp, temp.struct_size, temp.checksum);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(temp.checksum, geometry-&gt;checksum, <span class="hljs-built_in">sizeof</span>(temp.checksum)) != <span class="hljs-number">0</span>) &#123;<br>            LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has invalid geometry checksum.&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (geometry-&gt;struct_size != <span class="hljs-built_in">sizeof</span>(LpMetadataGeometry)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has invalid struct size.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (geometry-&gt;metadata_slot_count == <span class="hljs-number">0</span>) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has invalid slot count.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (geometry-&gt;metadata_max_size % LP_SECTOR_SIZE != <span class="hljs-number">0</span>) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Metadata max size is not sector-aligned.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-LpMetadataHeader"><a href="#1-2-LpMetadataHeader" class="headerlink" title="1.2 LpMetadataHeader"></a>1.2 LpMetadataHeader</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\liblp\include\liblp\metadata_format.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataHeader</span> &#123;<br>    <span class="hljs-type">uint32_t</span> magic;<br>    <span class="hljs-type">uint16_t</span> major_version;<br>    <span class="hljs-type">uint16_t</span> minor_version;<br>    <span class="hljs-type">uint32_t</span> header_size;<br>    <span class="hljs-type">uint8_t</span> header_checksum[<span class="hljs-number">32</span>];<br>    <span class="hljs-type">uint32_t</span> tables_size;<br>    <span class="hljs-type">uint8_t</span> tables_checksum[<span class="hljs-number">32</span>];<br>    LpMetadataTableDescriptor partitions;<br>    LpMetadataTableDescriptor extents;<br>    LpMetadataTableDescriptor groups;<br>    LpMetadataTableDescriptor block_devices;<br>&#125; __attribute__((packed)) LpMetadataHeader;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataTableDescriptor</span> &#123;<br>    <span class="hljs-type">uint32_t</span> offset;<br>    <span class="hljs-type">uint32_t</span> num_entries;<br>    <span class="hljs-type">uint32_t</span> entry_size;<br>&#125; __attribute__((packed)) LpMetadataTableDescriptor;<br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/fc1dd4f8828e4e279906e52bd4417f7a.png" alt="在这里插入图片描述" style="zoom:100%;"><h3 id="1-3-LpMetadataPartition"><a href="#1-3-LpMetadataPartition" class="headerlink" title="1.3 LpMetadataPartition"></a>1.3 LpMetadataPartition</h3><p>这个就是表示super中的一个个逻辑分区所有的字段，比如说name表示逻辑分区名，attributes表示逻辑分区属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataPartition</span> &#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">36</span>];                 <span class="hljs-comment">// 分区名字</span><br>    <span class="hljs-type">uint32_t</span> attributes;   <span class="hljs-comment">// 分区表属性</span><br>    <span class="hljs-type">uint32_t</span> first_extent_index;   <span class="hljs-comment">// 在1.4节中extents的第一个元素值索引【一般一个分区只会占用一个extents数组中的元素】</span><br>    <span class="hljs-type">uint32_t</span> num_extents;          <span class="hljs-comment">// 在1.4节中extents数组中占用了几个元素【一般只会占用一个，所以num_extents一般为0x01】</span><br>    <span class="hljs-type">uint32_t</span> group_index;          <span class="hljs-comment">// 在1.5节中的分组索引</span><br>&#125; __attribute__((packed)) LpMetadataPartition;<br><br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/e3b51aa1d6f94b66a78618b135853e75.png" alt="在这里插入图片描述" style="zoom:100%;"><p>我们来看一下前面的36字节表示的逻辑分区名，可以看到这里表示的是<strong>system</strong></p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230320234029590.png" alt="image-20230320234029590" style="zoom:80%;"><h3 id="1-4-LpMetadataExtent"><a href="#1-4-LpMetadataExtent" class="headerlink" title="1.4 LpMetadataExtent"></a>1.4 LpMetadataExtent</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataExtent</span> &#123;<br>    <span class="hljs-type">uint64_t</span> num_sectors;       <span class="hljs-comment">// 当前分区占用扇区数量，一个扇区大小为512Byte</span><br>    <span class="hljs-type">uint32_t</span> target_type;       <span class="hljs-comment">// 想要映射的类型，0表示线性Linear</span><br>    <span class="hljs-type">uint64_t</span> target_data;       <span class="hljs-comment">// 相对于super实际地址的偏移地址</span><br>    <span class="hljs-type">uint32_t</span> target_source;     <span class="hljs-comment">// 在1.6节中表示哪一个source，在安卓映射逻辑分区就是super，所以target_source一般为0x0【super在blockdevice位置】</span><br>&#125; __attribute__((packed)) LpMetadataExtent;<br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/02bdee1d427e444ab4e2d8b2416591fe.png" alt="在这里插入图片描述" style="zoom:100%;"><p>通过<code>lpdump super.img.raw</code>（未压缩的super.img）可以看到以下内容，</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230427230005157.png" alt="image-20230427230005157" style="zoom:80%;"><h3 id="1-5-LpMetadataPartitionGroup"><a href="#1-5-LpMetadataPartitionGroup" class="headerlink" title="1.5 LpMetadataPartitionGroup"></a>1.5 LpMetadataPartitionGroup</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataPartitionGroup</span> &#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">36</span>];<br>    <span class="hljs-type">uint32_t</span> flags;<br>    <span class="hljs-type">uint64_t</span> maximum_size;<br>&#125; __attribute__((packed)) LpMetadataPartitionGroup;<br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/0ea2cc17e450475396458ff4843f7a78.png" alt="在这里插入图片描述" style="zoom:100%;"><h3 id="1-6-LpMetadataBlockDevice"><a href="#1-6-LpMetadataBlockDevice" class="headerlink" title="1.6 LpMetadataBlockDevice"></a>1.6 LpMetadataBlockDevice</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataBlockDevice</span> &#123;<br>    <span class="hljs-type">uint64_t</span> first_logical_sector;<br>    <span class="hljs-type">uint32_t</span> alignment;<br>    <span class="hljs-type">uint32_t</span> alignment_offset;<br>    <span class="hljs-type">uint64_t</span> size;<br>    <span class="hljs-type">char</span> partition_name[<span class="hljs-number">36</span>];<br>    <span class="hljs-type">uint32_t</span> flags;<br>&#125; __attribute__((packed)) LpMetadataBlockDevice;<br><br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/9d54d69d1fe943458fe819d4edfa5bb8.png" alt="在这里插入图片描述" style="zoom100%;"><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230426231255747.png" alt="image-20230426231255747" style="zoom:60%;"><h2 id="2-Device-Mapper机制简介"><a href="#2-Device-Mapper机制简介" class="headerlink" title="2.Device Mapper机制简介"></a>2.Device Mapper机制简介</h2><blockquote><p>参考<strong>内核工匠</strong>的<a href="https://blog.csdn.net/feelabclihu/article/details/106581248?spm=1001.2014.3001.5506">DeviceMapper架构及在android上的应用</a></p></blockquote><p>Device Mapper是Linux2.6 内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构。</p><p>Device Mapper将所有与策略相关的工作放到用户空间完成，内核中主要提供完成这些策略所需要的机制。用户空间部分责配置具体的策略和控制逻辑，比如逻辑设备和哪些物理设备建立映射，怎么建立这些映射关系等，而具体重定向 IO 请求的工作由内核中相关代码完成。</p><p>内核中相关代码在内核源码的 kernel&#x2F;driver&#x2F;md&#x2F; 目录中，其代码文件可以划分为实现device mapper 内核中基本架构的文件(例如：dm.c dm_table.c等)和实现具体映射工作的 target driver 插件文件(例如：dm-bow.c dm-crypt.c dm-linear.c等)两部分。</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/format.png" style="zoom:80%;"><p>它包含三个重要的对象概念，Mapped Device、Mapping Table、Target device。</p><ul><li><strong>Mapped Device</strong>：是一个抽象的逻辑设备，通过MappingTable描述的映射关系（Mapped Device 逻辑的起始地址、范围、和表示在 Target Device 所在物理设备的地址偏移量以及Target 类型等信息）和Target Device建立映射关系。</li><li><strong>Target Device</strong>：是Mapped Device所映射的物理空间段。</li><li><strong>Mapping Table</strong>：DeviceMapper在内核中通过一个一个模块化的 Target Driver 插件实现对 IO 请求的过滤或者重新定向等工作，当前已经实现的插件包括：dm-crypt、dm-linear、dm-verity、dm-bow、dm-raid等。</li></ul><p>Device mapper 中这三个对象和 target driver 插件一起构成了一个可迭代的设备树。该层次在理论上可以在 device mapper 架构下无限迭代下去。</p><h3 id="2-1-核心数据结构"><a href="#2-1-核心数据结构" class="headerlink" title="2.1 核心数据结构"></a>2.1 核心数据结构</h3><ul><li><strong>mapped_device</strong> ：在dm.c 文件中定义，该结构用于表示 mapped device，它主要包括该 mapped device 相关的锁，注册的请求队列和一些内存池以及指向它所对应映射表的指针等域。</li><li><strong>dm_table</strong>：在文件dm_table.c 文件中定义，该结构中包含一个 dm_target结构数组，dm_target 结构具体描述了 mapped_device 到它某个 target device 的映射关系。而在 dm_table 结构中将这些 dm_target 按照 B 树的方式组织起来方便 IO 请求映射时的查找操作。dm_target 结构具体记录该结构对应 target device 所映射的 mapped device 逻辑区域的开始地址和范围，同时还包含指向具体 target device 相关操作的 target_type 结构的指针。</li><li><strong>target_type</strong>：该结构主要包含了 target device 对应的 target driver 插件的名字、定义的构建和删除该类型target device的方法、该类target device对应的IO请求重映射和结束IO的方法等。而表示具体的target device的域是dm_target中的private域，该指针指向mapped device所映射的具体target device对应的结构。表示target device的具体结构由于不同的target 类型而不同。</li></ul><p>开发者可以定制device target部分，以实现自己所需要的需求功能。</p><h3 id="2-2-三步建立dm设备的过程"><a href="#2-2-三步建立dm设备的过程" class="headerlink" title="2.2 三步建立dm设备的过程"></a>2.2 <strong>三步建立dm设备的过程</strong></h3><p>通过下述的三个主要步骤，device mapper在内核中就建立一个可以提供给用户使用的mapped device逻辑块设备。</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/device-mapper.png"><h2 id="3-挂载阶段创建逻辑分区"><a href="#3-挂载阶段创建逻辑分区" class="headerlink" title="3.挂载阶段创建逻辑分区"></a>3.挂载阶段创建逻辑分区</h2><h3 id="3-1-开始挂载"><a href="#3-1-开始挂载" class="headerlink" title="3.1 开始挂载"></a>3.1 开始挂载</h3><p>🐼 关于第一阶段挂载的流程可以参考我之前写的<a href="https://blog.csdn.net/stephen_curry300/article/details/126110983?spm=1001.2014.3001.5501">CSDN博客</a></p><p>挂载的入口如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 路径: /system/core/init/first_stage_mount.cpp</span><br><span class="hljs-comment">// 在设备树中挂载由fstab文件指定的分区</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DoFirstStageMount</span><span class="hljs-params">(<span class="hljs-type">bool</span> create_devices)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> fsm = FirstStageMount::<span class="hljs-built_in">Create</span>();<br>    <span class="hljs-keyword">return</span> (*fsm)-&gt;<span class="hljs-built_in">DoFirstStageMount</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FirstStageMount::DoFirstStageMount</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">MountPartitions</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终与创建逻辑分区的代码走到 <strong>FirstStageMount::CreateLogicalPartitions</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\first_stage_mount.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FirstStageMount::CreateLogicalPartitions</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 遍历读取到的fstab中flag中是否含有logical</span><br>    <span class="hljs-comment">// 如果有，则支持DmLinear</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsDmLinearEnabled</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 对应3.2 读取元数据</span><br>    <span class="hljs-keyword">auto</span> metadata = android::fs_mgr::<span class="hljs-built_in">ReadCurrentMetadata</span>(super_path_);<br><br>    <span class="hljs-comment">// 对应3.3 创建逻辑分区</span><br>    <span class="hljs-keyword">return</span> android::fs_mgr::<span class="hljs-built_in">CreateLogicalPartitions</span>(*metadata.<span class="hljs-built_in">get</span>(), super_path_);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-读取元数据"><a href="#3-2-读取元数据" class="headerlink" title="3.2 读取元数据"></a>3.2 读取元数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\fs_mgr_dm_linear.cpp</span><br><span class="hljs-comment">// 传进来的block_device是super分区对应的真实的块设备（假设为/dev/block/vda2）</span><br><span class="hljs-function">std::unique_ptr&lt;LpMetadata&gt; <span class="hljs-title">ReadCurrentMetadata</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; block_device)</span> </span>&#123;<br>    <span class="hljs-comment">// fs_mgr_get_slot_suffix获取环境变量ro.boot.slot_suffix</span><br>    <span class="hljs-comment">// 如果当前启动分区为_a，则slot=0</span><br>    <span class="hljs-comment">// 如果当前启动分区为_b，则slot=1</span><br>    <span class="hljs-type">uint32_t</span> slot = <span class="hljs-built_in">SlotNumberForSlotSuffix</span>(<span class="hljs-built_in">fs_mgr_get_slot_suffix</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReadMetadata</span>(block_device.<span class="hljs-built_in">c_str</span>(), slot);<br>&#125;<br><br><span class="hljs-comment">// 传进来的super_partition是/dev/block/vda2</span><br><span class="hljs-comment">// 假设启动分区为_a，slot_number为0</span><br><span class="hljs-function">std::unique_ptr&lt;LpMetadata&gt; <span class="hljs-title">ReadMetadata</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; super_partition, <span class="hljs-type">uint32_t</span> slot_number)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReadMetadata</span>(<span class="hljs-built_in">PartitionOpener</span>(), super_partition, slot_number);<br>&#125;<br><br><span class="hljs-comment">// --------------------------------------------------------------</span><br><br><span class="hljs-comment">// system\core\fs_mgr\liblp\reader.cpp</span><br><span class="hljs-function">std::unique_ptr&lt;LpMetadata&gt; <span class="hljs-title">ReadMetadata</span><span class="hljs-params">(<span class="hljs-type">const</span> IPartitionOpener&amp; opener,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         <span class="hljs-type">const</span> std::string&amp; super_partition, <span class="hljs-type">uint32_t</span> slot_number)</span> </span>&#123;<br>    android::base::unique_fd fd = opener.<span class="hljs-built_in">Open</span>(super_partition, O_RDONLY);<br><br>    LpMetadataGeometry geometry;<br>    <span class="hljs-comment">// 读取/dev/block/vda2中的元数据</span><br>    <span class="hljs-comment">// 读的是1.1节中的LpMetadataGeometry数据结构，将其保存到geometry</span><br>    <span class="hljs-comment">// 目的是直接赋值给下面即将创建的变量meta的成员变量geometry</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ReadLogicalPartitionGeometry</span>(fd, &amp;geometry)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    std::unique_ptr&lt;LpMetadata&gt; metadata;<br><br>    <span class="hljs-comment">// 读取/dev/block/mmcblk0p5中的所有的元数据</span><br>    <span class="hljs-comment">// 将其保存到metadata变量中，最后返回3.1中最初调用ReadCurrentMetadata的地方</span><br>    <span class="hljs-comment">// 所有的metadata结构都是按照1.整体认知——LpMetadata分布的</span><br>    metadata = <span class="hljs-built_in">ParseMetadata</span>(geometry, fd)<br>    <br>    <span class="hljs-keyword">return</span> metadata;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-创建逻辑分区"><a href="#3-3-创建逻辑分区" class="headerlink" title="3.3 创建逻辑分区"></a>3.3 创建逻辑分区</h3><p><strong>3.2节和3.3节是独立的，两节都是3.1的子篇，不要线性阅读</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateLogicalPartitions</span><span class="hljs-params">(<span class="hljs-type">const</span> LpMetadata&amp; metadata, <span class="hljs-type">const</span> std::string&amp; super_device)</span> </span>&#123;<br>    CreateLogicalPartitionParams params = &#123;<br>            .block_device = super_device,<br>            .metadata = &amp;metadata,<br>    &#125;;<br>    <span class="hljs-comment">// 这里的metadata.partitions是1.3节的LpMetadataPartition</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; partition : metadata.partitions) &#123;<br>        params.partition = &amp;partition;<br><br>        std::string ignore_path;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateLogicalPartition</span>(params, &amp;ignore_path)) &#123;<br>            LERROR &lt;&lt; <span class="hljs-string">&quot;Could not create logical partition: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetPartitionName</span>(partition);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会遍历metadata中存储的partitions成员变量，也就是metadata.img中存放的一个个逻辑分区信息，例如如果我们第一个存储的LpMetadataPartition是system的信息，那么首先调用CreateLogicalPartition去创建逻辑分区，第二个存储的LpMetadataPartition是vendor的信息，相应的调用CreateLogicalPartition去创建逻辑分。</p><p>🎈<strong>到这里解释了开头我们提到的为什么dm-1、dm-2创建的先后顺序，其与metadata.img中的分区顺序有关，换句话说，就是与生成super.img时指明的顺序有关。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateLogicalPartition</span><span class="hljs-params">(CreateLogicalPartitionParams params, std::string* path)</span> </span>&#123;<br>    CreateLogicalPartitionParams::OwnedData owned_data;<br>    <span class="hljs-comment">// 3.3.1：主要初始化params中的partition_name和device_name</span><br>    <span class="hljs-keyword">if</span> (!params.<span class="hljs-built_in">InitDefaults</span>(&amp;owned_data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    DmTable table;<br>    <span class="hljs-comment">// 3.3.2：主要创建dmtable</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateDmTableInternal</span>(params, &amp;table)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    DeviceMapper&amp; dm = DeviceMapper::<span class="hljs-built_in">Instance</span>();<br>    <span class="hljs-comment">// 3.3.2：完成第2.2中所说的三步走</span><br>    <span class="hljs-keyword">if</span> (!dm.<span class="hljs-built_in">CreateDevice</span>(params.device_name, table, path, params.timeout_ms)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 文章开头的启动日志打印就是在这里</span><br>    LINFO &lt;&lt; <span class="hljs-string">&quot;Created logical partition &quot;</span> &lt;&lt; params.device_name &lt;&lt; <span class="hljs-string">&quot; on device &quot;</span> &lt;&lt; *path;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-1-InitDefaults初始化CreateLogicalPartitionParams"><a href="#3-3-1-InitDefaults初始化CreateLogicalPartitionParams" class="headerlink" title="3.3.1 InitDefaults初始化CreateLogicalPartitionParams"></a>3.3.1 InitDefaults初始化CreateLogicalPartitionParams</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateLogicalPartitionParams::InitDefaults</span><span class="hljs-params">(CreateLogicalPartitionParams::OwnedData* owned)</span> </span>&#123;<br>    <span class="hljs-comment">// 3.3节开头的CreateLogicalPartitionParams params的参数中还没有初始化partition_name</span><br>    <span class="hljs-keyword">if</span> (partition_name.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// partition_name为system_a</span><br>        partition_name = android::fs_mgr::<span class="hljs-built_in">GetPartitionName</span>(*partition);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (partition_name != android::fs_mgr::<span class="hljs-built_in">GetPartitionName</span>(*partition)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Inconsistent partition_name &quot;</span> &lt;&lt; partition_name &lt;&lt; <span class="hljs-string">&quot; with partition &quot;</span><br>               &lt;&lt; android::fs_mgr::<span class="hljs-built_in">GetPartitionName</span>(*partition);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (device_name.<span class="hljs-built_in">empty</span>()) &#123;<br>        device_name = partition_name;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// --------------------------------------------------------------</span><br><br><span class="hljs-comment">// system\core\fs_mgr\liblp\reader.cpp</span><br><span class="hljs-function">std::string <span class="hljs-title">GetPartitionName</span><span class="hljs-params">(<span class="hljs-type">const</span> LpMetadataPartition&amp; partition)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">NameFromFixedArray</span>(partition.name, <span class="hljs-built_in">sizeof</span>(partition.name));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">NameFromFixedArray</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">size_t</span> buffer_size)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (name[buffer_size - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(name);<br>    &#125;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(name, buffer_size);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-CreateDmTableInternal创建dm-linear设备table"><a href="#3-3-2-CreateDmTableInternal创建dm-linear设备table" class="headerlink" title="3.3.2 CreateDmTableInternal创建dm-linear设备table"></a>3.3.2 CreateDmTableInternal创建dm-linear设备table</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateDmTableInternal</span><span class="hljs-params">(<span class="hljs-type">const</span> CreateLogicalPartitionParams&amp; params, DmTable* table)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; super_device = params.block_device;<br><br>    <span class="hljs-type">uint64_t</span> sector = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; params.partition-&gt;num_extents; i++) &#123;<br>        <span class="hljs-comment">// 找到各个分区自己的extents内容，也就是1.4节</span><br>        <span class="hljs-comment">// 在partition中的first_extent_index字段会指明当前分区在extents哪个位置</span><br>        <span class="hljs-comment">// 99%的情况只会占用一个位置，所以 params.partition-&gt;num_extents一般都是1</span><br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; extent = params.metadata-&gt;extents[params.partition-&gt;first_extent_index + i];<br>        std::unique_ptr&lt;DmTarget&gt; target;<br>        <span class="hljs-comment">// 从1.4展示的type来看是数字0，正好对应了这里的LP_TARGET_TYPE_LINEAR，线性排布的DM设备</span><br>        <span class="hljs-keyword">switch</span> (extent.target_type) &#123;<br>            <span class="hljs-keyword">case</span> LP_TARGET_TYPE_ZERO:<br><span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">case</span> LP_TARGET_TYPE_LINEAR: &#123;<br>                <span class="hljs-comment">// 从1.4展示的target_source是0，也就是system_a对应的target_source是0，也就是指向了1.6节中super所在的位置【super的索引为0】</span><br>                <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; block_device = params.metadata-&gt;block_devices[extent.target_source];<br>                std::string dev_string;<br>                <span class="hljs-comment">// 获取super真实的物理地址，所以dev_string为/dev/block/vda2</span><br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetPhysicalPartitionDevicePath</span>(params, block_device, super_device,<br>                                                    &amp;dev_string)) &#123;<br>                    <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Unable to complete device-mapper table, unknown block device&quot;</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-comment">// 创建一个DmTargetLinear类型的指针，由target独占管理</span><br>                target = std::<span class="hljs-built_in">make_unique</span>&lt;DmTargetLinear&gt;(sector, extent.num_sectors, dev_string,<br>                                                          extent.target_data);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Unknown target type in metadata: &quot;</span> &lt;&lt; extent.target_type;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将target添加到table里面去，DmTable维护了一个列表_target</span><br>        <span class="hljs-comment">// DmTable::AddTarget也就是把target添加push到_target中</span><br>        <span class="hljs-keyword">if</span> (!table-&gt;<span class="hljs-built_in">AddTarget</span>(std::<span class="hljs-built_in">move</span>(target))) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        sector += extent.num_sectors;<br>    &#125;<br>    <span class="hljs-comment">// 如果1.3节中Attribute含有READ_ONLY属性，TABLE设置成只读的</span><br>    <span class="hljs-keyword">if</span> (params.partition-&gt;attributes &amp; LP_PARTITION_ATTR_READONLY) &#123;<br>        table-&gt;<span class="hljs-built_in">set_readonly</span>(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-comment">// 如果params设置了强制可写，TABLE设置成可读可写</span><br>    <span class="hljs-keyword">if</span> (params.force_writable) &#123;<br>        table-&gt;<span class="hljs-built_in">set_readonly</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-2-1-数据结构梳理"><a href="#3-3-2-1-数据结构梳理" class="headerlink" title="3.3.2.1 数据结构梳理"></a>3.3.2.1 数据结构梳理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DmTarget</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DmTarget</span>(<span class="hljs-type">uint64_t</span> start, <span class="hljs-type">uint64_t</span> length) : <span class="hljs-built_in">start_</span>(start), <span class="hljs-built_in">length_</span>(length) &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DmTargetLinear</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> DmTarget &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DmTargetLinear</span>(<span class="hljs-type">uint64_t</span> start, <span class="hljs-type">uint64_t</span> length, <span class="hljs-type">const</span> std::string&amp; block_device,<br>                   <span class="hljs-type">uint64_t</span> physical_sector)<br>        : <span class="hljs-built_in">DmTarget</span>(start, length), <span class="hljs-built_in">block_device_</span>(block_device), <span class="hljs-built_in">physical_sector_</span>(physical_sector) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-3-CreateDevice"><a href="#3-3-3-CreateDevice" class="headerlink" title="3.3.3 CreateDevice"></a>3.3.3 CreateDevice</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\libdm\dm.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeviceMapper::CreateDevice</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> DmTable&amp; table, std::string* path,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">const</span> std::chrono::milliseconds&amp; timeout_ms)</span> </span>&#123;<br>    <span class="hljs-comment">// 通过/dev/urandom生成随机UUID</span><br>    std::string uuid = <span class="hljs-built_in">GenerateUuid</span>();<br>    <span class="hljs-comment">// 3.3.3.1 调用ioctl创建设备</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateDevice</span>(name, uuid)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    std::string unique_path;<br>    <span class="hljs-comment">// 3.3.3.2 LoadTableAndActivate创建DM设备三步法</span><br>    <span class="hljs-comment">// 3.3.3.3 GetDeviceUniquePath获取获取dm设备的uuid，看dm设备是否创建成功了</span><br>    <span class="hljs-comment">// 3.3.3.4 GetDmDevicePathByName获取dm设备，看dm设备是否创建成功</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">LoadTableAndActivate</span>(name, table) || !<span class="hljs-built_in">GetDeviceUniquePath</span>(name, &amp;unique_path) ||<br>        !<span class="hljs-built_in">GetDmDevicePathByName</span>(name, path)) &#123;<br>        <span class="hljs-comment">// 如果设备没有创建成功，DeleteDevice会调用ioctl[DM_DEV_REMOVE]删除创建的dm设备</span><br>        <span class="hljs-built_in">DeleteDevice</span>(name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-3-1-CreateDevice调用ioctl创建设备"><a href="#3-3-3-1-CreateDevice调用ioctl创建设备" class="headerlink" title="3.3.3.1 CreateDevice调用ioctl创建设备"></a>3.3.3.1 CreateDevice调用ioctl创建设备</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">DeviceMapper::CreateDevice</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name, <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; uuid)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dm_ioctl</span> <span class="hljs-title">io</span>;</span><br>    InitIo(&amp;io, name);<br>    <span class="hljs-comment">// 上面生成了随机的UUID，所以这里肯定不为空</span><br>    <span class="hljs-keyword">if</span> (!uuid.empty()) &#123;<br>        <span class="hljs-built_in">snprintf</span>(io.uuid, <span class="hljs-keyword">sizeof</span>(io.uuid), <span class="hljs-string">&quot;%s&quot;</span>, uuid.c_str());<br>    &#125;<br><br>    <span class="hljs-comment">// 向DeviceMapper驱动发送DM_DEV_CRETE创建设备</span><br>    <span class="hljs-keyword">if</span> (ioctl(fd_, DM_DEV_CREATE, &amp;io)) &#123;<br>        PLOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;DM_DEV_CREATE failed for [&quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-3-2-LoadTableAndActivate传table数据下去"><a href="#3-3-3-2-LoadTableAndActivate传table数据下去" class="headerlink" title="3.3.3.2 LoadTableAndActivate传table数据下去"></a>3.3.3.2 LoadTableAndActivate传table数据下去</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这边传进来的table是3.3.2创建的dm-linear设备table</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">DeviceMapper::LoadTableAndActivate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name, <span class="hljs-type">const</span> DmTable&amp; table)</span> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">ioctl_buffer</span><span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> dm_ioctl), <span class="hljs-number">0</span>)</span>;<br>    ioctl_buffer += table.Serialize();<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dm_ioctl</span>* <span class="hljs-title">io</span> =</span> reinterpret_cast&lt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dm_ioctl</span>*&gt;</span>(&amp;ioctl_buffer[<span class="hljs-number">0</span>]);<br>    InitIo(io, name);<br>    io-&gt;data_size = ioctl_buffer.size();<br>    io-&gt;data_start = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> dm_ioctl);<br>    io-&gt;target_count = static_cast&lt;<span class="hljs-type">uint32_t</span>&gt;(table.num_targets());<br>    <span class="hljs-keyword">if</span> (table.readonly()) &#123;<br>        io-&gt;flags |= DM_READONLY_FLAG;<br>    &#125;<br>    <span class="hljs-comment">// 向DeviceMapper驱动发送DM_TABLE_LOAD下发MappingTable</span><br>    <span class="hljs-keyword">if</span> (ioctl(fd_, DM_TABLE_LOAD, io)) &#123;<br>        PLOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;DM_TABLE_LOAD failed&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    InitIo(io, name);<br>    <span class="hljs-comment">// 向DeviceMapper驱动发送DM_DEV_SUSPEND使能MappedDevice</span><br>    <span class="hljs-keyword">if</span> (ioctl(fd_, DM_DEV_SUSPEND, io)) &#123;<br>        PLOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;DM_TABLE_SUSPEND resume failed&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-3-3-GetDeviceUniquePath获取获取dm设备的uuid，看dm设备是否创建成功了"><a href="#3-3-3-3-GetDeviceUniquePath获取获取dm设备的uuid，看dm设备是否创建成功了" class="headerlink" title="3.3.3.3 GetDeviceUniquePath获取获取dm设备的uuid，看dm设备是否创建成功了"></a>3.3.3.3 GetDeviceUniquePath获取获取dm设备的uuid，看dm设备是否创建成功了</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">DeviceMapper::GetDeviceUniquePath</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* path)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dm_ioctl</span> <span class="hljs-title">io</span>;</span><br>    InitIo(&amp;io, name);<br>    <span class="hljs-comment">// 向DeviceMapper驱动发送DM_DEV_STATUS查询MappedDevice(system_a)的状态</span><br>    <span class="hljs-keyword">if</span> (ioctl(fd_, DM_DEV_STATUS, &amp;io) &lt; <span class="hljs-number">0</span>) &#123;<br>        PLOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to get device path: &quot;</span> &lt;&lt; name;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果内核没有对参数uuid进行赋值，说明没有创建成功</span><br>    <span class="hljs-keyword">if</span> (io.uuid[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;Device does not have a unique path: &quot;</span> &lt;&lt; name;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *path = <span class="hljs-string">&quot;/dev/block/mapper/by-uuid/&quot;</span>s + io.uuid;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-3-4-GetDmDevicePathByName获取dm设备，看dm设备是否创建成功"><a href="#3-3-3-4-GetDmDevicePathByName获取dm设备，看dm设备是否创建成功" class="headerlink" title="3.3.3.4 GetDmDevicePathByName获取dm设备，看dm设备是否创建成功"></a>3.3.3.4 GetDmDevicePathByName获取dm设备，看dm设备是否创建成功</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">DeviceMapper::GetDmDevicePathByName</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* path)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dm_ioctl</span> <span class="hljs-title">io</span>;</span><br>    InitIo(&amp;io, name);<br>    <span class="hljs-comment">// 向DeviceMapper驱动发送DM_DEV_STATUS查询MappedDevice(system_a)的状态</span><br>    <span class="hljs-keyword">if</span> (ioctl(fd_, DM_DEV_STATUS, &amp;io) &lt; <span class="hljs-number">0</span>) &#123;<br>        PLOG(WARNING) &lt;&lt; <span class="hljs-string">&quot;DM_DEV_STATUS failed for &quot;</span> &lt;&lt; name;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-comment">// 上面调用ioctl后会对io.dev进行赋值</span><br>    <span class="hljs-comment">// minor(io.dev)拿到mapped deivec对应的设备</span><br>    <span class="hljs-comment">// 例如system_a的dev_num为0</span><br>    <span class="hljs-type">uint32_t</span> dev_num = minor(io.dev);<br>    *path = <span class="hljs-string">&quot;/dev/block/dm-&quot;</span> + <span class="hljs-built_in">std</span>::to_string(dev_num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>最后画了一张图，完美闭关</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230427231954102.png" alt="image-20230427231954102" style="zoom:1000%;"><h2 id="5-感谢"><a href="#5-感谢" class="headerlink" title="5.感谢"></a>5.感谢</h2><p>感谢 <a href="https://www.cnblogs.com/pyjetson/p/14872499.html%EF%BC%8C%E4%BB%8E%E5%AE%83%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%87%8C%E9%9D%A2%E5%AD%A6%E5%88%B0%E4%BA%86%E5%BE%88%E5%A4%9A%F0%9F%8E%97%EF%B8%8F">https://www.cnblogs.com/pyjetson/p/14872499.html，从它的博客里面学到了很多🎗️</a></p>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>展讯Android P System_as_root规范说明</title>
    <link href="/2023/03/16/%E5%B1%95%E8%AE%AFAndroid-P-System-as-root%E8%A7%84%E8%8C%83%E8%AF%B4%E6%98%8E/"/>
    <url>/2023/03/16/%E5%B1%95%E8%AE%AFAndroid-P-System-as-root%E8%A7%84%E8%8C%83%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="展讯Android-P-System-as-root规范说明"><a href="#展讯Android-P-System-as-root规范说明" class="headerlink" title="展讯Android P System_as_root规范说明"></a>展讯Android P System_as_root规范说明</h1><blockquote><p>作为个人学习笔记使用，<a href="https://bbs.16rd.com/thread-584995-1-1.html">https://bbs.16rd.com/thread-584995-1-1.html</a></p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Android 从 8.0 开始引入了 Treble 架构，目的是让 Android 设备制造商能够更快，更容易，更低成本的去升级 Android 版本。为实现这一目的，Google 设定了很多规则，设备商只有实现了这些规 则，才能满足 Treble 架构的要求。本文介绍的 system as root 就是 Google 在 AndroidP 上提出的一 项改动规则。</p><p>所谓 system as root，指的是 system 分区被挂载为 rootfs，android 可以通过 OTA 直接升级 rootfs，避免出现 system 升级之后，存储在 ramdisk（rootfs）中的 init&#x2F;init.rc 与新的 android 版本不匹配导致系统出问题。 在 A&#x2F;B 系统的 device 上，ramdisk 已经打包到 system.img 了，所以无需做什么适配。搭载Android 9.x 的所有新设备都必须使用 system-as-root（BOARD_BUILD_SYSTEM_ROOT_IMAGE必须为 true），它可以将 ramdisk.img 合并到 system.img，而后者会反过来再作为 rootfs 进行装载。对于要升级到 Android 9 的设备，使用 system-as-root 并非强制要求。</p><p>System as root 的改动部分可如下图所示：</p><img src="/2023/03/16/%E5%B1%95%E8%AE%AFAndroid-P-System-as-root%E8%A7%84%E8%8C%83%E8%AF%B4%E6%98%8E/173632rimzt33h8mi4ntif.jpg" alt="173632rimzt33h8mi4ntif" style="zoom:80%;"><h2 id="2-System-as-root-规范"><a href="#2-System-as-root-规范" class="headerlink" title="2.System as root 规范"></a>2.System as root 规范</h2><p>System as root 的核心在于 ramdisk 会被打包到 system.img，基于这种状况，设备厂商自行添加到 ramdisk 中的改动，必须转移到其它位置，否则 system.img 一更换（例如 GSI 版本），ramdisk中添加的内容就丢失了，导致系统启动可能出现问题。根据 Google 发布的 system as root 文档的要求，总结了下面这些需要调整的部分：</p><table><thead><tr><th>ID</th><th>修改内容</th><th>规范</th></tr></thead><tbody><tr><td>1</td><td>rc文件的调整</td><td>原来放置在device&#x2F;{board}&#x2F;路径中的rc文件，需要编译 到vendor&#x2F;etc&#x2F;init;另一方面如果修改了 &#x2F;system&#x2F;core&#x2F;rootdir&#x2F;T init.*.rc ,最好将修改移动到设备厂 商自行添加的rc文件中；rc文件中import的路径需要修改， 避免import路径错误导致rc文件没有被解析。</td></tr><tr><td>2</td><td>内核模块移岀ramdisk</td><td>内核模块驱动已经移到vendor分区。</td></tr><tr><td>3</td><td>fstab文件路径调整</td><td>fstab文件需要从ramdisk移动到vendor&#x2F;etc</td></tr><tr><td>4</td><td>ramdisk打包调整</td><td>ramdisk.img 需要打包到 system.img 中</td></tr><tr><td>5</td><td>dm-verify实现方案调整</td><td>AndroidP ± dm-verify必须开启,UNISOC版本已默认 开启 dm-verify</td></tr></tbody></table><h3 id="2-1-rc文件的调整"><a href="#2-1-rc文件的调整" class="headerlink" title="2.1 rc文件的调整"></a>2.1 rc文件的调整</h3><p>在 device&#x2F;{board}仓库中存在很多设备相关的 rc 文件，在 AndroidP 之前，这些 rc 文件是被编译到 ramdisk 的根路径的，但是按照 system as root 的要求，这些文件必须调整到其它路径，且文件 中 import rc 等语句所对应的路径需要做调整。具体改动如下：</p><ul><li>device&#x2F;{board} 路径的 rc 文件 copy 到 vendor 分区，例如： device&#x2F;{board}&#x2F;common&#x2F;DeviceCommon.mk</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">product_COPY_FILES += \<br><span class="hljs-variable">$(LOCAL_PATH)</span>/rootdir/root/init.common.rc:<span class="hljs-variable">$(TARGET_COPY_OUT_VENDOR)</span>/etc/init/hw/init.common .rc \<br><span class="hljs-variable">$(LOCAL_PATH)</span>/rootdir/root/init.ram.rc:<span class="hljs-variable">$(TARGET_COPY_OUT_VENDOR)</span>/etc/init/hw/init.ram.rc \<br></code></pre></td></tr></table></figure><ul><li>device&#x2F;{board} 路径的 rc 文件 import 路径需要做相应调整：例如 device&#x2F;{board}&#x2F;common&#x2F;rootdir&#x2F;root&#x2F;init.common.rc 文件原本 import 的都是根路径的 rc 文件，现在需要根据实际归档路径来调整。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">import /vendor/etc/init/hw/init.$&#123;ro.hardware&#125;.usb.rc<br>import /vendor/etc/init/hw/init.ram.rc<br>import /vendor/etc/init/hw/init.storage.rc<br></code></pre></td></tr></table></figure><h3 id="2-2-内核模块移出ramdisk"><a href="#2-2-内核模块移出ramdisk" class="headerlink" title="2.2  内核模块移出ramdisk"></a>2.2  内核模块移出ramdisk</h3><p>在 UNISOC 平台，部分 kernel modules 放到 ramdisk 的 lib 路径下，在开启了 <strong>system as root</strong>之后，遵循 Google 的建议，需要统一调整到&#x2F;vendor&#x2F;lib&#x2F;modules 中：</p><ul><li>在模块的 Android.mk(bp)中，将模块 bin 文件归档路径设定为&#x2F;vendor&#x2F;lib&#x2F;modules：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs make\">vendor/sprd/modules/wcn/fm/driver/Android.mk<br>1. LOCAL_MODULE := sprd_fm.ko<br>2. LOCAL_MODULE_CLASS := SHARED_LIBRARIES<br>3. LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/etc/modules<br></code></pre></td></tr></table></figure><h3 id="2-3-fstab-文件路径调整"><a href="#2-3-fstab-文件路径调整" class="headerlink" title="2.3 fstab 文件路径调整"></a>2.3 fstab 文件路径调整</h3><p>fstab 是用于定义文件系统 mount 信息的，这个文件与设备的存储强相关，所以也需要从 ramdisk移出，将 fstab 放在 vendor&#x2F;etc&#x2F;路径下。需要注意的是，recovery 模式所用的 ramdisk 与正常开机的不是一个， 所以 recovery 模式所用的 fstab 文件，路径不用修改。</p>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>User Data Checkpoint机制</title>
    <link href="/2023/03/15/User-Data-Checkpoint%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/03/15/User-Data-Checkpoint%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="User-Data-Checkpoint机制-UDC"><a href="#User-Data-Checkpoint机制-UDC" class="headerlink" title="User Data Checkpoint机制(UDC)"></a>User Data Checkpoint机制(UDC)</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>由于AB升级的回滚机制只支持到early_boot阶段，如果OTA升级的过程中，data分区被修改了，并且OTA升级失败了，则data分区是无法回滚到之前的状态的。UDC功能是为了解决OTA升级失败后，当data分区被修改后，不支持回滚data分区的问题。UDC同时支持绑定key版本以及防止key回滚的功能。</p><h2 id="2-实现UDC"><a href="#2-实现UDC" class="headerlink" title="2.实现UDC"></a>2.实现UDC</h2><blockquote><p>一定要参考安卓官网：<a href="https://source.android.com/docs/core/ota/user-data-checkpoint?hl=zh-cn">https://source.android.com/docs/core/ota/user-data-checkpoint?hl=zh-cn</a></p></blockquote><h3 id="2-1-设置"><a href="#2-1-设置" class="headerlink" title="2.1 设置"></a>2.1 设置</h3><p>在 <code>init.hardware.rc</code> 文件的 <code>on fs</code> 中，确保您具有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount_all /vendor/etc/fstab.$&#123;ro.boot.hardware.platform&#125; --early<br></code></pre></td></tr></table></figure><p>在 <code>init.hardware.rc</code> 文件的 <code>on late-fs</code> 中，确保您具有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount_all /vendor/etc/fstab.$&#123;ro.boot.hardware.platform&#125; --late<br></code></pre></td></tr></table></figure><p>在 <code>fstab.hardware</code> 文件中，确保将 <code>/data</code> 标记为 <code>latemount</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/dev/block/bootdevice/by-name/userdata              /data              f2fs<br>noatime,nosuid,nodev,discard,reserve_root=32768,resgid=1065,fsync_mode=nobarrier<br>latemount,wait,check,fileencryption=ice,keydirectory=/metadata/vold/metadata_encryption,quota,formattable,sysfs_path=/sys/devices/platform/soc/1d84000.ufshc,reservedsize=128M,checkpoint=fs<br></code></pre></td></tr></table></figure><h3 id="2-2-添加metadata分区"><a href="#2-2-添加metadata分区" class="headerlink" title="2.2 添加metadata分区"></a>2.2 添加metadata分区</h3><p>UDC 需要使用 metadata 分区来存储非引导加载程序重试计数和密钥。设置 metadata 分区并提前将其装载在 <code>/metadata</code> 中。</p><p>在 <code>fstab.hardware</code> 文件中，确保将 <code>/metadata</code> 标记为 <code>earlymount</code> 或 <code>first_stage_mount</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/dev/block/by-name/metadata           /metadata           ext4<br>noatime,nosuid,nodev,discard,sync<br>wait,formattable,first_stage_mount<br></code></pre></td></tr></table></figure><p>将分区初始化为全零。</p><p>将以下行添加到 <code>BoardConfig.mk</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">BOARD_USES_METADATA_PARTITION := true<br>BOARD_ROOT_EXTRA_FOLDERS := existing_folders metadata<br></code></pre></td></tr></table></figure><h3 id="2-3-更新系统"><a href="#2-3-更新系统" class="headerlink" title="2.3 更新系统"></a>2.3 更新系统</h3><p><strong>F2FS 系统</strong></p><ul><li><p>对于使用 F2FS 来格式化数据的系统，请确保您的 F2FS 版本支持检查点。</p></li><li><p>对于在 <code>/data</code> 装载的设备，请将 <code>checkpoint=fs</code> 标志添加到 fstab 的 <code>&lt;fs_mgr_flags&gt;</code> 部分。</p></li></ul><p><strong>非 F2FS 系统</strong></p><ul><li>对于非 F2FS 系统，必须在内核配置中启用 <code>dm-bow</code>。</li><li>对于在 <code>/data</code> 装载的设备，请将 <code>checkpoint=block</code> 标志添加到 fstab 的 <code>&lt;fs_mgr_flags&gt;</code> 部分。</li></ul><h2 id="3-f2fs挂载流程"><a href="#3-f2fs挂载流程" class="headerlink" title="3.f2fs挂载流程"></a>3.f2fs挂载流程</h2><p>既然上面提到了f2fs天然支持checkpoint，那我们分析一下它的挂载流程</p><h3 id="3-1开始挂载所有"><a href="#3-1开始挂载所有" class="headerlink" title="3.1开始挂载所有"></a>3.1开始挂载所有</h3><p>在rc中会调用mount_all来挂载所有fstab中的entry</p><p>在<code>device/softwinner/ceres-common/init.sun50iw10p1.rc</code>文件的on fs中有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount_all /vendor/etc/fstab.sun50iw10p1 --early<br></code></pre></td></tr></table></figure><p>在<code>device/softwinner/ceres-b3/fstab.sun50iw10p1.rc</code>文件的<code>data</code>分区中添加<code>latemount</code>和<code>checkpoint=fs</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/dev/block/by-name/UDISK      /data        f2fs     noatime,nosuid,nodev,discard wait,check,formattable,quota,reservedsize=33554432,fileencryption=aes-256-xts:aes-256-cts,latemount,checkpoint=fs<br></code></pre></td></tr></table></figure><p>此时会去解析mount_all对应的动作，然后将<code>/vendor/etc/fstab.sun50iw10p1</code>作为arg[0]，<code>--early</code>作为arg[1]传给mount_all对应的处理函数<code>do_mount_all</code></p><img src="/2023/03/15/User-Data-Checkpoint%E6%9C%BA%E5%88%B6/image-20230315202320251.png" alt="image-20230315202320251"><p>在<code>do_mount_all</code>中会调用fs_mgr_mount_all挂载所有<code>/vendor/etc/fstab.sun50iw10p1</code>中的项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\builtins.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> Result&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">do_mount_all</span><span class="hljs-params">(<span class="hljs-type">const</span> BuiltinArguments&amp; args)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    Fstab fstab;<br>    <span class="hljs-keyword">if</span> (mount_all-&gt;fstab_path.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ReadDefaultFstab</span>(&amp;fstab)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Error</span>() &lt;&lt; <span class="hljs-string">&quot;Could not read default fstab&quot;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 会将/vendor/etc/fstab.sun50iw10p1中的每一项解析好放在fstab数组中</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ReadFstabFromFile</span>(mount_all-&gt;fstab_path, &amp;fstab)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Error</span>() &lt;&lt; <span class="hljs-string">&quot;Could not read fstab&quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 调用fs_mgr_mount_all挂载所有解析出来的entry</span><br>    <span class="hljs-keyword">auto</span> mount_fstab_result = <span class="hljs-built_in">fs_mgr_mount_all</span>(&amp;fstab, mount_all-&gt;mode);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-fs-mgr-mount-all做好准备工作"><a href="#3-2-fs-mgr-mount-all做好准备工作" class="headerlink" title="3.2 fs_mgr_mount_all做好准备工作"></a>3.2 fs_mgr_mount_all做好准备工作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">MountAllResult <span class="hljs-title">fs_mgr_mount_all</span><span class="hljs-params">(Fstab* fstab, <span class="hljs-type">int</span> mount_mode)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(fstab-&gt;<span class="hljs-built_in">size</span>()); i++) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; current_entry = (*fstab)[i];<br>        <span class="hljs-comment">// 调用checkpoint_manager的Update方法</span><br>        <span class="hljs-keyword">if</span> (!checkpoint_manager.<span class="hljs-built_in">Update</span>(&amp;current_entry)) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// system\core\fs_mgr\fs_mgr.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(FstabEntry* entry, <span class="hljs-type">const</span> std::string&amp; block_device = std::string())</span> </span>&#123;<br>    <span class="hljs-comment">// fs_mgr_flags是否包含checkpoint=fs或checkpoint=blk</span><br>    <span class="hljs-comment">// 显然包含</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SupportsCheckpoint</span>(entry)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ***********************这里是最重要的***********************</span><br>    <span class="hljs-comment">// ***********************这里是最重要的***********************</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NeedsCheckpoint</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">UpdateCheckpointPartition</span>(entry, block_device)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Could not set up checkpoint partition, skipping!&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-1-NeedsCheckpoint判断是否需要检查Checkpoint"><a href="#3-2-1-NeedsCheckpoint判断是否需要检查Checkpoint" class="headerlink" title="3.2.1 NeedsCheckpoint判断是否需要检查Checkpoint"></a>3.2.1 NeedsCheckpoint判断是否需要检查Checkpoint</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\fs_mgr.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NeedsCheckpoint</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用vdc二进制，传入第一个参数checkpoint,第二个参数needsCheckpoint，最终回调的结果是needs_checkpoint_</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">call_vdc</span>(&#123;<span class="hljs-string">&quot;checkpoint&quot;</span>, <span class="hljs-string">&quot;needsCheckpoint&quot;</span>&#125;, &amp;needs_checkpoint_)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Failed to find if checkpointing is needed. Assuming no.&quot;</span>;<br>        needs_checkpoint_ = NO;<br>    &#125;<br>    <span class="hljs-keyword">return</span> needs_checkpoint_ == YES;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>vdc</strong>二进制编译完以后位于<code>out/target/product/[productName]</code>中</p><img src="/2023/03/15/User-Data-Checkpoint%E6%9C%BA%E5%88%B6/image-20230315204223717.png" alt="image-20230315204223717" style="zoom:50%;"><p>下面看一下它的main入口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\vold\vdc.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (xxx) &#123;<br>        <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;checkpoint&quot;</span> &amp;&amp; args[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;needsCheckpoint&quot;</span> &amp;&amp; args.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">bool</span> enabled = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 调用needsCheckpoint方法</span><br>        <span class="hljs-built_in">checkStatus</span>(args, vold-&gt;<span class="hljs-built_in">needsCheckpoint</span>(&amp;enabled));<br>        <span class="hljs-keyword">return</span> enabled ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">binder::Status <span class="hljs-title">VoldNativeService::needsCheckpoint</span><span class="hljs-params">(<span class="hljs-type">bool</span>* _aidl_return)</span> </span>&#123;<br>    *_aidl_return = <span class="hljs-built_in">cp_needsCheckpoint</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Ok</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cp_needsCheckpoint</span><span class="hljs-params">()</span> </span>&#123;<br><br>    sp&lt;IBootControl&gt; <span class="hljs-keyword">module</span> = IBootControl::<span class="hljs-built_in">getService</span>();<br><br>    <span class="hljs-keyword">if</span> (isCheckpointing) <span class="hljs-keyword">return</span> isCheckpointing;<br><br>    <span class="hljs-comment">// 调用bootctl的isSlotMarkedSuccessful方法</span><br>    <span class="hljs-comment">// 如果是第一次启动，那必然boot分区没有succ标记</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">module</span> &amp;&amp; <span class="hljs-keyword">module</span>-&gt;<span class="hljs-built_in">isSlotMarkedSuccessful</span>(<span class="hljs-keyword">module</span>-&gt;<span class="hljs-built_in">getCurrentSlot</span>()) == BoolResult::FALSE) &#123;<br>        isCheckpointing = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>如果是OTA升级阶段或者是第一次刷固件的时候（调用boot_ctrl判断当前slot是否已经Marked Successful了，如果没有，表明此时处于OTA升级阶段或者是第一次刷固件的时候，需要进行checkpoint），则返回true；正常情况就是false；</strong></p><h4 id="3-2-2-UpdateCheckpointPartition更新挂载opt选项"><a href="#3-2-2-UpdateCheckpointPartition更新挂载opt选项" class="headerlink" title="3.2.2 UpdateCheckpointPartition更新挂载opt选项"></a>3.2.2 UpdateCheckpointPartition更新挂载opt选项</h4><p>如果NeedsCheckpoint为True，调用UpdateCheckpointPartition</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UpdateCheckpointPartition</span><span class="hljs-params">(FstabEntry* entry, <span class="hljs-type">const</span> std::string&amp; block_device)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (entry-&gt;fs_mgr_flags.checkpoint_fs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_f2fs</span>(entry-&gt;fs_type)) &#123;<br>            <span class="hljs-comment">// 会在这里添加checkpoint=disable</span><br>            entry-&gt;fs_checkpoint_opts = <span class="hljs-string">&quot;,checkpoint=disable&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-mount-with-alternatives执行真正的挂载"><a href="#3-3-mount-with-alternatives执行真正的挂载" class="headerlink" title="3.3 mount_with_alternatives执行真正的挂载"></a>3.3 mount_with_alternatives执行真正的挂载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">mount_with_alternatives</span><span class="hljs-params">(<span class="hljs-type">const</span> Fstab&amp; fstab, <span class="hljs-type">int</span> start_idx, <span class="hljs-type">int</span>* end_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">int</span>* attempted_idx)</span> </span>&#123;<br>    <span class="hljs-comment">// 总共尝试2次</span><br> <span class="hljs-type">int</span> retry_count = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (retry_count-- &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 调用__mount开始真正的挂载</span><br>        <span class="hljs-keyword">if</span> (!__mount(fstab[i].blk_device, fstab[i].mount_point, fstab[i])) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><blockquote><p> 🍭 参考大神pyjeston：<a href="https://www.cnblogs.com/pyjetson/p/14682457.html">https://www.cnblogs.com/pyjetson/p/14682457.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手写一个简单的文件系统</title>
    <link href="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="动手写一个简单的文件系统"><a href="#动手写一个简单的文件系统" class="headerlink" title="动手写一个简单的文件系统"></a>动手写一个简单的文件系统</h1><blockquote><p>🍉 <strong>参考博客</strong>：<a href="https://www.jianshu.com/p/8966d121263b">https://www.jianshu.com/p/8966d121263b</a></p><p>🍒 <strong>项目地址</strong>：<a href="https://github.com/ZhangShurong/HUST_OS_fs_experiment">https://github.com/ZhangShurong/HUST_OS_fs_experiment</a></p><p>🍐 <strong>文件系统前置知识：</strong><a href="https://blog.csdn.net/u012489236/article/details/123834123?spm=1001.2014.3001.5506">https://blog.csdn.net/u012489236/article/details/123834123?spm=1001.2014.3001.5506</a></p></blockquote><h2 id="0-下载运行"><a href="#0-下载运行" class="headerlink" title="0.下载运行"></a>0.下载运行</h2><p>按照<code>Readme.md</code>执行以后，可以看到具有了一个基础文件系统的功能：</p><img src="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230311221220446.png" alt="image-20230311221220446" style="zoom: 67%;"><p>如果有编译报错，有关于timepesc类型转换的；解决方案如下：</p><img src="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230311224039035.png" alt="image-20230311224039035" style="zoom: 55%;"><h2 id="1-总体设计"><a href="#1-总体设计" class="headerlink" title="1.总体设计"></a>1.总体设计</h2><p>本文件系统的磁盘结构参考minix的文件系统实现。但是自举块（或称引导块）中没有数据。且不采用二级或者多级索引，其结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">|Dummy Block|Super Block|IMap|BMap|Inode Table|Data blocks|<br></code></pre></td></tr></table></figure><img src="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230312230337246.png" alt="image-20230312230337246" style="zoom:67%;"><p>其中每个块的大小定义为4096bytes，每个Inode含有10个块所以单个文件最大为40KB，支持的最小磁盘大小为24K。以下详细阐述文件系统中所需要的三个基本数据结构。</p><h3 id="1-1-超级块结构"><a href="#1-1-超级块结构" class="headerlink" title="1.1 超级块结构"></a>1.1 超级块结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_fs_super_block</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> version;<br>    <span class="hljs-type">uint64_t</span> magic;<br>    <span class="hljs-type">uint64_t</span> block_size;<br>    <span class="hljs-type">uint64_t</span> inodes_count;<br>    <span class="hljs-type">uint64_t</span> free_blocks;<br>    <span class="hljs-type">uint64_t</span> blocks_count;<br>    <span class="hljs-type">uint64_t</span> bmap_block;<br>    <span class="hljs-type">uint64_t</span> imap_block;<br>    <span class="hljs-type">uint64_t</span> inode_table_block;<br>    <span class="hljs-type">uint64_t</span> data_block_number;<br>    <span class="hljs-type">char</span> padding[<span class="hljs-number">4016</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>超级块中的padding数组，是为了使超级块的大小为4096bytes，以简化后期的工作；“Magic”为1314522；indoe_count记录文件系统所支持的inode个数，这个值在格式化时就已经计算并写入超级块了。Bmap_block记录着bmap开始的数据块索引,imap_block，inode_table_block和data_block_number同理，记录索引是为了简化文件块的定位操作。</p><h3 id="1-2-HUST-inode结构"><a href="#1-2-HUST-inode结构" class="headerlink" title="1.2 HUST_inode结构"></a>1.2 HUST_inode结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> &#123;</span>  <br>    <span class="hljs-type">mode_t</span> mode; <span class="hljs-comment">//sizeof(mode_t) is 4  </span><br>    <span class="hljs-type">uint64_t</span> inode_no;  <br>    <span class="hljs-type">uint64_t</span> blocks;  <br>    <span class="hljs-type">uint64_t</span> block[HUST_N_BLOCKS];  <br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>  <br>        <span class="hljs-type">uint64_t</span> file_size;  <br>        <span class="hljs-type">uint64_t</span> dir_children_count;  <br>    &#125;;  <br>    <span class="hljs-type">int32_t</span> i_uid;   <br>    <span class="hljs-type">int32_t</span> i_gid;  <br>    <span class="hljs-type">int32_t</span> i_nlink;  <br>    <span class="hljs-type">int64_t</span> i_atime;  <br>    <span class="hljs-type">int64_t</span> i_mtime;  <br>    <span class="hljs-type">int64_t</span> i_ctime;  <br>    <span class="hljs-type">char</span> padding[<span class="hljs-number">112</span>];  <br>&#125;;  <br></code></pre></td></tr></table></figure><p>HUST_inode对应着磁盘上的inode结构，在后文会描述它是如何转换为VFS中的inode的。在上述结构体中，mode代表该inode是文件还是目录，blocks代表该inode的大小（所占块的数目），i_uid和i_gid用于后面的多用户管理。Padding数组是为了让HUST_inode结构体能够被4096整除；宏HUST_N_BLOCK被定义为10，意味着每个文件（目录）最大的大小为10个块；block数组存储着每个块的索引，用于定位文件。</p><h3 id="1-3-文件系统的目录结构"><a href="#1-3-文件系统的目录结构" class="headerlink" title="1.3 文件系统的目录结构"></a>1.3 文件系统的目录结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_dir_record</span> &#123;</span>  <br>    <span class="hljs-type">char</span> filename[HUST_FILENAME_MAX_LEN];  <br>    <span class="hljs-type">uint64_t</span> inode_no;  <br>&#125;;<br></code></pre></td></tr></table></figure><p>文件记录是为了储存目录项，其中HUST_FILENAME_MAX_LEN定义为256也就是说，文件名最大长度256。<br> 编写文件系统除了设计文件系统的磁盘结构，定义文件系统支持的操作也是十分重要的，这个直接影响了文件系统的功能。本文件系统支持基本的文件的增删改查，多用户等功能，但是不支持文件的移动，软硬链接等操作。</p><h2 id="2-mkfs的实现"><a href="#2-mkfs的实现" class="headerlink" title="2.mkfs的实现"></a>2.mkfs的实现</h2><p>要使用这个文件系统，必须首先创建一个符合磁盘布局的映像文件，所以我们需要实现一个格式化程序，这个程序按照惯例叫做mkfs。本节详细描述mkfs的实现。</p><p>mkfs的作用是将一个文件改写成对应于我们文件系统的结构，其主要功能点为<strong>写入超级块，写入imap,bmap，写入inode table</strong>，以及创建一个根目录和测试文件。</p><p>超级块包含了文件系统的基本信息，其信息在上文中有详细描述。写入超级块信息，需要计算整个磁盘的大小，然后计算imap，bmap以及inode table的大小，这样才能确定各个区域在磁盘中的位置。这些工作都是在init_disk这个函数中完成的。基本逻辑为读取需要格式化的文件大小，计算出整个磁盘中的块的个数，简单的将块的个数与inode的个数等同起来；然后通过块数以及inode个数计算imap和bmap的大小。其中bmap的大小如下（imap大小计算公式与bmap一致）：<br>$$<br>bmapsize &#x3D; blockcount&#x2F; HUST_BLOCKSIZE * 8<br>$$<br>关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">init_disk</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span>  <br>&#123;  <br>    <span class="hljs-comment">//获取基本信息  </span><br>    <span class="hljs-comment">//... ...  </span><br>    <span class="hljs-comment">//计算bmap  </span><br>    bmap_size = super_block.blocks_count/(<span class="hljs-number">8</span>*HUST_BLOCKSIZE);  <br>    super_block.bmap_block = RESERVE_BLOCKS;  <br>  <br>    <span class="hljs-keyword">if</span> (super_block.blocks_count%(<span class="hljs-number">8</span>*HUST_BLOCKSIZE) != <span class="hljs-number">0</span>) &#123;  <br>        bmap_size += <span class="hljs-number">1</span>;  <br>    &#125;  <br>    bmap = (<span class="hljs-type">uint8_t</span> *)<span class="hljs-built_in">malloc</span>(bmap_size*HUST_BLOCKSIZE);  <span class="hljs-comment">// 单位是块</span><br>    <span class="hljs-built_in">memset</span>(bmap,<span class="hljs-number">0</span>,bmap_size*HUST_BLOCKSIZE);  <br>  <br>    <span class="hljs-comment">//计算imap  </span><br>    imap_size = super_block.inodes_count/(<span class="hljs-number">8</span>*HUST_BLOCKSIZE);  <span class="hljs-comment">// 单位是块</span><br>    super_block.imap_block = super_block.bmap_block + bmap_size;  <br> <br>    <span class="hljs-keyword">if</span>(super_block.inodes_count%(<span class="hljs-number">8</span>*HUST_BLOCKSIZE) != <span class="hljs-number">0</span>) &#123;  <br>        imap_size += <span class="hljs-number">1</span>;  <br>    &#125;  <br>    imap = (<span class="hljs-type">uint8_t</span> *)<span class="hljs-built_in">malloc</span>(imap_size*HUST_BLOCKSIZE);  <br>    <span class="hljs-built_in">memset</span>(imap,<span class="hljs-number">0</span>,imap_size*HUST_BLOCKSIZE);  <br>  <br>    <span class="hljs-comment">//计算inode_table  </span><br>    inode_table_size = super_block.inodes_count/(HUST_BLOCKSIZE/HUST_INODE_SIZE);  <br>    super_block.inode_table_block = super_block.imap_block + imap_size;  <br>    super_block.data_block_number = RESERVE_BLOCKS + bmap_size + imap_size + inode_table_size;  <br>    super_block.free_blocks = super_block.blocks_count - super_block.data_block_number - <span class="hljs-number">1</span>;  <br><br>    <span class="hljs-comment">// 设置bmap以及imap  </span><br>    <span class="hljs-comment">// ... ...  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，imap和bmap为uint8_t的全局数组。</p><p>计算完基本信息之后，我们需要将其写入文件并创建根目录和测试文件。文件创建的基本步骤如下：</p><ol><li>检测（获取）磁盘（文件）大小，确认是否有足够的空间</li><li>找的空闲的inode和block，并标记imap和bmap。</li><li>生成相应的数据，并写入对应的块中。对于根目录来讲，写入的数据为三个目录项，目录项的内容为文件（目录）名以及对应的inode编号。第一个目录项为当前目录和对应的inode编号0，第二个目录项为上一级目录和对应的inode编号0，第三个目录项为欢迎文件，内容为文件名“file”和对应的inode编号1。</li><li>设置对应的inode信息，如是文件还是目录（mode信息），创建时间修改时间(i_ctime和i_mtime)，用户id和组id信息（i_uid和i_gid）等。</li><li>更新超级块信息。</li></ol><p>在我们的文件系统写完之前，我们可以新建一个文件来测试我们的mkfs是否能正常运行，通过16进制编辑器来查看是否功能正常。具体步骤如下：</p><ul><li>运行下列命令创建文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">dd bs=4096 count=100 if=/dev/zero of=image <br><br>- if=文件名：输入文件名，默认为标准输入。即指定源文件。<br>- of=文件名：输出文件名，默认为标准输出。即指定目的文件。<br>- bs=bytes：同时设置读入/输出的块大小为bytes个字节。<br>- count=blocks：仅拷贝blocks个块，块大小等于bs指定的字节数。<br></code></pre></td></tr></table></figure><ul><li>编译mkfs.c</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc mkfs.c -o mkfs <br></code></pre></td></tr></table></figure><ul><li>格式化image文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./mkfs ./image<br></code></pre></td></tr></table></figure><ul><li>通过hexdump来查看文件的结构，结果如下图。通过检查，我们发现，image文件结构写入正确无误。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">amx@amxxxx:~/Desktop/simple_fs$ hexdump ./image <br><span class="hljs-number">0000000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0001000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0</span>eda <span class="hljs-number">0014</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>  <span class="hljs-comment">/* HUST_fs文件系统的magic为1314522 */</span><br><span class="hljs-number">0001010</span> <span class="hljs-number">1000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0064</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0001020</span> <span class="hljs-number">0059</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0064</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0001030</span> <span class="hljs-number">0002</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0003</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0001040</span> <span class="hljs-number">0004</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">000</span>a <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0001050</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0002000</span> <span class="hljs-number">07f</span>f <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0002010</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0003000</span> <span class="hljs-number">0003</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0003010</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0004000</span> <span class="hljs-number">4000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0004010</span> <span class="hljs-number">0001</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">000</span>a <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0004020</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0004040</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">24</span>ed <span class="hljs-number">4</span>c27 <span class="hljs-number">7f</span>f3 <span class="hljs-number">0000</span><br><span class="hljs-number">0004050</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">3760</span> <span class="hljs-number">4</span>c3b <span class="hljs-number">7f</span>f3 <span class="hljs-number">0000</span><br><span class="hljs-number">0004060</span> <span class="hljs-number">0</span>d68 <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0003</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0004070</span> <span class="hljs-number">03e8</span> <span class="hljs-number">0000</span> <span class="hljs-number">03e8</span> <span class="hljs-number">0000</span> <span class="hljs-number">0002</span> <span class="hljs-number">0000</span> <span class="hljs-number">7f</span>f3 <span class="hljs-number">0000</span><br><span class="hljs-number">0004080</span> <span class="hljs-number">8f</span>e7 <span class="hljs-number">640</span>c <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">8f</span>e7 <span class="hljs-number">640</span>c <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0004090</span> <span class="hljs-number">8f</span>e7 <span class="hljs-number">640</span>c <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">3848</span> <span class="hljs-number">4</span>c3b <span class="hljs-number">7f</span>f3 <span class="hljs-number">0000</span><br>...............................................<br>amx@amxxxx:~/Desktop/simple_fs$ <br></code></pre></td></tr></table></figure><h2 id="3-文件系统的实现"><a href="#3-文件系统的实现" class="headerlink" title="3.文件系统的实现"></a>3.文件系统的实现</h2><p>一个通常意义上的文件系统驱动可以单独被编译成模块动态加载，也可以被直接编译到内核中，为了调试的方便，本文中的文件系统采用动态加载的方式实现。实现一个文件系统必须遵照内核的一些“规则”，以下我将以递进的顺序阐述文件系统的实现过程。</p><h3 id="3-1-文件系统的加载与卸载"><a href="#3-1-文件系统的加载与卸载" class="headerlink" title="3.1 文件系统的加载与卸载"></a>3.1 文件系统的加载与卸载</h3><p>首先为了能够成功加载文件系统，文件系统需要提供文件系统的名字，超级块的加载和删除方法。这些东西反应在<code>file_system_type</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> <span class="hljs-title">HUST_fs_type</span> =</span> &#123;  <br>    .owner = THIS_MODULE,  <br>    .name = <span class="hljs-string">&quot;HUST_fs&quot;</span>,  <br>    .mount = HUST_fs_mount,  <br>    .kill_sb = HUST_fs_kill_superblock, <span class="hljs-comment">/* unmount */</span>  <br>&#125;;  <br></code></pre></td></tr></table></figure><p>文件系统作为一种块设备驱动，自然也需要实现module_init以及mocule_exit。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Called when the module is loaded. */</span>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_fs_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>    <span class="hljs-type">int</span> ret;  <br>    ret = register_filesystem(&amp;HUST_fs_type);  <br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)  <br>        printk(KERN_INFO <span class="hljs-string">&quot;Sucessfully registered HUST_fs\n&quot;</span>);  <br>    <span class="hljs-keyword">else</span>  <br>        printk(KERN_ERR <span class="hljs-string">&quot;Failed to register HUST_fs. Error: [%d]\n&quot;</span>, ret);  <br>    <span class="hljs-keyword">return</span> ret;  <br>&#125;  <br>  <br><span class="hljs-comment">/* Called when the module is unloaded. */</span>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">HUST_fs_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br><br>    <span class="hljs-type">int</span> ret;  <br>    ret = unregister_filesystem(&amp;HUST_fs_type);  <br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)  <br>        printk(KERN_INFO <span class="hljs-string">&quot;Sucessfully unregistered HUST_fs\n&quot;</span>);  <br>    <span class="hljs-keyword">else</span>  <br>        printk(KERN_ERR <span class="hljs-string">&quot;Failed to unregister HUST_fs. Error: [%d]\n&quot;</span>, ret);  <br>&#125;  <br>module_init(HUST_fs_init);  <br>module_exit(HUST_fs_exit);  <br>  <br>MODULE_LICENSE(<span class="hljs-string">&quot;MIT&quot;</span>);  <br>MODULE_AUTHOR(<span class="hljs-string">&quot;cv&quot;</span>); <br></code></pre></td></tr></table></figure><p>我们可以看到，设备驱动加载的时候，驱动向内核注册了文件系统，而驱动卸载的时候，文件系统的信息也被删除。文件系统加载时调用的函数为HUST_fs_mount，实际上，这个函数向内核注册了一个回调：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_fs_fill_super</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">void</span> *data, <span class="hljs-type">int</span> silent)</span>  <br></code></pre></td></tr></table></figure><p>这个函数是用来与VFS交互从而生成VFS超级块的。在HUST fs中，超级块在磁盘的第二个4096字节上，即块号为1。这个函数执行时会从磁盘中读取信息，填充到VFS提供的超级块结构体中，下列为部分关键代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_fs_fill_super</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">void</span> *data, <span class="hljs-type">int</span> silent)</span>  &#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> *<span class="hljs-title">bh</span>;</span>  <br>    bh = sb_bread(sb, <span class="hljs-number">1</span>);  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_fs_super_block</span> *<span class="hljs-title">sb_disk</span>;</span>  <br>    sb_disk = (<span class="hljs-keyword">struct</span> HUST_fs_super_block *)bh-&gt;b_data;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">root_inode</span>;</span>  <br>    <span class="hljs-keyword">if</span> (sb_disk-&gt;block_size != <span class="hljs-number">4096</span>) &#123;  <br>        printk(KERN_ERR <span class="hljs-string">&quot;HUST_fs expects a blocksize of %d\n&quot;</span>, <span class="hljs-number">4096</span>);  <br>        ret = -EFAULT;  <br>        <span class="hljs-keyword">goto</span> release;  <br>   &#125;  <br>   <span class="hljs-comment">//fill vfs super block  </span><br>    sb-&gt;s_magic = sb_disk-&gt;magic;  <br>    sb-&gt;s_fs_info = sb_disk;  <br>    sb-&gt;s_maxbytes = HUST_BLOCKSIZE * HUST_N_BLOCKS; <span class="hljs-comment">/* Max file size */</span>  <br>    sb-&gt;s_op = &amp;HUST_fs_super_ops;  <br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码可以看出，我们用sb_read来读取磁盘上的内容，然后填充super_block结构体。值得注意的是，有关超级块的操作函数即superblock_operations也是在此处赋值的。由于super_block* sb在文件系统卸载之前是一直存在于内存中的，所以我们可以使用s_fs_info来存储原始的超级块信息，避免后期交互时 再次读取磁盘。</p><p>文件系统卸载的时候超级块信息需要被删除，所以HUST_fs_kill_superblock的作用时释放该超级块，通知VFS该挂载点已经卸载。</p><p>实现基本函数后，可以对文件系统进行挂载操作，挂载操作的脚本内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">sudo umount ./test  <br>sudo rmmod HUST_fs  <br>dd bs=<span class="hljs-number">4096</span> count=<span class="hljs-number">100</span> <span class="hljs-keyword">if</span>=/dev/zero of=image  <br>./mkfs image  <br>insmod HUST_fs.ko  <br>mount -o loop -t HUST_fs image ./test  <br>dmesg<br></code></pre></td></tr></table></figure><p>我们从第0节可以看到挂载成功</p><h3 id="3-2-ls命令的实现"><a href="#3-2-ls命令的实现" class="headerlink" title="3.2  ls命令的实现"></a>3.2  ls命令的实现</h3><p>加载文件系统之后第一个要实现的功能是读取文件系统中的数据，所以选择实现文件夹读取操作，这一操作在2.x内核中是<code>.readdir</code>函数指针，在最新版本中是<code>.iterate</code>函数指针。这个指针在保存在file_operation中，如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">HUST_fs_dir_ops</span> =</span> &#123;  <br>    .owner = THIS_MODULE,  <br>    .iterate = HUST_fs_iterate,  <br>&#125;; <br></code></pre></td></tr></table></figure><p>HUST_fs_iterate函数主要功能逻辑是读取inode的块数据，并且将块数据中的inode和文件名通过dir_emit函数传输到VFS层。以根目录为例，根目录的包含三个数据项，分别是父目录，当前目录和欢迎文件，所以该函数会执行以下三个语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//参数分别表示上下文，文件/目录名，文件/目录名长度，inode号，文件类型  </span><br>dir_emit(ctx, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>, DT_DIR);  <br>dir_emit(ctx, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-number">2</span>,<span class="hljs-number">0</span>, DT_DIR);  <br>dir_emit(ctx, <span class="hljs-string">&quot;file&quot;</span>, <span class="hljs-number">4</span>,<span class="hljs-number">1</span>, DT_REG);<br></code></pre></td></tr></table></figure><p>完成该函数后，在填充根目录inode时将HUST_fs_dir_ops指针赋值，即可在挂在文件系统后执行ls命令。</p><img src="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230311223941193.png" alt="image-20230311223941193" style="zoom: 80%;"><p>如上图所示，我们成功看到了欢迎文件。但是此时我们不能对文件进行任何操作，因为还没有实现其他的接口。</p><h3 id="3-3-磁盘管理相关逻辑的实现"><a href="#3-3-磁盘管理相关逻辑的实现" class="headerlink" title="3.3 磁盘管理相关逻辑的实现"></a>3.3 磁盘管理相关逻辑的实现</h3><p>这个磁盘管理的内涵包括向磁盘写入和从磁盘取出读取inode，更新inode信息，维护imap，bmap，inode table等操作。为了使磁盘上的内容有序的组合起来，磁盘空间的管理十分的重要，后续的文件读写操作都与此相关。</p><p>写入和删除inode的操作存放在super_operations这个结构体中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_operations</span> <span class="hljs-title">HUST_fs_super_ops</span> =</span> &#123;  <br>    .evict_inode = HUST_evict_inode,  <br>    .write_inode = HUST_write_inode,  <br>&#125;;<br></code></pre></td></tr></table></figure><p>HUST_fs_super_ops需要在填充超级块时赋值到super_block的s_ops字段中。HUST_write_inode函数的功能是将内存中的inode保存在磁盘上。关键代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_write_inode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> writeback_control *wbc)</span>  <br>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">bh</span>;</span>  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> * <span class="hljs-title">raw_inode</span> =</span> <span class="hljs-literal">NULL</span>;  <br>    HUST_fs_get_inode(inode-&gt;i_sb, inode-&gt;i_ino, raw_inode);  <br>    <span class="hljs-keyword">if</span> (!raw_inode)  <br>        <span class="hljs-keyword">return</span> -EFAULT;  <br>    raw_inode-&gt;mode = inode-&gt;i_mode;  <br>    raw_inode-&gt;i_uid = fs_high2lowuid(i_uid_read(inode));  <br>    raw_inode-&gt;i_gid = fs_high2lowgid(i_gid_read(inode));  <br>    raw_inode-&gt;i_nlink = inode-&gt;i_nlink;  <br>    raw_inode-&gt;file_size = inode-&gt;i_size;      <br>    raw_inode-&gt;i_atime = (inode-&gt;i_atime.tv_sec);  <br>    raw_inode-&gt;i_mtime = (inode-&gt;i_mtime.tv_sec);  <br>    raw_inode-&gt;i_ctime = (inode-&gt;i_ctime.tv_sec);  <br>    mark_buffer_dirty(bh);  <br>    brelse(bh);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>可以看到，该函数的将vfs inode中的相关信息存储到HUST_inode结构体中，然后写入磁盘。这个是单独的写入磁盘操作，事实上，当我们申请inode时，imap也是需要检查刷新的，需要把相应位置标记为1。同理，evict_inode函数的作用时删除inode，删除成功后，我们需要刷新imap的值，把相应位置标记为0。</p><p>设置和写入map的操作都在map.c中，以下以imap为例。对于imap来讲，申请inode的时候需要检查第一个空闲的inode编号，当inode被释放的时候也要及时清零对应的imap。与此相关的函数如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从磁盘中读取数据并存在imap数组中  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_imap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block* sb, <span class="hljs-type">uint8_t</span>* imap, <span class="hljs-type">ssize_t</span> imap_size)</span>;  <br><span class="hljs-comment">//在vaddr数组中找到第一个为0的bit，这个函数用于定位空inode或者block  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_find_first_zero_bit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *vaddr, <span class="hljs-type">unsigned</span> size)</span>;  <br><span class="hljs-comment">//将imap的某一位置0或者1，并保存在磁盘上  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">set_and_save_imap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block* sb, <span class="hljs-type">uint64_t</span> inode_num, <span class="hljs-type">uint8_t</span> value)</span>;  <br><span class="hljs-comment">//定义的位操作宏如下  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> setbit(number,x) number |= 1UL &lt;&lt; x  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clearbit(number, x) number &amp;= ~(1UL &lt;&lt; x)  </span><br></code></pre></td></tr></table></figure><p>由于本文件系统并不是为了实际使用，所以上述的操作都没有考虑性能以及准确性问题。事实上，能够加上校验或者冗余备份是最好的。</p><h3 id="3-4-读写文件内容"><a href="#3-4-读写文件内容" class="headerlink" title="3.4 读写文件内容"></a>3.4 读写文件内容</h3><p>为了能够快速看到文件系统在正常工作，所以接下来需要实现文件的读写操作。文件读写操作按照一般处理，应该是实现在struct file_operations这个结构体中的。事实上，最开始我是实现在这个结构体中的read_iter函数指针中的。但是比较有趣的一点是，如果我们实现了struct address_space_operations结构体中的函数，那么struct file_operations结构体中的函数则可以交由VFS实现。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">HUST_fs_file_ops</span> =</span> &#123;  <br>    .owner = THIS_MODULE,  <br>    .llseek = generic_file_llseek,  <br>    .mmap = generic_file_mmap,  <br>    .fsync = generic_file_fsync,  <br>    .read_iter = generic_file_read_iter,  <br>    .write_iter = generic_file_write_iter,  <br>&#125;;  <br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>   <span class="hljs-title">address_space_operations</span> <span class="hljs-title">HUST_fs_aops</span> =</span> &#123;  <br>    .readpage = HUST_fs_readpage,  <br>    .writepage = HUST_fs_writepage,  <br>    .write_begin = HUST_fs_write_begin,  <br>    .write_end = generic_write_end,  <br>&#125;;<br></code></pre></td></tr></table></figure><p>上述的generic开头的函数是不需要我们手动实现的。上述的address_space_operations操作其实是实现了页高速缓存的一些操作。页高速缓存是linux内核实现的一种主要磁盘缓存，它主要用来减少对磁盘的IO操作，具体地讲，是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。这些接口一旦实现，那么对文件的操作就可以转移到内存中，这就是为什么可以使用generic开头的这些函数来代替手写。</p><p>HUST_fs_readpage, HUST_fs_writepage以及HUST_fs_write_begin都被注册回调到同一个函数HUST_fs_get_block。HUST_fs_get_block主要返回内核请求长度的数据。至于读写操作，内核调用__bwrite函数最终调用块设备驱动执行。因为在我没有采用二级或者多级索引，故而HUST_fs_get_block函数逻辑比较简单，部分代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_fs_get_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-type">sector_t</span> block,  </span><br><span class="hljs-params">              <span class="hljs-keyword">struct</span> buffer_head *bh, <span class="hljs-type">int</span> create)</span>  <br>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> inode-&gt;i_sb;  <br>    <span class="hljs-keyword">if</span> (block &gt; HUST_N_BLOCKS) <br>        <span class="hljs-keyword">return</span> -ENOSPC;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> <span class="hljs-title">H_inode</span>;</span>  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == HUST_fs_get_inode(sb, inode-&gt;i_ino, &amp;H_inode))  <br>        <span class="hljs-keyword">return</span> -EFAULT;  <br>    <span class="hljs-keyword">if</span> (H_inode.blocks == <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">if</span>(alloc_block_for_inode(sb, &amp;H_inode, <span class="hljs-number">1</span>)) <br>            <span class="hljs-keyword">return</span> -EFAULT;  <br>    map_bh(bh, sb, H_inode.block[block]);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，该函数判断传入的block的大小，并将磁盘内容映射到bh中。后续的读写操作将有VFS帮我们完成。</p><h3 id="3-5-inode操作"><a href="#3-5-inode操作" class="headerlink" title="3.5 inode操作"></a>3.5 inode操作</h3><p>Inode操作涉及文件(夹)的创建删除，将HUST_inode映射到VFS中的inode等操作。具体实现的函数如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span> <span class="hljs-title">HUST_fs_inode_ops</span> =</span> &#123;  <br>    .lookup = HUST_fs_lookup,  <br>    .mkdir = HUST_fs_mkdir,  <br>    .create = HUST_fs_create,  <br>    .unlink = HUST_fs_unlink,  <br>&#125;; <br></code></pre></td></tr></table></figure><p>HUST_fs_lookup是其中比较复杂的一个函数，它负责将一个目录下的inode信息交由VFS管理。首先，HUST_fs_lookup读取文件夹的内容，然后遍历文件夹下面的HUST_inode，找到我们想要的HUST_inode，根据不同的文件属性，申请vfs_inode；并对不同的vfs_inode设置不同的操作。假设vfs_inode对应的是一个文件，那么就设置vfs_inode-&gt;mapping-&gt;a_ops，如果vfs_inode对应的是文件夹，那么就设置vfs_inode-&gt;f_ops &#x3D; &amp;HUST_fs_dir_ops;最后将vfs_inode注册到VFS中。这部分的关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> dentry *<span class="hljs-title function_">HUST_fs_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *parent_inode,  </span><br><span class="hljs-params">                  <span class="hljs-keyword">struct</span> dentry *child_dentry, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span>  <br>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> parent_inode-&gt;i_sb;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> <span class="hljs-title">H_inode</span>;</span>  <br><span class="hljs-comment">//省略代码  </span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; H_inode.dir_children_count; i++) &#123;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>  <br>            (child_dentry-&gt;d_name.name, dtptr[i].filename,  <br>             HUST_FILENAME_MAX_LEN) == <span class="hljs-number">0</span>)&#123;  <br>            inode = iget_locked(sb, dtptr[i].inode_no);  <br>            <span class="hljs-keyword">if</span> (inode-&gt;i_state &amp; I_NEW) &#123;  <br>                inode_init_owner(inode, parent_inode, <span class="hljs-number">0</span>);  <br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> <span class="hljs-title">H_child_inode</span>;</span>  <br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == HUST_fs_get_inode(sb, dtptr[i].inode_no, &amp;H_child_inode))  <br>                    <span class="hljs-keyword">return</span> ERR_PTR(-EFAULT);  <br>                HUST_fs_convert_inode(&amp;H_child_inode, inode);  <br>                inode-&gt;i_op = &amp;HUST_fs_inode_ops;  <br>                <span class="hljs-keyword">if</span> (S_ISDIR(H_child_inode.mode)) &#123;  <br>                    inode-&gt;i_fop = &amp;HUST_fs_dir_ops;  <br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISREG(H_child_inode.mode)) &#123;  <br>                    inode-&gt;i_fop = &amp;HUST_fs_file_ops;;  <br>                    inode-&gt;i_mapping-&gt;a_ops = &amp;HUST_fs_aops;  <br>                &#125;  <br>                inode-&gt;i_mode = H_child_inode.mode;  <br>                inode-&gt;i_size = H_child_inode.file_size;  <br>                insert_inode_hash(inode);  <br>                unlock_new_inode(inode);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br><span class="hljs-comment">//省略代码  </span><br>&#125; <br></code></pre></td></tr></table></figure><p>只有在这里注册了相关函数，系统调用才能正常执行。不然就会出现不支持的操作这种报错信息。</p><p>.create与.mkdir都是对应了inode的创建，只是inode的属性不能而已。.create创建普通文件而.mkdir创建文件夹。所以这两个函数的功能被函数HUST_fs_create_obj所处理。这个函数接受新建文件（夹）的请求，检查磁盘的大小，检查是否有空余的indoe，并且分配inode号，然后更新imap信息，最后更新超级块信息。由于该函数逻辑简单但是代码量比较大，故而不在此展示其具体实现。</p><p>在完成上述工作之后，我们的文件系统基本已经完成了，这个系统采用线性（区别于minixi二级索引用树来管理）的方式管理磁盘空间，支持基本的增删改查文件操作，支持文件权限，支持多用户。</p>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android HIDL服务实现</title>
    <link href="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-HIDL服务实现"><a href="#Android-HIDL服务实现" class="headerlink" title="Android HIDL服务实现"></a>Android HIDL服务实现</h1><blockquote><p><a href="https://www.jianshu.com/p/b75c4321ae0a">https://www.jianshu.com/p/b75c4321ae0a</a></p></blockquote><p><strong>Android O(8.0)</strong> 版本之后，底层实现有了比较大的变化，最显著的一个方面就是 <strong>HIDL</strong> 机制的全面实施。本文将从 <strong>HIDL的基本概念</strong>、<strong>HIDL服务模拟</strong>、<strong>framework层aidl服务</strong>、<strong>应用层程序</strong> 这四个方面来全面的阐述 <strong>HIDL</strong> 工作全过程，这对于理解系统源码中 <strong>Gnss</strong>、<strong>Usb</strong>、<strong>Camera</strong> 等模块的工作原理有极大帮助。</p><h2 id="1-HIDL设计目的"><a href="#1-HIDL设计目的" class="headerlink" title="1. HIDL设计目的"></a>1. HIDL设计目的</h2><p>在 <strong>Android O(8.0)</strong> 之前系统的升级牵扯多方协作，极为麻烦，<strong>HIDL</strong>机制的推出就是将 <strong>framework</strong> 与 <strong>hal</strong> 层分开，使得框架部分可以直接被覆盖、更新，而不需要重新对 HAL 进行编译，这样在系统升级时，<strong>OEM</strong> 厂商 跳过 <strong>SoC</strong> 厂商，先对 <strong>framework</strong> 进行升级。</p><h3 id="1-1-Android-8-0之前"><a href="#1-1-Android-8-0之前" class="headerlink" title="1.1 Android 8.0之前"></a>1.1 Android 8.0之前</h3><p><strong>framework</strong> 与 <strong>hal</strong> 紧紧耦合存在于 <strong>system.img</strong> 中，因此在版本升级时需要: <strong>OEM</strong> 厂商适配 <strong>framework</strong> ，<strong>SoC厂商</strong> 适配 <strong>hal</strong>， 之后将修改打包到 <strong>system.img</strong>，生成 OTA 升级包，推送到手机进行 OTA 升级</p><h3 id="1-2-Android-8-0之后"><a href="#1-2-Android-8-0之后" class="headerlink" title="1.2 Android 8.0之后"></a>1.2 Android 8.0之后</h3><p><strong>framework</strong> 与 <strong>hal</strong> 进行了解耦， <strong>framework</strong> 存在于 <strong>system.img</strong>，<strong>hal</strong> 存在于<strong>vendor.img</strong>，进行版本升级时，分为两次升级:</p><ul><li><strong>framework升级</strong> ： OEM 厂商适配 framework，将修改打包到 system.img， 生成OTA 升级包，推送到手机进行 OTA 升级(framework 发生改变，hal 层未变)。</li><li><strong>hal升级</strong> ：SoC 厂商适配 hal， 将修改打包到 vendor.img, 生成OTA 升级包，推送到手机进行OTA升级(framework发生改变，hal 层发生改变)。</li></ul><h2 id="2-HIDL机制演进"><a href="#2-HIDL机制演进" class="headerlink" title="2.HIDL机制演进"></a>2.HIDL机制演进</h2><h3 id="2-1-老版本-Framework-与-HAL-的通信框架"><a href="#2-1-老版本-Framework-与-HAL-的通信框架" class="headerlink" title="2.1 老版本 Framework 与 HAL 的通信框架"></a>2.1 老版本 Framework 与 HAL 的通信框架</h3><p>正如上述所言，旧版的系统架构中， Android Framework 层与 Hal 层是打包成一个 <strong>system.img</strong> 的，且 Framework 与 hal 层之间是紧密耦合的，通过链接的方式使用相应的硬件 <strong>so</strong> 库。它们之间的架构一般有如下两种方式：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-0fed2e7f185e551d.png" style="zoom:80%;"><h3 id="2-2-HIDL-类型介绍"><a href="#2-2-HIDL-类型介绍" class="headerlink" title="2.2  HIDL 类型介绍"></a>2.2  HIDL 类型介绍</h3><p>为了解决两者之间这种紧耦合所带来的弊端，google 引入 HIDL 来定义 Framework 与 HAL 之间的接口，可以用下图来描述：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-ea297e84897f8686.webp" style="zoom:80%;"><p>事实上虽然 google 推出了这种机制，但是很多厂商没有很快的跟上节奏，因此为了向前兼容， google 定义了三种类型：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-5b8123370101b01f.png" style="zoom: 67%;"><p>① 是 Treble Project 之前使用的实现架构，使用的是传统 HAL 和旧版 HAL</p><p>② 直通模式，passthrough mode。如图所示，Framework 和 HAL 层工作在同一个进程当中，下面的 HAL 是使用 HIDL 封装后的库，是直通式 HAL。这些库文件也可用于 ③ 绑定模式</p><p>③ 绑定模式，binderized mode。是直通式 HAL binder 化，变为绑定式 HAL。Framework 和 HAL 层工作在不同的进程，之间通过 Binder 进行 IPC</p><p>④ 纯绑定式。相对于 ③ 来说，绑定式 HAL 中并不包含直通式 HAL，因此称为纯绑定式</p><p><strong>上述可总结为</strong>：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-619180c0c7f8afc5.png" style="zoom: 67%;"><h2 id="3-Binderized-Mode（绑定式）简介"><a href="#3-Binderized-Mode（绑定式）简介" class="headerlink" title="3.Binderized Mode（绑定式）简介"></a>3.Binderized Mode（绑定式）简介</h2><p>们知道 <strong>绑定模式</strong> 是 google 为了向前兼容而定义的一种类型，且 Android 8.0 及后续版本的设备都必须只支持这种模式。这种模式下 Framework 与 Hal 分别位于不同的进程中，其实从具体实现来讲这种模式也更应该被称为 <strong>Binder 化的直通式</strong>。本文将通过这种方式实现一个 <strong>HIDL</strong> 服务。</p><h2 id="4-环境-x2F-工具准备"><a href="#4-环境-x2F-工具准备" class="headerlink" title="4.环境&#x2F;工具准备"></a>4.环境&#x2F;工具准备</h2><ul><li>Ubuntu 20.04 TLS</li><li>Android 源码：Android 9.0，编译烧录详见 <a href="https://www.jianshu.com/p/848414148272">Android源码编译烧录</a></li><li>hidl-gen 工具：Android 系统自带，需要配置一下环境变量</li></ul><h2 id="5-HIDL实现"><a href="#5-HIDL实现" class="headerlink" title="5.HIDL实现"></a>5.HIDL实现</h2><p>本文目的是实现一个具有 <strong>加减乘除</strong> 运算的 HIDL 服务,命名为 <strong>银河一号(GalaxyOne)<strong>。HIDL用起来非常简单，在系统源码中的 <strong>hardware&#x2F;interfaces</strong> 目录下有很多的 HIDL，我们仿照其他 HIDL 来创建自己的目录：</strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0</strong></p><h3 id="5-1-创建IGalaxyOne-hal-文件"><a href="#5-1-创建IGalaxyOne-hal-文件" class="headerlink" title="5.1 创建IGalaxyOne.hal 文件"></a>5.1 创建IGalaxyOne.hal 文件</h3><p><strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0&#x2F;IGalaxyOne.hal</strong></p><p>这里定义了四种基本的运算：加、减、乘、除，这是上层调用 HAL 的入口，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">package android.hardware.galaxy_one@<span class="hljs-number">1.0</span>;<br><br>interface IGalaxyOne&#123;<br><br>    <span class="hljs-comment">//加法</span><br>    add(<span class="hljs-type">uint32_t</span> a,<span class="hljs-type">uint32_t</span> b) generates (<span class="hljs-type">uint32_t</span> result);<br>    <span class="hljs-comment">//减法</span><br>    sub(<span class="hljs-type">uint32_t</span> a,<span class="hljs-type">uint32_t</span> b) generates (<span class="hljs-type">uint32_t</span> result);<br>    <span class="hljs-comment">//乘法</span><br>    mul(<span class="hljs-type">uint32_t</span> a,<span class="hljs-type">uint32_t</span> b) generates (<span class="hljs-type">uint32_t</span> result);<br>    <span class="hljs-comment">//除法</span><br>    div(<span class="hljs-type">uint32_t</span> a,<span class="hljs-type">uint32_t</span> b) generates (<span class="hljs-type">uint32_t</span> result);<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-2-hidl-gen生成HIDL框架"><a href="#5-2-hidl-gen生成HIDL框架" class="headerlink" title="5.2 hidl-gen生成HIDL框架"></a>5.2 hidl-gen生成HIDL框架</h3><p>在使用 hidl-gen 之前需要先做两件事：<br>1、hidl-gen 由 Android 提供，使用之前需要先配置一下系统路径，如我这里所做的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># vim ~/.bashrc</span><br>export PATH=/home/zsk/AOSP/out/soong/host/linux-x86/bin:$PATH<br></code></pre></td></tr></table></figure><p>2、Ubuntu 新的终端窗口必须先设定一些 Android 环境变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">source build/envsetup.sh<br>lunch aosp_sailfish-userdebug  <span class="hljs-comment">// lunch mode 根据需求修改</span><br>make hidl-gen<br></code></pre></td></tr></table></figure><p>配置完成之后在 <strong>源码根目录</strong> 下执行如下命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">PACKAGE=android.hardware.galaxy_one@<span class="hljs-number">1.0</span><br>LOC=hardware/interfaces/galaxy_one/<span class="hljs-number">1.0</span>/<span class="hljs-keyword">default</span>/<br>    <br>hidl-gen -o $LOC -Lc++-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE<br><br>hidl-gen -o $LOC -Landroidbp-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE<br></code></pre></td></tr></table></figure><p>命令执行成功之后会发现在 <strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0</strong> 目录下多了一个 <strong>default</strong> 目录，进入之后发现有如下文件：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-0096f7494b4dbff9.png" style="zoom: 80%;"><p>之后执行 <strong>update-makefiles.sh</strong> 脚本来为 HIDL 生成对应的 <strong>Android.bp</strong> 文件，此脚本位于 <strong>hardware&#x2F;interfaces</strong> 目录下，同样可在源码根目录下执行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">./hardware/interfaces/update-makefiles.sh<br></code></pre></td></tr></table></figure><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-5ea845283e2c2d58.png" style="zoom: 80%;"><p>接下来我们需要添加两个空文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">touch hardware/interfaces/galaxy_one/<span class="hljs-number">1.0</span>/<span class="hljs-keyword">default</span>/android.hardware.galaxy_one@<span class="hljs-number">1.0</span>-service.rc<br>touch hardware/interfaces/galaxy_one/<span class="hljs-number">1.0</span>/<span class="hljs-keyword">default</span>/service.cpp<br></code></pre></td></tr></table></figure><p>完成之后，整个工程结构如下所示：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-118902147dc61749.png" style="zoom: 80%;"><h3 id="5-3-调用流程"><a href="#5-3-调用流程" class="headerlink" title="5.3 调用流程"></a>5.3 调用流程</h3><p>上述过程已经将 HIDL 服务所需要的全本文件配置完成，虽然其中很多文件是空的，或者没有具体实现，我们现在先放在一边，先来对整体的调用流程及各个文件的功效略作说明。</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-865d0cf346cee965.png" style="zoom: 80%;"><ul><li>Application：指上层应用</li><li>JNI：指 framework 层，getService 获取 hal 层 service</li><li><a href="mailto:&#97;&#110;&#x64;&#114;&#111;&#105;&#x64;&#x2e;&#104;&#x61;&#x72;&#x64;&#x77;&#x61;&#x72;&#101;&#46;&#x67;&#97;&#108;&#x61;&#x78;&#121;&#95;&#111;&#110;&#x65;&#x40;&#49;&#x2e;&#48;&#x2e;&#115;&#x6f;">&#97;&#110;&#x64;&#114;&#111;&#105;&#x64;&#x2e;&#104;&#x61;&#x72;&#x64;&#x77;&#x61;&#x72;&#101;&#46;&#x67;&#97;&#108;&#x61;&#x78;&#121;&#95;&#111;&#110;&#x65;&#x40;&#49;&#x2e;&#48;&#x2e;&#115;&#x6f;</a>：由 IGalaxyOne.hal 生成的接口库，由 <strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0&#x2F;Android.bp</strong> 通过 <strong>IGalaxyOne.hal</strong> 生成，这样只要这个接口库不变，那么 framework 的更新和 hal 层就隔绝开了</li><li><a href="mailto:&#x61;&#x6e;&#100;&#x72;&#111;&#105;&#x64;&#x2e;&#x68;&#x61;&#114;&#x64;&#x77;&#x61;&#114;&#101;&#46;&#103;&#97;&#x6c;&#x61;&#x78;&#x79;&#95;&#111;&#x6e;&#101;&#64;&#x31;&#x2e;&#x30;&#x2d;&#115;&#101;&#x72;&#x76;&#105;&#x63;&#101;&#46;&#x72;&#99;">&#x61;&#x6e;&#100;&#x72;&#111;&#105;&#x64;&#x2e;&#x68;&#x61;&#114;&#x64;&#x77;&#x61;&#114;&#101;&#46;&#103;&#97;&#x6c;&#x61;&#x78;&#x79;&#95;&#111;&#x6e;&#101;&#64;&#x31;&#x2e;&#x30;&#x2d;&#115;&#101;&#x72;&#x76;&#105;&#x63;&#101;&#46;&#x72;&#99;</a>：设备开机时通过 <strong>rc</strong> 文件启动此服务</li><li>galaxy_hal_service：service的名，可通过 <strong>start galaxy_hal_service</strong> 启动服务，由service.cpp编译生成</li><li><a href="mailto:&#x61;&#110;&#x64;&#114;&#111;&#105;&#100;&#46;&#x68;&#97;&#114;&#x64;&#119;&#97;&#x72;&#x65;&#46;&#103;&#x61;&#108;&#x61;&#120;&#121;&#95;&#x6f;&#x6e;&#x65;&#x40;&#49;&#x2e;&#48;&#45;&#105;&#x6d;&#112;&#x6c;&#46;&#x73;&#x6f;">&#x61;&#110;&#x64;&#114;&#111;&#105;&#100;&#46;&#x68;&#97;&#114;&#x64;&#119;&#97;&#x72;&#x65;&#46;&#103;&#x61;&#108;&#x61;&#120;&#121;&#95;&#x6f;&#x6e;&#x65;&#x40;&#49;&#x2e;&#48;&#45;&#105;&#x6d;&#112;&#x6c;&#46;&#x73;&#x6f;</a>：实现库，上层应用的最终调用，由GalaxyOne.cpp编译生成</li></ul><p>关于 <strong>Application、JNI</strong> 这两层内容会在稍后用两个篇幅去分析，此处暂不理会。现在我们就着这个调用过程将需要的内容补充完成。明出处。</p><h4 id="5-3-1-接口库生成"><a href="#5-3-1-接口库生成" class="headerlink" title="5.3.1 接口库生成"></a>5.3.1 接口库生成</h4><p><a href="mailto:&#97;&#110;&#x64;&#x72;&#111;&#x69;&#100;&#x2e;&#x68;&#97;&#114;&#x64;&#119;&#97;&#114;&#x65;&#46;&#x67;&#97;&#108;&#97;&#120;&#x79;&#x5f;&#111;&#x6e;&#x65;&#x40;&#x31;&#46;&#x30;&#46;&#115;&#111;">&#97;&#110;&#x64;&#x72;&#111;&#x69;&#100;&#x2e;&#x68;&#97;&#114;&#x64;&#119;&#97;&#114;&#x65;&#46;&#x67;&#97;&#108;&#97;&#120;&#x79;&#x5f;&#111;&#x6e;&#x65;&#x40;&#x31;&#46;&#x30;&#46;&#115;&#111;</a>，由 <strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0&#x2F;Android.bp</strong> 通过 <strong>IGalaxyOne.hal</strong> 生成，Android.bp 文件是在上面一些列命令执行之后生成，而接口库是当我们最终执行编译模块时生成，可以说这个过程不需要我们手动参与，Android.bp 内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile">// This file is autogenerated by hidl-gen -Landroidbp.<br><br>hidl_interface &#123;<br>    name: <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0&quot;</span>,   //此处设置接口库的名字<br>    root: <span class="hljs-string">&quot;android.hardware&quot;</span>,<br>    vndk: &#123;<br>        enabled: true,<br>    &#125;,<br>    srcs: [<br>        <span class="hljs-string">&quot;IGalaxyOne.hal&quot;</span>,<br>    ],<br>    interfaces: [<br>        <span class="hljs-string">&quot;android.hidl.base@1.0&quot;</span>,<br>    ],<br>    gen_java: true,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-2-实现库生成"><a href="#5-3-2-实现库生成" class="headerlink" title="5.3.2 实现库生成"></a>5.3.2 实现库生成</h4><p><a href="mailto:&#97;&#110;&#x64;&#114;&#x6f;&#105;&#100;&#x2e;&#x68;&#x61;&#x72;&#x64;&#x77;&#x61;&#114;&#101;&#x2e;&#103;&#x61;&#108;&#97;&#120;&#x79;&#x5f;&#x6f;&#110;&#101;&#x40;&#x31;&#46;&#x30;&#45;&#105;&#109;&#x70;&#x6c;&#46;&#115;&#111;">&#97;&#110;&#x64;&#114;&#x6f;&#105;&#100;&#x2e;&#x68;&#x61;&#x72;&#x64;&#x77;&#x61;&#114;&#101;&#x2e;&#103;&#x61;&#108;&#97;&#120;&#x79;&#x5f;&#x6f;&#110;&#101;&#x40;&#x31;&#46;&#x30;&#45;&#105;&#109;&#x70;&#x6c;&#46;&#115;&#111;</a>，由 <strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0&#x2F;default&#x2F;Android.bp</strong> 通过 <strong>GalaxyOne.cpp</strong> 生成，注意这个 Android.bp 文件是位于 <strong>default</strong> 目录下，同样的在最后模块编译时生成，原始内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cc_library_shared &#123;<br>    name: <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0-impl&quot;</span>,<br>    relative_install_path: <span class="hljs-string">&quot;hw&quot;</span>,<br>    proprietary: true,<br>    srcs: [<br>        <span class="hljs-string">&quot;GalaxyOne.cpp&quot;</span>,<br>    ],<br>    shared_libs: [    //这里可以添加我们需要的库<br>        <span class="hljs-string">&quot;liblog&quot;</span>,     <br>        <span class="hljs-string">&quot;libhidlbase&quot;</span>,<br>        <span class="hljs-string">&quot;libhidltransport&quot;</span>,<br>        <span class="hljs-string">&quot;libhwbinder&quot;</span>,<br>        <span class="hljs-string">&quot;libutils&quot;</span>,<br>        <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0&quot;</span>,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-3-GalaxyOne-cpp实现"><a href="#5-3-3-GalaxyOne-cpp实现" class="headerlink" title="5.3.3 GalaxyOne.cpp实现"></a>5.3.3 GalaxyOne.cpp实现</h4><p>在 <strong>5.3.2</strong> 中，实现库是由 <strong>GalaxyOne.cpp</strong> 编译而成，现在我们来将此文件补充完成：</p><p><strong>GalaxyOne.h:</strong><br> Binder化直通式，同样需要将 HIDL_FETCH_XXX 打开，至于原因我们在后面会提及</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ANDROID_HARDWARE_GALAXY_ONE_V1_0_GALAXYONE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANDROID_HARDWARE_GALAXY_ONE_V1_0_GALAXYONE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hardware/galaxy_one/1.0/IGalaxyOne.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/MQDescriptor.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/Status.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;log/log.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> android &#123;<br><span class="hljs-keyword">namespace</span> hardware &#123;<br><span class="hljs-keyword">namespace</span> galaxy_one &#123;<br><span class="hljs-keyword">namespace</span> V1_0 &#123;<br><span class="hljs-keyword">namespace</span> implementation &#123;<br><br><span class="hljs-keyword">using</span> ::android::hardware::hidl_array;<br><span class="hljs-keyword">using</span> ::android::hardware::hidl_memory;<br><span class="hljs-keyword">using</span> ::android::hardware::hidl_string;<br><span class="hljs-keyword">using</span> ::android::hardware::hidl_vec;<br><span class="hljs-keyword">using</span> ::android::hardware::Return;<br><span class="hljs-keyword">using</span> ::android::hardware::Void;<br><span class="hljs-keyword">using</span> ::android::sp;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GalaxyOne</span> : <span class="hljs-keyword">public</span> IGalaxyOne &#123;<br>    <span class="hljs-comment">// Methods from ::android::hardware::galaxy_one::V1_0::IGalaxyOne follow.</span><br>    <span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> <span class="hljs-keyword">override</span></span>;<br><br>    <span class="hljs-comment">// Methods from ::android::hidl::base::V1_0::IBase follow.</span><br><br>&#125;;<br><br><span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> most likely delete, this is only for passthrough implementations</span><br> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">IGalaxyOne* <span class="hljs-title">HIDL_FETCH_IGalaxyOne</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span></span>;<br><br>&#125;  <span class="hljs-comment">// namespace implementation</span><br>&#125;  <span class="hljs-comment">// namespace V1_0</span><br>&#125;  <span class="hljs-comment">// namespace galaxy_one</span><br>&#125;  <span class="hljs-comment">// namespace hardware</span><br>&#125;  <span class="hljs-comment">// namespace android</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// ANDROID_HARDWARE_GALAXY_ONE_V1_0_GALAXYONE_H</span></span><br><br></code></pre></td></tr></table></figure><p><strong>GalaxyOne.cpp:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GalaxyOne.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> android &#123;<br><span class="hljs-keyword">namespace</span> hardware &#123;<br><span class="hljs-keyword">namespace</span> galaxy_one &#123;<br><span class="hljs-keyword">namespace</span> V1_0 &#123;<br><span class="hljs-keyword">namespace</span> implementation &#123;<br><br><span class="hljs-comment">// Methods from ::android::hardware::galaxy_one::V1_0::IGalaxyOne follow.</span><br><span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">GalaxyOne::add</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> result = a + b;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;GalaxyOne::add  a = %d,b = %d,result = %d&quot;</span>,a,b,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">GalaxyOne::sub</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> result = a - b;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;GalaxyOne::sub  a = %d,b = %d,result = %d&quot;</span>,a,b,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">GalaxyOne::mul</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> result = a * b;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;GalaxyOne::mul  a = %d,b = %d,result = %d&quot;</span>,a,b,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">GalaxyOne::div</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> result = a / b;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;GalaxyOne::div  a = %d,b = %d,result = %d&quot;</span>,a,b,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// Methods from ::android::hidl::base::V1_0::IBase follow.</span><br><span class="hljs-function">IGalaxyOne* <span class="hljs-title">HIDL_FETCH_IGalaxyOne</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-comment">/* name */</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">ALOG</span>(<span class="hljs-string">&quot;galaxy_one service init success....&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">GalaxyOne</span>();<br>&#125;<br><br>&#125;  <span class="hljs-comment">// namespace implementation</span><br>&#125;  <span class="hljs-comment">// namespace V1_0</span><br>&#125;  <span class="hljs-comment">// namespace galaxy_one</span><br>&#125;  <span class="hljs-comment">// namespace hardware</span><br>&#125;  <span class="hljs-comment">// namespace android</span><br></code></pre></td></tr></table></figure><h4 id="5-3-4-模块编译"><a href="#5-3-4-模块编译" class="headerlink" title="5.3.4 模块编译"></a>5.3.4 模块编译</h4><p>现在除了需要的 <strong>rc</strong> 文件没有补充、<strong>galaxy-hal-service</strong> 服务没有生成外其余均已配置好了，现在进行编译生成对应的库。进入根目录下执行如下命令：(注意是在刚刚执行过的 <strong>source build&#x2F;envsetup.sh</strong> 和 <strong>lunch</strong> 的窗口下编译，若是新窗口则需要重新执行这两条命令)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mmm  hardware/interfaces/galaxy_one/1.0<br></code></pre></td></tr></table></figure><p>此时应该可以在 <strong>out&#x2F;tartget&#x2F;product&#x2F;XXX&#x2F;vendor&#x2F;lib64&#x2F;hw</strong> 和 <strong>out&#x2F;tartget&#x2F;product&#x2F;XXX&#x2F;system&#x2F;lib64&#x2F;hw</strong> 目录下找到 <strong><a href="mailto:&#97;&#x6e;&#100;&#114;&#x6f;&#x69;&#100;&#46;&#x68;&#x61;&#114;&#100;&#119;&#97;&#x72;&#101;&#46;&#x67;&#97;&#x6c;&#97;&#x78;&#121;&#x5f;&#111;&#110;&#x65;&#64;&#49;&#x2e;&#48;&#45;&#105;&#109;&#112;&#108;&#x2e;&#115;&#x6f;">&#97;&#x6e;&#100;&#114;&#x6f;&#x69;&#100;&#46;&#x68;&#x61;&#114;&#100;&#119;&#97;&#x72;&#101;&#46;&#x67;&#97;&#x6c;&#97;&#x78;&#121;&#x5f;&#111;&#110;&#x65;&#64;&#49;&#x2e;&#48;&#45;&#105;&#109;&#112;&#108;&#x2e;&#115;&#x6f;</a></strong> 和 <strong><a href="mailto:&#97;&#x6e;&#100;&#114;&#111;&#x69;&#x64;&#x2e;&#104;&#x61;&#x72;&#x64;&#119;&#97;&#x72;&#101;&#46;&#x67;&#97;&#x6c;&#97;&#x78;&#121;&#95;&#111;&#x6e;&#x65;&#x40;&#x31;&#x2e;&#x30;&#x2e;&#x73;&#111;">&#97;&#x6e;&#100;&#114;&#111;&#x69;&#x64;&#x2e;&#104;&#x61;&#x72;&#x64;&#119;&#97;&#x72;&#101;&#46;&#x67;&#97;&#x6c;&#97;&#x78;&#121;&#95;&#111;&#x6e;&#x65;&#x40;&#x31;&#x2e;&#x30;&#x2e;&#x73;&#111;</a></strong> 两个动态库</p><h4 id="5-3-5-service生成"><a href="#5-3-5-service生成" class="headerlink" title="5.3.5 service生成"></a>5.3.5 service生成</h4><p>上面过程将需要的动态库生成完毕，接下来我们需要生成对应的 service 可执行文件，这个过程一共分为三步：</p><p><strong>1、向&#x2F;default下的Android.bp 文件添加以下内容</strong></p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs make">cc_library &#123;<br>    name: <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0-service&quot;</span>,<br>    defaults: [<span class="hljs-string">&quot;hidl_defaults&quot;</span>],<br>    relative_install_path: <span class="hljs-string">&quot;hw&quot;</span>,<br>    vendor: true,<br>    srcs: [<br>        <span class="hljs-string">&quot;service.cpp&quot;</span><br>    ],<br>    init_rc: [<span class="hljs-string">&quot;android.hardware.galaxy_one@1.0-service.rc&quot;</span>],<br>    shared_libs: [<br>        <span class="hljs-string">&quot;liblog&quot;</span>,<br>        <span class="hljs-string">&quot;libhidlbase&quot;</span>,<br>        <span class="hljs-string">&quot;libhidltransport&quot;</span>,<br>        <span class="hljs-string">&quot;libhwbinder&quot;</span>,<br>        <span class="hljs-string">&quot;libutils&quot;</span>,<br>        <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0&quot;</span>,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、补充 service.cpp 内容</strong></p><p>内容很简单，<strong>defaultPassthroughServiceImplementation</strong> 帮我们自动注册服务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_TAG <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0-service&quot;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hardware/galaxy_one/1.0/IGalaxyOne.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/LegacySupport.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GalaxyOne.h&quot;</span></span><br> <br><span class="hljs-comment">// Generated HIDL files</span><br><span class="hljs-keyword">using</span> android::hardware::galaxy_one::V1_0::IGalaxyOne;<br><span class="hljs-keyword">using</span> android::hardware::galaxy_one::V1_0::implementation::GalaxyOne;<br> <br><span class="hljs-keyword">using</span> android::hardware::defaultPassthroughServiceImplementation;<br><span class="hljs-keyword">using</span> android::hardware::configureRpcThreadpool;<br><span class="hljs-keyword">using</span> android::hardware::joinRpcThreadpool;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">defaultPassthroughServiceImplementation</span>&lt;IGalaxyOne&gt;();<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>3、补充 rc 文件</strong></p><p>注意这里的 <strong>galaxy-hal-service</strong> 相当于这个服务的别名，系统就是根据这个文件在启动的同时也将这个 service 启动，因此在下面我们手动启动测试时没有什么作用，不过这里先补充完整。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">service galaxy-hal-service /vendor/bin/hw/android.hardware.galaxy_one@1.0-service<br>    class hal<br>    user system<br>    group system<br></code></pre></td></tr></table></figure><p>同样执行 <strong>mmm hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0</strong> 命令，完成之后就会得到如下二进制可执行文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ba">out/target/product/sailfish/vendor/bin/hw/android.hardware.galaxy_one@1.0-service<br></code></pre></td></tr></table></figure><h3 id="5-4-client端"><a href="#5-4-client端" class="headerlink" title="5.4 client端"></a>5.4 client端</h3><p>经过一系列过程之后，我们得到了三个产物<br>1、<strong><a href="mailto:&#97;&#110;&#x64;&#114;&#111;&#105;&#100;&#46;&#104;&#x61;&#x72;&#x64;&#x77;&#x61;&#x72;&#101;&#x2e;&#103;&#x61;&#108;&#x61;&#120;&#121;&#x5f;&#x6f;&#x6e;&#101;&#x40;&#49;&#46;&#x30;&#x2e;&#x73;&#x6f;">&#97;&#110;&#x64;&#114;&#111;&#105;&#100;&#46;&#104;&#x61;&#x72;&#x64;&#x77;&#x61;&#x72;&#101;&#x2e;&#103;&#x61;&#108;&#x61;&#120;&#121;&#x5f;&#x6f;&#x6e;&#101;&#x40;&#49;&#46;&#x30;&#x2e;&#x73;&#x6f;</a></strong><br>2、<strong><a href="mailto:&#x61;&#x6e;&#x64;&#x72;&#x6f;&#x69;&#100;&#46;&#104;&#x61;&#x72;&#100;&#x77;&#x61;&#x72;&#x65;&#x2e;&#103;&#x61;&#x6c;&#97;&#120;&#121;&#95;&#x6f;&#110;&#101;&#64;&#49;&#46;&#48;&#x2d;&#x69;&#109;&#x70;&#x6c;&#x2e;&#x73;&#x6f;">&#x61;&#x6e;&#x64;&#x72;&#x6f;&#x69;&#100;&#46;&#104;&#x61;&#x72;&#100;&#x77;&#x61;&#x72;&#x65;&#x2e;&#103;&#x61;&#x6c;&#97;&#120;&#121;&#95;&#x6f;&#110;&#101;&#64;&#49;&#46;&#48;&#x2d;&#x69;&#109;&#x70;&#x6c;&#x2e;&#x73;&#x6f;</a></strong><br>3、<strong><a href="mailto:&#97;&#110;&#x64;&#x72;&#x6f;&#x69;&#x64;&#46;&#104;&#x61;&#x72;&#100;&#119;&#97;&#114;&#101;&#x2e;&#103;&#x61;&#x6c;&#x61;&#x78;&#x79;&#95;&#x6f;&#x6e;&#x65;&#x40;&#49;&#x2e;&#48;&#x2d;&#115;&#101;&#114;&#118;&#x69;&#99;&#x65;">&#97;&#110;&#x64;&#x72;&#x6f;&#x69;&#x64;&#46;&#104;&#x61;&#x72;&#100;&#119;&#97;&#114;&#101;&#x2e;&#103;&#x61;&#x6c;&#x61;&#x78;&#x79;&#95;&#x6f;&#x6e;&#x65;&#x40;&#49;&#x2e;&#48;&#x2d;&#115;&#101;&#114;&#118;&#x69;&#99;&#x65;</a></strong></p><p>现在需要模拟一个客户端来测试调用，因此在 <strong>default</strong> 目录下新建 <strong>test</strong> 目录，并新建 <strong>client.cpp、Android.bp</strong> 文件，具体结构如下：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-cfccd9a1dea02880.png" style="zoom: 67%;"><p><strong>client.cpp 内容如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hardware/galaxy_one/1.0/IGalaxyOne.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/Status.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;log/log.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> android::sp;<br><span class="hljs-keyword">using</span> android::hardware::galaxy_one::V1_0::IGalaxyOne;<br><span class="hljs-keyword">using</span> android::hardware::Return;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    android::sp&lt;IGalaxyOne&gt; service = IGalaxyOne::<span class="hljs-built_in">getService</span>();<br>    <span class="hljs-keyword">if</span> (service == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;faile to get galaxy_one service......&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;success to get galaxy_one service.....&quot;</span>);<br><br>    <span class="hljs-type">uint32_t</span> addResult = service-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;galaxy_one service add: result = %d&quot;</span>,(<span class="hljs-type">int</span>)addResult);<br><br>    <span class="hljs-type">uint32_t</span> subResult = service-&gt;<span class="hljs-built_in">sub</span>(<span class="hljs-number">8</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;galaxy_one service sub: result = %d&quot;</span>,(<span class="hljs-type">int</span>)subResult);<br><br>    <span class="hljs-type">uint32_t</span> mulResult = service-&gt;<span class="hljs-built_in">mul</span>(<span class="hljs-number">3</span>,<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;galaxy_one service mul: result = %d&quot;</span>,(<span class="hljs-type">int</span>)mulResult);<br><br>    <span class="hljs-type">uint32_t</span> divResult = service-&gt;<span class="hljs-built_in">div</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;galaxy_one service div: result = %d&quot;</span>,(<span class="hljs-type">int</span>)divResult);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Android.bp 内容如下：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cc_binary &#123;<br>    name: <span class="hljs-string">&quot;galaxy_test&quot;</span>,    //表示生成的 client 名称<br>    srcs: [<br>        <span class="hljs-string">&quot;client.cpp&quot;</span><br>    ],<br>    shared_libs: [<br>        <span class="hljs-string">&quot;liblog&quot;</span>,<br>        <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0&quot;</span>,<br>        <span class="hljs-string">&quot;libhidlbase&quot;</span>,<br>        <span class="hljs-string">&quot;libhidltransport&quot;</span>,<br>        <span class="hljs-string">&quot;libhwbinder&quot;</span>,<br>        <span class="hljs-string">&quot;libutils&quot;</span>,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>mmm hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0</strong> 命令编译之后，可以在 <strong>out&#x2F;target&#x2F;product&#x2F;XXX&#x2F;system&#x2F;bin</strong> 目录下找到 <strong>galaxy_test</strong> 。</p><h3 id="5-5-声明使得Framework可以识别"><a href="#5-5-声明使得Framework可以识别" class="headerlink" title="5.5 声明使得Framework可以识别"></a>5.5 声明使得Framework可以识别</h3><p><strong>HIDL</strong> 想要被 <strong>framework</strong> 获取使用还需要在 <strong>manifest.xml</strong> 中注册，此文件位于 <code>device/[companyName]/[productName]/manifest.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">hal</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;hidl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>android.hardware.galaxy_one<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transport</span>&gt;</span>hwbinder<span class="hljs-tag">&lt;/<span class="hljs-name">transport</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">interface</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>IGalaxyOne<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">instance</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">instance</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">interface</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fqname</span>&gt;</span>@1.0::IGalaxyOne/default<span class="hljs-tag">&lt;/<span class="hljs-name">fqname</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">hal</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-6-添加sepolicy策略"><a href="#5-6-添加sepolicy策略" class="headerlink" title="5.6 添加sepolicy策略"></a>5.6 添加sepolicy策略</h3><p>本文暂时关闭selinux</p><h2 id="6-验证服务"><a href="#6-验证服务" class="headerlink" title="6.验证服务"></a>6.验证服务</h2><h3 id="6-1-push设备"><a href="#6-1-push设备" class="headerlink" title="6.1 push设备"></a>6.1 push设备</h3><p>现在我们一共得到 4 个产物，使用 <strong>adb</strong> 命令将其 <strong>push</strong> 到手机对应目录下：</p><p>1、<a href="mailto:&#97;&#110;&#x64;&#114;&#111;&#105;&#100;&#x2e;&#104;&#97;&#114;&#x64;&#x77;&#x61;&#x72;&#101;&#x2e;&#x67;&#97;&#x6c;&#97;&#120;&#x79;&#x5f;&#x6f;&#x6e;&#101;&#x40;&#x31;&#46;&#x30;&#45;&#x69;&#109;&#x70;&#108;&#46;&#x73;&#111;">&#97;&#110;&#x64;&#114;&#111;&#105;&#100;&#x2e;&#104;&#97;&#114;&#x64;&#x77;&#x61;&#x72;&#101;&#x2e;&#x67;&#97;&#x6c;&#97;&#120;&#x79;&#x5f;&#x6f;&#x6e;&#101;&#x40;&#x31;&#46;&#x30;&#45;&#x69;&#109;&#x70;&#108;&#46;&#x73;&#111;</a> &#x3D;&#x3D;&#x3D;&gt; &#x2F;vendor&#x2F;lib64&#x2F;hw<br>2、<a href="mailto:&#x61;&#x6e;&#x64;&#114;&#x6f;&#105;&#x64;&#x2e;&#104;&#97;&#114;&#100;&#119;&#x61;&#x72;&#101;&#46;&#103;&#x61;&#108;&#97;&#x78;&#121;&#95;&#x6f;&#110;&#x65;&#64;&#49;&#x2e;&#x30;&#x2e;&#115;&#x6f;">&#x61;&#x6e;&#x64;&#114;&#x6f;&#105;&#x64;&#x2e;&#104;&#97;&#114;&#100;&#119;&#x61;&#x72;&#101;&#46;&#103;&#x61;&#108;&#97;&#x78;&#121;&#95;&#x6f;&#110;&#x65;&#64;&#49;&#x2e;&#x30;&#x2e;&#115;&#x6f;</a> &#x3D;&#x3D;&#x3D;&gt; vendor&#x2F;lib64<br>3、<a href="mailto:&#x61;&#x6e;&#x64;&#114;&#x6f;&#105;&#100;&#46;&#104;&#97;&#x72;&#100;&#x77;&#97;&#x72;&#101;&#46;&#x67;&#97;&#x6c;&#x61;&#x78;&#x79;&#95;&#111;&#x6e;&#x65;&#64;&#x31;&#x2e;&#48;&#x2d;&#x73;&#101;&#x72;&#118;&#105;&#x63;&#101;">&#x61;&#x6e;&#x64;&#114;&#x6f;&#105;&#100;&#46;&#104;&#97;&#x72;&#100;&#x77;&#97;&#x72;&#101;&#46;&#x67;&#97;&#x6c;&#x61;&#x78;&#x79;&#95;&#111;&#x6e;&#x65;&#64;&#x31;&#x2e;&#48;&#x2d;&#x73;&#101;&#x72;&#118;&#105;&#x63;&#101;</a> &#x3D;&#x3D;&#x3D;&gt; &#x2F;vendor&#x2F;bin&#x2F;hw<br>4、galaxy_test &#x3D;&#x3D;&#x3D;&gt; &#x2F;system&#x2F;bin</p><h3 id="6-2-运行service"><a href="#6-2-运行service" class="headerlink" title="6.2 运行service"></a>6.2 运行service</h3><p>这里我们手动启动，用于测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./vendor/bin/hw/android.hardware.galaxy_one@1.0-service<br></code></pre></td></tr></table></figure><h3 id="6-3-运行client"><a href="#6-3-运行client" class="headerlink" title="6.3 运行client"></a>6.3 运行client</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./system/bin/galaxy_test<br></code></pre></td></tr></table></figure><p>运行成功之后可查看日志，有如下内容则表示服务建立成功：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-a17a33c648493e73.png" style="zoom: 75%;">]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件系统mount过程</title>
    <link href="/2023/03/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fmount%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/03/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fmount%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统mount过程"><a href="#文件系统mount过程" class="headerlink" title="文件系统mount过程"></a>文件系统mount过程</h1><blockquote><p>🍒 <strong>环境</strong>：内核版本4.5</p><p>🍉 <strong>说明</strong>：参考<a href="https://blog.csdn.net/zr_lang/article/details/39963253%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2%EF%BC%8C%E6%94%B6%E8%8E%B7%E9%A2%87%E4%B8%B0">https://blog.csdn.net/zr_lang/article/details/39963253，非常感谢，收获颇丰</a></p></blockquote><p>从用户下发mount指令到具体的文件系统进行挂载，大致经历了下面的步骤【以<code>f2fs</code>文件系统为例】。</p><img src="/2023/03/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fmount%E8%BF%87%E7%A8%8B/image-20230309225903725.png" alt="image-20230309225903725" style="zoom: 67%;"><h2 id="1-每个人该有的样子file-system-type"><a href="#1-每个人该有的样子file-system-type" class="headerlink" title="1.每个人该有的样子file_system_type"></a>1.每个人该有的样子file_system_type</h2><p>每个人在冲浪的都有自己的昵称，自己的个性标签，这仿佛是每个人共同的样子，不妨将所有的文件系统也抽象成同一个样子表示<code>file_system_type</code>，每一个文件系统肯定有</p><ul><li>name: 文件系统的名字，如xfs, ext2等</li><li>fs_flags: 说明文件系统的类型</li><li>mount: 代替早期的get_sb()，用户挂载此文件系统时使用的回调函数。</li><li>kill_sb: 删除内存中的super block，在卸载文件系统时使用。</li><li>owner: 指向实现这个文件系统的模块，通常为THIS_MODULE宏。</li><li>next: 指向文件系统类型链表的下一个文件系统类型。</li><li>fs_supers: 具有同样此文件系统类型的超级块结构，都串连在这个表头下。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include\linux\fs.h</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> &#123;</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>        <span class="hljs-type">int</span> fs_flags;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_REQUIRES_DEV         1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_BINARY_MOUNTDATA     2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_HAS_SUBTYPE          4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_USERNS_MOUNT         8       <span class="hljs-comment">/* Can be mounted by userns root */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_USERNS_DEV_MOUNT     16 <span class="hljs-comment">/* A userns mount does not imply MNT_NODEV */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_RENAME_DOES_D_MOVE   32768   <span class="hljs-comment">/* FS will handle d_move() during rename() internally. */</span></span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *(*<span class="hljs-title">mount</span>) (<span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> *, <span class="hljs-title">int</span>, <span class="hljs-title">const</span> <span class="hljs-title">char</span> *, <span class="hljs-title">void</span> *);</span><br>        <span class="hljs-type">void</span> (*kill_sb) (<span class="hljs-keyword">struct</span> super_block *);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> * <span class="hljs-title">next</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span> <span class="hljs-title">fs_supers</span>;</span><br>       <span class="hljs-comment">// ....</span><br>        <span class="hljs-comment">//为了说明方便，此处省略若干锁相关变量。</span><br>        <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在kernel的<code>/fs</code>有各种各样的文件系统，file_system_type结构一般被定义在super.c。下面以<strong>f2fs</strong>文件系统为例介绍一下他的<code>file_system_type</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs\f2fs\super.c</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> <span class="hljs-title">f2fs_fs_type</span> =</span> &#123;<br>.owner= THIS_MODULE,<br>.name= <span class="hljs-string">&quot;f2fs&quot;</span>,<br>.mount= f2fs_mount,<br>.kill_sb= kill_f2fs_super,<br>.fs_flags= FS_REQUIRES_DEV,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>owner说明f2fs模块本身拥有这个file_system_type。</p></li><li><p>name是f2fs。</p></li><li><p>fs_flags是FS_REQUIRES_DEV，表明f2fs一定要被使用在物理设备上。</p></li><li><p>mount是f2fs_mount，说明 f2fs_mount这个函数实现了f2fs的具体mount操作。在第3节阐述</p></li></ul><h2 id="2-注册账号register-filesystem"><a href="#2-注册账号register-filesystem" class="headerlink" title="2.注册账号register_filesystem"></a>2.注册账号register_filesystem</h2><p>当然，你自己想象好了自己的昵称，自己的个性表型，自己的能力，还有自己的一份简历【superblock】，不注册账号怎么冲浪嘛🏄</p><p>同理当初始化好了一个具体的文件系统，我们也要向内核进行注册<code>register_filesystem</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">register_filesystem</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file_system_type * fs)</span><br>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> ** <span class="hljs-title">p</span>;</span><br> <br>        BUG_ON(<span class="hljs-built_in">strchr</span>(fs-&gt;name, <span class="hljs-string">&#x27;.&#x27;</span>));<br>        <span class="hljs-keyword">if</span> (fs-&gt;next)<br>                <span class="hljs-keyword">return</span> -EBUSY;<br>        write_lock(&amp;file_systems_lock);<br>       <br>        <span class="hljs-comment">// 遍历全局file_systems链表，尝试查找本次要注册文件系统名。</span><br>        p = find_filesystem(fs-&gt;name, <span class="hljs-built_in">strlen</span>(fs-&gt;name));<br>        <span class="hljs-keyword">if</span> (*p) <span class="hljs-comment">// 如果不为NULL，则说明找到了重名的文件系统。注册失败。</span><br>                res = -EBUSY;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果返回NULL，说明已经到链表结尾，可以注册此文件系统。</span><br>                *p = fs; <span class="hljs-comment">// 将此文件系统链接到链表结尾。</span><br>        write_unlock(&amp;file_systems_lock);<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>file_system_type的基本操作都在fs&#x2F;filesystems.c文件里，文件不长，可以简短的浏览一下都有那些操作函数。最主要的变量莫过于此文件内的全局变量：</p><p>&#x2F;&#x2F; 此变量是文件系统类型单链表的头指针<code>static struct file_system_type *file_systems</code></p></blockquote><p>那么f2fs在哪里注册的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">init_f2fs_fs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    err = register_filesystem(&amp;f2fs_fs_type);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-开始属于f2fs的mount"><a href="#3-开始属于f2fs的mount" class="headerlink" title="3.开始属于f2fs的mount"></a>3.开始属于f2fs的mount</h2><p>在文章的开头我们可以看到，如果在用户空间执行<code>mount -t f2fs /dev/xxx /mntdir/xxx</code>，那么最终会去调用f2fs的mount函数，在第1节的f2fs_fs_type指明了f2fs文件系统的mount函数为<code>f2fs_mount</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dentry *<span class="hljs-title function_">f2fs_mount</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file_system_type *fs_type, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *dev_name, <span class="hljs-type">void</span> *data)</span><br>&#123;<br><span class="hljs-keyword">return</span> mount_bdev(fs_type, flags, dev_name, data, f2fs_fill_super);<br>&#125;<br></code></pre></td></tr></table></figure><p>看起来就是一个mount_bdev()函数，但是看参数可以看到一些重要的东西</p><ul><li>fs_type不用多说，携带file_system_type的信息，这里传递它主要是因为它携带了super block的链表和很多锁变量。</li><li>flags文件系统的通用挂载选项。</li><li>dev_name是mount操作时的设备名，如&#x2F;dev&#x2F;sda1。后面会用到这个设备名找到对应的设备信息，从而从中获得super block。</li><li>data是挂载时指定的挂载选项信息。</li><li>f2fs_fill_super是一个由f2fs特定实现的fill_super方法，用来根据f2fs文件系统的特性解析mount data并继续填充super block的字段，并且初始化挂载点的根索引节点对象和目录项对象。</li></ul><h2 id="4-挂载选项flag和data"><a href="#4-挂载选项flag和data" class="headerlink" title="4.挂载选项flag和data"></a>4.挂载选项flag和data</h2><p>在第3节中我们可以看到f2fs挂载的时候有flags和data，但是我们平常挂载的只有一个<code>- o</code>参数啊，例如<code>mount -t f2fs -o ro /dev/xxx /mntdir/xxx</code>。那么我们如何区分具体的flag和data呢？</p><p>先来看一下flags都有哪些可选值(取自<code>include/uapi/linux/fs.h</code>)，我们来尽量把它们和mount命令里的选项对应一下(man 2 mount)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * These are the fs-independent mount-flags: up to 32 flags are supported</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RDONLY        1         <span class="hljs-comment">/* 对应-o ro/rw */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSUID        2         <span class="hljs-comment">/* 对应-o suid/nosuid */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODEV         4         <span class="hljs-comment">/*  对应-o suid/nosuid */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOEXEC        8         <span class="hljs-comment">/* 对应-o exec/noexec */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SYNCHRONOUS  16         <span class="hljs-comment">/* 对应-o sync/async */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REMOUNT      32         <span class="hljs-comment">/* 对应-o remount，告诉mount这是一次remount操作 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MANDLOCK     64         <span class="hljs-comment">/* 对应-o mand/nomand */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_DIRSYNC      128        <span class="hljs-comment">/* 对应-o dirsync */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOATIME      1024       <span class="hljs-comment">/* 对应-o atime/noatime */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODIRATIME   2048       <span class="hljs-comment">/* 对应-o diratime/nodiratime */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BIND         4096       <span class="hljs-comment">/* 对应-B/--bind选项，告诉mount这是一次bind操作 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MOVE         8192       <span class="hljs-comment">/* 对应-M/--move，告诉mount这是一次move操作 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REC          16384      <span class="hljs-comment">/* rec是recursive的意思，这个flag一般不单独出现，都是伴随这其它flag，表示递归的进行操作 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_VERBOSE      32768      <span class="hljs-comment">/* 对应-v/--verbose */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SILENT       32768      <span class="hljs-comment">/* 对应-o silent/loud */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_POSIXACL     (1&lt;&lt;16)    <span class="hljs-comment">/* 让VFS不应用umask，如NFS */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_UNBINDABLE   (1&lt;&lt;17)    <span class="hljs-comment">/* 对应--make-unbindable */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_PRIVATE      (1&lt;&lt;18)    <span class="hljs-comment">/* 对应--make-private */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SLAVE        (1&lt;&lt;19)    <span class="hljs-comment">/* 对应--make-slave */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SHARED       (1&lt;&lt;20)    <span class="hljs-comment">/* 对应--make-shared */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RELATIME     (1&lt;&lt;21)    <span class="hljs-comment">/* 对应-o relatime/norelatime */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_KERNMOUNT    (1&lt;&lt;22)    <span class="hljs-comment">/* 这个一般不在应用层使用，一般内核挂载的文件系统如sysfs使用，表示使用kern_mount()进行挂载 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_I_VERSION    (1&lt;&lt;23)    <span class="hljs-comment">/* 对应-o iversion/noiversion */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_STRICTATIME  (1&lt;&lt;24)    <span class="hljs-comment">/* 对应-o strictatime/nostrictatime */</span></span><br> <br><span class="hljs-comment">/* 下面这几个flags都是内核内部使用的，它们的含义我只是通过简单的查看代码逻辑暂时猜测的 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSEC        (1&lt;&lt;28)    <span class="hljs-comment">/* 有些文件系统不支持suid，security xattr等安全标记 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BORN         (1&lt;&lt;29)    <span class="hljs-comment">/* 表示内存superblock已经创建完成 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_ACTIVE       (1&lt;&lt;30)    <span class="hljs-comment">/* 表示内存superblock正处于活动状态 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOUSER       (1&lt;&lt;31)    <span class="hljs-comment">/* 表示文件系统不能被应用层挂载使用，只能被内核使用，如rootfs */</span></span><br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Superblock flags that can be altered by MS_REMOUNT</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RMT_MASK     (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION)  <span class="hljs-comment">// 可以在remount是改变的flags</span></span><br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Old magic mount flag and mask</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_VAL 0xC0ED0000      <span class="hljs-comment">/* 过去使用的magic，现在基本被忽略了 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_MSK 0xffff0000      <span class="hljs-comment">/* 过去使用的flag的的mask */</span></span><br></code></pre></td></tr></table></figure><p>从上面可以看出，flags基本上是options中通用的那些，也就是说基本是<strong>面向所有文件系统通用的</strong>，当然还有一些是内核使用的。这些flags大部分都在VFS层被解析使用。</p><p>而data呢，把options中通用的去掉，<strong>剩下的就是每个文件系统各自支持的挂载选项</strong>。</p><p>🎈让我们来看个例子：我们选取一个与flags对应的option，如nodev。在从xfs【也是一种文件系统】中选取一个特定的option，如noquota。然后用strace跟踪一下mount的过程，执行</p><p><code>strace mount /dev/loop0 /mnt/test -o noquota,nodev</code></p><p>在接近最后的位置我们可以看到mount系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mount(<span class="hljs-string">&quot;/dev/loop0&quot;</span>, <span class="hljs-string">&quot;/mnt/test&quot;</span>, <span class="hljs-string">&quot;xfs&quot;</span>, MS_MGC_VAL|MS_NODEV, <span class="hljs-string">&quot;noquota&quot;</span>) = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>果然，nodev被解释为flag，noquota被当作了mount data。</p><h2 id="5-mount系统调用的实现（sys-mount）"><a href="#5-mount系统调用的实现（sys-mount）" class="headerlink" title="5.mount系统调用的实现（sys_mount）"></a>5.mount系统调用的实现（sys_mount）</h2><p>如果要研究mount的执行过程先要找到mount的发起位置，有些mount是内核发起的，由内核自主挂载。而绝大部分的mount都是用户通过mount系统调用发起的，我们就以后者为起点开始分析。<strong>mount系统调用</strong>（sys_mount）定义在fs&#x2F;namespace.c中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs\namespace.c</span><br><br>SYSCALL_DEFINE5(mount, <span class="hljs-type">char</span> __user *, dev_name, <span class="hljs-type">char</span> __user *, dir_name,<br>                <span class="hljs-type">char</span> __user *, type, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, flags, <span class="hljs-type">void</span> __user *, data)<br>&#123;<br>        <span class="hljs-type">int</span> ret;<br>        <span class="hljs-type">char</span> *kernel_type;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filename</span> *<span class="hljs-title">kernel_dir</span>;</span><br>        <span class="hljs-type">char</span> *kernel_dev;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data_page;<br> <br>        <span class="hljs-comment">/* 拷贝得到文件系统类型名 */</span><br>        ret = copy_mount_string(type, &amp;kernel_type);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">goto</span> out_type;<br> <br>        <span class="hljs-comment">/* 得到文件系统挂载点名 */</span><br>        kernel_dir = getname(dir_name);<br>        <span class="hljs-keyword">if</span> (IS_ERR(kernel_dir)) &#123;<br>                ret = PTR_ERR(kernel_dir);<br>                <span class="hljs-keyword">goto</span> out_dir;<br>        &#125;<br> <br>        <span class="hljs-comment">/* 拷贝得到文件系统所在的设备名 */</span><br>        ret = copy_mount_string(dev_name, &amp;kernel_dev);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">goto</span> out_dev;<br> <br>        <span class="hljs-comment">/* 拷贝得到文件系统定制的mount data */</span><br>        ret = copy_mount_options(data, &amp;data_page);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">goto</span> out_data;<br> <br>        <span class="hljs-comment">/* 到此mount所需要的fstype, dev_name, mountpoint, flags和data这几个参数都拷贝到内核空间了 */</span><br>        <span class="hljs-comment">/* 调用do_mount函数继续下面的操作 */</span><br>        ret = do_mount(kernel_dev, kernel_dir-&gt;name, kernel_type, flags,<br>                (<span class="hljs-type">void</span> *) data_page);<br> <br>        free_page(data_page);<br>out_data:<br>        kfree(kernel_dev);<br>out_dev:<br>        putname(kernel_dir);<br>out_dir:<br>        kfree(kernel_type);<br>out_type:<br>        <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-do-mount调用"><a href="#6-do-mount调用" class="headerlink" title="6.do_mount调用"></a>6.do_mount调用</h2><p>系统调用sys_mount后，会继续执行do_mount函数，该函数在VFS层。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">do_mount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *dev_name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dir_name,</span><br><span class="hljs-params">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type_page, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-type">void</span> *data_page)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">path</span> <span class="hljs-title">path</span>;</span><br>        <span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> mnt_flags = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">/* Discard magic */</span><br>        <span class="hljs-keyword">if</span> ((flags &amp; MS_MGC_MSK) == MS_MGC_VAL)<br>                flags &amp;= ~MS_MGC_MSK;<br>        <span class="hljs-comment">/* Basic sanity checks */</span><br>        <span class="hljs-keyword">if</span> (!dir_name || !*dir_name || !<span class="hljs-built_in">memchr</span>(dir_name, <span class="hljs-number">0</span>, PAGE_SIZE))<br>                <span class="hljs-keyword">return</span> -EINVAL;<br>        <span class="hljs-keyword">if</span> (data_page)<br>                ((<span class="hljs-type">char</span> *)data_page)[PAGE_SIZE - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 把mountpoint解释成path内核结构，这里是路径名解析的过程</span><br>        <span class="hljs-comment">// 调用do_path_lookup。关于路径名解析我们后面再说</span><br>        <span class="hljs-comment">/* ... and get the mountpoint */</span><br>        retval = kern_path(dir_name, LOOKUP_FOLLOW, &amp;path);<br>        <span class="hljs-keyword">if</span> (retval)<br>                <span class="hljs-keyword">return</span> retval;<br>        retval = security_sb_mount(dev_name, &amp;path,<br>                                   type_page, flags, data_page);<br>        <span class="hljs-keyword">if</span> (!retval &amp;&amp; !may_mount())<br>                retval = -EPERM;<br>        <span class="hljs-keyword">if</span> (retval)<br>                <span class="hljs-keyword">goto</span> dput_out;<br>        <span class="hljs-comment">// 从这里开始就是一系列的对flags的解析，把通用option提出来</span><br>        <span class="hljs-comment">// 并且找出我们要mount做哪种操作，如bind, remount, newmount等</span><br>        <span class="hljs-comment">/* Default to relatime unless overriden */</span><br>        <span class="hljs-keyword">if</span> (!(flags &amp; MS_NOATIME))<br>                mnt_flags |= MNT_RELATIME;<br>        <span class="hljs-comment">/* Separate the per-mountpoint flags */</span><br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NOSUID)<br>                mnt_flags |= MNT_NOSUID;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NODEV)<br>                mnt_flags |= MNT_NODEV;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NOEXEC)<br>                mnt_flags |= MNT_NOEXEC;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NOATIME)<br>                mnt_flags |= MNT_NOATIME;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NODIRATIME)<br>                mnt_flags |= MNT_NODIRATIME;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_STRICTATIME)<br>                mnt_flags &amp;= ~(MNT_RELATIME | MNT_NOATIME);<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_RDONLY)<br>                mnt_flags |= MNT_READONLY;<br>        <span class="hljs-comment">/* The default atime for remount is preservation */</span><br>        <span class="hljs-keyword">if</span> ((flags &amp; MS_REMOUNT) &amp;&amp;<br>            ((flags &amp; (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |<br>                       MS_STRICTATIME)) == <span class="hljs-number">0</span>)) &#123;<br>                mnt_flags &amp;= ~MNT_ATIME_MASK;<br>                mnt_flags |= path.mnt-&gt;mnt_flags &amp; MNT_ATIME_MASK;<br>        &#125;<br>        flags &amp;= ~(MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_ACTIVE | MS_BORN |<br>                   MS_NOATIME | MS_NODIRATIME | MS_RELATIME| MS_KERNMOUNT |<br>                   MS_STRICTATIME);<br>        <span class="hljs-comment">// 根据flags的指示，决定做哪种mount操作</span><br>        <span class="hljs-keyword">if</span> (flags &amp; MS_REMOUNT)<br>                retval = do_remount(&amp;path, flags &amp; ~MS_REMOUNT, mnt_flags,<br>                                    data_page);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flags &amp; MS_BIND)<br>                retval = do_loopback(&amp;path, dev_name, flags &amp; MS_REC);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flags &amp; (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))<br>                retval = do_change_type(&amp;path, flags);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flags &amp; MS_MOVE)<br>                retval = do_move_mount(&amp;path, dev_name);<br>        <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 我们这里以new mount为入手点，继续向下分析</span><br>                retval = do_new_mount(&amp;path, type_page, flags, mnt_flags,<br>                                      dev_name, data_page);<br>dput_out:<br>        path_put(&amp;path);<br>        <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上所述，我们得出do_mount主要干这么几个事：</p><ol><li><p>解析mountpoint路径名，把字符串路径名变成内核dentry或者说path结构</p></li><li><p>解析flags，把通用option分出来。</p></li><li><p>根据flags中指明mount操作的标志，决定做哪一种mount操作。</p></li><li><p>执行remount&#x2F;bind&#x2F;shared&#x2F;move&#x2F;new mount操作。</p></li></ol><p>到此mount就可能做5种mount操作（remount, bind, chang type, move和new mount）之一。我们以do_new_mount为例继续分析，do_new_mount属于最常见的情况，挂载一个新的文件系统。</p><h2 id="7-do-new-mount调用"><a href="#7-do-new-mount调用" class="headerlink" title="7.do_new_mount调用"></a>7.do_new_mount调用</h2><p>do_new_mount函数也在namespace.c里可以找到，它主要做三件事：</p><ol><li>根据fstype从全局文件系统类型(file_system_type)链表中找到对应的文件系统类型结构</li><li>用上一步得到的特定文件系统类型结构中的mount回调函数执行下面的挂载操作，最终构建一个mount结构体，其中包含vfsmount信息。</li><li>将得到的mount结构体加入全局文件系统树中</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_new_mount</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> path *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fstype, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">                        <span class="hljs-type">int</span> mnt_flags, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> *<span class="hljs-title">type</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span> *<span class="hljs-title">user_ns</span> =</span> current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vfsmount</span> *<span class="hljs-title">mnt</span>;</span><br>        <span class="hljs-type">int</span> err;<br> <br>        <span class="hljs-keyword">if</span> (!fstype)<br>                <span class="hljs-keyword">return</span> -EINVAL;<br> <br>        <span class="hljs-comment">// 根据fs类型名（如xfs）在全局文件系统类型链表上找到其对应的file_system_type结构</span><br>        type = get_fs_type(fstype);<br>        <span class="hljs-keyword">if</span> (!type)<br>                <span class="hljs-keyword">return</span> -ENODEV;<br> <br>        <span class="hljs-comment">// 调用此函数准备进入每个文件系统的个别处理函数，构建一个vfsmnt结构</span><br>        <span class="hljs-comment">// 注意这里以文件系统类型、挂载标记、设备名和挂载选项信息为参数，并没有mountpoint参数。这里只是想用type中的mount回调函数读取设备的superblock信息，填充mnt结构，然后把flag和data解析后填充到mnt结构中。</span><br>        mnt = vfs_kern_mount(type, flags, name, data);<br>        <span class="hljs-keyword">if</span> (!IS_ERR(mnt) &amp;&amp; (type-&gt;fs_flags &amp; FS_HAS_SUBTYPE) &amp;&amp;<br>            !mnt-&gt;mnt_sb-&gt;s_subtype)<br>                mnt = fs_set_subtype(mnt, fstype);<br> <br>        put_filesystem(type);<br>        <span class="hljs-keyword">if</span> (IS_ERR(mnt))<br>                <span class="hljs-keyword">return</span> PTR_ERR(mnt);<br> <br>        <span class="hljs-comment">// 准备将得到的mnt结构加入全局文件系统树</span><br>        <span class="hljs-comment">// 注意path变量，也就是mountpoint在这里</span><br>        err = do_add_mount(real_mount(mnt), path, mnt_flags);<br>        <span class="hljs-keyword">if</span> (err)<br>                mntput(mnt);<br>        <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="99-向驱动大哥学习，走进file-operations"><a href="#99-向驱动大哥学习，走进file-operations" class="headerlink" title="99.向驱动大哥学习，走进file_operations"></a>99.向驱动大哥学习，走进file_operations</h2><p>我们按照学习驱动的方式，学习整个文件系统的挂载。在学习驱动的时候，最关键的就是字符设备操作集<code>file_operations </code>，我们写驱动的时候会初始化每一个驱动对应的操作集，例如我们编写一个led驱动，我们常常写成下面的样子，每一个file_operation的操作，如open、write都在自己的驱动中指明对应的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">led_fops</span> =</span> &#123;<br>    .owner = THIS_MODULE,<br>    .open = led_open,<br>    .write = led_write,<br>    .release = led_release,<br>&#125;;<br></code></pre></td></tr></table></figure><p>那么文件系统也是通用的道理，也有文件系统自己的操作集<code>file_operations</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include\linux\fs.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-type">loff_t</span> (*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<br><span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br><span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br><span class="hljs-type">ssize_t</span> (*read_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br><span class="hljs-type">ssize_t</span> (*write_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br><span class="hljs-type">int</span> (*iterate) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);<br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *)</span>;<br><span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br><span class="hljs-type">int</span> (*mremap)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br><span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br><span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);<br><span class="hljs-type">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br><span class="hljs-type">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span> datasync);<br><span class="hljs-type">int</span> (*aio_fsync) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-type">int</span> datasync);<br><span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);<br><span class="hljs-type">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br><span class="hljs-type">ssize_t</span> (*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">int</span>);<br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<br><span class="hljs-type">int</span> (*check_flags)(<span class="hljs-type">int</span>);<br><span class="hljs-type">int</span> (*flock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br><span class="hljs-type">ssize_t</span> (*splice_write)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><span class="hljs-type">ssize_t</span> (*splice_read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><span class="hljs-type">int</span> (*setlease)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">long</span>, <span class="hljs-keyword">struct</span> file_lock **, <span class="hljs-type">void</span> **);<br><span class="hljs-type">long</span> (*fallocate)(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> mode, <span class="hljs-type">loff_t</span> offset,<br>  <span class="hljs-type">loff_t</span> len);<br><span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">struct</span> file *f);<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><br><span class="hljs-type">unsigned</span> (*mmap_capabilities)(<span class="hljs-keyword">struct</span> file *);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>对于一个具体的文件系统ext4、f2fs等，都会指明自己的file_operations，以f2fs为例</p><img src="/2023/03/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fmount%E8%BF%87%E7%A8%8B/image-20230309230859994.png" alt="image-20230309230859994" style="zoom: 67%;"><p>加入我们在用户态执行ioctl操作，那么对应的<code>f2fs_ioct</code>l就会执行。</p>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>懂得了Android I/O调优对你的应用帮助很大（上篇）</title>
    <link href="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/"/>
    <url>/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="懂得了Android-I-x2F-O调优对你的应用帮助很大（上篇）"><a href="#懂得了Android-I-x2F-O调优对你的应用帮助很大（上篇）" class="headerlink" title="懂得了Android I&#x2F;O调优对你的应用帮助很大（上篇）"></a>懂得了Android I&#x2F;O调优对你的应用帮助很大（上篇）</h1><blockquote><p>🍀转载自：<a href="https://www.cnblogs.com/mysweetAngleBaby/articles/16066846.html">https://www.cnblogs.com/mysweetAngleBaby/articles/16066846.html</a></p></blockquote><h2 id="1-I-x2F-O的基本知识"><a href="#1-I-x2F-O的基本知识" class="headerlink" title="1.I&#x2F;O的基本知识"></a>1.I&#x2F;O的基本知识</h2><p>在工作中，我发现很多工程师对I&#x2F;O的认识其实比较模糊，认为I&#x2F;O就是应用程序执行read()、write()这样的一些操作，并不清楚这些操作背后的整个流程是怎样的。</p><img src="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/26731569-b807a907e68b8792.png" style="zoom: 67%;"><p>我画了一张简图，你可以看到整个文件I&#x2F;O操作由应用程序、文件系统和磁盘共同完成。首先应用程序将I&#x2F;O命令发送给文件系统，然后文件系统会在合适的时机把I&#x2F;O操作发给磁盘。<br>这就好比CPU、内存、磁盘三个小伙伴一起完成接力跑，最终跑完的时间很大程度上取决于最慢的小伙伴。我们知道，CPU和内存相比磁盘是高速设备，整个流程的瓶颈在于磁盘I&#x2F;O的性能。所以很多时候，文件系统性能比磁盘性能更加重要，为了降低磁盘对应用程序的影响，文件系统需要通过各种各样的手段进行优化。那么接下来，我们首先来看文件系统。</p><h3 id="1-1-文件系统"><a href="#1-1-文件系统" class="headerlink" title="1.1 文件系统"></a>1.1 文件系统</h3><p>文件系统，简单来说就是存储和组织数据的方式。比如在iOS 10.3系统以后，苹果使用APFS（Apple File System）替代之前旧的文件系统HFS+。对于Android来说，现在普遍使用的是Linux常用的ext4文件系统。</p><p>关于文件系统还需要多说两句，华为在EMUI 5.0以后就使用F2FS取代ext4，Google也在最新的旗舰手机Pixel 3使用了F2FS文件系统。Flash-Friendly File System是三星是专门为NAND闪存芯片开发的文件系统，也做了大量针对闪存的优化。根据华为的测试数据，F2FS文件系统在小文件的随机读写方面比ext4更快，例如随机写可以优化60%，不足之处在于可靠性方面出现过一些问题。我想说的是，随着Google、华为的投入和规模化使用，F2FS系统应该是未来Android的主流文件系统。</p><p>还是回到文件系统的I&#x2F;O。应用程序调用read()方法，系统会通过中断从用户空间进入内核处理流程，然后经过VFS（Virtual File System，虚拟文件系统）、具体文件系统、页缓存Page Cache。下面是Linux一个通用的I&#x2F;O架构模型。</p><img src="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/26731569-a7586fb52f51be3a.png" style="zoom: 67%;"><ul><li>虚拟文件系统（VFS）。它主要用于实现屏蔽具体的文件系统，为应用程序的操作提供一个统一的接口。这样保证就算厂商把文件系统从ext4切换到F2FS，应用程序也不用做任何修改。</li><li>文件系统（File System）。ext4、F2FS都是具体文件系统实现，文件元数据如何组织、目录和索引结构如何设计、怎么分配和清理数据，这些都是设计一个文件系统必须要考虑的。<strong>每个文件系统都有适合自己的应用场景，我们不能说F2FS就一定比ext4要好。</strong>F2FS在连续读取大文件上并没有优势，而且会占用更大的空间。只是对一般应用程序来说，随机I&#x2F;O会更加频繁，特别是在启动的场景。你可以在&#x2F;proc&#x2F;filesystems看到系统可以识别的所有文件系统的列表。</li><li>页缓存（Page Cache）。在启动优化中我已经讲过Page Cache这个概念了，在读文件的时候会，先看它是不是已经在Page Cache中，如果命中就不会去读取磁盘。在Linux 2.4.10之前还有一个单独的Buffer Cache，后来它也合并到Page Cache中的Buffer Page了。</li></ul><p>具体来说，Page Cache就像是我们经常使用的数据缓存，是文件系统对数据的缓存，目的是提升内存命中率。Buffer Cache就像我们经常使用的BufferInputStream，是磁盘对数据的缓存，目的是合并部分文件系统的I&#x2F;O请求、降低磁盘I&#x2F;O的次数。需要注意的是，它们既会用在读请求中，也会用到写请求中。<br>通过&#x2F;proc&#x2F;meminfo文件可以查看缓存的内存占用情况，当手机内存不足的时候，系统会回收它们的内存，这样整体I&#x2F;O的性能就会有所降低。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">MemTotal:    2866492 kB<br>MemFree:      72192 kB<br>Buffers:      62708 kB      // Buffer Cache<br>Cached:      652904 kB      // Page Cache<br></code></pre></td></tr></table></figure><h3 id="1-2-磁盘"><a href="#1-2-磁盘" class="headerlink" title="1.2 磁盘"></a>1.2 磁盘</h3><p>磁盘指的是系统的存储设备，就像小时候我们常听的CD或者电脑使用的机械硬盘，当然还有现在比较流行的SSD固态硬盘。<br>正如我上面所说，如果发现应用程序要read()的数据没有在页缓存中，这时候就需要真正向磁盘发起I&#x2F;O请求。这个过程要先经过内核的通用块层、I&#x2F;O调度层、设备驱动层，最后才会交给具体的硬件设备处理。</p><img src="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/26731569-5a8d09f33aacf7fd.png" style="zoom: 67%;"><ul><li>通用块层。系统中能够随机访问固定大小数据块（block）的设备称为块设备，CD、硬盘和SSD这些都属于块设备。通用块层主要作用是接收上层发出的磁盘请求，并最终发出I&#x2F;O请求。它跟VFS的作用类似，让上层不需要关心底层硬件设备的具体实现。</li><li>I&#x2F;O调度层。磁盘I&#x2F;O那么慢，为了降低真正的磁盘I&#x2F;O，我们不能接收到磁盘请求就立刻交给驱动层处理。所以我们增加了I&#x2F;O调度层，它会根据设置的调度算法对请求合并和排序。这里比较关键的参数有两个，一个是队列长度，一个是具体的调度算法。我们可以通过下面的文件可以查看对应块设备的队列长度和使用的调度算法。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">/sys/block/[disk]/queue/nr_requests      // 队列长度，一般是 128。<br>/sys/block/[disk]/queue/scheduler        // 调度算法<br></code></pre></td></tr></table></figure><ul><li>块设备驱动层。块设备驱动层根据具体的物理设备，选择对应的驱动程序通过操控硬件设备完成最终的I&#x2F;O请求。例如光盘是靠激光在表面烧录存储、闪存是靠电子擦写存储数据</li></ul><h2 id="2-I-x2F-O的性能评估"><a href="#2-I-x2F-O的性能评估" class="headerlink" title="2.I&#x2F;O的性能评估"></a>2.I&#x2F;O的性能评估</h2><p>正如下图你所看到的，整个I&#x2F;O的流程涉及的链路非常长。我们在应用程序中通过打点，发现一个文件读取需要300ms。但是下面每一层可能都有自己的策略和调度算法，因此很难真正的得到每一层的耗时。</p><img src="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/26731569-ee5db940a613d188.png" style="zoom: 67%;"><p>在前面的启动优化内容中，我讲过Facebook和支付宝采用编译单独ROM的方法来评估I&#x2F;O性能。这是一个比较复杂但是有效的做法，我们可以通过定制源码，选择打开感兴趣的日志来追踪I&#x2F;O的性能。</p><ol><li>I&#x2F;O性能指标<br>I&#x2F;O性能评估中最为核心的指标是吞吐量和IOPS。今天文章开头所说的，“连续读取不超过550MB&#x2F;s，连续写入不超过520MB&#x2F;s”，就指的是I&#x2F;O吞吐量。<br>还有一个比较重要的指标是IOPS，它指的是每秒可以读写的次数。对于随机读写频繁的应用，例如大量的小文件存储，IOPS是关键的衡量指标。</li><li>I&#x2F;O测量<br>如果不采用定制源码的方式，还有哪些方法可以用来测量I&#x2F;O的性能呢？\</li></ol><p><strong>第一种方法：使用proc。</strong><br>总的来说，I&#x2F;O性能会跟很多因素有关，是读还是写、是否是连续、I&#x2F;O大小等。另外一个对I&#x2F;O性能影响比较大的因素是负载，I&#x2F;O性能会随着负载的增加而降低，我们可以通过I&#x2F;O的等待时间和次数来衡量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">proc/self/schedstat:<br>  se.statistics.iowait_count：IO 等待的次数<br>  se.statistics.iowait_sum：  IO 等待的时间<br></code></pre></td></tr></table></figure><p>如果是root的机器，我们可以开启内核的I&#x2F;O监控，将所有block读写dump到日志文件中，这样可以通过dmesg命令来查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 1 &amp;gt; /proc/sys/vm/block_dump<br>dmesg -c grep pid<br>.sample.io.test(7540): READ block 29262592 on dm-1 (256 sectors)<br>.sample.io.test(7540): READ block 29262848 on dm-1 (256 sectors)<br></code></pre></td></tr></table></figure><p><strong>第二种方法：使用strace。</strong><br>Linux提供了iostat、iotop等一些相关的命令，不过大部分Anroid设备都不支持。我们可以通过 strace来跟踪I&#x2F;O相关的系统调用次数和耗时。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">strace -ttT -f -p [pid]<br>read(53, &amp;quot;*****************&amp;quot;\.\.\., 1024) = 1024       &amp;lt;0.000447&amp;gt;<br>read(53, &amp;quot;*****************&amp;quot;\.\.\., 1024) = 1024       &amp;lt;0.000084&amp;gt;<br>read(53, &amp;quot;*****************&amp;quot;\.\.\., 1024) = 1024       &amp;lt;0.000059&amp;gt;<br></code></pre></td></tr></table></figure><p>通过上面的日志，你可以看到应用程序在读取文件操作符为53的文件，每次读取1024个字节。第一次读取花了447us，后面两次都使用了100us不到。这跟启动优化提到的“数据重排”是一个原因，文件系统每次读取以block为单位，而block的大小一般是4KB，后面两次的读取是从页缓存得到。<br>我们也可以通过strace统计一段时间内所有系统调用的耗时概况。不过strace本身也会消耗不少资源，对执行时间也会产生影响。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">strace -c -f -p [pid]<br><span class="hljs-meta prompt_">% </span><span class="language-bash">time     seconds  usecs/call     calls    errors  syscall</span><br>------ ----------- ----------- --------- --------- ————————<br> 97.56    0.041002          21      1987             read<br>  1.44    0.000605          55        11             write<br></code></pre></td></tr></table></figure><p>从上面的信息你可以看到，读占了97.56%的时间，一共调用了1987次，耗时0.04s，平均每次系统调用21us。同样的道理，我们也可以计算应用程序某个任务I&#x2F;O耗时的百分比。假设一个任务执行了10s，I&#x2F;O花了9s，那么I&#x2F;O耗时百分比就是90%。这种情况下，I&#x2F;O就是我们任务很大的瓶颈，需要去做进一步的优化。</p><p><strong>第三种方法：使用vmstat。</strong><br>vmstat的各个字段说明可以参考《vmstat监视内存使用情况》，其中Memory中的buff和cache，I&#x2F;O中的bi和bo，System中的cs，以及CPU中的sy和wa，这些字段的数值都与I&#x2F;O行为有关。</p><p>我们可以配合dd命令来配合测试，观察vmstat的输出数据变化。不过需要注意的是Android里面的dd命令似乎并不支持conv和flag参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">//清除Buffer和Cache内存缓存<br>echo 3 &amp;gt; /proc/sys/vm/drop_caches<br>//每隔1秒输出1组vmstat数据<br>vmstat 1<br>//测试写入速度，写入文件/data/data/test，buffer大小为4K，次数为1000次<br>dd if=/dev/zero of=/data/data/test bs=4k count=1000<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言字符串处理函数</title>
    <link href="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"/>
    <url>/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言字符串处理函数"><a href="#C语言字符串处理函数" class="headerlink" title="C语言字符串处理函数"></a>C语言字符串处理函数</h1><p>写代码时对字符和字符串的处理很频繁，但是C语言中本身没有字符串类型，字符串通常存储在<strong>常量字符串（const char* str）</strong>中或者<strong>字符数组（char str[] &#x3D; “amx”）</strong>中。<strong>常量字符串</strong>适用于那些对它不做修改的字符串函数。</p><p>首先，我们要确定在C语言中，字符串都是以\0结尾的，只不过我们创建的时候不用自己添加，是编译的时候由编译器添加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-keyword">if</span> (str[<span class="hljs-number">3</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;末尾是\\0\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/截屏2022-05-21 16.32.40.png"><h2 id="1-字符串的长度"><a href="#1-字符串的长度" class="headerlink" title="1.字符串的长度"></a>1.字符串的长度</h2><h3 id="1-1-strlen"><a href="#1-1-strlen" class="headerlink" title="1.1 strlen"></a>1.1 strlen</h3><p>作用：求字符串的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strlen</span>(str)); <span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-长度不受限制的字符串函数"><a href="#2-长度不受限制的字符串函数" class="headerlink" title="2.长度不受限制的字符串函数"></a>2.长度不受限制的字符串函数</h2><h3 id="2-1-strcpy"><a href="#2-1-strcpy" class="headerlink" title="2.1  strcpy"></a>2.1  strcpy</h3><p>作用：复制字符串</p><p>将<strong>源</strong>所指向的 C 字符串复制到<strong>目标</strong>所指向的数组中，包括终止空字符（并在该点停止）。</p><blockquote><p>为避免溢出，目标所指向的数组的大小应足够长，以包含与源相同的 C 字符串（包括终止空字符），并且不应在内存中与 source 重叠。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">20</span>];<br>    <br>    <span class="hljs-built_in">strcpy</span>(str2,str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str2);  <span class="hljs-comment">// amx</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-strcat"><a href="#2-2-strcat" class="headerlink" title="2.2 strcat"></a>2.2 strcat</h3><p>作用：连接字符串</p><p>将‎‎<strong>源</strong>‎‎字符串的副本追加到‎‎<strong>目标</strong>‎‎字符串。‎<em>‎</em>目标‎‎中的终止空字符被‎<em>‎</em>源<em>‎</em>‎的第一个字符覆盖，并且在‎<em>‎</em>目标<em>‎</em>‎中由两者串联形成的新字符串的末尾包含一个空字符。‎</p><blockquote><p>注：目的地‎‎和‎‎来源‎‎不得重叠。<strong>自己不能给自己追加。</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;hello &quot;</span>;<br>    <br>    <span class="hljs-built_in">strcat</span>(str2,str1);  <span class="hljs-comment">// 将str1添加到str2后面去</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str2);  <span class="hljs-comment">// hello amx</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-strcmp"><a href="#2-3-strcmp" class="headerlink" title="2.3 strcmp"></a>2.3 strcmp</h3><p>作用：比较两个字符串</p><img src="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/d04949f8-1e4a-482b-be1c-b1de518ec939.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;hello &quot;</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strcmp</span>(str1,str2));  <span class="hljs-comment">// -7</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-长度受限制的字符串函数"><a href="#3-长度受限制的字符串函数" class="headerlink" title="3.长度受限制的字符串函数"></a>3.长度受限制的字符串函数</h2><h3 id="3-1-strncpy"><a href="#3-1-strncpy" class="headerlink" title="3.1 strncpy"></a>3.1 strncpy</h3><p>作用：<strong>Copy characters from string</strong>从字符串中复制字符</p><p>将<strong>源</strong>的前<strong>num</strong>字符复制到<strong>目标</strong>。如果在复制<strong>num</strong>个字符之前找到<strong>源</strong>C 字符串（由空字符指示）的末尾，则<strong>目标</strong>将填充零，直到向其写入总共<strong>num</strong>个字符。</p><blockquote><p>如果源的长度超过 num，则不会在目标末尾隐式追加空字符。</p><p>因此，在这种情况下，<strong>目标</strong>不应被视为以空值结尾的 C 字符串（这样读取它会溢出）。</p><p>目的地和来源不得重叠（重叠时，请参阅 memmove 以了解更安全的替代方案）。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">20</span>];<br>    <br>    <span class="hljs-built_in">strncpy</span>(str2,str1,<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str2);  <span class="hljs-comment">// hello</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-strncat"><a href="#3-2-strncat" class="headerlink" title="3.2 strncat"></a>3.2 strncat</h3><p>作用：将<strong>源</strong>的前<strong>num</strong>个字符追加到<strong>目标</strong>，加上一个终止空字符。</p><blockquote><p>如果源中 C 字符串的长度小于<strong>num</strong>，则仅复制直到终止空字符的内容。</p><p>如果source拷贝进去之后desination还有原本存在的字符会主动追加一个’\0’。</p><p>如果追加长度num大于strlen(source),则只追加source原本的字符串和一个’\0’</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;HI!&quot;</span>;<br>    <br>    <span class="hljs-built_in">strncat</span>(str2,str1,<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str2);  <span class="hljs-comment">// HI!hello</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-strncmp"><a href="#3-3-strncmp" class="headerlink" title="3.3 strncmp"></a>3.3 strncmp</h3><p>作用：将 C 字符串<strong>str1</strong>的<strong>最多 num</strong>个字符与 C 字符串<strong>str2</strong>的字符数进行比较。</p><blockquote><p>此函数开始比较每个字符串的第一个字符。如果它们彼此相等，则继续向后比较，直到字符不同，直到达到终止空字符，或者直到两个字符串中的<strong>num</strong>字符匹配，以先发生的情况为准。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;hellaaaa&quot;</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strncmp</span>(str1,str2,<span class="hljs-number">4</span>));  <span class="hljs-comment">// 0</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strncmp</span>(str1,str2,<span class="hljs-number">5</span>));  <span class="hljs-comment">// 14</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-安全的字符串函数"><a href="#4-安全的字符串函数" class="headerlink" title="4.安全的字符串函数"></a>4.安全的字符串函数</h2><blockquote><p>为了减轻程序员添加结束符和处理字符串截断的负担，可以使用strlcpy和strlcat函数。</p><p>🍭文档：<a href="https://gratisoft.us/todd/papers/strlcpy.html">https://gratisoft.us/todd/papers/strlcpy.html</a></p></blockquote><h3 id="4-1-strlcpy"><a href="#4-1-strlcpy" class="headerlink" title="4.1 strlcpy"></a>4.1 strlcpy</h3><p>作用：</p><p><strong>strlcpy源代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">strlcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">size_t</span> dsize)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *osrc = src;<br>    <span class="hljs-type">size_t</span> nleft = dsize;<br>    <span class="hljs-comment">/* Copy as many bytes as will fit. */</span><br>    <span class="hljs-keyword">if</span> (nleft != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (--nleft != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((*dst++ = *src++) == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* Not enough room in dst, add NUL and traverse rest of src. */</span><br>    <span class="hljs-keyword">if</span> (nleft == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (dsize != <span class="hljs-number">0</span>)<br>            *dst = <span class="hljs-string">&#x27;\0&#x27;</span>;        <span class="hljs-comment">/* NUL-terminate dst */</span><br>        <span class="hljs-keyword">while</span> (*src++);<br>    &#125;<br>    <span class="hljs-keyword">return</span>(src - osrc - <span class="hljs-number">1</span>);    <span class="hljs-comment">/* count does not include NUL */</span><br>&#125;<br></code></pre></td></tr></table></figure><p> <code>strlcpy</code>将 <code>src</code> 按字符拷贝到 <code>dst</code>中，最多拷贝<code>dszie-1</code>个字符，拷贝结束后在 <code>dst</code> 末尾添加 <code>0x00</code>结束符，返回值是 <code>src</code>的长度。一般将 <code>dsize</code>置为<code>dst</code>的大小。相较于strncpy，<strong>strlcpy有两个优点</strong>：</p><ul><li>当<code>strlen(src)</code>大于等于<code>dsize</code>时自动在<code>dst</code>末尾添加结束符；</li><li>返回值大于等于<code>dsize</code>时确定发生字符串截断。以上两点帮助程序员进行判断，方便后续处理。</li></ul><h3 id="4-2-strlcat"><a href="#4-2-strlcat" class="headerlink" title="4.2 strlcat"></a>4.2 strlcat</h3><p>作用：</p><p><strong>strlcat源代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">strlcat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">size_t</span> dsize)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *odst = dst;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *osrc = src;<br>    <span class="hljs-type">size_t</span> n = dsize;<br>    <span class="hljs-type">size_t</span> dlen;<br>    <span class="hljs-comment">/* Find the end of dst and adjust bytes left but don&#x27;t go past end. */</span><br>    <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span> &amp;&amp; *dst != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        dst++;<br>    dlen = dst - odst;<br>    n = dsize - dlen;<br><br>    <span class="hljs-keyword">if</span> (n-- == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>(dlen + <span class="hljs-built_in">strlen</span>(src));<br>    <span class="hljs-keyword">while</span> (*src != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n != <span class="hljs-number">0</span>) &#123;<br>            *dst++ = *src;<br>            n--;<br>        &#125;<br>        src++;<br>    &#125;<br>    *dst = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span>(dlen + (src - osrc));    <span class="hljs-comment">/* count does not include NUL */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>dlen</code>是 <code>dst</code>中原有字符串的长度（不包含<code>0x00</code>结束符）；<code>dsize</code>是 <code>dst</code>缓冲区的总大小（包含结束符）。 它首先找到 <code>dst</code>中源字符串的结束符，然后计算剩余空间大小，如果为0，则返回。如果有剩余空间，就依次往其中添加<code>src</code>字符串，直至<code>dst</code>缓冲区填满，返回值是<code>dst</code>原字符串长度与<code>src</code>长度之和。相比较strncat，<strong>strlcat的优点是</strong>：</p><ul><li>第三个参数大小直接带入<code>dst</code>的大小，不需要计算剩余空间；</li><li>返回值可以用来判断是否发生字符串截断。</li></ul><h2 id="5-字符串查找"><a href="#5-字符串查找" class="headerlink" title="5.字符串查找"></a>5.字符串查找</h2><h3 id="5-1-strstr"><a href="#5-1-strstr" class="headerlink" title="5.1 strstr"></a>5.1 strstr</h3><p>作用：返回一个指向<strong>str1</strong>中第一次出现的<strong>str2</strong>的指针，如果<strong>str2</strong> 不是 <strong>str1</strong>的一部分，则返回空指针</p><blockquote><p>匹配过程不包括终止空字符，但碰到它就此停止。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] =<span class="hljs-string">&quot;This is a simple string&quot;</span>;  <br>    <span class="hljs-type">char</span>* pch;<br>    pch = <span class="hljs-built_in">strstr</span>(str,<span class="hljs-string">&quot;is&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p&quot;</span>,*pch);  <span class="hljs-comment">// 0X69</span><br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-strtok"><a href="#5-2-strtok" class="headerlink" title="5.2 strtok"></a>5.2 strtok</h3><p>作用：将字符串拆分为标记</p><p>对该函数的一系列调用将str拆分为标记，这些标记是由分隔符中的任何字符分隔的连续字符序列。</p><h2 id="6-错误信息报告"><a href="#6-错误信息报告" class="headerlink" title="6.错误信息报告"></a>6.错误信息报告</h2><h3 id="6-1-strerror"><a href="#6-1-strerror" class="headerlink" title="6.1 strerror"></a>6.1 strerror</h3><p>作用：<strong>string</strong>获取指向错误消息字符串的指针</p><p>错误码是程序员知道的，但是要转化为用户能看懂的错误信息，就需要使用函数将其转化为错误信息。</p><p>解释<strong>errnum</strong>的值，生成一个字符串，其中包含一条描述错误条件的消息，就好像被库的函数设置为<strong>errno</strong>一样。</p><blockquote><p>errno在头文件&lt;errno.h&gt;中</p><p>errno是一个全局的错误码变量</p><p>当C语言的库函数在执行过程中，发生错误，就会把对应的错误码，赋值到errno中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE * pFile;<br>    <span class="hljs-comment">//打开文件</span><br>    pFile = fopen (<span class="hljs-string">&quot;unexist.ent&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error opening file unexist.ent: %s\n&quot;</span>,strerror(errno));<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Win opening file!&quot;</span>);<br>    &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/4b271827-30e6-493f-a1b7-59db778d01d7.png"><h2 id="7-字符分类函数"><a href="#7-字符分类函数" class="headerlink" title="7.字符分类函数"></a>7.字符分类函数</h2><p>函数使用需要的头文件<code>#include &lt;ctype.h&gt;</code></p><img src="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/df04e811-541d-4e15-9bfe-3525a4827235.png"><p><strong>字符转换</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">tolower</span>(c);<span class="hljs-comment">//转小写字母</span><br><span class="hljs-built_in">toupper</span>(c);<span class="hljs-comment">//转大写字母</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;I Am A Good Student&quot;</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(str[i])&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isupper</span>(str[i]))&#123;<br>            str[i] = <span class="hljs-built_in">tolower</span>(str[i]);<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str);  <span class="hljs-comment">// i am a good student</span><br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Binder系统学习笔记</title>
    <link href="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Binder系统学习笔记"><a href="#Binder系统学习笔记" class="headerlink" title="Binder系统学习笔记"></a>Binder系统学习笔记</h1><h2 id="1-Binder系统的两大核心"><a href="#1-Binder系统的两大核心" class="headerlink" title="1.Binder系统的两大核心"></a>1.Binder系统的两大核心</h2><h3 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h3><p>A进程想要把数据传递给B进程，这就涉及到了<strong>IPC</strong>（Inter Process Communication 跨进程通信），如下图所示：</p><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230305230100824.png" alt="image-20230305230100824" style="zoom:80%;"><p>例如A进程想要通过<code>led_open</code> 或者 <code>led_ctl</code> 打开led，但是当前A进程没有权限，那么会通过RPC进程通信：</p><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230305230747468.png" alt="image-20230305230747468" style="zoom:80%;"><p>从这个图来看，从底下来看仿佛是A进程调用了一个本地的方法led_open&#x2F;led_ctl，然后把数据发给B，由B进程来操作硬件！【整个过程就是RPC】</p><blockquote><p><strong>RPC</strong>:(Reomote Procedure Call 远程过程调用) ：客户端将调用一个本地方法，而这个本地方法则是负责透明的与远程服务端进行过程间通信。这个本地方法会将相关参数顺序打包到一个消息中，然后把这个消息发送给服务端提供的方法，服务端的方法会从消息中解出序列化发出来的参数，然后执行，最后仍以同样的方式将方法的返回值发送给客户端。</p></blockquote><h3 id="1-2-binder系统中的IPC和RPC"><a href="#1-2-binder系统中的IPC和RPC" class="headerlink" title="1.2 binder系统中的IPC和RPC"></a>1.2 binder系统中的IPC和RPC</h3><p>binder系统中IPC需要具备下面三个要素：</p><ul><li><strong>源</strong>：在上面的例子中，源就是进程A</li><li><strong>目的</strong>：1）B 向 servicemanager 注册led服务；2）A 向 servicemanager 查询led服务，得到一个handle</li><li><strong>数据</strong>：就是一个char buf，用来存放通信的数据</li></ul><p><strong>实际的RPC过程中我们需要思考下面的问题</strong>：</p><ol><li>A进程需要调用B进程的什么函数</li><li>A进程需要传递什么参数给B进程</li><li>A进程会得到B进程的什么返回值</li></ol><blockquote><p>第2步A进程通过IPC将buf传输数据给B；</p><p>第3步同样B进程处理完以后通过IPC将数据返回给A</p></blockquote><h2 id="2-Binder机制分析"><a href="#2-Binder机制分析" class="headerlink" title="2 Binder机制分析"></a>2 Binder机制分析</h2><h3 id="2-1-servicemanager的作用"><a href="#2-1-servicemanager的作用" class="headerlink" title="2.1 servicemanager的作用"></a>2.1 servicemanager的作用</h3><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d12a5c80-9140-4483-bbf4-3ac05cd8a5f9.png" style="zoom: 67%;"><p>代码路径：frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">bs</span>;</span><br><br>    bs = binder_open(<span class="hljs-number">128</span>*<span class="hljs-number">1024</span>);  <span class="hljs-comment">// 打开binder驱动【bs是描述binder驱动的结构体】</span><br>    <span class="hljs-keyword">if</span> (!bs) &#123;<br>        ALOGE(<span class="hljs-string">&quot;failed to open binder driver\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 告诉binder驱动我就是servicemanager</span><br>    <span class="hljs-keyword">if</span> (binder_become_context_manager(bs)) &#123;<br>        ALOGE(<span class="hljs-string">&quot;cannot become context manager (%s)\n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    svcmgr_handle = BINDER_SERVICE_MANAGER;<br>    binder_loop(bs, svcmgr_handler);  <span class="hljs-comment">// 循环监听binder驱动，完成相应服务的函数调用</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个疑惑：svcmgr_handle是什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">svcmgr_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_transaction_data *txn,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_io *msg,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_io *reply)</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">switch</span>(txn-&gt;code) &#123;<br>    <span class="hljs-keyword">case</span> SVC_MGR_GET_SERVICE:<br>    <span class="hljs-keyword">case</span> SVC_MGR_CHECK_SERVICE:<br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">case</span> SVC_MGR_ADD_SERVICE:<br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">case</span> SVC_MGR_LIST_SERVICES: &#123;<br>       <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    bio_put_uint32(reply, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到svcmgr_handler实际上是一个函数【这个函数里面会根据传进来的txn结构体中的code来决定，到底是去注册服务还是调用服务】</p><ul><li>如果是<code>SVC_MGR_ADD_SERVICE</code>，就是注册服务</li><li>如果是<code>SVC_MGR_CHECK_SERVICE</code>，就是检查服务是否存在</li><li>如果是<code>SVC_MGR_GET_SERVICE</code>，就是获取服务</li></ul><blockquote><p>这里正好对应上了开头思维导图上的最后一项servicemanager的作用</p></blockquote><h3 id="1-3-2-server端作用"><a href="#1-3-2-server端作用" class="headerlink" title="1.3.2 server端作用"></a>1.3.2 server端作用</h3><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1a4196fb-da3b-4125-99f4-a1a9516218fd.png" style="zoom: 50%;"><p>我们先看一下注册服务的流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">svcmgr_publish</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs, <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *ptr)</span><br>&#123;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);<br>    bio_put_string16_x(&amp;msg, name);<br>    bio_put_obj(&amp;msg, ptr);<br><br>    <span class="hljs-keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    status = bio_get_uint32(&amp;reply);<br><br>    binder_done(bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端注册服务时会调用<code>svcmgr_publish</code>函数，这个函数里面最主要的是去调用<code>binder_call</code>函数</p><p><strong>binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE)</strong></p><ul><li>bs：描述binder驱动的结构体</li><li>msg：表示要注册服务的相关信息的binder_io结构体</li><li>reply：表示servicemanager回复的数据</li><li>target：注册时target传的是BINDER_SERVICE_MANAGER，该值表示的就是servicemanager</li><li>SVC_MGR_ADD_SERVICE：表示调用目标的函数，该函数的CODE值为SVC_MGR_ADD_SERVICE【在注册时相当于调用servicemanager的addservice服务】</li></ul><h3 id="1-3-3-client端作用"><a href="#1-3-3-client端作用" class="headerlink" title="1.3.3 client端作用"></a>1.3.3 client端作用</h3><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f955b7ac-25ac-4cd8-82b1-af135a447d3b.png" style="zoom: 50%;"><p>client端首先会去获取服务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">svcmgr_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs, <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);<br>    bio_put_string16_x(&amp;msg, name);<br><br>    <span class="hljs-keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_CHECK_SERVICE))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    handle = bio_get_ref(&amp;reply);<br><br>    <span class="hljs-keyword">if</span> (handle)<br>        binder_acquire(bs, handle);<br><br>    binder_done(bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> handle;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里同样也会去调用binder_call函数</p><p><strong>binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE)</strong></p><ul><li>bs：描述binder驱动的结构体</li><li>msg：表示即将查询服务的相关信息的binder_io结构体</li><li>reply：表示servicemanager回复的数据，数据里面会包含刚刚想要查询服务的进程</li><li>target：注册时target传的是BINDER_SERVICE_MANAGER，该值表示的就是servicemanager</li><li>SVC_MGR_CHECK_SERVICE：表示调用目标的函数，该函数的CODE值为SVC_MGR_CHECK_SERVICE【在注册时相当于调用servicemanager的getservice服务】</li></ul><h3 id="1-3-4-理解binder-call函数"><a href="#1-3-4-理解binder-call函数" class="headerlink" title="1.3.4 理解binder_call函数"></a>1.3.4 理解binder_call函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">binder_call</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs,</span><br><span class="hljs-params">                <span class="hljs-keyword">struct</span> binder_io *msg, <span class="hljs-keyword">struct</span> binder_io *reply,</span><br><span class="hljs-params">                <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">uint32_t</span> code)</span><br>&#123;<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_write_read</span> <span class="hljs-title">bwr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-type">uint32_t</span> cmd;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_transaction_data</span> <span class="hljs-title">txn</span>;</span><br>    &#125; __attribute__((packed)) writebuf;<br>    <span class="hljs-type">unsigned</span> readbuf[<span class="hljs-number">32</span>];<br><br>    <span class="hljs-keyword">if</span> (msg-&gt;flags &amp; BIO_F_OVERFLOW) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;binder: txn buffer overflow\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> fail;<br>    &#125;<br><br>    writebuf.cmd = BC_TRANSACTION;<br>    writebuf.txn.target.handle = target;<br>    writebuf.txn.code = code;<br>    writebuf.txn.flags = <span class="hljs-number">0</span>;<br>    writebuf.txn.data_size = msg-&gt;data - msg-&gt;data0;<br>    writebuf.txn.offsets_size = ((<span class="hljs-type">char</span>*) msg-&gt;offs) - ((<span class="hljs-type">char</span>*) msg-&gt;offs0);<br>    writebuf.txn.data.ptr.buffer = (<span class="hljs-type">uintptr_t</span>)msg-&gt;data0;<br>    writebuf.txn.data.ptr.offsets = (<span class="hljs-type">uintptr_t</span>)msg-&gt;offs0;<br><br>    bwr.write_size = <span class="hljs-keyword">sizeof</span>(writebuf);<br>    bwr.write_consumed = <span class="hljs-number">0</span>;<br>    bwr.write_buffer = (<span class="hljs-type">uintptr_t</span>) &amp;writebuf;<br><br>    hexdump(msg-&gt;data0, msg-&gt;data - msg-&gt;data0);<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        bwr.read_size = <span class="hljs-keyword">sizeof</span>(readbuf);<br>        bwr.read_consumed = <span class="hljs-number">0</span>;<br>        bwr.read_buffer = (<span class="hljs-type">uintptr_t</span>) readbuf;<br><br>        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);<br><br>        <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;binder: ioctl failed (%s)\n&quot;</span>, strerror(errno));<br>            <span class="hljs-keyword">goto</span> fail;<br>        &#125;<br><br>        res = binder_parse(bs, reply, (<span class="hljs-type">uintptr_t</span>) readbuf, bwr.read_consumed, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> fail;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>binder_call就是rpc中的远程调用函数</strong></p><p>在注册服务，获取服务，调用服务中的接口函数都是使用了binder_call函数，我们来分析一下binder_call函数具体在干嘛：</p><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3bdaac93-c274-45df-b04b-2a106eb4a42c.png" style="zoom: 67%;"><p><strong>binder_call内部实现：</strong></p><ol><li>构造参数msg，该值是一个binder_io类型的数据</li><li>将binder_io数据转化为<code>binder_write_read</code>类型的数据，因为binder驱动的ioctl中传递的是<code>binder_write_read</code>类型的数据</li></ol><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9b6e2287-0653-4646-8533-7cf9bdaf8b79.png" style="zoom: 67%;"><ol start="3"><li>客户端会调用ioctl发送数据</li></ol><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4f6deea3-edd7-44e5-9d8a-01d697da89d2.png" style="zoom: 67%;"><ol start="4"><li>服务端会调用ioctl接收数据</li></ol><h2 id="3-C程序实现Hello服务"><a href="#3-C程序实现Hello服务" class="headerlink" title="3.C程序实现Hello服务"></a>3.C程序实现Hello服务</h2><h3 id="3-1-server端和client端编写思路"><a href="#3-1-server端和client端编写思路" class="headerlink" title="3.1 server端和client端编写思路"></a>3.1 server端和client端编写思路</h3><p><strong>client端：</strong></p><ul><li>打开驱动，binder_open</li><li>获取服务的handle【服务以进程的形式存在，就是获得服务对应进程的handle】</li><li>构造参数binder_io</li><li>调用函数binder_call进行远程服务访问</li><li>返回binder_io，取出返回值</li><li>释放获得的handle</li></ul><p><strong>server端：</strong></p><ul><li>打开驱动，binder_open</li><li>调用svcmgr_publish注册服务</li><li>ioctl去读取binder驱动的数据</li><li>解析数据，将binder_write_read类型的数据转换为binder_io类型的数据</li><li>根据解析出的数据中的CODE值，去调用当前服务的对应函数</li><li>把返回值转换为binder_io</li></ul><h3 id="3-2-hello服务的server端"><a href="#3-2-hello服务的server端" class="headerlink" title="3.2 hello服务的server端"></a>3.2 hello服务的server端</h3><ul><li>test_server.h</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义hello服务的CODE编码，来表示当前应该调用服务的哪一个函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _TEST_SERVER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _TEST_SERVER_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO_SVR_CMD_SAYHELLO     1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO_SVR_CMD_SAYHELLO_TO  2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GOODBYE_SVR_CMD_SAYGOODBYE     1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GOODBYE_SVR_CMD_SAYGOODBYE_TO  2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// _TEST_SERVER_H</span></span><br></code></pre></td></tr></table></figure><ul><li>test_server.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/* Copyright 2008 The Android Open Source Project</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;private/android_filesystem_config.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;binder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test_server.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">svcmgr_publish</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs, <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *ptr)</span><br>&#123;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);<br>    bio_put_string16_x(&amp;msg, name);<br>    bio_put_obj(&amp;msg, ptr);<br><br>    <span class="hljs-keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    status = bio_get_uint32(&amp;reply);<br><br>    binder_done(bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sayhello</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;say hello : %d\n&quot;</span>, ++cnt);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sayhello_to</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;say hello to %s : %d\n&quot;</span>, name, ++cnt);<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">hello_service_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_transaction_data *txn,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_io *msg,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_io *reply)</span><br>&#123;<br>    <span class="hljs-comment">/* 根据txn-&gt;code知道要调用哪一个函数</span><br><span class="hljs-comment">     * 如果需要参数, 可以从msg取出</span><br><span class="hljs-comment">     * 如果要返回结果, 可以把结果放入reply</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/* sayhello</span><br><span class="hljs-comment">     * sayhello_to</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-type">uint16_t</span> *s;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">512</span>];<br>    <span class="hljs-type">size_t</span> len;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">uint32_t</span> strict_policy;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-comment">// Equivalent to Parcel::enforceInterface(), reading the RPC</span><br>    <span class="hljs-comment">// header with the strict mode policy mask and the interface name.</span><br>    <span class="hljs-comment">// Note that we ignore the strict_policy and don&#x27;t propagate it</span><br>    <span class="hljs-comment">// further (since we do no outbound RPCs anyway).</span><br>    strict_policy = bio_get_uint32(msg);<br><br>    <span class="hljs-keyword">switch</span>(txn-&gt;code) &#123;<br>    <span class="hljs-keyword">case</span> HELLO_SVR_CMD_SAYHELLO:<br>        sayhello();<br>        bio_put_uint32(reply, <span class="hljs-number">0</span>); <span class="hljs-comment">/* no exception */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">case</span> HELLO_SVR_CMD_SAYHELLO_TO:<br>        <span class="hljs-comment">/* 从msg里取出字符串 */</span><br>        s = bio_get_string16(msg, &amp;len);  <span class="hljs-comment">//&quot;IHelloService&quot;</span><br>        s = bio_get_string16(msg, &amp;len);  <span class="hljs-comment">// name</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            name[i] = s[i];<br>        name[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        <span class="hljs-comment">/* 处理 */</span><br>        i = sayhello_to(name);<br><br>        <span class="hljs-comment">/* 把结果放入reply */</span><br>        bio_put_uint32(reply, <span class="hljs-number">0</span>); <span class="hljs-comment">/* no exception */</span><br>        bio_put_uint32(reply, i);<br>        <br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;unknown code %d\n&quot;</span>, txn-&gt;code);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">bs</span>;</span><br>    <span class="hljs-type">uint32_t</span> svcmgr = BINDER_SERVICE_MANAGER;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">int</span> ret;<br><br>    bs = binder_open(<span class="hljs-number">128</span>*<span class="hljs-number">1024</span>);<br>    <span class="hljs-keyword">if</span> (!bs) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to open binder driver\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* add service */</span><br>    ret = svcmgr_publish(bs, svcmgr, <span class="hljs-string">&quot;hello&quot;</span>, hello_service_handler);<br>    <span class="hljs-keyword">if</span> (ret) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to publish hello service\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* read data */</span><br>        <span class="hljs-comment">/* parse data, and process */</span><br>        <span class="hljs-comment">/* reply */</span><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    binder_set_maxthreads(bs, <span class="hljs-number">10</span>);<br><br>    binder_loop(bs, hello_service_handler);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-hello服务的client端"><a href="#3-3-hello服务的client端" class="headerlink" title="3.3 hello服务的client端"></a>3.3 hello服务的client端</h3><ul><li>test_client.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c">&lt;&gt;<span class="hljs-comment">/* Copyright 2008 The Android Open Source Project</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;private/android_filesystem_config.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;binder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test_server.h&quot;</span></span><br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">svcmgr_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs, <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);<br>    bio_put_string16_x(&amp;msg, name);<br><br>    <span class="hljs-keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_CHECK_SERVICE))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    handle = bio_get_ref(&amp;reply);<br><br>    <span class="hljs-keyword">if</span> (handle)<br>        binder_acquire(bs, handle);<br><br>    binder_done(bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> handle;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">g_bs</span>;</span><br><span class="hljs-type">uint32_t</span> g_hello_handle;<br><span class="hljs-type">uint32_t</span> g_goodbye_handle;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sayhello</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    <span class="hljs-comment">/* 构造binder_io */</span><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, <span class="hljs-string">&quot;IHelloService&quot;</span>);<br><br>    <span class="hljs-comment">/* 放入参数 */</span><br><br>    <span class="hljs-comment">/* 调用binder_call */</span><br>    <span class="hljs-keyword">if</span> (binder_call(g_bs, &amp;msg, &amp;reply, g_hello_handle, HELLO_SVR_CMD_SAYHELLO))<br>        <span class="hljs-keyword">return</span> ;<br>    <br>    <span class="hljs-comment">/* 从reply中解析出返回值 */</span><br><br>    binder_done(g_bs, &amp;msg, &amp;reply);<br>    <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sayhello_to</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">int</span> exception;<br><br>    <span class="hljs-comment">/* 构造binder_io */</span><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, <span class="hljs-string">&quot;IHelloService&quot;</span>);<br><br>    <span class="hljs-comment">/* 放入参数 */</span><br>    bio_put_string16_x(&amp;msg, name);<br><br>    <span class="hljs-comment">/* 调用binder_call */</span><br>    <span class="hljs-keyword">if</span> (binder_call(g_bs, &amp;msg, &amp;reply, g_hello_handle, HELLO_SVR_CMD_SAYHELLO_TO))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">/* 从reply中解析出返回值 */</span><br>    exception = bio_get_uint32(&amp;reply);<br>    <span class="hljs-keyword">if</span> (exception)<br>        ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>        ret = bio_get_uint32(&amp;reply);<br><br>    binder_done(g_bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> ret;<br>    <br>&#125;<br><br><br><span class="hljs-comment">/* ./test_client hello</span><br><span class="hljs-comment"> * ./test_client hello &lt;name&gt;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">bs</span>;</span><br>    <span class="hljs-type">uint32_t</span> svcmgr = BINDER_SERVICE_MANAGER;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">int</span> ret;<br><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage:\n&quot;</span>);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s &lt;hello&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s &lt;hello&gt; &lt;name&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    bs = binder_open(<span class="hljs-number">128</span>*<span class="hljs-number">1024</span>);<br>    <span class="hljs-keyword">if</span> (!bs) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to open binder driver\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    g_bs = bs;<br><br>    <span class="hljs-comment">/* get service */</span><br>    handle = svcmgr_lookup(bs, svcmgr, <span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!handle) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to get hello service\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    g_hello_handle = handle;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Handle for hello service = %d\n&quot;</span>, g_hello_handle);<br><br>    <span class="hljs-comment">/* send data to server */</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello&quot;</span>))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>) &#123;<br>            sayhello();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span>) &#123;<br>            ret = sayhello_to(argv[<span class="hljs-number">2</span>]);<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;get ret of sayhello_to = %d\n&quot;</span>, ret);      <br>        &#125;<br>    &#125;<br><br>    binder_release(bs, handle);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3f3601eb-c63d-46bb-9692-1dfdc4d24690.png"><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/b20537c9-9aff-4da7-84ae-dd1dbcb30baf.png">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 8.1从零开始写HAL</title>
    <link href="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/"/>
    <url>/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-8-1从零开始写HAL"><a href="#Android-8-1从零开始写HAL" class="headerlink" title="Android 8.1从零开始写HAL"></a>Android 8.1从零开始写HAL</h1><blockquote><p>🍛版权声明：本文为CSDN博主「Qidi_Huang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>🍜原文链接：<a href="https://blog.csdn.net/Qidi_Huang/article/details/107426961">https://blog.csdn.net/Qidi_Huang/article/details/107426961</a></p></blockquote><h2 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1.定义接口"></a>1.定义接口</h2><p>【前言】<br>我们都知道从 <code>Android 8.0</code> 开始， Google 启动了 <code>Treble 项目</code>，自此开始推行 Binder 化的 HAL 实现。除少数类型 HAL 外，在 Android 9.0 及其之后的版本，Google 甚至要求大部分<strong>外设</strong>(peripherals) 必须支持使用 Binder 化的 HAL，否则都不再视为合规。因此，本文中的 HAL 指的是用 HIDL 语言描述、使用 Binder 方式实现的 HAL。</p><p>在阅读本系列文章前，如果你已经大致了解 <code>Android SELinux</code> 概念（比如 <code>*.te</code> 文件和 <code>file_contexts</code>），以及 Binder 的基本调用方法（比如知道序列化的概念、 transact()&#x2F;onTransact()的调用时机），对于理解本文的内容会很有帮助。</p><p>根据项目不同，有的时候我们也许希望在设备上使用一种新的外设，比如某种传感器；或者有的时候，我们可能需要在 Android native 层运行一个特定进程，用来辅助处理来自 Android Frameworks 的数据，或者用于和其它 native 层的进程进行交互。对于前一种场景，我们需要为外设编写全新的 HAL；对于后一种场景，我们不需要编写 HAL，但需要实现一个很类似的 vendor service。这二者的实现方式极其类似，区别只在于他们使用的设备节点不同（一个使用<code>/dev/hwbinder</code>，另一个使用 <code>/dev/vndbinder</code>），还有各自申请的 sepolicy 权限有别。</p><p>以下正文以实现一个全新的 HAL 为例进行说明，但并不涉及对设备节点的操作。</p><h3 id="1-1-明确HAL接口"><a href="#1-1-明确HAL接口" class="headerlink" title="1.1 明确HAL接口"></a>1.1 明确HAL接口</h3><p>Android 大量采用面向接口编程的理念，HAL 也不例外。常用的 HAL 模块接口已经由 Google 和业界充分讨论并预定义，比如 Audio 和 Camera，这些模块需要支持的功能也已经明确，其接口描述可以在 <code>/hardware/interfaces/</code> 目录下找到。</p><p>同理，我们实现自己的 HAL 时，也应该先明确新 HAL 要支持的功能，再根据需求需要设计要暴露给给其它进程的接口。</p><p><strong>为了说明方便，我们不以真实的外设 HAL 来描述，而是做一系列假设，自己给自己设计需求。虽然这样的 HAL 不对应具体的使用场景，但道理是相通的，完全可以照猫画虎、举一反三。</strong></p><p>我们假设新 HAL 需要支持 3 个功能：</p><ul><li>允许其它进程主动设置状态</li><li>允许其它进程注册回调函数</li><li>允许其它进程注销回调函数</li></ul><p>给 <strong>新外设</strong>取名为 <code>demoComponent</code>，给<strong>新 HAL 的进程</strong>取名为 <code>demoService</code>。给支持上述 3 项功能的接口分别取名为 <code>setStatus() </code>、 <code>registerCallback()</code> 和 <code>unregisterCallback()</code>。假设其它进程所设置的“状态”是一个 <code>DemoData</code> 结构体，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-built_in">string</span>  name;<br>    <span class="hljs-type">int</span>     value;<br>&#125; DemoData;<br></code></pre></td></tr></table></figure><p>假设回调函数方法为 <code>onCallbackEvent()</code>， 参数同样为 <code>DemoData</code> 结构。</p><h3 id="1-2-编写接口描述文件"><a href="#1-2-编写接口描述文件" class="headerlink" title="1.2 编写接口描述文件"></a>1.2 编写接口描述文件</h3><p>通常，经过前述步骤明确接口之后，我们就可以写出完整的头文件来了，继而对应实现各接口。但是在 HAL 实现过程中，我们首先要写的不是头文件，而是创作出用 HIDL 语言编写的 <code>*.hal</code> 接口描述文件。（<strong>不过，在 Android R 上将支持用 AIDL 语言来编写接口描述文件，以后可能逐步废弃 HIDL 语言</strong>）</p><p>按照目前的开发规范，我们的自定义接口描述文件通常放在 <code>/vendor/&lt;CompanyName&gt;/hardware/interfaces/&lt;ComponentName&gt;/&lt;SubComponentName&gt;/&lt;VersionCode&gt;/</code> 目录下。 根据我们前文的假设，这里的<code>&lt;ComponentName&gt;</code>就是 demoComponent。<code>&lt;SubComponentName&gt;</code> 可有可无，在这个例子中对应的是 demoService。VersionCode 表示 HAL 接口的版本号，因为我们编写的是一个全新的 HAL，所以版本号是 1.0。</p><p>因为我们的实现涉及 <strong>HAL 进程、回调函数、参数数据</strong> 3 个部分，所以对应的 hal 文件也有 3 个，分别是：</p><ul><li><strong>IDemoServiceDef.hal</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">package vendor.harman.hardware.demoComponent.demoService@<span class="hljs-number">1.0</span>;<br><br>import IDemoCallback;<br><br>interface IDemoServiceDef &#123;<br><br>    setStatus(DemoData data) generates (<span class="hljs-type">int32_t</span> status);<br>    registerCallback(IDemoCallback cb) generates (<span class="hljs-type">int32_t</span> status);<br>    unregisterCallback(IDemoCallback cb) generates (<span class="hljs-type">int32_t</span> status);<br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li><strong>IDemoCallback.hal</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">package vendor.harman.hardware.demoComponent.demoService@<span class="hljs-number">1.0</span>;<br><br>interface IDemoCallback &#123;<br><br>   onCallbackEvent(DemoData payload) generates (<span class="hljs-type">int32_t</span> status);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>types.hal</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">package vendor.harman.hardware.demoComponent.demoService@<span class="hljs-number">1.0</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DemoData</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-built_in">string</span>  name;<br>    <span class="hljs-type">int32_t</span> value;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里有四个基本点需要注意。</p><ol><li><p><strong>数据类型描述文件的文件名是个固定名称</strong> <code>types.hal</code>；接口描述文件的文件名要以<strong>大写字母 I</strong> 开头写作 <code>IXxxx.hal</code>，并且相应地以<code>interface IXxxx &#123;&#125; </code>进行描述；<strong>generates</strong> 后加数据类型表示接口的返回值类型。</p></li><li><p>每个<code> *.hal</code> 文件都需要在文件头声明它所属的包。这里的包名为<code> package vendor.harman.hardware.demoComponent.demoService@1.0;</code>。</p></li><li><p>HIDL 语言所使用的数据类型和 C&#x2F;C++&#x2F;Java 的数据类型稍有区别。举个简单例子，对比 DemoData 结构体的原始写法与 HIDL 写法，可以看到 int32 被替换成了 int32_t。 再比如说，HIDL 数据类型也不支持 C&#x2F;C++ 的原始指针。关于 HIDL 数据类型的详细介绍可以参考《HIDL 数据类型》。</p></li><li><p>另外，<code>*.hal</code> 文件之间相互引用时，使用 <code>import</code> 关键字进行声明。</p></li></ol><p>这些固定形式是由 HIDL 框架决定的，我们必须遵从。</p><p>编写完成后用 <code>ls</code> 命令查看，就是下图中 3 个绿色文件的样子（<code>Android.*</code> 是自动生成的，1.3节就要讲到。<code>default/</code> 的含义和作用留待第2章进行介绍）：</p><img src="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/20200717231917282.png"><h3 id="1-3-生成-Makefile"><a href="#1-3-生成-Makefile" class="headerlink" title="1.3 生成 Makefile"></a>1.3 生成 Makefile</h3><p>编写好接口描述文件后，我们需要执行脚本 <code>/vendor/&lt;CompanyName&gt;/hardware/interfaces/update-makefiles.sh</code> 为接口描述文件自动生成 2 个 Makefile —— <code>Android.bp</code> 和 <code>Android.mk</code>。</p><p>有了这 2 个 Makefile，在编译阶段就可以自动从接口描述文件生成 Binder 框架的源文件、头文件以和对应的库，而无需我们手动敲一遍，十分方便。</p><h2 id="2-实现-HAL-主体"><a href="#2-实现-HAL-主体" class="headerlink" title="2.实现 HAL 主体"></a>2.实现 HAL 主体</h2><h3 id="2-1-配置HAL"><a href="#2-1-配置HAL" class="headerlink" title="2.1 配置HAL"></a>2.1 配置HAL</h3><p>因为不同的产品可能使用不同的外设，所以每个产品都有自己的资源清单 <code>manifest.xml</code>，位于目录 <code>/device/&lt;CompanyName&gt;/&lt;PlatformName&gt;/&lt;ProductName&gt;/</code> 下。清单中会列出该款产品支持的所有外设、服务和它们的 HAL 类型。</p><p>我们也应该把正在创建的 demoComponent HAL 添加进这个清单里。以我用的 Intel 平台为例，产品代号就不说了，<code>manifest.xml</code> 位于 <code>/device/harman/broxton/XXXX/</code> 目录下。添加完成后看起来类似下面这个样子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;device&quot;</span>&gt;</span><br><br>    ......<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hal</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;hidl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>vendor.harman.hardware.demoComponent.demoService<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transport</span>&gt;</span>hwbinder<span class="hljs-tag">&lt;/<span class="hljs-name">transport</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">interface</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>IDemoServiceDef<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">instance</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">instance</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">interface</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">hal</span>&gt;</span><br><br>    ......<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sepolicy</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>27.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sepolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 <code>&lt;hal format=&quot;hidl&quot;&gt;</code> 表示 HAL 使用 HIDL 描述； <code>&lt;name&gt;</code> 的值可以看出来就是接口描述文件所在的位置，但中间少了个 <strong>“.interfaces”</strong> ；<code>&lt;transport&gt;</code> 表示 HAL 实现所依赖的 binder 类型；<code>&lt;version&gt;</code> 表示 HAL 版本，回忆上一节，我们在编写接口描述文件时，文件存放路径里也有个 HAL 版本号，这两个版本号要一致； <code>&lt;interface&gt;</code> 节点用来标明 HAL 接口，下属的<code> &lt;name&gt;</code> 指定了 HAL 的接口描述文件为 <code>IDemoServiceDef.hal</code>， <code>&lt;instance&gt;</code> 指定了 HAL 的实现位于 <code>default/</code> 目录下。</p><p>default&#x2F; <strong>目录需要我们自己创建，位于</strong> <code>/vendor/&lt;CompanyName&gt;/hardware/interfaces/&lt;ComponentName&gt;/&lt;SubComponentName&gt;/&lt;VersionCode&gt;/</code>。 还是以我用的平台为例，完整路径为 <code>/vendor/harman/hardware/interfaces/demoComponent/demoService/1.0/default</code>。</p><h3 id="2-2-实现HAL主体"><a href="#2-2-实现HAL主体" class="headerlink" title="2.2 实现HAL主体"></a>2.2 实现HAL主体</h3><p>接下来我们要实现 demoComponent HAL 的主体。 因为 <strong>Binder 化后的 HAL 是以服务进程的形式运行在 Android native 层</strong>的，所以我给这个主体取名为 demoService。在 <code>default/</code> 目录下新建 <code>DemoServiceImpl.h</code> 和<code>DemoServiceImpl.cpp</code>。</p><p>这之后要做的事大家就很熟悉了 —— 在 <code>DemoServiceImpl.h</code> 里引用必要的头文件、声明类和方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hardware/hardware.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/IServiceManager.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/IPCThreadState.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/IDemoServiceDef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/IDemoCallback.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> android;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoServiceImpl</span> : <span class="hljs-keyword">public</span> IDemoServiceDef &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DemoServiceImpl</span>();<br>    ~<span class="hljs-built_in">DemoServiceImpl</span>() &#123;&#125;<br><br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> <span class="hljs-keyword">override</span></span>;<br><br><br><span class="hljs-keyword">private</span>:<br>    android::sp&lt;IDemoCallback&gt; callback = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong><code>DemoServiceImpl</code> 类继承自 <code>IDemoServiceDef</code> 类，并对接口进行覆写，同时声明了一个 <code>IDemoCallback</code> 指针用来保存回调函数。</strong></p><p>大家可能会困惑<strong>IDemoServiceDef</strong> 类和接口声明是哪里来的？我们可以通过名字推测它是由 <strong>IDemoServiceDef.hal</strong> 生成的。实际上和推测一样，编译阶段自动生成的文件会被放在 <code>/out/soong/.intermediates/vendor/harman/hardware/interfaces/demoComponent/demoService/1.0/</code> 目录，头文件和源文件可以分别在 <code>vendor.harman.hardware.demoComponent.demoService@1.0_genc++_headers</code> 和 <code>vendor.harman.hardware.demoComponent.demoService@1.0_genc++ </code>中找到。 <strong>在 <code>DemoServiceImpl.h</code> 里需要 <code>#include</code> 引用这些自动生成的头文件。</strong></p><p>下方展示的是自动生成的头文件 <code>IDemoServiceDef.h</code> 的部分代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HIDL_GENERATED_VENDOR_HARMAN_HARDWARE_DEMOCOMPONENT_DEMOSERVICE_V1_0_IDEMOSERVICEDEF_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HIDL_GENERATED_VENDOR_HARMAN_HARDWARE_DEMOCOMPONENT_DEMOSERVICE_V1_0_IDEMOSERVICEDEF_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hidl/base/1.0/IBase.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/IDemoCallback.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/types.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hidl/manager/1.0/IServiceNotification.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/HidlSupport.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/MQDescriptor.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/Status.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/NativeHandle.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/misc.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> vendor &#123;<br><span class="hljs-keyword">namespace</span> harman &#123;<br><span class="hljs-keyword">namespace</span> hardware &#123;<br><span class="hljs-keyword">namespace</span> demoComponent &#123;<br><span class="hljs-keyword">namespace</span> demoService &#123;<br><span class="hljs-keyword">namespace</span> V1_0 &#123;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IDemoServiceDef</span> : <span class="hljs-keyword">public</span> ::android::hidl::base::V1_0::IBase &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isRemote</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><br><br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// ....省略</span><br>&#125;;<br><br><span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoServiceDef&gt;&amp;)</span></span>;<br><br>&#125;  <span class="hljs-comment">// namespace V1_0</span><br>&#125;  <span class="hljs-comment">// namespace demoService</span><br>&#125;  <span class="hljs-comment">// namespace demoComponent</span><br>&#125;  <span class="hljs-comment">// namespace hardware</span><br>&#125;  <span class="hljs-comment">// namespace harman</span><br>&#125;  <span class="hljs-comment">// namespace vendor</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// HIDL_GENERATED_VENDOR_HARMAN_HARDWARE_DEMOCOMPONENT_DEMOSERVICE_V1_0_IDEMOSERVICEDEF_H</span></span><br></code></pre></td></tr></table></figure><p>然后在 <code>DemoServiceImpl.cpp</code> 中实现各方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceImpl.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><br>DemoServiceImpl::<span class="hljs-built_in">DemoServiceImpl</span>() &#123;<br><br>&#125;<br><br>::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">DemoServiceImpl::setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoServiceImpl setStatus&quot;</span>);<br>    <span class="hljs-comment">// 省略设置状态的代码</span><br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService invokes callback&quot;</span>);<br>    <span class="hljs-comment">// 在最后执行回调函数发送通知</span><br>    callback-&gt;<span class="hljs-built_in">onCallbackEvent</span>(sta);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">DemoServiceImpl::registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoServiceImpl registerCallback&quot;</span>);<br>    <span class="hljs-comment">// 保存回调函数</span><br>    callback = cb;<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService callback function saved&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">DemoServiceImpl::unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoServiceImpl unregisterCallback&quot;</span>);<br>    <span class="hljs-keyword">if</span> (callback == cb) &#123;<br>        <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService callback function cleared.&quot;</span>);<br>        <span class="hljs-comment">// 清空回调函数</span><br>        callback = <span class="hljs-literal">nullptr</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService callback function mismatch, uncleared.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这 3 个接口的实现写得很简单，直接看代码注释就可以，无需赘言。</p><h3 id="2-3-将-HAL-注册为-Binder-服务"><a href="#2-3-将-HAL-注册为-Binder-服务" class="headerlink" title="2.3 将 HAL 注册为 Binder 服务"></a>2.3 将 HAL 注册为 Binder 服务</h3><p><strong>因为 Binder 化的 HAL 以独立本地进程的形式运行</strong>，<strong>所以必定需要 main() 函数作为进程启动入口</strong>。我们当然可以把 main() 写在 DemoServiceImpl.cpp 中，但为了与接口实现进行区分，我在<code>default/ </code>目录下新建源文件 <code>DemoService.cpp</code>，在该文件中实现且仅实现 main() 函数。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_TAG <span class="hljs-string">&quot;vendor.harman.demoComponent.demoService@1.0-service&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/log.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/ProcessState.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/LegacySupport.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceImpl.h&quot;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-comment">/* argc */</span>, <span class="hljs-type">char</span>* <span class="hljs-comment">/* argv */</span> [])</span> </span>&#123;<br>    android::ProcessState::<span class="hljs-built_in">initWithDriver</span>(<span class="hljs-string">&quot;/dev/hwbinder&quot;</span>);  <span class="hljs-comment">// 初始化 Binder 驱动</span><br>    <span class="hljs-keyword">auto</span> service = std::<span class="hljs-built_in">make_unique</span>&lt;DemoServiceImpl&gt;();      <span class="hljs-comment">// 构造 DemoServiceImpl 实例</span><br>    android::hardware::<span class="hljs-built_in">configureRpcThreadpool</span>(<span class="hljs-number">4</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/* callerWillJoin */</span>);<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService registerAsService&quot;</span>);<br>    android::<span class="hljs-type">status_t</span> status = service-&gt;<span class="hljs-built_in">registerAsService</span>();  <span class="hljs-comment">// 注册为 Binder 服务</span><br>    <span class="hljs-keyword">if</span> (status != android::OK) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Unable to register DemoService (%d)&quot;</span>, status);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    android::hardware::<span class="hljs-built_in">joinRpcThreadpool</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在 <strong>main()</strong> 函数中主要干了些事：使用设备节点 <code>/dev/hwbinder</code> 初始化 Binder 驱动，并以单例（Singleton）的方式将 <code>DemoServiceImpl</code> 类的一个实例注册为 Binder 服务。</p><p><strong>如果你希望 HAL 进程也能与其它本地进程交互，那么在初始化驱动的时候应该使用</strong> <code>/dev/vndbinder</code>。</p><h2 id="3-实现-Bp、Bn-端"><a href="#3-实现-Bp、Bn-端" class="headerlink" title="3.实现 Bp、Bn 端"></a>3.实现 Bp、Bn 端</h2><p><strong>【前言】</strong></p><p>既然 Binder 化的 HAL 依赖于 Binder 机制进行实现，那么我们自然必须按照 Binder 框架，相应编写 <strong>demoComponent HAL</strong> 的 <strong>Bp</strong> 端和 <strong>Bn</strong> 端。只有这样，才能打通客户端进程调用到服务端进程 —— 我们的 demoService —— 的通路。</p><h3 id="3-1-定义demoService接口类"><a href="#3-1-定义demoService接口类" class="headerlink" title="3.1 定义demoService接口类"></a>3.1 定义demoService接口类</h3><p>要将 demoService 接入 Binder，就必须定义一个我们自己的接口类，继承 Binder 的接口基类 <code>IInterface</code>，并实现所有 Binder 通信过程中要用到的方法。不过我们并不需要事无巨细地完成这项繁杂的工作，因为 Binder 框架提供了数个模板类和宏，大大方便了我们实现。</p><p>还记得在上一节《实现 HAL 主体》里我们创建了 <code>default/</code> 目录。在该目录下新建头文件 <code>DemoServiceBinderInterface.h</code>，并在这个头文件里定义接口类 <code>IDemoService</code>。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/IInterface.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/IDemoCallback.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEMOSERVICE_NAME <span class="hljs-string">&quot;com.qidi.demoService&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><span class="hljs-keyword">using</span> ::vendor::harman::hardware::demoComponent::demoService::V1_0::IDemoCallback;<br><span class="hljs-keyword">using</span> ::vendor::harman::hardware::demoComponent::demoService::V1_0::DemoData;<br><br><span class="hljs-keyword">namespace</span> android &#123;<br><br>    <span class="hljs-comment">// command codes for binder transactions</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">eDemoServiceTransactionID</span><br>    &#123;<br>        SET_STATUS = android::IBinder::FIRST_CALL_TRANSACTION,<br>        REGISTER_CALLBACK,<br>        UNREGISTER_CALLBACK<br>    &#125;;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">IDemoService</span>: <span class="hljs-keyword">public</span> IInterface &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">DECLARE_META_INTERFACE</span>(DemoService);<br><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>= <span class="hljs-number">0</span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了定义类 <code>IDemoService</code>，我们还在头文件 <code>DemoServiceBinderInterface.h</code> 里以<strong>枚举数据的形式</strong>定义了和 demoService Binder 调用相关的 Command code。 三个 Command code <code>SET_STATUS</code>、<code>REGISTER_CALLBACK</code> 和 <code>UNREGISTER_CALLBACK</code> 分别对应 demoService 的三个接口。<strong>第一个 Command code 必须赋值为</strong> <code>android::IBinder::FIRST_CALL_TRANSACTION</code>。</p><p>宏 <code>DECLARE_META_INTERFACE()</code> 主要用来声明用于 Binder 通信的成员变量 <code>descriptor</code> 和通用接口 <code>asInterface()</code> 、 <code>getInterfaceDescriptor()</code>。 相关代码位于 <code>IInterface.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span><br><span class="hljs-meta">    static const ::android::String16 descriptor;                        \</span><br><span class="hljs-meta">    static ::android::sp<span class="hljs-string">&lt;I##INTERFACE&gt;</span> asInterface(                     \</span><br><span class="hljs-meta">            const ::android::sp<span class="hljs-string">&lt;::android::IBinder&gt;</span>&amp; obj);              \</span><br><span class="hljs-meta">    virtual const ::android::String16&amp; getInterfaceDescriptor() const;  \</span><br><span class="hljs-meta">    I##INTERFACE();                                                     \</span><br><span class="hljs-meta">    virtual ~I##INTERFACE();                                            \</span><br></code></pre></td></tr></table></figure><p>至此，demoService 的接口类就定义好了。</p><h3 id="3-2-声明-Bp、Bn-端"><a href="#3-2-声明-Bp、Bn-端" class="headerlink" title="3.2 声明 Bp、Bn 端"></a>3.2 声明 Bp、Bn 端</h3><p>有了接口类之后，就可以正式着手 Bp、Bn 端的工作了。依照先声明后实现的顺序，我们继续在 <code>default/</code> 目录下新建头文件 <code>BpDemoService.h</code> 和 <code>BnDemoService.h</code>。<strong>Binder 框架提供了模板类<code>BpInterface&lt;&gt;</code>和 <code>BnInterface&lt;&gt;</code> 来简化这一过程</strong>。</p><ul><li><strong><code>BpDemoService.h</code> 代码如下：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><br><span class="hljs-keyword">namespace</span> android &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">BpDemoService</span>: <span class="hljs-keyword">public</span> BpInterface&lt;android::IDemoService&gt; &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">BpDemoService</span>(<span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; impl);<br><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span></span>;<br>    &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Bp 端头文件中将 <code>IDemoService</code> 作为参数传入 <code>BpInterface&lt;&gt;</code> 模板，所以需要引用 <code>DemoServiceBinderInterface.h</code>。由于模板类的设计，文件中声明的 demoService 的 3 个接口将被整合到 Binder 框架代码中。我们即便不去关注其中的细节也没关系，只要负责填入接口类和接口声明，剩下的交给 Binder 框架就好。当然，如果你充满好奇且时间充裕，也可以一头扎进去理一理思路。 <code>BpInterface&lt;&gt;</code> 模板类的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> INTERFACE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BpInterface</span> : <span class="hljs-keyword">public</span> INTERFACE, <span class="hljs-keyword">public</span> BpRefBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span>                    <span class="hljs-title">BpInterface</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; remote)</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IBinder*            <span class="hljs-title">onAsBinder</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong><code>BnDemoService.h</code> 代码如下：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> android &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">BnDemoService</span>: <span class="hljs-keyword">public</span> BnInterface&lt;IDemoService&gt; &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">status_t</span> <span class="hljs-title">onTransact</span><span class="hljs-params">( <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                Parcel* reply, <span class="hljs-type">uint32_t</span> flags = <span class="hljs-number">0</span>)</span></span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Bn 端头文件的内容与 Bp 端类似，但需要注意，由于 Binder 框架的设计原因，这里的方法名 <code>onTransact()</code> 及参数都是固定的，我们不能写成其它形式。</strong> <code>BnInterface&lt;&gt;</code> 模板类在 <code>IInterface.h</code> 中的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> INTERFACE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BnInterface</span> : <span class="hljs-keyword">public</span> INTERFACE, <span class="hljs-keyword">public</span> BBinder<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> sp&lt;IInterface&gt;      <span class="hljs-title">queryLocalInterface</span><span class="hljs-params">(<span class="hljs-type">const</span> String16&amp; _descriptor)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> String16&amp;     <span class="hljs-title">getInterfaceDescriptor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IBinder*            <span class="hljs-title">onAsBinder</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-3-实现-Bp、Bn-端"><a href="#3-3-实现-Bp、Bn-端" class="headerlink" title="3.3 实现 Bp、Bn 端"></a>3.3 实现 Bp、Bn 端</h3><p>声明之后，该进行实现了。继续在 <code>default/</code> 目录下新建源文件 <code>BpDemoService.cpp</code> 和 <code>BnDemoService.cpp</code>。</p><p>实现过程只是顺水推舟而已，直接看代码吧。</p><ul><li><strong>BpDemoService.cpp:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/Log.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/IServiceManager.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/Parcel.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;BpDemoService.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_D ALOGD</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_E ALOGE</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> android;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><br><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">BpDemoService::setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span> </span>&#123;<br>    Parcel data, reply;<br><br>    data.<span class="hljs-built_in">writeInterfaceToken</span>(IDemoService::<span class="hljs-built_in">getInterfaceDescriptor</span>());<br>    data.<span class="hljs-built_in">write</span>(&amp;sta, <span class="hljs-built_in">sizeof</span>(DemoData));<br><br>    <span class="hljs-type">status_t</span> status = <span class="hljs-built_in">remote</span>()-&gt;<span class="hljs-built_in">transact</span>(SET_STATUS, data, &amp;reply);<br>    <span class="hljs-keyword">if</span> (status != NO_ERROR) &#123;<br>        <span class="hljs-built_in">LOG_E</span>(<span class="hljs-string">&quot;BpDemoService::setStatus transact failed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> reply.<span class="hljs-built_in">readInt32</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">BpDemoService::registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>&#123;<br>    Parcel data, reply;<br><br>    data.<span class="hljs-built_in">writeInterfaceToken</span>(IDemoService::<span class="hljs-built_in">getInterfaceDescriptor</span>());<br>    data.<span class="hljs-built_in">write</span>(&amp;cb, <span class="hljs-built_in">sizeof</span>(::android::sp&lt;IDemoCallback&gt;));<br><br>    <span class="hljs-type">status_t</span> status = <span class="hljs-built_in">remote</span>()-&gt;<span class="hljs-built_in">transact</span>(REGISTER_CALLBACK, data, &amp;reply);<br>    <span class="hljs-keyword">if</span> (status != NO_ERROR) &#123;<br>        <span class="hljs-built_in">LOG_E</span>(<span class="hljs-string">&quot;BpDemoService::registerCallback transact failed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> reply.<span class="hljs-built_in">readInt32</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">BpDemoService::unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>&#123;<br>    Parcel data, reply;<br><br>    data.<span class="hljs-built_in">writeInterfaceToken</span>(IDemoService::<span class="hljs-built_in">getInterfaceDescriptor</span>());<br>    data.<span class="hljs-built_in">write</span>(&amp;cb, <span class="hljs-built_in">sizeof</span>(::android::sp&lt;IDemoCallback&gt;));<br><br>    <span class="hljs-type">status_t</span> status = <span class="hljs-built_in">remote</span>()-&gt;<span class="hljs-built_in">transact</span>(UNREGISTER_CALLBACK, data, &amp;reply);<br>    <span class="hljs-keyword">if</span> (status == NO_ERROR) &#123;<br>        <span class="hljs-built_in">LOG_E</span>(<span class="hljs-string">&quot;BpDemoService::unregisterCallback transact failed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> reply.<span class="hljs-built_in">readInt32</span>();<br>&#125;<br><br>BpDemoService::<span class="hljs-built_in">BpDemoService</span>(<span class="hljs-type">const</span> sp&lt;IBinder&gt; &amp;impl) : <span class="hljs-built_in">BpInterface</span>&lt;IDemoService&gt;(impl) &#123;&#125;<br><span class="hljs-built_in">IMPLEMENT_META_INTERFACE</span>(DemoService, DEMOSERVICE_NAME);<br><br></code></pre></td></tr></table></figure><p>Bp 端的源文件里使用了宏 <code>IMPLEMENT_META_INTERFACE()</code>，扩展之后即是宏 <code>DECLARE_META_INTERFACE()</code> 所声明的接口的实现。</p><p>这个宏同样定义在 <code>IInterface.h</code> 中，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span><br><span class="hljs-meta">    const ::android::String16 I##INTERFACE::descriptor(NAME);           \</span><br><span class="hljs-meta">    const ::android::String16&amp;                                          \</span><br><span class="hljs-meta">            I##INTERFACE::getInterfaceDescriptor() const &#123;              \</span><br><span class="hljs-meta">        return I##INTERFACE::descriptor;                                \</span><br><span class="hljs-meta">    &#125;                                                                   \</span><br><span class="hljs-meta">    ::android::sp<span class="hljs-string">&lt;I##INTERFACE&gt;</span> I##INTERFACE::asInterface(              \</span><br><span class="hljs-meta">            const ::android::sp<span class="hljs-string">&lt;::android::IBinder&gt;</span>&amp; obj)               \</span><br><span class="hljs-meta">    &#123;                                                                   \</span><br><span class="hljs-meta">        ::android::sp<span class="hljs-string">&lt;I##INTERFACE&gt;</span> intr;                               \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (obj != NULL) &#123;                                              \</span><br><span class="hljs-meta">            intr = static_cast<span class="hljs-string">&lt;I##INTERFACE*&gt;</span>(                          \</span><br><span class="hljs-meta">                obj-&gt;queryLocalInterface(                               \</span><br><span class="hljs-meta">                        I##INTERFACE::descriptor).get());               \</span><br><span class="hljs-meta">            <span class="hljs-keyword">if</span> (intr == NULL) &#123;                                         \</span><br><span class="hljs-meta">                intr = new Bp##INTERFACE(obj);                          \</span><br><span class="hljs-meta">            &#125;                                                           \</span><br><span class="hljs-meta">        &#125;                                                               \</span><br><span class="hljs-meta">        return intr;                                                    \</span><br><span class="hljs-meta">    &#125;                                                                   \</span><br><span class="hljs-meta">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span><br><span class="hljs-meta">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span><br></code></pre></td></tr></table></figure><ul><li><strong>BnDemoService.cpp:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/Log.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/Errors.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/Parcel.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;BnDemoService.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_D ALOGD</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_E ALOGE</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> android;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><span class="hljs-keyword">using</span> ::vendor::harman::hardware::demoComponent::demoService::V1_0::DemoData;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BnDemoService::onTransact</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel &amp;data, Parcel *reply, <span class="hljs-type">uint32_t</span> flags)</span> </span>&#123;<br>    <span class="hljs-type">status_t</span> retCode = NO_ERROR;<br>    <span class="hljs-keyword">switch</span> (code) &#123;<br>        <span class="hljs-keyword">case</span> SET_STATUS:&#123;<br>            <span class="hljs-built_in">LOG_D</span>(<span class="hljs-string">&quot;BnDemoService SET_STATUS()&quot;</span>);<br>            <span class="hljs-built_in">CHECK_INTERFACE</span>(IDemoService, data, reply);<br>            DemoData sta;<br>            data.<span class="hljs-built_in">read</span>(&amp;sta, <span class="hljs-built_in">sizeof</span>(DemoData));<br>            reply-&gt;<span class="hljs-built_in">writeInt32</span>(<span class="hljs-built_in">setStatus</span>(sta));<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> REGISTER_CALLBACK:&#123;<br>            <span class="hljs-built_in">LOG_D</span>(<span class="hljs-string">&quot;BnDemoService REGISTER_CALLBACK()&quot;</span>);<br>            <span class="hljs-built_in">CHECK_INTERFACE</span>(IDemoService, data, reply);<br>            ::android::sp&lt;IDemoCallback&gt; rcb;<br>            data.<span class="hljs-built_in">read</span>(&amp;rcb, <span class="hljs-built_in">sizeof</span>(::android::sp&lt;IDemoCallback&gt;));<br>            reply-&gt;<span class="hljs-built_in">writeInt32</span>(<span class="hljs-built_in">registerCallback</span>(rcb));<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> UNREGISTER_CALLBACK: &#123;<br>            <span class="hljs-built_in">LOG_D</span>(<span class="hljs-string">&quot;BnDemoService UNREGISTER_CALLBACK()&quot;</span>);<br>            <span class="hljs-built_in">CHECK_INTERFACE</span>(IDemoService, data, reply);<br>            sp&lt;IDemoCallback&gt; urcb;<br>            data.<span class="hljs-built_in">read</span>(&amp;urcb, <span class="hljs-built_in">sizeof</span>(::android::sp&lt;IDemoCallback&gt;));<br>            reply-&gt;<span class="hljs-built_in">writeInt32</span>(<span class="hljs-built_in">unregisterCallback</span>(urcb));<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>: &#123;<br>            <span class="hljs-built_in">LOG_E</span>(<span class="hljs-string">&quot;BnDemoService::onTransact(0x%x,0x%x)&quot;</span>, code, flags);<br>            retCode = BBinder::<span class="hljs-built_in">onTransact</span>(code, data, reply, flags);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> retCode;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Bn 端的源文件里对 <code>onTransact()</code> 进行实现，使用 <code>switch...case...</code> 对 Command code 进行处理。<strong>在每个 case 的末尾可以看到对 demoService 里各个方法的调用</strong>，并将调用的返回值写入 reply。</p><h2 id="4-编译与打包"><a href="#4-编译与打包" class="headerlink" title="4.编译与打包"></a>4.编译与打包</h2><h3 id="4-1-编写Makefile"><a href="#4-1-编写Makefile" class="headerlink" title="4.1 编写Makefile"></a>4.1 编写Makefile</h3><p><strong>这里说的 Makefile 是指 <code>Android.bp</code>（当然也可以使用 <code>Android.mk</code>，语法稍有区别）</strong>。</p><p>在 <code>default/</code> 目录下新建文件 <code>Android.bp</code>，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cc_defaults &#123;<br>    name: <span class="hljs-string">&quot;demoSvc_v1_0_default&quot;</span>,<br>    shared_libs: [<br>        <span class="hljs-string">&quot;libhidlbase&quot;</span>,<br>        <span class="hljs-string">&quot;libhidltransport&quot;</span>,<br>        <span class="hljs-string">&quot;liblog&quot;</span>,<br>        <span class="hljs-string">&quot;libutils&quot;</span>,<br>        <span class="hljs-string">&quot;libhardware&quot;</span>,<br>        <span class="hljs-string">&quot;libbinder&quot;</span>,<br>        <span class="hljs-string">&quot;vendor.harman.hardware.demoComponent.demoService@1.0_vendor&quot;</span>,<br>    ],<br>    cflags: [<br>        <span class="hljs-string">&quot;-Wall&quot;</span>,<br>        <span class="hljs-string">&quot;-Wextra&quot;</span>,<br>        <span class="hljs-string">&quot;-Werror&quot;</span>,<br>    ],<br>&#125;<br><br>cc_binary &#123;<br>    name: <span class="hljs-string">&quot;vendor.harman.demoComponent.demoService@1.0-service&quot;</span>,<br>    defaults: [<span class="hljs-string">&quot;demoSvc_v1_0_default&quot;</span>],<br>    init_rc: [<span class="hljs-string">&quot;vendor.harman.demoComponent.demoService@1.0-service.rc&quot;</span>],<br>    vendor: <span class="hljs-literal">true</span>,<br>    relative_install_path: <span class="hljs-string">&quot;hw&quot;</span>,<br><br>    include_dirs:[<span class="hljs-string">&quot;vendor/harman/hardware/interfaces/demoComponent/demoService/1.0/default&quot;</span>],<br>    srcs: [<br>        <span class="hljs-string">&quot;DemoService.cpp&quot;</span>,<br>        <span class="hljs-string">&quot;DemoServiceImpl.cpp&quot;</span>,<br>        <span class="hljs-string">&quot;BpDemoService.cpp&quot;</span>,<br>        <span class="hljs-string">&quot;BnDemoService.cpp&quot;</span><br>    ],<br>    shared_libs: [<br>        <span class="hljs-string">&quot;libbase&quot;</span>,<br>        <span class="hljs-string">&quot;libprotobuf-cpp-lite&quot;</span>,<br>        <span class="hljs-string">&quot;vendor.harman.hardware.demoComponent.demoService@1.0_vendor&quot;</span><br>    ],<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>目标 demoSvc_v1_0_default 可以理解成是将和 Binder 框架相关的库打包而成的一个总的库文件，<a href="mailto:&#x76;&#x65;&#x6e;&#x64;&#x6f;&#x72;&#x2e;&#x68;&#x61;&#114;&#x6d;&#97;&#x6e;&#x2e;&#104;&#97;&#114;&#100;&#119;&#97;&#x72;&#101;&#46;&#100;&#101;&#x6d;&#x6f;&#67;&#111;&#x6d;&#x70;&#111;&#110;&#x65;&#x6e;&#116;&#x2e;&#x64;&#x65;&#x6d;&#x6f;&#x53;&#101;&#x72;&#x76;&#105;&#99;&#x65;&#64;&#x31;&#x2e;&#48;&#95;&#x76;&#101;&#110;&#100;&#111;&#x72;">&#x76;&#x65;&#x6e;&#x64;&#x6f;&#x72;&#x2e;&#x68;&#x61;&#114;&#x6d;&#97;&#x6e;&#x2e;&#104;&#97;&#114;&#100;&#119;&#97;&#x72;&#101;&#46;&#100;&#101;&#x6d;&#x6f;&#67;&#111;&#x6d;&#x70;&#111;&#110;&#x65;&#x6e;&#116;&#x2e;&#x64;&#x65;&#x6d;&#x6f;&#x53;&#101;&#x72;&#x76;&#105;&#99;&#x65;&#64;&#x31;&#x2e;&#48;&#95;&#x76;&#101;&#110;&#100;&#111;&#x72;</a> 是通过接口描述文件自动生成的，同样可以在 &#x2F;out&#x2F;soong&#x2F;.intermediates&#x2F;… 目录下找到；</p></li><li><p>目标 <a href="mailto:&#x76;&#x65;&#110;&#100;&#111;&#x72;&#46;&#104;&#97;&#114;&#x6d;&#97;&#110;&#46;&#100;&#101;&#x6d;&#111;&#67;&#111;&#x6d;&#112;&#x6f;&#x6e;&#101;&#x6e;&#x74;&#46;&#x64;&#x65;&#x6d;&#111;&#83;&#x65;&#114;&#x76;&#105;&#x63;&#101;&#64;&#49;&#46;&#48;&#45;&#x73;&#x65;&#x72;&#x76;&#105;&#x63;&#101;">&#x76;&#x65;&#110;&#100;&#111;&#x72;&#46;&#104;&#97;&#114;&#x6d;&#97;&#110;&#46;&#100;&#101;&#x6d;&#111;&#67;&#111;&#x6d;&#112;&#x6f;&#x6e;&#101;&#x6e;&#x74;&#46;&#x64;&#x65;&#x6d;&#111;&#83;&#x65;&#114;&#x76;&#105;&#x63;&#101;&#64;&#49;&#46;&#48;&#45;&#x73;&#x65;&#x72;&#x76;&#105;&#x63;&#101;</a> 就是最终要生成的可执行文件；</p></li><li><p>属性 vendor: true 表示这是一个自定义的文件；</p></li><li><p>属性 relative_install_path: “hw” 和前一个属性共同作用，表示生成文件的相对存放位置在 <code>out/target/product/&lt;ProductName&gt;/vendor/bin/hw/ </code>目录；</p></li><li><p>属性 srcs 属性下包含了我们在之前几篇文章里编写的所有源文件 —— DemoService.cpp、DemoServiceImpl.cpp、BpDemoService.cpp 和 BnDemoService.cpp。</p></li></ul><h3 id="4-2-编写HAL启动脚本"><a href="#4-2-编写HAL启动脚本" class="headerlink" title="4.2 编写HAL启动脚本"></a>4.2 编写HAL启动脚本</h3><p>基于上述的 Makefile 在 <code>default/</code> 目录下<strong>手动（mm 命令）</strong>进行编译，我们能得到名为 <code>vendor.harman.demoComponent.demoService@1.0-service</code> 的可执行文件。为了让 demoComponent HAL 随系统启动而启动，我们还需要编写 <code>*.rc</code> 脚本，并在脚本中标注进程名、可执行文件、用户组等信息。</p><p>一般以可执行文件名作为脚本名，也就是 <code>vendor.harman.demoComponent.demoService@1.0-service.rc</code>。</p><p>在 <code>default/</code> 目录下新建脚本，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">service MyDemoService /vendor/bin/hw/vendor.harman.demoComponent.demoService@1.0-service<br>    class main<br>    user system<br>    group system<br>    capabilities sys_nice net_bind_service net_admin net_raw<br></code></pre></td></tr></table></figure><ul><li><p>关键字 service 用来定义一个进程（或称为本地服务），后面第一个参数 MyDemoService 是进程名，第二个参数是可执行文件的绝对路径；</p></li><li><p>class main 表示把 MyDemoService 归属到 main 类；</p></li><li><p>user system 和 group system 表示 MyDemoService 的用户和组用户都是 system；</p></li><li><p>capabilities 指定了一些权限相关的属性。</p></li></ul><h3 id="4-3-打包可执行文件到系统镜像"><a href="#4-3-打包可执行文件到系统镜像" class="headerlink" title="4.3 打包可执行文件到系统镜像"></a>4.3 打包可执行文件到系统镜像</h3><p>要实现 demoComponent HAL 随系统启动而启动，需要将它的 <code>可执行文件</code> 和 <code>*.rc</code> 文件都打包进系统镜像。通过修改产品的 Makefile 可以实现这一目的。</p><p>先在 <code>/device/&lt;CompanyName&gt;/&lt;PlatformName&gt;/common/</code> 路径下为 demoComponent HAL 新建一个名为 <code>demoComponent/</code> 的专属目录，再在这个目录下创建名为 <code>device_demoComponent.mk</code> 的 Makefile。（其实叫什么名字都可以，但是用 demoComponent 更直观）</p><p><strong>如此一来我们就有了 <code>/device/harman/broxton/common/demoComponent/device_demoComponent.mk</code>。</strong> 除去注释，Makefile 内容只有一句话：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">############################</span><br><span class="hljs-comment"># DemoService</span><br><span class="hljs-comment">############################</span><br><br>PRODUCT_PACKAGES += vendor.harman.demoComponent.demoService@1.0-service<br></code></pre></td></tr></table></figure><p>这句话表示要将可执行文件 <code>vendor.harman.demoComponent.demoService@1.0-service</code> 打包进系统镜像，确切地说是打包进 <code>vendor.img</code>。</p><p>切记，不要忘了把我们新建的 Makefile 添加到产品的 Makefile 中。 产品 Makefile 一般位于 <code>/device/&lt;CompanyName&gt;/&lt;PlatformName&gt;/&lt;ProductName&gt;/device.mk</code>，所以我们在 <code>/device/harman/broxton/XXXX/device.mk</code> 中增加以下语句（以 diff 形式展示）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">diff --git a/XXXX/device.mk b/XXXX/device.mk<br>index b0866f3d2..d7a7d8ef7 100755<br>--- a/XXXX/device.mk<br>+++ b/XXXX/device.mk<br>@@ -1,5 +1,6 @@<br> <span class="hljs-keyword">include</span> device/harman/broxton/common/device_common.mk<br> <span class="hljs-keyword">include</span> <span class="hljs-variable">$(LOCAL_PATH)</span>/audio/device_audio.mk<br>+<span class="hljs-keyword">include</span> device/harman/broxton/common/demoComponent/device_demoComponent.mk<br> <span class="hljs-keyword">include</span> device/harman/broxton/common/tuner/device_radioTuner.mk<br> <span class="hljs-keyword">include</span> device/harman/broxton/common/speech/vpa.mk<br></code></pre></td></tr></table></figure><p>注意上面以 <code>+</code> 开头的 <code>include</code> 语句，就是在引用我们的新建 Makefile。</p><hr><p><strong>【结语】</strong></p><p>打包已经完成，我们的 demoComponent HAL 正跃跃欲试。但如果你将打包好的系统镜像烧写到设备上，会发现 demoComponent HAL 不能按照预期工作，甚至连自启动都做不到。相反，我们会在 logcat 或 dmesg 里发现有很多日志提示我们没有操作权限。 下一节《添加执行权限》将介绍如何给 demoComponent HAL 添加必要的权限。</p><p>如果你急切地想看一看刚刚写好的 HAL 进程运行的样子，可以执行命令 <code>setenforce 0</code> 将设备的 SELinux 策略暂时关闭。 这样尽管系统仍然会报告权限错误，但不会禁止运行。</p><h2 id="5-添加执行权限"><a href="#5-添加执行权限" class="headerlink" title="5.添加执行权限"></a>5.添加执行权限</h2><p><strong>【前言】</strong></p><p>demoComponent HAL 已经成功编译且打包到系统镜像中，但到目前为止还没有被赋予访问 Binder 的权限。所以我们至少会看到，在将 demoService 注册为 Binder 服务时，日志中会打印类似下方的提示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[   <span class="hljs-number">10.368517</span>] type=<span class="hljs-number">1400</span> <span class="hljs-built_in">audit</span>(<span class="hljs-number">1483292256.112</span>:<span class="hljs-number">14</span>): avc: denied &#123; add &#125; ...<br></code></pre></td></tr></table></figure><p>这篇文章就是要说明完善 demoComponent HAL 所需要的 SELinux 权限的方法。</p><h3 id="5-1-编写策略文件"><a href="#5-1-编写策略文件" class="headerlink" title="5.1 编写策略文件"></a>5.1 编写策略文件</h3><p>依各公司习惯不同，用于配置产品权限的文件一般放在 <code>/device/&lt;CompanyName&gt;/sepolicy/</code> 或 <code>/device/&lt;CompanyName&gt;/common/sepolicy/</code> 目录下（也不排除是其它路径的可能性，但肯定是在<code>device/</code> 目录下的某个 <code>sepolicy/ </code>子目录）。在这个目录下，再为不同的部件分别创建相应的子目录，并在这个子目录中新建 <code>*.te</code> 文件和 <code>*_contexts</code> 文件，以添加必要的权限。</p><p>还是以我正在使用的平台为例，创建新目录 <code>/device/harman/sepolicy/demoComponent/</code>，并在该目录下新建如下图所示的文件：</p><img src="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/20200720203213989.png"><p>说明下各文件的内容和作用：</p><ul><li><strong>file_contexts:</strong><ul><li>首先编写 <code>file_contexts</code> 文件。这个文件名是由 SELinux 框架固定的。我们在 <code>file_contexts</code> 中将 demoService 的可执行文件定义为安全对象。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> demoService executable binary as a security object</span><br>/vendor/bin/hw/vendor.harman.demoComponent.demoService@<span class="hljs-number">1.0</span>-service   u:object_r:demoService_exec:s0<br></code></pre></td></tr></table></figure><ul><li><strong>hwservice_contexts:</strong><ul><li>然后，因为 demoComponent HAL 依赖 hwbinder 进行通信，所以我们还需要编写 <code>hwservice_contexts</code>。这个文件名也是由 SELinux 框架固定的。我们在这个文件中将新增的接口定义为一个安全对象，作用和 file_contexts 类似。（如果使用 vndbinder，则应编写 vndservice_contexts）</li><li>从 Android 8.0 开始，SELinux 也一分为二成为了 system 部分和 vendor 部分。其中 vendor 部分又因为不同部件使用的 binder 节点不同，从原先唯一的的 <code>service_contexts</code> 中剥离出了 <code>hwservice_contexts</code> 和 <code>vndservice_contexts</code> 两个文件。当使用 &#x2F;dev&#x2F;hwbinder 时手动创建前者并在文件中添加定义，当使用 &#x2F;dev&#x2F;vndbinder 时创建后者并同样在文件中添加定义。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> HAL interface as a security object</span><br>vendor.harman.hardware.demoComponent.demoService::IDemoServiceDef  u:object_r:vendor_demoService_hwservice:s0<br></code></pre></td></tr></table></figure><ul><li><strong>hwservicemanager.te</strong>:<ul><li>由于我们使用的是 hwbinder 节点，所以还应该编写 hwservicemanager.te。文件名也是固定的。在这个文件中声明 demoService 需要使用 hwbinder。（如果使用 vndbinder，则应编写 vndservicemanager.te）</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># grant demoService permission of using hwbinder</span><br><span class="hljs-built_in">hwbinder_use</span>(demoService)<br></code></pre></td></tr></table></figure><ul><li><strong>hwservice.te:</strong><ul><li>同理，编写 <code>hwservice.te</code>。文件名依然是固定的。在这个文件中为 demoService 定义了专属的 hwservice 类型，在添加 “注册服务” 权限时会用到。（如果使用 vndbinder，则应编写 <code>vndservice.te</code>）</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> demoService as hwservice_manager, so it can be added as a hwservice</span><br>type vendor_demoService_hwservice, hwservice_manager_type;<br></code></pre></td></tr></table></figure><ul><li><strong>demoService.te:</strong><ul><li>接着编写 demoService.te 文件。 这个文件通常以需要添加权限的对象为名。在这个文件中，我们为 demoService 定义了一个专属的安全域，赋予可 demoService 的执行文件以需要的文件属性，并且为 demoService 域添加和 Binder 操作相关的必要权限，比如 “注册为服务”、“允许 hwbinder 调用” 等。</li><li>不同的 HAL 进程或本地服务要操作的文件不同，其实现的作用也不同，所以这个文件里的内容差异也很大。依照最小权限规则，根据自己的实际需要添加权限即可。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> a security domain for demo service</span><br>type demoService, domain;<br><br><span class="hljs-meta"># specify demo service attributes</span><br>type demoService_exec, exec_type, file_type, vendor_file_type;<br><br><span class="hljs-meta"># initialize demo service domain</span><br><span class="hljs-built_in">init_daemon_domain</span>(demoService)<br><br><span class="hljs-built_in">add_hwservice</span>(demoService, vendor_demoService_hwservice)<br><br><span class="hljs-built_in">binder_call</span>(demoService, vndservicemanager)<br><span class="hljs-built_in">binder_call</span>(demoService, hwservicemanager)<br><span class="hljs-built_in">binder_call</span>(demoService, system_app)<br><br>allow demoService vndbinder_device:chr_file rw_file_perms;<br>allow demoService hwservicemanager_prop:file r_file_perms;<br></code></pre></td></tr></table></figure><ul><li><strong>system_app.te:</strong><ul><li>最后，还要为用户进程添加调用权限。我们通常会以 APP 对 demoService 的调用为例说明调用过程，所以这里新建 <code>system_app.te</code>。为 system_app 添加通过 hwservice_manager 查找服务、以及通过 binder 调用 demoService 的权限。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"># <span class="hljs-function">APP access priviledges <span class="hljs-keyword">for</span> demoService</span><br><span class="hljs-function"><span class="hljs-title">binder_call</span><span class="hljs-params">(system_app, demoService)</span></span><br><span class="hljs-function">allow system_app vendor_demoService_hwservice:hwservice_manager find;</span><br></code></pre></td></tr></table></figure><h3 id="5-2-应用策略文件"><a href="#5-2-应用策略文件" class="headerlink" title="5.2 应用策略文件"></a>5.2 应用策略文件</h3><p>为了使新增的安全规则生效，需要将刚刚创建的目录添加到 Makefile 中，这样一来编译镜像时就可以扫描到了。我们一般把这个改动添加到 <code>/device/&lt;CompanyName&gt;/&lt;PlatformName&gt;/&lt;ProductName&gt;/BoardConfig.mk</code>。</p><p>这里我改动的文件是 <code>/device/harman/broxton/XXXX/BoardConfig.mk</code>，修改部分如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile">diff --git a/XXXX/BoardConfig.mk b/XXXX/BoardConfig.mk<br>index 4979507a7..8e700f22d 100755<br>--- a/XXXX/BoardConfig.mk<br>+++ b/XXXX/BoardConfig.mk<br>@@ -72,6 +72,12 @@ BOARD_SEPOLICY_DIRS += device/harman/sepolicy/vold<br> INTEL_AUDIO_HAL=imc<br> BOARD_SEPOLICY_DIRS += device/harman/sepolicy/audio<br>+<br>+<span class="hljs-comment">########################################################</span><br>+<span class="hljs-comment"># DemoService</span><br>+<span class="hljs-comment">########################################################</span><br>+BOARD_SEPOLICY_DIRS += device/harman/sepolicy/demoComponent<br>+<br></code></pre></td></tr></table></figure><hr><p><strong>【结语】</strong></p><p>完全编译后，烧写镜像到设备上。待设备启动后，执行命令 <code>ps -A | grep -i demo</code> ，终于可以看到我们的 demoComponent HAL 进程已经随系统启动成功。</p><img src="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/2020072020305469.png"><p>如果在系统刚启动时执行命令 <code>logcat | grep -i demo</code>，还可以看到 demoComponent HAL 注册为 Binder 服务的日志打印：</p><img src="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/20200720203133940.png"><h2 id="6-感谢"><a href="#6-感谢" class="headerlink" title="6.感谢"></a>6.感谢</h2><p>🎊再次感谢大佬【Qidi_Huang】的精彩博客！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理学习笔记</title>
    <link href="/2023/03/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="《哈工大编译原理》学习笔记"><a href="#《哈工大编译原理》学习笔记" class="headerlink" title="《哈工大编译原理》学习笔记"></a>《哈工大编译原理》学习笔记</h1><blockquote><p>本系列博客主要记录自己学习编译原理的笔记，并手写一个C语言编译器</p><ul><li>☃️<strong>编译原理学习资料</strong>：哈工大陈鄞老师的《编译原理》</li></ul></blockquote><ul><li><p>✏️第一章：<a href="https://anmuxixixi.github.io/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/">编译原理绪论</a></p></li><li><p>🖊️第二章：<a href="https://anmuxixixi.github.io/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/">词法及文法</a></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二、语言及其文法</title>
    <link href="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/"/>
    <url>/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="二、语言及文法"><a href="#二、语言及文法" class="headerlink" title="二、语言及文法"></a>二、语言及文法</h1><h2 id="1-字母表"><a href="#1-字母表" class="headerlink" title="1.字母表"></a>1.字母表</h2><p>字母表Σ是一个有穷符号集合；这里的符号可以是字母、数字、标点符号……下面的例子都是字母表</p><ul><li>二进制字母表：{0,1}</li><li>ASCII字符集</li><li>Unicode字符集</li></ul><p>字母表有下面几种运算：</p><ul><li>乘积</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235051480.png" alt="image-20230302235051480" style="zoom:50%;"><ul><li>n次幂</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235116133.png" alt="image-20230302235116133" style="zoom:50%;"><ul><li>正闭包</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235140690.png" alt="image-20230302235140690" style="zoom:50%;"><ul><li>克林闭包</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235156202.png" alt="image-20230302235156202" style="zoom:50%;"><h2 id="2-串"><a href="#2-串" class="headerlink" title="2.串"></a>2.串</h2><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235218276.png" alt="image-20230302235218276" style="zoom: 50%;"><p>下面介绍一下串上的运算：</p><ul><li>连接</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235351581.png" alt="image-20230302235351581" style="zoom: 50%;"><ul><li>幂</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235405401.png" alt="image-20230302235405401" style="zoom:50%;"><h2 id="3-文法的定义"><a href="#3-文法的定义" class="headerlink" title="3.文法的定义"></a>3.文法的定义</h2>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、编译原理绪论</title>
    <link href="/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="一、编译原理绪论"><a href="#一、编译原理绪论" class="headerlink" title="一、编译原理绪论"></a>一、编译原理绪论</h1><h2 id="1-什么是编译"><a href="#1-什么是编译" class="headerlink" title="1.什么是编译"></a>1.什么是编译</h2><p>🫁<strong>编译</strong>：将高级语言【源语言】翻译成汇编语言或机器语言【目标语言】的过程</p><img src="/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/image-20230302225554584.png" alt="image-20230302225554584" style="zoom:67%;"><p>我们把C语言中的x &#x3D; 2编译成汇编语言<code>MOV X,2</code>，或是直接编译成机器语言<code>C706 0000 0002</code></p><p><strong>下面我们看一下整个编译的流程：</strong></p><img src="/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/image-20230302225855228.png" alt="image-20230302225855228" style="zoom: 67%;"><ul><li>预处理器：把存储在不同文件中的源程序聚合在一起；把被称为宏的缩写语句转换为原始语句</li><li>可重定位的机器代码：汇编器生成的可重定位起始代码在内存中存放的起始位置不是固定的，所有地址都是相对于起始位置的相对地址</li><li>加载器：修改可重定位地址；将修改后的指令和数据放在内存中适合的位置</li><li>链接器：将多个可重定位的机器代码文件（包括库文件）连接到一起；解决外部内部地址问题</li></ul><h2 id="2-编译器的结构"><a href="#2-编译器的结构" class="headerlink" title="2.编译器的结构"></a>2.编译器的结构</h2><img src="/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/image-20230302230959458.png" alt="image-20230302230959458" style="zoom:67%;"><p>编译器大致可以分为三个部分：</p><ul><li><p>前端部分，与源语言相关，也就是与我们写的高级语言C&#x2F;Java等有关</p></li><li><p>后端部分，与目标语言相关，也就是生成的目标机器语言</p></li><li><p>中间部分：机器无关代码优化器</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kernel下输入输出console如何实现</title>
    <link href="/2023/02/25/kernel%E4%B8%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BAconsole%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/02/25/kernel%E4%B8%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BAconsole%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="kernel下输入输出console如何实现"><a href="#kernel下输入输出console如何实现" class="headerlink" title="kernel下输入输出console如何实现"></a>kernel下输入输出console如何实现</h1><blockquote><p>🍛<strong>大部分内容转载自</strong>：</p><ul><li><a href="https://www.cnblogs.com/lifexy/p/7993136.html">https://www.cnblogs.com/lifexy/p/7993136.html</a></li><li><a href="https://blog.csdn.net/skyflying2012/article/details/41078349?spm=1001.2014.3001.5506">https://blog.csdn.net/skyflying2012/article/details/41078349?spm=1001.2014.3001.5506</a></li></ul></blockquote><h2 id="1-在驱动调试中-使用printk-是最简单-最方便的办法"><a href="#1-在驱动调试中-使用printk-是最简单-最方便的办法" class="headerlink" title="1.在驱动调试中,使用printk(),是最简单,最方便的办法"></a>1.在驱动调试中,使用printk(),是最简单,最方便的办法</h2><p>✨<strong>先说结论，当uboot命令行中设置不同的console参数，输出到的设备不同：</strong></p><ul><li><p>当uboot的命令行里的<strong>“console&#x3D;tty1”</strong>时,表示printk()输出在开发板的LCD屏上</p></li><li><p>当uboot的命令行里的<strong>“console&#x3D;ttySA0,115200”</strong>时,表示printk()输出在串口UART0上,波特率&#x3D;115200</p></li><li><p>当uboot的命令行里的<strong>“console&#x3D;tty1 console&#x3D;ttySA0,115200”</strong>时,表示printk()同时输出在串口上,以及开发板的LCD屏上</p></li></ul><p>内核又是怎么根据上面命令行参数来确定printk()的输出设备？</p><h2 id="2-以console-ttySA0-115200为例分析printk"><a href="#2-以console-ttySA0-115200为例分析printk" class="headerlink" title="2.以console=ttySA0,115200为例分析printk"></a>2.以<code>console=ttySA0,115200</code>为例分析printk</h2><h3 id="2-1-命令行激活-setup"><a href="#2-1-命令行激活-setup" class="headerlink" title="2.1 命令行激活__setup"></a>2.1 命令行激活__setup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel\printk\printk.c</span><br>__setup(<span class="hljs-string">&quot;console=&quot;</span>, console_setup);<br></code></pre></td></tr></table></figure><p>**__setup()**的作用就是：若uboot传递进来的命令行字符串里含有“console&#x3D;”,便调用console_setup()函数,并对“console&#x3D;”后面带的字符串”ttySA0,115200”进行分析</p><h3 id="2-2-调用console-setup函数"><a href="#2-2-调用console-setup函数" class="headerlink" title="2.2 调用console_setup函数"></a>2.2 调用console_setup函数</h3><p>我们以ttySA0,115200为例，分析一个<code>console_setup</code>函数，这里注意一下，这里结构体和数组同名，都是<code>console_cmdline</code>，区分一下🐖</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CMDLINECONSOLES 8</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console_cmdline</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span>name[<span class="hljs-number">16</span>];<span class="hljs-comment">/* Name of the driver    */</span><br><span class="hljs-type">int</span>    index;<span class="hljs-comment">/* Minor dev. to use    */</span><br><span class="hljs-type">char</span>*options;<span class="hljs-comment">/* Options for the driver   */</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console_cmdline</span> <span class="hljs-title">console_cmdline</span>[<span class="hljs-title">MAX_CMDLINECONSOLES</span>];</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">console_setup</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span>                    <span class="hljs-comment">//*str=&quot;ttySA0,115200&quot;</span><br>&#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-keyword">sizeof</span>(console_cmdline[<span class="hljs-number">0</span>].name)];     <span class="hljs-comment">// char name[16]</span><br>    <span class="hljs-type">char</span> *s, *options;<br>    <span class="hljs-type">int</span> idx; <br><br>    <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;                    <br>            <span class="hljs-built_in">strcpy</span>(name, <span class="hljs-string">&quot;ttyS&quot;</span>);<br>            <span class="hljs-built_in">strncpy</span>(name + <span class="hljs-number">4</span>, str, <span class="hljs-keyword">sizeof</span>(name) - <span class="hljs-number">5</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">strncpy</span>(name, str, <span class="hljs-keyword">sizeof</span>(name) - <span class="hljs-number">1</span>);   <span class="hljs-comment">//*name=&quot;ttySA0,115200&quot;</span><br>    &#125;<br><br>    name[<span class="hljs-keyword">sizeof</span>(name) - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">if</span> ((options = <span class="hljs-built_in">strchr</span>(str, <span class="hljs-string">&#x27;,&#x27;</span>)) != <span class="hljs-literal">NULL</span>)   <span class="hljs-comment">// 找到&#x27;,&#x27;,返回给options</span><br>            *(options++) = <span class="hljs-number">0</span>;                <span class="hljs-comment">//*options=&quot;115200&quot;</span><br><br><br>    <span class="hljs-keyword">for</span> (s = name; *s; s++)                                     <span class="hljs-comment">//*s=&quot;0&quot;</span><br>            <span class="hljs-keyword">if</span> ((*s &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; *s &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || *s == <span class="hljs-string">&#x27;,&#x27;</span>)<br>                    <span class="hljs-keyword">break</span>;<br><br>idx = simple_strtoul(s, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>);   <span class="hljs-comment">//和strtoul()一样,将s中的&quot;0&quot;提出来,所以idx=0</span><br>    *s = <span class="hljs-number">0</span>;<br><br>add_preferred_console(name, idx, options);      <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的代码和注释得到，最终调用add_preferred_console(“ttySA”, 0, “115200”)函数来添加控制台</p><h3 id="2-3-调用add-preferred-console函数"><a href="#2-3-调用add-preferred-console函数" class="headerlink" title="2.3 调用add_preferred_console函数"></a>2.3 调用add_preferred_console函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add_preferred_console</span><span class="hljs-params">(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> idx, <span class="hljs-type">char</span> *options)</span><br>&#123;<br><span class="hljs-keyword">return</span> __add_preferred_console(name, idx, options, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __add_preferred_console(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> idx, <span class="hljs-type">char</span> *options, <span class="hljs-type">char</span> *brl_options)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console_cmdline</span> *<span class="hljs-title">c</span>;</span><br><span class="hljs-type">int</span> i;<br><br>    <span class="hljs-comment">// MAX_CMDLINECONSOLES=8,表示最多添加8个控制台</span><br>    <span class="hljs-comment">// 这是直接将c指向了全局变量console_cmdline</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, c = console_cmdline; i &lt; MAX_CMDLINECONSOLES &amp;&amp; c-&gt;name[<span class="hljs-number">0</span>]; i++, c++) &#123;<br>        <span class="hljs-comment">// 该console名字和下标好已经存在了【目的是为了去重】</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(c-&gt;name, name) == <span class="hljs-number">0</span> &amp;&amp; c-&gt;index == idx) &#123;<br><span class="hljs-keyword">if</span> (!brl_options)<br>selected_console = i;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>    <br>    <span class="hljs-comment">// i == 8,表示数组存满了</span><br><span class="hljs-keyword">if</span> (i == MAX_CMDLINECONSOLES)<br><span class="hljs-keyword">return</span> -E2BIG;<br><span class="hljs-keyword">if</span> (!brl_options)<br>selected_console = i; <span class="hljs-comment">// 将selected_console设置为最新添加的console_cmdline的下标号</span><br><br>strlcpy(c-&gt;name, name, <span class="hljs-keyword">sizeof</span>(c-&gt;name));<br>c-&gt;options = options;<br>braille_set_options(c, brl_options);<br><br>c-&gt;index = idx;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>__add_preferred_console</code>将name idx options保存到数组下一个成员console_cmdline结构体中，如果数组中已有重名，则不添加，并置selected_console为最新添加的console_cmdline的下标号。</p><p>比如cmdline中有“console&#x3D;ttyS0,115200 console&#x3D;ttyS1,9600”</p><p>则在console_cmdline[8]数组中console_cmdline[0]代表ttyS0，console_cmdline[1]代表ttyS1，而selected_console&#x3D;1.</p><h3 id="2-4-kernel下如何选择printk-console"><a href="#2-4-kernel下如何选择printk-console" class="headerlink" title="2.4 kernel下如何选择printk console"></a>2.4 kernel下如何选择printk console</h3><p>根据<a href="https://anmuxixixi.github.io/2023/02/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E5%86%85%E6%A0%B8%E8%BE%93%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/">printk的实现原理</a>，printk最后调用console_unlock实现log_buf数据刷出到指定设备。</p><p>这里先不关心printk如何处理log buf数据(比如添加内容级别)，只关心printk如何一步步找到指定的输出设备，根据printk.c代码，可以找到如下线索。</p><p><strong>printk-&gt;vprintk-&gt;console_unlock-&gt;call_console_drivers</strong></p><p>看线索最底层的call_console_drivers</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> *<span class="hljs-title">console_drivers</span>;</span> <span class="hljs-comment">// 全局</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> for_each_console(con) \</span><br><span class="hljs-meta">for (con = console_drivers; con != NULL; con = con-&gt;next)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">call_console_drivers</span><span class="hljs-params">(<span class="hljs-type">int</span> level, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *text, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> *<span class="hljs-title">con</span>;</span><br><br>trace_console(text, len);<br><br><span class="hljs-keyword">if</span> (level &gt;= console_loglevel &amp;&amp; !ignore_loglevel)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (!console_drivers)<br><span class="hljs-keyword">return</span>;<br><br>for_each_console(con) &#123;<br><span class="hljs-keyword">if</span> (exclusive_console &amp;&amp; con != exclusive_console)  <span class="hljs-comment">// 如果指明了唯一的console，且当前不是那个console</span><br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (!(con-&gt;flags &amp; CON_ENABLED))  <span class="hljs-comment">// 当前的console不是enabled的</span><br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (!con-&gt;write)   <span class="hljs-comment">// 当前console没有write函数</span><br><span class="hljs-keyword">continue</span>;<br>con-&gt;write(con, text, len);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历console_drivers链表所有console struct，调用所有<u><strong>ENABLE</strong></u>的console的write方法将log buf中start到end的内容发出。</p><blockquote><p>到这里就很明了了，kernel下每次printk打印，首先存log_buf，然后遍历console_drivers，找到合适console，刷出log。</p><p>console_drivers链表的成员是哪里来的，接着来看下一部分，kernel下console的注册</p></blockquote><h3 id="2-5-console驱动注册"><a href="#2-5-console驱动注册" class="headerlink" title="2.5 console驱动注册"></a>2.5 console驱动注册</h3><p>接下来来搜索该数组，看看printk()如何调用控制台的硬件处理函数的。搜索到在<code>Printk.c</code>里的<code>register_console(struct console *console)</code>函数,有用到console_cmdline[]</p><p>显然,register_console()函数就用来注册控制台的,继续搜索register_console</p><img src="/2023/02/25/kernel%E4%B8%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BAconsole%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/image-20230225225234632.png" alt="image-20230225225234632" style="zoom:67%;"><p>我们以<code>drivers\tty\serial\serial_ks8695.c</code>为例，进行分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ks8695_console_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>add_preferred_console(SERIAL_KS8695_DEVNAME, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>register_console(&amp;ks8695_console);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>console_initcall(ks8695_console_init); <span class="hljs-comment">// 声明控制台初始化函数</span><br></code></pre></td></tr></table></figure><p>上面通过register_console()来注册<code>ks8695_console</code>结构体,该结构体成员如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERIAL_KS8695_DEVNAME<span class="hljs-string">&quot;ttyAM&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> <span class="hljs-title">ks8695_console</span> =</span> &#123;<br>.name= SERIAL_KS8695_DEVNAME,  <span class="hljs-comment">// 控制台名称</span><br>.write= ks8695_console_write,   <span class="hljs-comment">// 打印串口数据的硬件处理函数</span><br>.device= uart_console_device,    <span class="hljs-comment">// tty驱动</span><br>.setup= ks8695_console_setup,   <span class="hljs-comment">// 用来设置UART的波特率，发送，接收等功能</span><br>.flags= CON_PRINTBUFFER,        <span class="hljs-comment">// 标志位</span><br>.index= <span class="hljs-number">-1</span>,                     <span class="hljs-comment">// 索引</span><br>.data= &amp;ks8695_reg,            <span class="hljs-comment">// 寄存器</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在register_console()里，便会通过<code>ttyAM</code>来匹配console_cmdline[i]的名称,当匹配成功，printk()调用的console结构体便是ks8695_console了</p><p>☃️当驱动加载的时候，会走到MODULE_INIT，然后走到对应驱动注册的init函数中，在这里就是<code>ks8695_console_init</code>，紧接着会调用<code>register_console</code>，这里的register_console就是<code>printk.c</code>中的register_console。</p><hr><p>因此我们来看下printk.c中的register_console</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">register_console</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> console *newcon)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> *<span class="hljs-title">bcon</span> =</span> <span class="hljs-literal">NULL</span>;<br> <br>    <span class="hljs-comment">//如果注册的是bootconsole（kernel早期启动打印），需要检查console_drivers中</span><br>    <span class="hljs-comment">//没有“real console”也就是说bootconsole必须是第一个注册的console。</span><br>    <span class="hljs-keyword">if</span> (console_drivers &amp;&amp; newcon-&gt;flags &amp; CON_BOOT) &#123;<br>        <span class="hljs-comment">/* find the last or real console */</span><br>        for_each_console(bcon) &#123;<br>            <span class="hljs-keyword">if</span> (!(bcon-&gt;flags &amp; CON_BOOT)) &#123;<br>                printk(KERN_INFO <span class="hljs-string">&quot;Too late to register bootconsole %s%d\n&quot;</span>,<br>                    newcon-&gt;name, newcon-&gt;index);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span> (console_drivers &amp;&amp; console_drivers-&gt;flags &amp; CON_BOOT)<br>        bcon = console_drivers;<br> <br>    <span class="hljs-comment">//preferred console为console_cmdline中最后一个console</span><br>    <span class="hljs-keyword">if</span> (preferred_console &lt; <span class="hljs-number">0</span> || bcon || !console_drivers)<br>        preferred_console = selected_console;<br> <br>    <span class="hljs-keyword">if</span> (newcon-&gt;early_setup)<br>        newcon-&gt;early_setup();<br> <br>    <span class="hljs-keyword">if</span> (preferred_console &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;index &lt; <span class="hljs-number">0</span>)<br>            newcon-&gt;index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;setup == <span class="hljs-literal">NULL</span> ||<br>            newcon-&gt;setup(newcon, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">0</span>) &#123;<br>            newcon-&gt;flags |= CON_ENABLED;<br>            <span class="hljs-keyword">if</span> (newcon-&gt;device) &#123;<br>                newcon-&gt;flags |= CON_CONSDEV;<br>                preferred_console = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">//检查newcon是否是cmdline指定的console，如果是，则使能(CON_ENABLE)并初始化该console</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_CMDLINECONSOLES &amp;&amp; console_cmdline[i].name[<span class="hljs-number">0</span>];<br>            i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(console_cmdline[i].name, newcon-&gt;name) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;index &gt;= <span class="hljs-number">0</span> &amp;&amp;<br>            newcon-&gt;index != console_cmdline[i].index)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;index &lt; <span class="hljs-number">0</span>)<br>            newcon-&gt;index = console_cmdline[i].index;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;setup &amp;&amp;<br>            newcon-&gt;setup(newcon, console_cmdline[i].options) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        newcon-&gt;flags |= CON_ENABLED;<br>        newcon-&gt;index = console_cmdline[i].index;<br>        <span class="hljs-keyword">if</span> (i == selected_console) &#123;<br>            <span class="hljs-comment">//如果newcon是cmdline指定的最新的console，则置位CONSDEV</span><br>            newcon-&gt;flags |= CON_CONSDEV;<br>            preferred_console = selected_console;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">//该console没有使能，退出</span><br>    <span class="hljs-keyword">if</span> (!(newcon-&gt;flags &amp; CON_ENABLED))<br>        <span class="hljs-keyword">return</span>;<br> <br>    <span class="hljs-comment">//如果有bootconsole，则newcon不需要输出register之前的log，因为如果bootconsole和newcon是同一个设备</span><br>    <span class="hljs-comment">//则之前的log就输出2次</span><br>    <span class="hljs-keyword">if</span> (bcon &amp;&amp; ((newcon-&gt;flags &amp; (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV))<br>        newcon-&gt;flags &amp;= ~CON_PRINTBUFFER;<br> <br>    <span class="hljs-comment">//把newcon加入console_drivers链表，对于置位CON_CONSDEV的con，放在链表首</span><br>    console_lock();<br>    <span class="hljs-keyword">if</span> ((newcon-&gt;flags &amp; CON_CONSDEV) || console_drivers == <span class="hljs-literal">NULL</span>) &#123;<br>        newcon-&gt;next = console_drivers;<br>        console_drivers = newcon;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;next)<br>            newcon-&gt;next-&gt;flags &amp;= ~CON_CONSDEV;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        newcon-&gt;next = console_drivers-&gt;next;<br>        console_drivers-&gt;next = newcon;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newcon-&gt;flags &amp; CON_PRINTBUFFER) &#123;<br>        <span class="hljs-comment">//如果newcon置位PRINTBUFFER,则将log全部刷出</span><br>        raw_spin_lock_irqsave(&amp;logbuf_lock, flags);<br>        con_start = log_start;<br>        raw_spin_unlock_irqrestore(&amp;logbuf_lock, flags);<br>        <span class="hljs-comment">//修改printk输出的指定唯一exclusive_console为newcon</span><br>        <span class="hljs-comment">//保证将之前的log只输出到newcon</span><br>        exclusive_console = newcon;<br>    &#125;<br>    <span class="hljs-comment">//解锁console，刷出log到newcon</span><br>    console_unlock();<br>    console_sysfs_notify();<br> <br>    <span class="hljs-comment">//如果有bootconsole，则unregister bootconsole（从console_drivers中删掉）</span><br>    <span class="hljs-comment">//并告诉使用者现在console切换</span><br>    <span class="hljs-keyword">if</span> (bcon &amp;&amp;<br>        ((newcon-&gt;flags &amp; (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &amp;&amp;<br>        !keep_bootcon) &#123;<br>        printk(KERN_INFO <span class="hljs-string">&quot;console [%s%d] enabled, bootconsole disabled\n&quot;</span>,<br>            newcon-&gt;name, newcon-&gt;index);<br>        for_each_console(bcon)<br>            <span class="hljs-keyword">if</span> (bcon-&gt;flags &amp; CON_BOOT)<br>                unregister_console(bcon);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        printk(KERN_INFO <span class="hljs-string">&quot;%sconsole [%s%d] enabled\n&quot;</span>,<br>            (newcon-&gt;flags &amp; CON_BOOT) ? <span class="hljs-string">&quot;boot&quot;</span> : <span class="hljs-string">&quot;&quot;</span> ,<br>            newcon-&gt;name, newcon-&gt;index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果之前注册了bootconsole，则不会将该次register之前的log刷出，防止bootconsole和该次注册的newcon是同一个物理设备时，log打印2次。</p><p>如果没有bootconsole，则会指定exclusive_console&#x3D;newcon，console_unlock时，刷新全部log到该指定exclusive console。</p><p>console_unlock结束时会将exclusive_console置NULL，所以exclusive console默认情况下就是NULL。</p><p>最后会unregister bootconsole，是将bootconsole从console_drivers中删除，这样之后的printk就不会向bootconsole输出了。</p><p>有意思的一个地方是，在unregister bootconsole之前的printk：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">printk(KERN_INFO <span class="hljs-string">&quot;console [%s%d] enabled, bootconsole disabled\n&quot;</span>,<br>            newcon-&gt;name, newcon-&gt;index);<br></code></pre></td></tr></table></figure><p><u>因为此时bootconsole还没删掉，而newconsole已经加入console_drivers，如果bootconsole和newconsole是同一个物理设备，我们会看到这句printk会出现2次哦！</u></p><p>如果在cmdline指定2个I&#x2F;O设备，如<code>&quot;console==ttyS0,115200 console=ttyS1,115200&quot;</code>，因ttyS设备都是serial driver中注册的real console，所以会看到kernel的打印分别出现在2个串口上！</p><p><u><strong>boot console</strong>和<strong>real console</strong>差别在于bootconsole注册于kernel启动早期，方便对于kernel早期启动进行调试打印。</u></p><p>那这些console是在哪里调用register_console进行注册的？</p><ul><li><p>bootconsole的注册，如arch&#x2F;arm&#x2F;kernel&#x2F;early_printk.c，是在parse_args参数解析阶段注册bootconsole。</p><ul><li>在start_kernel中console_init函数也会遍历.con_initcall.init段中所有注册函数，而这些注册函数也可以来注册bootconsole。</li><li>.con_initcall.init段中函数的注册可以使用宏定义console_initcall。这些函数中调用register_console，方便在kernel初期实现printk打印。</li></ul></li><li><p>realconsole的注册，是在各个driver，如serial加载时完成。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】linux内核输出的日志去哪里了</title>
    <link href="/2023/02/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E5%86%85%E6%A0%B8%E8%BE%93%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/"/>
    <url>/2023/02/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E5%86%85%E6%A0%B8%E8%BE%93%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h1 id="linux内核输出的日志去哪里了"><a href="#linux内核输出的日志去哪里了" class="headerlink" title="linux内核输出的日志去哪里了"></a>linux内核输出的日志去哪里了</h1><blockquote><p>🍕转载自：<a href="https://mp.weixin.qq.com/s/mdDLw6AIp9ws9LTaHg64pg">https://mp.weixin.qq.com/s/mdDLw6AIp9ws9LTaHg64pg</a></p><p>🥯感谢大佬精彩的文章！！！</p></blockquote><p><img src="/2023/02/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E5%86%85%E6%A0%B8%E8%BE%93%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/image-20230221230542976.png" alt="image-20230221230542976">我们可以根据这张图，来理解printk的整体架构。</p><h2 id="1-printk实现简述"><a href="#1-printk实现简述" class="headerlink" title="1.printk实现简述"></a>1.printk实现简述</h2><h3 id="1-1-内核态printk"><a href="#1-1-内核态printk" class="headerlink" title="1.1 内核态printk"></a>1.1 内核态printk</h3><p>在内核编码时，如果想要输出一些信息，通常并不会直接使用printk，而是会使用其衍生函数，比如 pr_err &#x2F; pr_info &#x2F; pr_debug 等，这些衍生函数附带了日志级别、所属模块等其他信息，比较友好，但其最终还是调用了printk。</p><p>printk函数会将每次输出的日志，放到内核为其专门分配的名为<strong>ring buffer</strong>的一个槽位里。</p><ul><li><p>ring buffer其实就是一个用数组实现的环形队列，不过既然是环形队列，就会有一个问题，即当ring buffer满了的时候，下一条新的日志，会覆盖最开始的旧的日志。</p></li><li><p>ring buffer的大小，可以通过内核参数来修改。</p></li><li><p>printk在将日志放到ring buffer后，会再调用系统console的相关方法，将还未输出到系统控制台的消息，继续输出到控制台，这个后面会详细说，这里就暂不赘述。</p></li></ul><p>以上就是printk在内核态的实现。</p><h3 id="1-2-用户态printk"><a href="#1-2-用户态printk" class="headerlink" title="1.2 用户态printk"></a>1.2 用户态printk</h3><p>在用户态，我们有几个方式，可以查看printk输出的内核日志，比如使用dmesg命令，cat &#x2F;proc&#x2F;kmsg文件，或者是使用klogctl函数等，这些方式分别对应于全景图中用户态的橙色、绿色、和蓝色的部分。</p><p><strong>（1）dmesg命令</strong></p><p><strong>dmesg命令，在默认情况下，是通过读取&#x2F;dev&#x2F;kmsg文件</strong>，来实现查看内核日志的。</p><p>当该命令运行时，dmesg会先调用open函数，打开&#x2F;dev&#x2F;kmsg文件，该打开操作在内核中的逻辑，会为dmesg分配一个file实例，在这个file实例里，会有一个seq变量，该变量记录着下一条要读取的内核日志在ring buffer中的位置。</p><p>刚打开&#x2F;dev&#x2F;kmsg文件时，这个seq指向的就是ring buffer中最开始的那条日志。</p><p>之后，dmesg会以打开的&#x2F;dev&#x2F;kmsg文件为媒介，不断的调用read函数，从内核中读取日志消息，每读取出一条，seq的值都会加一，即指向下一条日志的位置，依次往复，直到所有的内核日志读取完毕，dmesg退出。</p><p>以上就是dmesg的主体实现。</p><p><strong>（2）cat &#x2F;proc&#x2F;kmsg 命令</strong></p><p>第二种查看内核日志的方式，是通过 cat &#x2F;proc&#x2F;kmsg 命令。</p><p>该命令和dmesg命令的实现机制基本类似，都是通过读文件，只不过cat读取的是&#x2F;proc&#x2F;kmsg文件，而dmesg读取的是&#x2F;dev&#x2F;kmsg文件。</p><p>读取这两个文件最大的区别是，&#x2F;dev&#x2F;kmsg文件每次打开时，内核都会为其分配一个单独的seq变量，而&#x2F;proc&#x2F;kmsg文件每次打开时，用的都是同一个全局的静态seq变量，叫做syslog_seq。</p><p>syslog_seq指向的也是下一条要读取的内核日志在ring buffer中的位置，但因为它是一个全局的静态变量，当有多个进程要读取&#x2F;proc&#x2F;kmsg文件时，就会有一个比较严重的问题，即内核日志会被这几个进程随机抢占读取，也就是说，每个进程读到的都是整个内核日志的一部分，是不完整的，这也是dmesg命令默认不使用&#x2F;proc&#x2F;kmsg文件的原因。</p><p><strong>（3）klogctl函数</strong></p><p>第三种查看内核日志的方式，是通过klogctl函数。</p><p>该函数是glibc对syslog系统调用的一个简单封装，其具体使用方式，可以参考全景图中用户态的蓝色部分。</p><p>klogctl函数可以指定很多命令，在上图的示例中，我们使用的是SYSLOG_ACTION_READ命令，以此来模拟 cat &#x2F;proc&#x2F;kmsg 行为。</p><p>其实在内核层面，cat &#x2F;proc&#x2F;kmsg命令，使用的就是klogctl对应的syslog系统调用的SYSLOG_ACTION_READ命令的处理逻辑，所以示例中的klogctl函数相关代码，和 cat &#x2F;proc&#x2F;kmsg 命令其实是等价的。</p><p>也就是说，klogctl函数在内核里使用的也是syslog_seq变量，它也有和&#x2F;proc&#x2F;kmsg文件同样的问题。</p><p><strong>（4）系统控制台</strong></p><p>其实还有一种方式可以查看内核日志，就是通过系统控制台。</p><p>但这种方式和前面讲的三种方式都不一样，它是完全被动的，是内核在调用printk函数，将日志信息放到ring buffer后，再去通知系统控制台，告知其可以输出这些日志。</p><p>系统控制台也是通过一个console_seq变量，记录下一条要输出内核日志的所在位置。</p><p>系统控制台输出的内容，是被日志级别过滤过的，内核默认的日志过滤级别是7，即debug级别以上的日志，比如info &#x2F; err 等，这些都会输出，但debug级别不会输出。</p><p>该日志过滤级别，可以通过很多方式改变，比如说，可以通过内核参数 loglevel，所以，如果发现系统控制台没有输出想要的日志信息，先看下其是否被过滤掉了。</p><h2 id="2-kernel日志调试设置"><a href="#2-kernel日志调试设置" class="headerlink" title="2.kernel日志调试设置"></a>2.kernel日志调试设置</h2><h3 id="2-1-查看日志级别"><a href="#2-1-查看日志级别" class="headerlink" title="2.1 查看日志级别"></a>2.1 查看日志级别</h3><p>输入<code>cat proc/sys/kernel/printk</code></p><p>这四个数字依次对应 console_loglevel，default_message_loglevel，minimum_console_loglevel，default_console_loglevel。</p><ul><li><p><strong>console_loglevel：</strong>控制台使用的日志级别；</p></li><li><p><strong>default_message_loglevel：</strong>调用 printk() 未指定日志级别时使用的日志级别；</p></li><li><p><strong>minimum_console_loglevel：</strong>允许设置的控制台日志级别（console_loglevel）最小值；</p></li><li><p><strong>default_console_loglevel：</strong>系统启动时使用的日志级别。</p></li></ul><h3 id="2-2-修改kernel日志级别"><a href="#2-2-修改kernel日志级别" class="headerlink" title="2.2 修改kernel日志级别"></a>2.2 修改kernel日志级别</h3><p>（1）最直接的方法就是：<code>echo xxx &gt; proc/sys/kernel/printk</code>，其余方式参考：<a href="https://blog.csdn.net/qq_34597963/article/details/128669281">https://blog.csdn.net/qq_34597963/article/details/128669281</a></p><p>日志级别如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_EMERG      KERN_SOH <span class="hljs-string">&quot;0&quot;</span>    /* system is unusable */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_ALERT      KERN_SOH <span class="hljs-string">&quot;1&quot;</span>    /* action must be taken immediately */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_CRIT       KERN_SOH <span class="hljs-string">&quot;2&quot;</span>    /* critical conditions */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_ERR        KERN_SOH <span class="hljs-string">&quot;3&quot;</span>    /* error conditions */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_WARNING    KERN_SOH <span class="hljs-string">&quot;4&quot;</span>    /* warning conditions */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_NOTICE     KERN_SOH <span class="hljs-string">&quot;5&quot;</span>    /* normal but significant condition */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_INFO       KERN_SOH <span class="hljs-string">&quot;6&quot;</span>    /* informational */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_DEBUG      KERN_SOH <span class="hljs-string">&quot;7&quot;</span>    /* debug-level messages */</span><br><br>-----------------<br><br>致命级(KERN_EMESG),<br>警戒级(KERN_ALERT),<br>临界级(KERN_CRIT),<br>错误级(KERN_ERR),<br>告警级(KERN_WARN)<br>注意级(KERN_NOTICE),<br>通知级(KERN_INFO),<br>调试级(KERN_DEBUG).<br></code></pre></td></tr></table></figure><p>（2）在kernel中修改log默认等级</p><p>找到<code>/include/linux/printk.h</code>，在下面这个函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">console_verbose</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><p>修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">console_loglevel = CONSOLE_LOGLEVEL_MIN; <span class="hljs-comment">//CONSOLE_LOGLEVEL_MOTORMOUTH;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-Android-Init进程日志打印不全"><a href="#2-3-Android-Init进程日志打印不全" class="headerlink" title="2.3 Android Init进程日志打印不全"></a>2.3 Android Init进程日志打印不全</h3><blockquote><p>参考：<a href="https://blog.csdn.net/superlee1125/article/details/114099144?spm=1001.2014.3001.5506">https://blog.csdn.net/superlee1125/article/details/114099144?spm=1001.2014.3001.5506</a></p></blockquote><p>在抓Android内核的log时，init进程的log往往打印不全，这是因为内核限制了log的输出，在内核代码中找到下面的文件，并按照下面的提示把代码注释掉，然后重新编译内核，再刷到设备中，init进程的打印就完整了。</p><p>内核代码中找到这个文件 <code>kernel/printk/printk.c</code>，在下面这个函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">devkmsg_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kiocb *iocb, <span class="hljs-keyword">struct</span> iov_iter *from)</span><br></code></pre></td></tr></table></figure><p>注释掉下面这两句话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">/* Ratelimit when not explicitly enabled. */</span><br>    <span class="hljs-keyword">if</span> (!(devkmsg_log &amp; DEVKMSG_LOG_MASK_ON)) &#123;<br>-       <span class="hljs-keyword">if</span> (!___ratelimit(&amp;user-&gt;rs, current-&gt;comm))<br>-           <span class="hljs-keyword">return</span> ret;<br>+       <span class="hljs-comment">//if (!___ratelimit(&amp;user-&gt;rs, current-&gt;comm))</span><br>+           <span class="hljs-comment">//return ret;</span><br>    &#125;<br>    buf = kmalloc(len+<span class="hljs-number">1</span>, GFP_KERNEL);<br></code></pre></td></tr></table></figure><h3 id="2-4-Android修改日志级别"><a href="#2-4-Android修改日志级别" class="headerlink" title="2.4 Android修改日志级别"></a>2.4 Android修改日志级别</h3><p>以Android 10.0 qcom平台为例，修改如下：<code>device/qcom/common/rootdir/etc/init.qcom.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">case &quot;$buildvariant&quot; in<br>    &quot;userdebug&quot; | &quot;eng&quot;)<br>        #set default loglevel to KERN_INFO<br>        echo &quot;6 6 1 7&quot; &gt; /proc/sys/kernel/printk  ##### 根据需要进行修改<br><br>        ;;<br>    *)<br>        #set default loglevel to KERN_WARNING<br>        echo &quot;4 4 1 4&quot; &gt; /proc/sys/kernel/printk<br>        ;;<br>esac<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android通用内核GKI</title>
    <link href="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/"/>
    <url>/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/</url>
    
    <content type="html"><![CDATA[<h1 id="Android通用内核GKI"><a href="#Android通用内核GKI" class="headerlink" title="Android通用内核GKI"></a>Android通用内核GKI</h1><h2 id="1-GKI概述"><a href="#1-GKI概述" class="headerlink" title="1.GKI概述"></a>1.GKI概述</h2><p><strong>快速了解</strong>： GKI全称为Generic kernel Image。自2019年开始，来自Google Android的Kernel team经过多年准备，开始在Android 11.0的研发版本上推行GKI设计。GKI的目标在于消除Android阵营Linux Kernel的碎片化状态。 <strong>GKI的终极目标是由Google统一发布boot.image镜像给全球用户使用</strong>。GKI是Google Treble项目的重要举措之一。</p><h3 id="1-1-谷歌为什么要提出GKI"><a href="#1-1-谷歌为什么要提出GKI" class="headerlink" title="1.1 谷歌为什么要提出GKI"></a>1.1 谷歌为什么要提出GKI</h3><p>直接搬运官网，讲的太详细了。</p><p><u><strong>Android 通用内核 (ACK)</strong></u> 是所有 Android 产品内核的基础。供应商内核和设备内核位于 ACK 的下游。供应商通过修改内核源代码并添加设备驱动程序，添加了对 SoC 和外围设备的支持。这些修改内容可能很多，以至于设备上运行的代码中有多达 50% 是树外代码（并非来自上游 Linux 和 AOSP 通用内核）。</p><p>因此，设备内核由以下部分组成：</p><ul><li>上游：来自 kernel.org 的 Linux 内核</li><li>AOSP：AOSP 通用内核的其他 Android 专用补丁程序</li><li>供应商：供应商提供的 SoC 和外围设备支持以及优化补丁程序</li><li>原始设备制造商 (OEM)&#x2F;设备：其他设备驱动程序和自定义项</li></ul><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230217234034047.png" alt="image-20230217234034047" style="zoom: 67%;"><p>Kernel从Linux分支一路到OEM厂商，不断进行修改，全球这么多vendor厂商，这么多oem厂商，每家都来这么一套自己的kernel，碎片化太太太严重了，谷歌真的很难维护。用官网的话，<strong>内核碎片化会对 Android 社区产生若干负面影响</strong>。</p><ul><li>安全更新需要耗费大量人力<ul><li>Android 安全公告 (ASB) 中引用的安全补丁程序必须向后移植到每个设备内核中。但是，由于存在内核碎片化问题，向正常使用的 Android 设备传播安全修复的代价非常之高。</li></ul></li><li>很难合并长期支持的更新<ul><li>长期支持 (LTS) 版本包含安全修复和其他重大问题修复。事实证明，使用最新的 LTS 版本是提供安全修复的最有效方式。我们发现，ASB 报告的内核安全问题中有 90% 都已在保持最新状态的 Pixel 设备上得到修复。</li></ul></li><li>妨碍 Android 平台进行版本升级<ul><li>由于碎片化问题，很难向正常使用的设备添加需要更改内核的 Android 新功能。Android 框架代码必须假设支持的内核版本多达 5 个，并且没有针对新的平台版本进行任何内核更改（Android 10 支持内核版本 3.18、4.4、4.9、4.14 和 4.19；在某些情况下，这些版本自 2017 年 Android 8 发布以来还未添加新功能）。</li></ul></li><li>很难将内核更改贡献回上游 Linux<ul><li>对内核进行完所有更改后，大多数旗舰设备附带的内核版本已经至少存在 18 个月了。例如，<code>kernel.org</code> 于 2017 年 11 月发布了 4.14 版内核，而首批使用 4.14 版内核的 Android 手机于 2019 年春季才发布。</li><li>上游内核发布与产品发布之间的这种长时间延迟导致 Android 社区很难将所需的功能和驱动程序馈送到上游内核中，因此解决碎片化问题并非易事。</li></ul></li></ul><h3 id="1-2-谷歌如何解决碎片化"><a href="#1-2-谷歌如何解决碎片化" class="headerlink" title="1.2 谷歌如何解决碎片化"></a>1.2 谷歌如何解决碎片化</h3><p>通用内核映像 (GKI) 项目通过统一核心内核并将 SoC 和板级支持从核心内核移至可加载模块中，解决了内核碎片化问题。GKI 内核为内核模块提供了稳定的内核模块接口 (KMI)，因此模块和内核可以独立进行更新。</p> <img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230217234449847.png" style="zoom: 80%;"><p>从图中可以看到，Google 会提供 KMI 接口，用于 vendor modules 和 GKI 的通讯。</p><blockquote><p>直白点说，就是谷歌把所有通用的Kernel放在了<code>Generic Kernel</code>里面，把通用的Moudules放在了<code>GKI Modules</code>里面。而与硬件强相关的，与各厂商紧密联系的模块放在了<code>Vendor Modules</code>里面。这样的好处是什么，我用户可以快速升级，只要到谷歌官网找到最新的GKI，就可以用上最新，最安全的Kernel！而与硬件强相关的，晚点升级也没事，既然手机能用，说明各大厂商对于驱动等早就适配好了。</p></blockquote><h3 id="1-3-GKI发展历程"><a href="#1-3-GKI发展历程" class="headerlink" title="1.3 GKI发展历程"></a>1.3 GKI发展历程</h3><p>Gogole GKI 分为下面两个阶段推进：</p><blockquote><p><em>•</em> I. GKI 兼容性：Android 11(R) + linux-5.4 require GKI compatibility test.</p><p><em>•</em> II. GKI 产品化：Android 12(S) + linux-5.x 及之后 require GKI kernel</p></blockquote><p><strong>GKI 1.0 - GKI 兼容性要求</strong></p><p>对于 Android 11 平台版本，为了保证与 Treble 兼容，必须对运行 v5.4 内核的设备进行 GKI 测试。</p><p>具备 GKI 兼容性是指设备通过将 GKI 启动映像刷写到 <code>boot</code> 分区并将 GSI 系统映像刷写到 <code>system</code> 分区来安装通用系统映像 (GSI) 和 GKI 内核，因此通过了 VTS 和 CTS-on-GSI+GKI 测试。设备可以附带不同的产品内核，并且可以使用 GKI 未提供的可加载模块。不过，产品内核和 GKI 内核都必须从相同的 <code>vendor_boot</code> 和 <code>vendor</code> 分区加载模块。因此，所有产品内核都必须具有相同的二进制内核模块接口 (KMI)。供应商可以扩展产品内核的 KMI，前提是它与 GKI KMI 兼容。GKI 1.0 不要求供应商模块可卸载。</p><p><strong>GKI 2.0 - GKI 产品</strong></p><p>搭载 Android S (2021) 平台版本且使用内核版本 v5.x（5.x 是 2020 年年底被选为 LTS 的内核版本）或更高版本的设备必须附带 GKI 内核。将提供已签名的启动映像，并通过 LTS 和重大问题修复定期对其进行更新。由于 KMI 将保持二进制稳定性，因此无需对供应商映像进行任何更改，即可安装这些启动映像。</p><h2 id="2-GKI后各镜像的变化"><a href="#2-GKI后各镜像的变化" class="headerlink" title="2.GKI后各镜像的变化"></a>2.GKI后各镜像的变化</h2><h3 id="2-1-boot分区变化"><a href="#2-1-boot分区变化" class="headerlink" title="2.1 boot分区变化"></a>2.1 boot分区变化</h3><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230219232030518.png" style="zoom:67%;"><p><code>boot</code> 分区包括头文件、内核以及内含启动 ramdisk 通用部分的 CPIO 归档。</p><p><code>boot</code> 分区使用 v3 版启动头文件后，先前的 <code>boot</code> 分区的以下部分将不复存在：</p><ul><li>第二阶段引导加载程序：如果设备具有第二阶段引导加载程序，则必须将相应引导加载程序存储在自己的分区中。</li><li>DTB：DTB 存储在供应商启动分区中。</li></ul><p><code>boot</code> 分区包含一个 CPIO压缩包，内含以下 GKI 组件：</p><ul><li>位于 <code>/lib/modules/</code> 的 GKI 内核模块</li><li><code>first_stage_init</code> 及其依赖的库</li><li><code>fastbootd</code> 和 <code>recovery</code>（用于 A&#x2F;B 和虚拟 A&#x2F;B 设备）</li></ul><h3 id="2-2-出现vendor-boot分区"><a href="#2-2-出现vendor-boot分区" class="headerlink" title="2.2 出现vendor_boot分区"></a>2.2 出现vendor_boot分区</h3><p><code>vendor_boot</code> 分区随 GKI 引入。该分区是采用A&#x2F;B 分区，包含一个头文件、供应商 ramdisk 和设备树 Blob。vendor ramdisk 是一个 CPIO 压缩包，其中包含设备启动所需的供应商模块。这包括用于启用关键 SoC 功能的模块，以及启动设备和显示启动画面所需的存储和显示驱动程序。</p><p>该 CPIO 压缩包包含：</p><ul><li>第一阶段 <code>init</code> 供应商内核模块，位于 <code>/lib/modules/</code></li><li><code>modprobe</code> 配置文件，位于 <code>/lib/modules</code></li><li><code>modules.load</code> 文件，用于指示要在第一阶段 <code>init</code> 期间加载的模块</li></ul><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><blockquote><p>全志的文档写的太好，非常感谢😸</p></blockquote><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230219232422846.png"><p>上图是 boot 分区支持 GKI 的变化情况，这张图很有指导意义，其中关键点有：</p><ul><li>boot.img 变为 boot.img + vendor-boot.img，其中 boot.img 中放的是 GKI 镜像 + ramdisk，<u>vendor-boot.img 中放的是需要启动加载的 vendor 模块 ko</u>；</li><li>启动过程中，需要 bootloader 加载并整合 boot.img 和 vendor-boot.img中的两个ramdisk</li><li>与 GKI 对应的，Google 还推出 GSI，也就是通用 system 镜像；</li><li>vendor.img 可以存放不需要要启动加载的 ko，这个跟以前是一样的。</li></ul><p>bootloader 开发需要注意的地方有：</p><ul><li>boot header V3.0</li><li>DTB 的存放位置从 boot.img 改到了 vendor-boot</li><li>启动过程中 boot 需要加载 boot.img 和 vendor-boot.img 中的 ramdisk 并做整合，而且 boot.img 的 ramdisk 优先级高</li></ul><h3 id="2-4-ramdisk拼接"><a href="#2-4-ramdisk拼接" class="headerlink" title="2.4 ramdisk拼接"></a>2.4 ramdisk拼接</h3><ul><li>Android 11中，ramdisk 分为两份，一份为<strong>boot_ramdisk</strong>，存放在 <strong>boot.img</strong>中。一份为<strong>vendor_boot_ramdisk</strong> 存放在 <strong>vendor_boot.img</strong> 中。</li><li>在 bootloader 启动时需要先后加载 boot_ramdisk，vendor_boot_ramdisk 并进行前后拼接。</li><li>ramdisk 用的是 cpio.lz4 格式，可以进行简单的首尾拼接，<u><strong>但是 bootloader 需要注意两个ramdisk 中间必须紧密拼接，不能对齐再拼接，否则会导致内核解压时失败</strong></u>，同时拼接后改变ramdisk 的大小。</li></ul><h2 id="3-如何下载最新的GKI"><a href="#3-如何下载最新的GKI" class="headerlink" title="3.如何下载最新的GKI"></a>3.如何下载最新的GKI</h2><h3 id="3-1-安卓官网描述"><a href="#3-1-安卓官网描述" class="headerlink" title="3.1 安卓官网描述"></a>3.1 安卓官网描述</h3><p>Android官网：<a href="https://source.android.com/docs/core/architecture/kernel/gki-android12-5_10-release-builds?hl=zh-cn">https://source.android.com/docs/core/architecture/kernel/gki-android12-5_10-release-builds?hl=zh-cn</a></p><p>如果要使用<code>boot.img</code>，选择boot-xxx.img</p><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230221223931378.png" alt="image-20230221223931378" style="zoom:67%;"><p>如果使用GKI，则点击kernel，选择image</p><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230221224045860.png" alt="image-20230221224045860" style="zoom:67%;"><blockquote><p>boot-xxx.img中的kernel和这个image是完全一模一样的！！！</p></blockquote><h3 id="3-2-全志文档"><a href="#3-2-全志文档" class="headerlink" title="3.2 全志文档"></a>3.2 全志文档</h3><p>根据全志文档，Android 12下载编译流程如下：</p><p><strong>1）下载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir android-kernel<br>cd android-kernel/<br>repo init -u https://android.googlesource.com/kernel/manifest -b common-android12-5.4<br>repo sync<br>repo start --all android12-5.4<br></code></pre></td></tr></table></figure><p><strong>2） 使用 Google 源码编译 GKI 镜像</strong></p><p>在 google 源码目录下运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">BUILD_BOOT_IMG=1 SKIP_VENDOR_BOOT=1 KERNEL_BINARY=Image GKI_RAMDISK_PREBUILT_BINARY=gki-<br>ramdisk.img BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh<br></code></pre></td></tr></table></figure><p>编译过程中在 LTO vmlinux.o 阶段可能会卡主一段时间（大概十分钟），属于正常现场，第一次编译会比较耗时。</p><p>编译完成以后，boot.img存放在<code>android-kernel/out/android12-5.4/dist/boot.img</code></p><h2 id="4-GKI启动流程"><a href="#4-GKI启动流程" class="headerlink" title="4. GKI启动流程"></a>4. GKI启动流程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">boot0<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">uboot: 加载boot.img中的GKI和ramdisk_1，加载vendor-boot.img的ramdisk_2，整合ramdisk_1和</span><br>ramdisk_2,jump to GKI<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">GKI: core kernel init</span><br>--&gt; kernel init： load modules ko<br>--&gt; android bringup<br></code></pre></td></tr></table></figure><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><ul><li><a href="https://bbs.16rd.com/thread-583693-1-1.html">https://bbs.16rd.com/thread-583693-1-1.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/240117889">https://zhuanlan.zhihu.com/p/240117889</a></li><li><a href="https://source.android.com/docs/core/architecture/kernel/generic-kernel-image?hl=zh-cn">https://source.android.com/docs/core/architecture/kernel/generic-kernel-image?hl=zh-cn</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>udev设备管理</title>
    <link href="/2023/02/16/udev%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <url>/2023/02/16/udev%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="udev设备管理器"><a href="#udev设备管理器" class="headerlink" title="udev设备管理器"></a>udev设备管理器</h1><p>🍋🍋🍋<strong>十分推荐阅读</strong>：<a href="http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf">http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf</a></p><h2 id="1-为什么会出现udev"><a href="#1-为什么会出现udev" class="headerlink" title="1.为什么会出现udev"></a>1.为什么会出现udev</h2><p><strong>devfs</strong>(设备文件系统)是由Linux2.4内核引入的，当时被许多工程师基于了高度的评价，devfs的出现使得设备驱动程序能够自主的管理自己的设备文件。比如，可以通过程序在设备初始化的时候在 &#x2F;dev 目录下创建设备文件，卸载时将他删除，而且设备驱动程序可以指定设备名，所有者和权限位，而且用户空间程序可以修改所有者和权限位，并且不再需要为设备驱动程序分配主设备号以及次设备号，在程序中可以直接给 register_chrdev()传递0主设备号用来获取可用的主设备号。并且可以在 devfs_register() 中指定次设备号。</p><p>🦋尽管devfs有这样和那样的优点，但是，在Linux 2.6内核中，devfs被认为是过时的方法，并最终被抛弃了，<strong>udev取代了它</strong>。</p><p>🐬<strong>Linux VFS内核维护者Al Viro指出了几点udev取代devfs的原因：</strong></p><ul><li>devfs所做的工作被确信可以在用户态来完成。</li><li>devfs被加入内核之时，大家期望它的质量可以迎头赶上</li><li>发现devfs有一些可修复和无法修复的bug。</li><li>对于可修复的bug，几个月前就已经被修复了，其维护者认为一切良好</li><li>对于后者，在相当长的一段时间内没有改观</li><li>devfs的维护者和作者对它感到失望并且已经停止了对代码的维护工作</li></ul><h2 id="2-udev简介"><a href="#2-udev简介" class="headerlink" title="2.udev简介"></a>2.udev简介</h2><p>udev是一个设备管理工具，**<u>udev以守护进程的形式运行</u>**，通过侦听内核发出来的uevent来管理&#x2F;dev目录下的设备文件。udev在用户空间运行，而不在内核空间 运行。它能够根据系统中的硬件设备的状态动态更新设备文件，包括设备文件的创建，删除等。设备文件通常放在&#x2F;dev目录下。使用udev后，在&#x2F;dev目录下就只包含系统中真正存在的设备。</p><blockquote><p><strong>DEVFS与UDEV的一个显著区别：</strong></p><ul><li>采用devfs，当一个<strong>并不存在的&#x2F;dev节点</strong>被打开的时候，devfs能<strong>自动加载对应的驱动</strong>，而<strong>udev则不这么做</strong></li><li>这是因为udev的设计者认为Linux应该在设备被发现的时候加载驱动模块，而不是当它被访问的时候。udev的设计者认为devfs所提供的打开&#x2F;dev节点时自动加载驱动的功能<strong>对一个配置正确的计算机来说是多余的</strong>。系统中所有的设备都应该产生热插拔事件并加载恰当的驱动， 而udev能注意到这点并且为它创建对应的设备节点</li></ul></blockquote><h2 id="3-udev的配置文件"><a href="#3-udev的配置文件" class="headerlink" title="3.udev的配置文件"></a>3.udev的配置文件</h2><p>主要的udev配置文件是&#x2F;etc&#x2F;udev&#x2F;udev.conf文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">udev_root=<span class="hljs-string">&quot;/dev/&quot;</span><br><br>udev_rules=<span class="hljs-string">&quot;/etc/udev/rules.d/&quot;</span><br><br>udev_log=<span class="hljs-string">&quot;err&quot;</span><br></code></pre></td></tr></table></figure><ul><li>udev_root：代表着设备文件添加到哪。</li><li>udev_rules：代表着udev的规则存储的目录。这个目录存储的是以.rules结束的文件。每一个文件处理一系列规则来帮助udev分配名字给设备文件以保证能被内核识别。你的&#x2F;etc&#x2F;udev&#x2F;rules.d下面可能有好几个udev规则文件，这些文件一部分是udev包安装的，另外一部分则是可能是别的硬件或者软件包生成的。该目录下有多个文件时，udev读取文件是按照文件名的ASCII字母顺序来读取的，如果udev一旦找到了与新加入的设备匹配的规则，udev 就会根据规则定义的措施对新设备进行配置。同时不再读后续的规则文件。</li><li>udev_log：代表着udev的日志级别，用syslog记录错误信息。</li></ul><h2 id="4-udev的工作流程图"><a href="#4-udev的工作流程图" class="headerlink" title="4.udev的工作流程图"></a>4.udev的工作流程图</h2><img src="/2023/02/16/udev%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20230215234615127.png" style="zoom:80%;"><h2 id="5-udev的匹配规则"><a href="#5-udev的匹配规则" class="headerlink" title="5.udev的匹配规则"></a>5.udev的匹配规则</h2><p>在&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;文件夹下有一系列的.rules文件，在这些文件中有一些匹配规则：</p><h3 id="5-1-udev规则的所有操作符"><a href="#5-1-udev规则的所有操作符" class="headerlink" title="5.1 udev规则的所有操作符"></a>5.1 udev规则的所有操作符</h3><ul><li><p>&#x3D;&#x3D; ：比较键、值，若等于，则该条件满足；</p></li><li><p>!&#x3D;  ：比较键、值，若不等于，则该条件满足；</p></li><li><p>&#x3D;   ：对一个键赋值；</p></li><li><p>+&#x3D; ：为一个表示多个条目的键赋值。</p></li><li><p>:&#x3D;  ：对一个键赋值，并拒绝之后所有对该键的改动。目的是防止后面的规则文件对该键赋值。</p></li></ul><h3 id="5-2-udev规则的匹配键"><a href="#5-2-udev规则的匹配键" class="headerlink" title="5.2 udev规则的匹配键"></a>5.2 <strong>udev规则的匹配键</strong></h3><ul><li>ACTION：事件(uevent)的行为，例如：add(添加设备)、remove(删除设备)。</li><li>KERNEL：内核设备名称，例如：sda,cdrom。</li><li>DEVPATH：设备的devpath路径。</li><li>SUBSYSTEM：设备的子系统名称，例如：sda的子系统为block。</li><li>BUS：设备在devpath 里的总线名称，例如：usb。</li><li>DRIVER：设备在devpath 里的设备驱动名称，例如：ide-cdrom。</li><li>ID：设备在devpath 里的识别号。</li><li>SYSFS{filename}：设备的devpath 路径下，设备的属性文件“filename”里的内容。</li></ul><blockquote><p>例如：SYSFS{model}&#x3D;&#x3D;“ST936701SS”表示：如果设备的型号为ST936701SS，则该设备匹配该匹配键。</p><p>在一条规则中，可以设定最多五条SYSFS的匹配键。</p></blockquote><ul><li>ENV{key}：环境变量。在一条规则中，可以设定最多五条环境变量的匹配键。</li><li>PROGRAM：调用外部命令。</li><li>RESULT：外部命令PROGRAM 的返回结果。例如：</li></ul><blockquote><p>PROGRAM&#x3D;&#x3D;”&#x2F;lib&#x2F;udev&#x2F;scsi_id-g -s $devpath”, RESULT&#x3D;&#x3D;“35000c50000a7ef67”</p><p>调用外部命令&#x2F;lib&#x2F;udev&#x2F;scsi_id查询设备的SCSIID，如果返回结果为35000c50000a7ef67，则该设备匹配该匹配键。</p></blockquote><h3 id="5-3-udev-的重要赋值键"><a href="#5-3-udev-的重要赋值键" class="headerlink" title="5.3 udev 的重要赋值键"></a>5.3 udev 的重要赋值键</h3><ul><li>NAME：在&#x2F;dev下产生的设备文件名。只有第一次对某个设备的NAME的赋值行为生效，之后匹配的规则再对该设备的NAME赋值行为将被忽略。如果没有任何规则对设备的NAME赋值，udev将使用内核设备名称来产生设备文件。</li><li>SYMLINK：为&#x2F;dev&#x2F;下的设备文件产生符号链接。由于udev只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的udev规则所产生的文件，推荐使用符号链接。</li><li>OWNER, GROUP, MODE：为设备设定权限。</li><li>ENV{key}：导入一个环境变量。</li><li>RUN:运行后面的程序。</li></ul><h3 id="5-4-udev-的值和可调用的替换操作符"><a href="#5-4-udev-的值和可调用的替换操作符" class="headerlink" title="5.4 udev 的值和可调用的替换操作符"></a>5.4 udev 的值和可调用的替换操作符</h3><p>在键值对中的键和操作符都介绍完了，最后是值(value)。Linux用户可以随意地定制udev规则文件的值。例如：my_root_disk,my_printer。同时也可以引用下面的替换操作符：</p><ul><li>$kernel, %k：设备的内核设备名称，例如：sda、cdrom。</li><li>$number, %n：设备的内核号码，例如：sda3的内核号码是3。</li><li>$devpath, %p：设备的devpath路径。</li><li>$id, %b：设备在devpath里的ID号。</li><li>$sysfs{file}，%s{file}：设备的sysfs里file的内容。其实就是设备的属性值。例如：sysfs{size}表示该设备(磁盘) 的大小。</li><li>$env{key}, %E{key}：一个环境变量的值。</li><li>$major, %M：设备的major号。</li><li>$minor %m：设备的minor号。</li><li>$result, %c：PROGRAM返回的结果。</li><li>$parent, %P：父设备的设备文件名。</li><li>$root, %r：udev_root的值，默认是&#x2F;dev&#x2F;。</li><li>$tempnode, %N：临时设备名。</li><li>%%：符号%本身。</li><li>$$： 符 号 ：符号：符号本身。</li></ul><p>注意：在匹配的过程中，要匹配所有的比较键都满足时，才算匹配成功。</p><h2 id="6-udev的使用方法"><a href="#6-udev的使用方法" class="headerlink" title="6.udev的使用方法"></a>6.udev的使用方法</h2><ol><li>使用udevadm 命令来查看设备的信息：在使用udev时需要获得该设备的一些信息，来用于匹配规则。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">udevadm info -a -p $(udevadm info -q path -n /dev/sdb)<br></code></pre></td></tr></table></figure><p>其中&#x2F;dev&#x2F;sdb是插入设备后设备在&#x2F;dev下的名字。</p><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs shell">Udevadm info starts with the device specified by the devpath and then<br>walks up the chain of parent devices. It prints for every device<br>found, all possible attributes in the udev rules key format.<br>A rule to match, can be composed by the attributes of the device<br>and the attributes from one single parent device.<br><br>  looking at device &#x27;/devices/pci0000:00/0000:00:10.0/host20/target20:0:1/20:0:1:0/block/sdb&#x27;:<br>    KERNEL==&quot;sdb&quot;<br>    SUBSYSTEM==&quot;block&quot;<br>    DRIVER==&quot;&quot;<br>    ATTR&#123;alignment_offset&#125;==&quot;0&quot;<br>    ATTR&#123;capability&#125;==&quot;50&quot;<br>    ATTR&#123;discard_alignment&#125;==&quot;0&quot;<br>    ATTR&#123;events&#125;==&quot;&quot;<br>    ATTR&#123;events_async&#125;==&quot;&quot;<br>    ATTR&#123;events_poll_msecs&#125;==&quot;-1&quot;<br>    ATTR&#123;ext_range&#125;==&quot;256&quot;<br>    ATTR&#123;hidden&#125;==&quot;0&quot;<br>    ATTR&#123;inflight&#125;==&quot;       0        0&quot;<br>    ATTR&#123;range&#125;==&quot;16&quot;<br>    ATTR&#123;removable&#125;==&quot;0&quot;<br>    ATTR&#123;ro&#125;==&quot;0&quot;<br>    ATTR&#123;size&#125;==&quot;41943040&quot;<br>    ATTR&#123;stat&#125;==&quot;      85        0     4184       20        0        0        0        0        0        8       20&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:10.0/host20/target20:0:1/20:0:1:0&#x27;:<br>    KERNELS==&quot;20:0:1:0&quot;<br>    SUBSYSTEMS==&quot;scsi&quot;<br>    DRIVERS==&quot;sd&quot;<br>    ATTRS&#123;blacklist&#125;==&quot;&quot;<br>    ATTRS&#123;device_blocked&#125;==&quot;0&quot;<br>    ATTRS&#123;device_busy&#125;==&quot;0&quot;<br>    ATTRS&#123;dh_state&#125;==&quot;detached&quot;<br>    ATTRS&#123;eh_timeout&#125;==&quot;10&quot;<br>    ATTRS&#123;evt_capacity_change_reported&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_inquiry_change_reported&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_lun_change_reported&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_media_change&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_mode_parameter_change_reported&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_soft_threshold_reached&#125;==&quot;0&quot;<br>    ATTRS&#123;inquiry&#125;==&quot;&quot;<br>    ATTRS&#123;iocounterbits&#125;==&quot;32&quot;<br>    ATTRS&#123;iodone_cnt&#125;==&quot;0x7a&quot;<br>    ATTRS&#123;ioerr_cnt&#125;==&quot;0x3&quot;<br>    ATTRS&#123;iorequest_cnt&#125;==&quot;0x7a&quot;<br>    ATTRS&#123;model&#125;==&quot;VMware Virtual S&quot;<br>    ATTRS&#123;queue_depth&#125;==&quot;32&quot;<br>    ATTRS&#123;queue_ramp_up_period&#125;==&quot;120000&quot;<br>    ATTRS&#123;queue_type&#125;==&quot;simple&quot;<br>    ATTRS&#123;rev&#125;==&quot;1.0 &quot;<br>    ATTRS&#123;scsi_level&#125;==&quot;3&quot;<br>    ATTRS&#123;state&#125;==&quot;running&quot;<br>    ATTRS&#123;timeout&#125;==&quot;180&quot;<br>    ATTRS&#123;type&#125;==&quot;0&quot;<br>    ATTRS&#123;vendor&#125;==&quot;VMware, &quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:10.0/host20/target20:0:1&#x27;:<br>    KERNELS==&quot;target20:0:1&quot;<br>    SUBSYSTEMS==&quot;scsi&quot;<br>    DRIVERS==&quot;&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:10.0/host20&#x27;:<br>    KERNELS==&quot;host20&quot;<br>    SUBSYSTEMS==&quot;scsi&quot;<br>    DRIVERS==&quot;&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:10.0&#x27;:<br>    KERNELS==&quot;0000:00:10.0&quot;<br>    SUBSYSTEMS==&quot;pci&quot;<br>    DRIVERS==&quot;mptspi&quot;<br>    ATTRS&#123;broken_parity_status&#125;==&quot;0&quot;<br>    ATTRS&#123;class&#125;==&quot;0x010000&quot;<br>    ATTRS&#123;config&#125;==&quot;&quot;<br>    ATTRS&#123;consistent_dma_mask_bits&#125;==&quot;32&quot;<br>    ATTRS&#123;d3cold_allowed&#125;==&quot;0&quot;<br>    ATTRS&#123;device&#125;==&quot;0x0030&quot;<br>    ATTRS&#123;dma_mask_bits&#125;==&quot;32&quot;<br>    ATTRS&#123;driver_override&#125;==&quot;(null)&quot;<br>    ATTRS&#123;enable&#125;==&quot;1&quot;<br>    ATTRS&#123;irq&#125;==&quot;17&quot;<br>    ATTRS&#123;local_cpulist&#125;==&quot;0-3&quot;<br>    ATTRS&#123;local_cpus&#125;==&quot;00000000,00000000,00000000,0000000f&quot;<br>    ATTRS&#123;msi_bus&#125;==&quot;1&quot;<br>    ATTRS&#123;numa_node&#125;==&quot;-1&quot;<br>    ATTRS&#123;revision&#125;==&quot;0x01&quot;<br>    ATTRS&#123;subsystem_device&#125;==&quot;0x1976&quot;<br>    ATTRS&#123;subsystem_vendor&#125;==&quot;0x15ad&quot;<br>    ATTRS&#123;vendor&#125;==&quot;0x1000&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00&#x27;:<br>    KERNELS==&quot;pci0000:00&quot;<br>    SUBSYSTEMS==&quot;&quot;<br>    DRIVERS==&quot;&quot;<br></code></pre></td></tr></table></figure><ol start="2"><li>编写.rules文件的规则：进入&#x2F;etc&#x2F;udev&#x2F;rules.d文件夹：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc/udev/rules.d<br></code></pre></td></tr></table></figure><p>新建文件10-usb.rules：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi 10-usb.rules<br></code></pre></td></tr></table></figure><p>在10-usb.rules文件中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">KERNEL==&quot;sdb&quot;,SUBSYSTEM==&quot;block&quot;,ACTION==&quot;add&quot;,SYMLINK+=&quot;USB_link&quot;<br></code></pre></td></tr></table></figure><p>然后保存，退出。</p><ol start="3"><li>使得udev文件生效的方法：通常，使得配置后的文件生效，需要采用热插拔的方法更新udev规则，不过有更简单的方法如下：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">udevadm test /sys/class/block/sdb<br></code></pre></td></tr></table></figure><p>4.结果如下：在&#x2F;dev文件夹下</p><img src="/2023/02/16/udev%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/20201228214401604.png"><h2 id="7-热插拔能自动设备，冷插拔怎么办？"><a href="#7-热插拔能自动设备，冷插拔怎么办？" class="headerlink" title="7.热插拔能自动设备，冷插拔怎么办？"></a>7.热插拔能自动设备，冷插拔怎么办？</h2><p>由于冷插拔的设备开机时就已经存在，在udev启动前已经被插入。针对这种情况，sysfs下的设备都存在uevent文件，向该文件写一个“add”,内核会重新发送netlink，之后udev就可以收到设备的详细信息了，从而创建&#x2F;dev下对应的设备节点。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://blog.csdn.net/chengziwang/article/details/111873757">https://blog.csdn.net/chengziwang/article/details/111873757</a></li><li><a href="https://gitee.com/low-level-of-logic/RaspberryPi/blob/master/docs/">https://gitee.com/low-level-of-logic/RaspberryPi/blob/master/docs/</a></li><li><a href="https://blog.csdn.net/woyimibayi/article/details/78320915">https://blog.csdn.net/woyimibayi/article/details/78320915</a></li><li><a href="http://m.wfuyu.com/server/23483.html">http://m.wfuyu.com/server/23483.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【实验】/dev目录无法同时挂载两个文件系统</title>
    <link href="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="【实验】-x2F-dev目录无法同时挂载两个文件系统"><a href="#【实验】-x2F-dev目录无法同时挂载两个文件系统" class="headerlink" title="【实验】&#x2F;dev目录无法同时挂载两个文件系统"></a>【实验】&#x2F;dev目录无法同时挂载两个文件系统</h1><p>先介绍一下我的开发板，NXP的IMX6ULL，里面是原生的Linux内核，版本为<code>4.1.5</code>。</p><p>下面开始做实验，证明&#x2F;dev目录无法同时挂载两个文件系统。</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p><strong>1.开机后查看当前的挂载的设备</strong></p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215220652226.png" alt="image-20230215220652226" style="zoom:67%;"><blockquote><p>可以看到此时devtmpfs大小为88.3M</p></blockquote><p><strong>2.尝试手动挂载&#x2F;dev</strong></p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215220610703.png" alt="image-20230215220610703" style="zoom:67%;"><p>我们知道tmpfs挂载后默认是RAM的一半</p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215220830308.png" alt="image-20230215220830308" style="zoom:67%;"><blockquote><p>可以发现devtmpfs跟随tmpfs一起办成了RAM的一半大小</p></blockquote><p><strong>3.再次确认挂载情况</strong></p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215220510027.png"><p><strong>4.查看此时&#x2F;dev目录是否正常</strong></p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215221013735.png"><blockquote><p>此时&#x2F;dev目录下为空，访问不到任何目录</p></blockquote><h2 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h2><p>通过实验我们可以发现：</p><ul><li>可以同时给<code>/dev</code>挂载两个文件系统，但是有问题</li><li>当系统以<code>devtmpfs</code>挂载后，再次以<code>tmpfs</code>挂载后，<code>devtmpfs</code>会随<code>tmpfs</code>大小一起变化，如果<code>tmpfs</code>挂载时不指明大小，默认为内存的一半</li><li>给<code>/dev</code>挂载两个文件系统后，<code>/dev</code>目录无法正常访问</li></ul><p><strong>说明：本文水平有限，可能存在诸多问题，请指正！</strong></p>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tmpfs文件系统与安卓</title>
    <link href="/2023/02/14/tmpfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%89%E5%8D%93/"/>
    <url>/2023/02/14/tmpfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%89%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="tmpfs文件系统与安卓"><a href="#tmpfs文件系统与安卓" class="headerlink" title="tmpfs文件系统与安卓"></a>tmpfs文件系统与安卓</h1><h2 id="1-什么是tmpfs文件系统"><a href="#1-什么是tmpfs文件系统" class="headerlink" title="1.什么是tmpfs文件系统"></a>1.什么是tmpfs文件系统</h2><p>先来看一下Kernel文档对于tmpfs文件系统的描述：<a href="https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt">https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">Tmpfs is a file system <span class="hljs-built_in">which</span> keeps all files <span class="hljs-keyword">in</span> virtual memory.<br><br>Everything <span class="hljs-keyword">in</span> tmpfs is temporary <span class="hljs-keyword">in</span> the sense that no files will be created on your hard drive. If you unmount a tmpfs instance, everything stored there <span class="hljs-keyword">in</span> is lost.<br><br>tmpfs puts everything into the kernel internal caches and grows andshrinks to accommodate the files it contains and is able to swap unneeded pages out to swap space. It has maximum size limits <span class="hljs-built_in">which</span> can be adjusted on the fly via <span class="hljs-string">&#x27;mount -o remount ...&#x27;</span><br><br>If you compare it to ramfs (<span class="hljs-built_in">which</span> was the template to create tmpfs) you gain swapping and <span class="hljs-built_in">limit</span> checking. Another similar thing is the RAMdisk (/dev/ram*), <span class="hljs-built_in">which</span> simulates a fixed size hard disk <span class="hljs-keyword">in</span> physical RAM, <span class="hljs-built_in">where</span> you have to create an ordinary filesystem on top. Ramdisks cannot swap and you <span class="hljs-keyword">do</span> not have the possibility to resize them. <br></code></pre></td></tr></table></figure><ul><li><p>tmpfs是一个将所有文件保存在虚拟内存中的文件系统。</p></li><li><p>tmpfs中的所有内容都是临时的，因为不会在硬盘上创建任何文件。如果卸载tmpfs实例，存储在其中的所有东西都丢失了</p></li><li><p>tmpfs将所有内容放入内核内部缓存，并进行增长和收缩以容纳其中包含的文件，并能够将不需要的页面交换出来以交换空间。它具有size限制，可以通过“mount-o remount…”进行动态调整</p></li><li><p>如果将其与ramfs（创建tmpfs的模板）进行比较，则会获得交换和限制检查。另一个类似的东西是RAMdisk（&#x2F;dev&#x2F;ram*），它在物理ram中模拟固定大小的硬盘，您必须在上面创建一个普通的文件系统。Ramdisks无法互换，您无法调整其大小。</p></li></ul><p><strong>我们总结一下tmpfs的特点：</strong></p><ol><li>由于是构建在内存中，存放在tmpfs中的所有数据在卸载或者断后丢失。【临时性】</li><li>内存的访问速度远远大于磁盘IO操作，即使使用了虚拟内存，性能仍然优于磁盘。【快速读写】</li><li>tmpfs一开始使用很小的空间，但是随着文件的复制和创建，tmpfs文件系统会分配更多的内存，并按照需求动态增加文件系统的空间，而且tmpfs文件系统会动态缩小文件并释放内存资源</li><li>像普通块设备需要mkfs格式化文件系统后才可以使用，但是tmpfs是独立的文件系统，只要挂载就可以使用。</li></ol><h2 id="2-Android中的tmpfs文件系统"><a href="#2-Android中的tmpfs文件系统" class="headerlink" title="2.Android中的tmpfs文件系统"></a>2.Android中的tmpfs文件系统</h2><p>Android中挂载tmpfs文件系统的时机主要在安卓init进程中的第一阶段挂载和第二阶段挂载【基于Android S】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FirstStageMain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br><br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/dev&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="hljs-string">&quot;mode=0755&quot;</span>));<br>    <br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/mnt&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=1000&quot;</span>));<br>    <br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/debug_ramdisk&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=0&quot;</span>));<br>    <br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, kSecondStageRes, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=0&quot;</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br># --------------------------------------------------------------------------------------<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SecondStageMain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-built_in">MountExtraFilesystems</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">MountExtraFilesystems</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// /apex is used to mount APEXes</span><br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/apex&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=0&quot;</span>));<br><br>    <span class="hljs-comment">// /linkerconfig is used to keep generated linker configuration</span><br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/linkerconfig&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=0&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看一下安卓真实运行环境中的挂载情况</p><img src="/2023/02/14/tmpfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%89%E5%8D%93/image-20230214223605505.png" style="zoom:80%;"><p>🐖【个人猜想】为什么类似&#x2F;dev，&#x2F;apex这种需要使用tmpfs文件系统：</p><ul><li>像安卓的设备创建后都在&#x2F;dev目录下，驱动会以&#x2F;dev&#x2F;xxx的文件形式存在，所以会发生大量的IO操作，显然使用tmpfs更快</li><li>像ART，VNDK等都存在于&#x2F;apex中，安卓启动的时候虚拟机ART创建都在&#x2F;apex中</li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://www.bilibili.com/video/BV1HG4y1K76E/">https://www.bilibili.com/video/BV1HG4y1K76E/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手动挂载apex包到loop设备</title>
    <link href="/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/"/>
    <url>/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="【实验】手动挂载apex镜像"><a href="#【实验】手动挂载apex镜像" class="headerlink" title="【实验】手动挂载apex镜像"></a>【实验】手动挂载apex镜像</h1><h2 id="1-loop设备"><a href="#1-loop设备" class="headerlink" title="1.loop设备"></a>1.loop设备</h2><p>在类 UNIX 系统里，loop 设备是一种伪设备(pseudo-device)，或者也可以说是仿真设备。它能使我们像块设备一样访问一个文件。</p><p>这要先从mount的流程来理解，挂载操作，实际上就是把设备上的文件系统&#x2F;目录文件连接到指定的目录（directory）下，在操作系统层面就是把挂载设备和挂载目录的对应关系加到内核中的Vfsmount里的对应表单里（内核启动后会从硬盘上加载到内存里），这样我们就可以通过访问目录路径来访问设备上的数据了。</p><p>loop mount是另一种mount方式，如果说普通mount解决了实际硬件存储设备的挂载，bind mount解决了目录到目录的挂载，那么loop mount则解决了将<strong>档案文件</strong>到目录的挂载</p><p>档案，英文Archive，与文件（file）不同，是一个打包好的文件集，里面一般包含许多文件, 比如 tar，jar，iso ，img就是常见的档案格式</p><p>那又是怎么实现将档案文件挂载到目录下呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs she">实际上，系统先把档案文件（比如某个.iso文件）映射到loop设备上<br>#losetup  /dev/loop0   xxxx.iso        使系统误认为xxxx.iso为存储设备/dev/loop0<br><br>再欺骗mount命令，使他认为  /dev/loop0真的是个设备在运行，挂载到指定目录<br>#mount   -t   xxxx.iso   /dev/loop0    /loop设备路径    <br><br></code></pre></td></tr></table></figure><p>但前提是，被访问的loop设备里的档案文件具有linux识别的文件系统，像tar, jar, zip 这样的档案，只是一种压缩格式，本身不是文件系统，即使通过loop mount挂载上去了，直接访问他也读不出什么数据，这很好理解，就像在windows下不装任何解压软件，就无法打开压缩文件一样。<u><strong>所有一般我们都是拿img、iso映射到loop设备。</strong></u></p><h2 id="2-apex包结构"><a href="#2-apex包结构" class="headerlink" title="2.apex包结构"></a>2.apex包结构</h2><p>APEX文件格式如下</p><img src="/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/20200601191934566.png"><p>从顶层看，APEX文件是一个Zip文件，其中的文件均是未压缩的。</p><p>其中的四个文件有<code>apex_manifest.json</code>，<code>AndroidManifest.xml</code>，<code>apex_pubkey</code>，<code>apex_payload.img</code></p><ul><li><p>apex_manifest.json文件包括package name和版本，用来标识该APEX文件</p></li><li><p>AndroidManifest.xml可以允许APEX文件使用一些apk的工具，像adb、package manager、 app install app等。举个例子APEX文件可以使用aapt检查文件的metadata。该文件还包括packcage name和版本号，这些内容通常也会再apex_manifest.json文件中。</p></li><li><p>apex_payload.img是依赖dm-verity的EXT4文件系统镜像。该镜像在运行时通过一个回环设备加载。具体地说，metadata和hash tree是通过libavb创建的。apex_payload.img还没有被解析，因为要求该文件是可挂载的。一些常规文件包含在该镜像中。</p></li><li><p>apex_pubkey是用来给文件系统签名的公钥。该公钥确保下载的apex文件是以编译阶段相同的方式签名。</p></li></ul><h2 id="3-开始实验"><a href="#3-开始实验" class="headerlink" title="3.开始实验"></a>3.开始实验</h2><ol><li><p><strong>将apex解压缩，上传到Linux中</strong></p><img src="/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/image-20230204111723539.png"></li></ol><p>其实apex包就是个压缩包，将后缀名改成<code>.zip</code>，自行使用Windows解压工具进行解压</p><p><strong>上传后我们可以看下它的文件结构和它的文件系统属性</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Android/system$ file apex_payload.img <br>apex_payload.img: Linux rev 1.0 ext2 filesystem data, UUID=7d1522e1-9dfa-5edb-a43e-98e3a4d20250 (extents) (large files) (huge files)<br><br>amx@amxxxx:~/Android/system$ tune2fs -l apex_payload.img <br>tune2fs 1.44.5 (15-Dec-2018)<br>Filesystem volume name:   &lt;none&gt;<br>Last mounted on:          &lt;not available&gt;<br>Filesystem UUID:          7d1522e1-9dfa-5edb-a43e-98e3a4d20250<br>Filesystem magic number:  0xEF53<br>Filesystem revision <span class="hljs-comment">#:    1 (dynamic)</span><br>Filesystem features:      ext_attr dir_index filetype extent sparse_super large_file huge_file uninit_bg dir_nlink extra_isize shared_blocks<br>Filesystem flags:         signed_directory_hash <br>Default mount options:    user_xattr acl<br>Filesystem state:         clean<br>Errors behavior:          Continue<br>Filesystem OS <span class="hljs-built_in">type</span>:       Linux<br>Inode count:              32<br>Block count:              8213<br>Reserved block count:     0<br>Free blocks:              8<br>Free inodes:              5<br>First block:              0<br>Block size:               4096<br>Fragment size:            4096<br>Blocks per group:         32768<br>Fragments per group:      32768<br>Inodes per group:         32<br>Inode blocks per group:   2<br>Filesystem created:       Thu Jan  1 08:00:01 1970<br>Last mount time:          n/a<br>Last write time:          Thu Jan  1 08:00:01 1970<br>Mount count:              0<br>Maximum mount count:      -1<br>Last checked:             Thu Jan  1 08:00:01 1970<br>Check interval:           0 (&lt;none&gt;)<br>Lifetime writes:          32 MB<br>Reserved blocks uid:      0 (user root)<br>Reserved blocks gid:      0 (group root)<br>First inode:              11<br>Inode size:               256<br>Required extra isize:     32<br>Desired extra isize:      32<br>Default directory <span class="hljs-built_in">hash</span>:   half_md4<br>Directory Hash Seed:      7d1522e1-9dfa-5edb-a43e-98e3a4d20250<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>查看当前空闲的loop设备</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Android/system$ sudo losetup -f<br>/dev/loop0<br></code></pre></td></tr></table></figure><p>可以看到当前空闲的loop设备为<code>/dev/loop0</code>，所以我们打算将apex与&#x2F;dev&#x2F;loop0进行关联</p><ol start="3"><li><strong>将apex镜像与loop设备关联</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Android/system$ sudo losetup /dev/loop0 apex_payload.img<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>将loop设备挂载到目标节点上</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Android/system$ sudo mount -o ro /dev/loop0 /home/amx/Android/apex/com.android.i18n<br></code></pre></td></tr></table></figure><p>这里我模仿了安卓将它挂载到了<code>/home/amx/Android/apex/com.android.i18n</code></p><blockquote><p>这里只能使用ro只读形式挂载，因为apex_playload.img采用了ext4文件系统，且在文件系统中添加了<code>shared_block</code>属性，该属性不允许随意修改镜像文件，也是为了将镜像文件尽量压缩到最小（从名字就可以看出来共享块）。这里可以通过改变inode结构改变这个属性，但是有点难度，需要了解ext文件系统才行。</p></blockquote><ol start="5"><li><strong>查看是否挂载成功</strong></li></ol><img src="/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/image-20230204111215939.png"><p>可以看到我们可以像访问块设备一样访问apex包啦</p><ol start="6"><li><strong>说明</strong></li></ol><p>真实的安卓环境中是先system&#x2F;apex下面的apex包挂载到对应的版本目录下，例如adb会先挂载到<code>/apex/com.android.adb@300009</code>，然后再将<code>/apex/com.android.adb@300009</code>以bind方式挂载到<code>/apex/com.android.adb</code></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><ul><li><a href="https://blog.csdn.net/shengxia1999/article/details/52081286?spm=1001.2014.3001.5506">https://blog.csdn.net/shengxia1999/article/details/52081286?spm=1001.2014.3001.5506</a></li><li><a href="https://blog.csdn.net/qq_28351465/article/details/106458089?spm=1001.2014.3001.5506">https://blog.csdn.net/qq_28351465/article/details/106458089?spm=1001.2014.3001.5506</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓开机动画</title>
    <link href="/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <url>/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓S开机动画流程"><a href="#安卓S开机动画流程" class="headerlink" title="安卓S开机动画流程"></a>安卓S开机动画流程</h1><p>开机动画是<strong>在SurfaceFlinger实例通过调用startBootAnim()启动的</strong>，BootAnim是如何启动和结束的，总体框架图如下：</p><img src="/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/整体架构2.png"><h2 id="1-SurfaceFlinger进程启动"><a href="#1-SurfaceFlinger进程启动" class="headerlink" title="1.SurfaceFlinger进程启动"></a>1.SurfaceFlinger进程启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">/frameworks/native/services/surfaceflinger/surfaceflinger.rc</span><br>service surfaceflinger /system/bin/surfaceflinger<br>    class core animation<br>    user system<br>    group graphics drmrpc readproc<br>    capabilities SYS_NICE<br>    onrestart restart zygote<br>    task_profiles HighPerformance<br>    socket pdx/system/vr/display/client     stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0<br>    socket pdx/system/vr/display/manager    stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0<br>    socket pdx/system/vr/display/vsync      stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0<br><br></code></pre></td></tr></table></figure><p>init进程会根据surfaceflinger.rc配置启动surfaceflinger进程，surfaceflinger进程(&#x2F;system&#x2F;bin&#x2F;surfaceflinger)启动，会走到main函数里面。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">/frameworks/native/services/surfaceflinger/Android.bp</span><br>filegroup &#123;<br>    name: &quot;surfaceflinger_binary_sources&quot;,<br>    srcs: [<br>        &quot;:libsurfaceflinger_sources&quot;,<br>        &quot;main_surfaceflinger.cpp&quot;,<br>    ],<br>&#125;<br><br>cc_binary &#123;<br>    name: &quot;surfaceflinger&quot;,<br>    defaults: [&quot;libsurfaceflinger_binary&quot;],<br>    init_rc: [&quot;surfaceflinger.rc&quot;],<br>    srcs: [<br>        &quot;:surfaceflinger_binary_sources&quot;,<br>        // Note: SurfaceFlingerFactory is not in the filegroup so that it<br>        // can be easily replaced.<br>        &quot;SurfaceFlingerFactory.cpp&quot;,<br>    ],<br>    shared_libs: [<br>        &quot;libSurfaceFlingerProp&quot;,<br>    ],<br><br>     logtags: [&quot;EventLog/EventLogTags.logtags&quot;],<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到编译surfaceflinger二进制进程的源文件为<code>surfaceflinger_binary_sources</code>和<code>SurfaceFlingerFactory.cpp</code>，其中surfaceflinger_binary_sources来源于<code>main_surfaceflinger.cpp</code></p><h2 id="2-注册启动surfaceflinger服务"><a href="#2-注册启动surfaceflinger服务" class="headerlink" title="2.注册启动surfaceflinger服务"></a>2.注册启动surfaceflinger服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// /frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>**)</span> </span>&#123;<br><span class="hljs-comment">// ...</span><br><br>    sp&lt;SurfaceFlinger&gt; flinger = surfaceflinger::<span class="hljs-built_in">createSurfaceFlinger</span>(); <span class="hljs-comment">//创建surfaceflinger服务实例</span><br><br><span class="hljs-comment">// ...</span><br>    flinger-&gt;<span class="hljs-built_in">init</span>();  <span class="hljs-comment">// 初始化flinger实例</span><br><br>    <span class="hljs-comment">// 向ServiceManager注册surfaceflinger服务</span><br>    <span class="hljs-function">sp&lt;IServiceManager&gt; <span class="hljs-title">sm</span><span class="hljs-params">(defaultServiceManager())</span></span>;<br>    sm-&gt;<span class="hljs-built_in">addService</span>(<span class="hljs-built_in">String16</span>(SurfaceFlinger::<span class="hljs-built_in">getServiceName</span>()), flinger, <span class="hljs-literal">false</span>,<br>                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);<br><br><span class="hljs-comment">// ...</span><br><br>    flinger-&gt;<span class="hljs-built_in">run</span>();   <span class="hljs-comment">// 启动surfaceflinger服务</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用SurfaceFlinger对象的init方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    mStartPropertySetThread = <span class="hljs-built_in">getFactory</span>().<span class="hljs-built_in">createStartPropertySetThread</span>(presentFenceReliable);<br><br>    <span class="hljs-keyword">if</span> (mStartPropertySetThread-&gt;<span class="hljs-built_in">Start</span>() != NO_ERROR) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Run StartPropertySetThread failed!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Done initializing&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>SurfaceFlinger调用init方法时会获取mStartPropertySetThread，调用该对象的Start方法，其实是准备启动一个线程去启动BootAnimation</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// /frameworks/native/services/surfaceflinger/StartPropertySetThread.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">StartPropertySetThread::Start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;SurfaceFlinger::StartPropertySetThread&quot;</span>, PRIORITY_NORMAL);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StartPropertySetThread::threadLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Set property service.sf.present_timestamp, consumer need check its readiness</span><br>    <span class="hljs-built_in">property_set</span>(kTimestampProperty, mTimestampPropertyValue ? <span class="hljs-string">&quot;1&quot;</span> : <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-comment">// 清除BootAnimation退出标志位service.bootanim.exit</span><br>    <span class="hljs-built_in">property_set</span>(<span class="hljs-string">&quot;service.bootanim.exit&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-comment">// 设置bootanim的进度为0</span><br>    <span class="hljs-built_in">property_set</span>(<span class="hljs-string">&quot;service.bootanim.progress&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-comment">// 通过service.bootanim.exit</span><br>    <span class="hljs-built_in">property_set</span>(<span class="hljs-string">&quot;ctl.start&quot;</span>, <span class="hljs-string">&quot;bootanim&quot;</span>);<br>    <span class="hljs-comment">// 立即退出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里一开始看起来比较疑惑，首先是StartPropertySetThread::Start函数，在<code>StartPropertySetThread.h</code>表明StartPropertySetThread继承自父类Thread，而父类Thread是由&lt;utils&#x2F;Thread.h&gt; 引入的，所以这里是子类引用父类方法，这里的run函数就是就是thread的run方法。这里会启动一个线程去运行，线程名为”StartPropertySetThread”，线程优先级为PRIORITY_NORMAL。线程启动以后，最终会调用 <code>_threadLoop</code> 函数，它会去调用threadLoop函数。这里整个函数调用栈就清楚了：</li></ul><img src="/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/线程函数调用.png"><ul><li>当系统属性发生改变时，init进程就会接收到一个系统属性变化通知，这个通知最终是由在init进程中的函数handle_property_set_fd来处理</li></ul><h2 id="3-bootanim进程启动"><a href="#3-bootanim进程启动" class="headerlink" title="3.bootanim进程启动"></a>3.bootanim进程启动</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// /frameworks/base/cmds/bootanimation/bootanimation_main.cpp</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    setpriority(PRIO_PROCESS, <span class="hljs-number">0</span>, ANDROID_PRIORITY_DISPLAY);<br><br>    <span class="hljs-type">bool</span> noBootAnimation = bootAnimationDisabled();<br>    ALOGI_IF(noBootAnimation,  <span class="hljs-string">&quot;boot animation disabled&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!noBootAnimation) &#123;<br>        <span class="hljs-comment">// 启动Binder线程池</span><br>        sp&lt;ProcessState&gt; <span class="hljs-title function_">proc</span><span class="hljs-params">(ProcessState::self())</span>;<br>        ProcessState::self()-&gt;startThreadPool();<br>        <br>        sp&lt;BootAnimation&gt; boot = new BootAnimation(audioplay::createAnimationCallbacks());<br><br>        waitForSurfaceFlinger();<br>        <br>        boot-&gt;run(<span class="hljs-string">&quot;BootAnimation&quot;</span>, PRIORITY_DISPLAY);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">bootAnimationDisabled</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> value[PROPERTY_VALUE_MAX];<br>    <span class="hljs-comment">// 如果debug.sf.nobootanimation=1，则不会显示动画</span><br>    property_get(<span class="hljs-string">&quot;debug.sf.nobootanimation&quot;</span>, value, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-keyword">if</span> (atoi(value) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-comment">// 如果ro.boot.quiescent=1，则不显示开机动画</span><br>    property_get(<span class="hljs-string">&quot;ro.boot.quiescent&quot;</span>, value, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-keyword">if</span> (atoi(value) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Only show the bootanimation for quiescent boots if this system property is set to enabled</span><br>        <span class="hljs-keyword">if</span> (!property_get_bool(<span class="hljs-string">&quot;ro.bootanim.quiescent.enabled&quot;</span>, <span class="hljs-literal">false</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断完BootAnimation是不是disabled之后，如果noBootAnimation为false，则创建一个BootAnimation对象。创建完了BootAnimation对象后，调用其run方法，由于BootAnimation也继承了Thread，所以最终也会走到对应的threadLoop方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BootAnimation::threadLoop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> r;<br><br>    <span class="hljs-keyword">if</span> (mZipFileName == <span class="hljs-literal">NULL</span>) &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r = <span class="hljs-built_in">movie</span>();  <span class="hljs-comment">// 调用movie方法</span><br>    &#125;<br>    <span class="hljs-comment">// 销毁 opengl 和 egl</span><br>    <span class="hljs-built_in">eglMakeCurrent</span>(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);<br>    <span class="hljs-built_in">eglDestroyContext</span>(mDisplay, mContext);<br>    <span class="hljs-built_in">eglDestroySurface</span>(mDisplay, mSurface);<br>    mFlingerSurface.<span class="hljs-built_in">clear</span>();<br>    mFlingerSurfaceControl.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">eglTerminate</span>(mDisplay);<br>    IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">stopProcess</span>();<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BootAnimation::movie</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    String8 desString;<br>    <span class="hljs-comment">// 读取 desc.txt 配置文件</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;desc.txt&quot;</span>, desString)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">char</span> <span class="hljs-type">const</span>* s = desString.<span class="hljs-built_in">string</span>();<br><br>    <span class="hljs-comment">// 解析描述文件</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;pcount ; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r=<span class="hljs-number">0</span> ; !part.count || r&lt;part.count ; r++) &#123;<br>            <span class="hljs-comment">// opengl 绘制操作</span><br>            <span class="hljs-built_in">glClearColor</span>(<br>                    part.backgroundColor[<span class="hljs-number">0</span>],<br>                    part.backgroundColor[<span class="hljs-number">1</span>],<br>                    part.backgroundColor[<span class="hljs-number">2</span>],<br>                    <span class="hljs-number">1.0f</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j=<span class="hljs-number">0</span> ; j&lt;fcount &amp;&amp; (!<span class="hljs-built_in">exitPending</span>() || part.playUntilComplete) ; j++) &#123;<br>                <span class="hljs-function"><span class="hljs-type">const</span> Animation::Frame&amp; <span class="hljs-title">frame</span><span class="hljs-params">(part.frames[j])</span></span>;<br>                <span class="hljs-type">nsecs_t</span> lastFrame = <span class="hljs-built_in">systemTime</span>();<br>                ...<br>                <span class="hljs-keyword">if</span> (r &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, frame.tid);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ...<br>                    <span class="hljs-built_in">initTexture</span>(frame);<br>                &#125;<br>                <br>                <span class="hljs-comment">// specify the y center as ceiling((mHeight - animation.height) / 2)</span><br>                <span class="hljs-comment">// which is equivalent to mHeight - (yc + animation.height)</span><br>                <span class="hljs-built_in">glDrawTexiOES</span>(xc, mHeight - (yc + animation.height),<br>                              <span class="hljs-number">0</span>, animation.width, animation.height);<br>                <span class="hljs-built_in">eglSwapBuffers</span>(mDisplay, mSurface);<br><br>                <span class="hljs-comment">// 不断绘制时检测是否需要退出</span><br>                <span class="hljs-built_in">checkExit</span>();<br>            &#125;<br>            <span class="hljs-comment">// 如果退出了就跳出结束绘制</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exitPending</span>() &amp;&amp; !part.count)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// free the textures for this part</span><br>        <span class="hljs-keyword">if</span> (part.count != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j=<span class="hljs-number">0</span> ; j&lt;fcount ; j++) &#123;<br>                <span class="hljs-function"><span class="hljs-type">const</span> Animation::Frame&amp; <span class="hljs-title">frame</span><span class="hljs-params">(part.frames[j])</span></span>;<br>                <span class="hljs-built_in">glDeleteTextures</span>(<span class="hljs-number">1</span>, &amp;frame.tid);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 读取 service.bootanim.exit 值是否是 1 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXIT_PROP_NAME <span class="hljs-string">&quot;service.bootanim.exit&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BootAnimation::checkExit</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Allow surface flinger to gracefully request shutdown</span><br>    <span class="hljs-type">char</span> value[PROPERTY_VALUE_MAX];<br>    <span class="hljs-built_in">property_get</span>(EXIT_PROP_NAME, value, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-type">int</span> exitnow = <span class="hljs-built_in">atoi</span>(value);<br>    <span class="hljs-keyword">if</span> (exitnow) &#123;<br>        <span class="hljs-built_in">requestExit</span>();<br>        <span class="hljs-keyword">if</span> (mAudioPlayer != <span class="hljs-literal">NULL</span>) &#123;<br>            mAudioPlayer-&gt;<span class="hljs-built_in">requestExit</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动动画底层采用的是 opengles 的方式来渲染绘制的，绘制的内容是本地的一个启动动画资源包，在绘制的过程中会不断的判断是否需要退出，读取的字段是 service.bootanim.exit ，为 1 代表需要 break 退出循环绘制。因此我们只需要找到 service.bootanim.exit 在哪里设置为 1 的，便可找到退出启动动画的入口。关闭动画的入口还是在 SurfaceFlinger 中只是这个调用流程比较复杂而已：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(IBinder token,</span></span><br><span class="hljs-params"><span class="hljs-function">                                boolean clearHide, boolean isForward, boolean reallyResume)</span> </span>&#123;<br>    ActivityClientRecord r = <span class="hljs-built_in">performResumeActivity</span>(token, clearHide);<br>    <span class="hljs-keyword">if</span> (r != null) &#123;<br>        <span class="hljs-keyword">if</span> (!r.onlyLocalRequest) &#123;<br>            r.nextIdle = mNewActivities;<br>            mNewActivities = r;<br>            <span class="hljs-comment">// 添加了一个 IdleHandler 消息</span><br>            Looper.<span class="hljs-built_in">myQueue</span>().<span class="hljs-built_in">addIdleHandler</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Idler</span>());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> Idler implements MessageQueue.IdleHandler &#123;<br>    @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> boolean <span class="hljs-built_in">queueIdle</span>() &#123;<br>        ActivityClientRecord a = mNewActivities;<br>        <span class="hljs-keyword">if</span> (a != null) &#123;<br>            mNewActivities = null;<br>            IActivityManager am = ActivityManagerNative.<span class="hljs-built_in">getDefault</span>();<br>            ActivityClientRecord prev;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (a.activity != null &amp;&amp; !a.activity.mFinished) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 调用 AMS 的 activityIdle</span><br>                        am.<span class="hljs-built_in">activityIdle</span>(a.token, a.createdConfig, stopProfiling);<br>                    &#125; <span class="hljs-built_in">catch</span> (RemoteException ex) &#123;<br>                        <span class="hljs-comment">// Ignore</span><br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">while</span> (a != null);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><br>@<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">activityIdle</span><span class="hljs-params">(IBinder token, Configuration config, boolean stopProfiling)</span> </span>&#123;<br>    <span class="hljs-built_in">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        ActivityStack stack = ActivityRecord.<span class="hljs-built_in">getStackLocked</span>(token);<br>        <span class="hljs-keyword">if</span> (stack != null) &#123;<br>            ActivityRecord r = mStackSupervisor.<span class="hljs-built_in">activityIdleInternalLocked</span>(token, <span class="hljs-literal">false</span>, config);<br>        &#125;<br>    &#125;<br>    Binder.<span class="hljs-built_in">restoreCallingIdentity</span>(origId);<br>&#125;<br><br><span class="hljs-comment">// Checked.</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> ActivityRecord <span class="hljs-title">activityIdleInternalLocked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> IBinder token, boolean fromTimeout,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                Configuration config)</span> </span>&#123;<br>    ActivityRecord r = ActivityRecord.forTokenLocked(token);<br>    <span class="hljs-keyword">if</span> (r != null) &#123;<br>        ...<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFrontStack</span>(r.task.stack) || fromTimeout) &#123;<br>                booting = <span class="hljs-built_in">checkFinishBootingLocked</span>();<br>            &#125;<br>    &#125;<br>    ...<br>        <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> boolean <span class="hljs-title">checkFinishBootingLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> boolean booting = mService.mBooting;<br>    boolean enableScreen = <span class="hljs-literal">false</span>;<br>    mService.mBooting = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!mService.mBooted) &#123;<br>        mService.mBooted = <span class="hljs-literal">true</span>;<br>        enableScreen = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (booting || enableScreen) &#123;<br>        mService.<span class="hljs-built_in">postFinishBooting</span>(booting, enableScreen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> booting;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enableScreenAfterBoot</span><span class="hljs-params">()</span> </span>&#123;<br>    mWindowManager.<span class="hljs-built_in">enableScreenAfterBoot</span>();<br>    <span class="hljs-built_in">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-built_in">updateEventDispatchingLocked</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">performEnableScreen</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">synchronized</span>(mWindowMap) &#123;<br>        <span class="hljs-keyword">if</span> (!mBootAnimationStopped) &#123;<br>            <span class="hljs-comment">// 向SurfaceFlinger 进程发起关闭开机界面的消息</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                IBinder surfaceFlinger = ServiceManager.<span class="hljs-built_in">getService</span>(<span class="hljs-string">&quot;SurfaceFlinger&quot;</span>);<br>                <span class="hljs-keyword">if</span> (surfaceFlinger != null) &#123;<br>                    Parcel data = Parcel.<span class="hljs-built_in">obtain</span>();<br>                    data.<span class="hljs-built_in">writeInterfaceToken</span>(<span class="hljs-string">&quot;android.ui.ISurfaceComposer&quot;</span>);<br>                    <span class="hljs-comment">// 向SurfaceComposer发送</span><br>                    surfaceFlinger.<span class="hljs-built_in">transact</span>(IBinder.FIRST_CALL_TRANSACTION, <span class="hljs-comment">// BOOT_FINISHED</span><br>                                            data, null, <span class="hljs-number">0</span>);<br>                    data.<span class="hljs-built_in">recycle</span>();<br>                &#125;<br>            &#125; <span class="hljs-built_in">catch</span> (RemoteException ex) &#123;<br>                ...<br>            &#125;<br>            mBootAnimationStopped = <span class="hljs-literal">true</span>;<br>        &#125;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ----------------------------------------------------------------------</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ISurfaceComposerTag</span> &#123;<br>    BOOT_FINISHED = IBinder::FIRST_CALL_TRANSACTION,<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// /frameworks/native/libs/gui/ISurfaceComposer.cpp</span><br><span class="hljs-type">status_t</span> BnSurfaceComposer::<span class="hljs-built_in">onTransact</span>(<br>    <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-type">uint32_t</span> flags)&#123;<br>    <span class="hljs-keyword">switch</span>(code) &#123;<br>            <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">case</span> BOOT_FINISHED: &#123;<br>            <span class="hljs-built_in">CHECK_INTERFACE</span>(ISurfaceComposer, data, reply);<br>            <span class="hljs-built_in">bootFinished</span>();<br>            <span class="hljs-keyword">return</span> NO_ERROR;<br>        &#125;<br>            <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// ----------------------------------------------------------------------</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::bootFinished</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 把 service.bootanim.exit 属性设置为 1 ，bootanim 进程读到 1 时就会退出开机启动动画</span><br>    <span class="hljs-built_in">property_set</span>(<span class="hljs-string">&quot;service.bootanim.exit&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭开机启动动画的流程还是比较复杂的，我们来缕一缕整个逻辑，我们的 Launcher 进程启动后会启动我们 Launcher Activity 界面，而 Activity 的生命周期调用都是由 ActivityThread 来执行的，其中就会执行到 handleResumeActivity 方法，在该方法中会添加一个 IdleHandler 消息，会调用到 AMS 的 activityIdle 方法，AMS 会调用 WMS 的 enableScreenAfterBoot 方法，WMS 会跨进程通知 SurfaceFlinger 去关闭我们的开机启动动画。</p><h2 id="4-开机动画包里有什么"><a href="#4-开机动画包里有什么" class="headerlink" title="4.开机动画包里有什么"></a>4.开机动画包里有什么</h2><p>这里建议先看一下官方文档：&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;bootanimation&#x2F;FORMAT.md</p><p>开机动画指的是以bootanimation.zip方式存在，启动的时候会依次选择一个bootanimation.zip加载</p><ol><li>&#x2F;system&#x2F;media&#x2F;bootanimation-encrypted.zip (if getprop(“vold.decrypt”) &#x3D; ‘1’)</li><li>&#x2F;system&#x2F;media&#x2F;bootanimation.zip</li><li>&#x2F;oem&#x2F;media&#x2F;bootanimation.zip</li></ol><p><code>bootanimation.zip</code> 文件中包含：</p><img src="/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/压缩文件.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">desc.txt - a text file<br>part0  \<br>part1   \  directories full of PNG frames<br>...     /<br>partN  /<br></code></pre></td></tr></table></figure><p><strong>“desc.txt”</strong>：<strong>用来描述用户自定义的开机动画是如何显示的</strong>。</p><p>以下面的例子为例：</p><blockquote><p>1280 720 1</p><p>p 1 1 part0</p><p>p 0 1 part1</p></blockquote><p>第一行的三个数字分别表示开机动画在屏幕中的显示宽度、高度以及帧速(fps)。剩余的每一行都用来描述一个动画片断，这些行必须要以字符“p”来开头，后面紧跟着两个数字以及一个文件目录路径名称。</p><p>第一个数字表示一个片断的循环显示次数，如果它的值等于0，那么就表示无限循环地显示该动画片断。</p><p>第二个数字表示每一个片断在两次循环显示之间的时间间隔。这个时间间隔是以一个帧的时间为单位的。</p><p>文件目录下面保存的是一系列png文件，这些png文件会被依次显示在屏幕中。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul><li><a href="https://blog.51cto.com/u_11176305/3796348">https://blog.51cto.com/u_11176305/3796348</a></li><li><a href="https://www.cnblogs.com/lufeibin/p/13529981.html">https://www.cnblogs.com/lufeibin/p/13529981.html</a></li><li><a href="https://blog.csdn.net/weixin_36044720/article/details/117277602?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_36044720/article/details/117277602?spm=1001.2014.3001.5506</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-Treble计划</title>
    <link href="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/"/>
    <url>/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<ul><li>🕊️本文来自视频：<a href="https://www.youtube.com/watch?v=zbebx1Kvqho">https://www.youtube.com/watch?v=zbebx1Kvqho</a></li><li>引用部分博客：<a href="https://new.qq.com/rain/a/20191016A070PF00">https://new.qq.com/rain/a/20191016A070PF00</a></li><li><a href="https://www.freesion.com/article/69471423144/">https://www.freesion.com/article/69471423144/</a></li></ul><h2 id="1-Andriod进入Treble之前存在什么问题"><a href="#1-Andriod进入Treble之前存在什么问题" class="headerlink" title="1.Andriod进入Treble之前存在什么问题"></a>1.Andriod进入Treble之前存在什么问题</h2><p>在Android 8.0（Android Oreo）之前那个时代，苹果手机一旦有了新的系统更新，用户都能在短时间内更新系统，对用户来说实在太简单了，用户只需要点击更新下载新系统就可以完美的拥有最新的系统功能。而对于安卓用户而言，当安卓发布新的源码以后，会经过下面一系列的操作，用户才能用上真正的全新安卓系统。</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/生成过程.png" style="zoom: 80%;"><ol><li>发布源码：Google将新系统源码发布至AOSP</li><li>启动硬件适配：芯片制造商如<strong>三星</strong>、<strong>高通</strong>、<strong>联发科</strong>、<strong>华为</strong>等对源码进行修改，确保自家的芯片在新版Android能正常运行和发挥性能</li><li>OEM适配：OEM 厂商进一步修改新系统</li><li>OEM测试：OEM 厂商对系统进行内部测试</li><li>推送给用户：试无误后的新版系统通过 OTA 推送给用户</li></ol><p>这样带来的问题是什么，用谷歌开发团队的话来说，整个过程会花费5-12个月的时间……寄🐓</p><p>虽然Google在提交AOSP源码上非常迅速，但是芯片制造商和OEM厂商往往因为技术问题、第三方系统定制原因等导致整体的进程偏慢，最终形成了用户茫茫然的等待，从以往的数据统计我们也可以看出，Android手机中新系统的覆盖率寥寥无几。</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/licheng.png" style="zoom: 50%;"><blockquote><p>可以看到自从安卓8.0退出Treble以来，安卓9.0开始突飞猛进，更新的用户几乎是8.0的一倍</p></blockquote><h2 id="2-Treble计划"><a href="#2-Treble计划" class="headerlink" title="2.Treble计划"></a>2.Treble计划</h2><h3 id="2-1-Treble简介"><a href="#2-1-Treble简介" class="headerlink" title="2.1 Treble简介"></a>2.1 Treble简介</h3><p>Android 8.0 版本的一项新元素是 Project Treble。这是 Android架构方面的一项重大改变，主要解决Android 版本碎片化问题，更方便快捷的升级到最新版本。其中最核心的一点是将AOSP代码和供应商（Vendor）代码做好解耦。贴一张张架构前后的对比图：</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/架构变化.png"><ul><li>升级前：Framework代码和Vendor的代码耦合，即使谷歌发布会完最新AOSP代码，设备厂商也需要花费很多时间处理和Vendor代码适配问题【Reworked】，所以升级会花费很大量的时间</li></ul><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/新架构.png"><ul><li>新的架构：Treble在Framework和Vendor实现代码中间定义一个稳定的接口，这样Framework代码和Vendor的代码实现解耦，这样设备厂商能够快速的升级AOSP，只要接口不变，系统还能正常起来。</li></ul><p>下面我们具体看一下以前的Framework层和HAL层是怎么交互的？</p><p><strong>Android O之前版本的框架：</strong></p><p>在此之前的Android 系统架构当中，Android Framework 与Android HAL是打包成一个system.img的，而且Framework 与HAL之间是紧耦合的，通过链接的方式使用相应的硬件相关so库。老版本的android 的系统框架当中framework与HAL之间的一般架构框架是：</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/框架.png"><p>所以每次Android framework的升级需要对应的Android HAL升级。所以这样每次Android 升级都需要Android 设备制造商投入大量的人力物理去升级相应的Vendor HAL Implemetation.</p><p><strong>Android O及之后的版本的框架：</strong></p><p>在Android O以及以后的版本当中，Android 更新了新的框架设计在新的框架设计当中，引入了一套叫HIDL的语言来定义Freamework与HAL之间的接口，新的架构如下图：</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/HIDL.png"><p>跟以往的Android 版本相比较，Android O里使用HIDL来解耦System Framework 与Vendor HAL Implemetation之间的关系【，从而简化降低Android系统升级的影响与难度。并且目前看起来，Android Framework与Vendor HAL Implemetation会存放在不同的分区当中，Android Framework会在system分区当中，而Vendor HAL Implemetation会在一个新定义的分区(Vendor.img)当中，这样刷新的system.img 才不会影响到Vendor HAL Implemetation。</p><p><strong>更清晰的调用关系</strong></p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/O之前.png" style="zoom:70%;"><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/O之后.png" style="zoom:70%;"><h3 id="2-2-Treble新技术"><a href="#2-2-Treble新技术" class="headerlink" title="2.2 Treble新技术"></a>2.2 Treble新技术</h3><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/架构对比.png"><p><strong>Treble架构中为了实现系统和供应商的分离，引入了许多新技术。关键技术包括：</strong></p><ul><li>HIDL：HAL接口定义语言，用于指定HAL和其他用户之间的接口的一直接口描述语言(IDL)</li><li>HAL：运行Android8.0或者更高版本的设备必须支持使用HIDL语言编写的HAL，分为binderized HAL（绑定式）和passthrough HAL（直通式）。</li><li>设备树叠加层(DTO)：将设备数(DT)分割为主DT和叠加DT。叠加DT由ODM厂商提供，存放在ODM分区。通过对叠加DT的修改升级，可以实现在DT中增加设备节点和修改设备属性。</li><li>供应商原生开发套件(VNDK)：提供了一组让供应商实现其HAL的专用库。</li><li>供应商接口对象(VINTF)：用于汇总设备的相关信息并通过可查询的API提供该信息。</li><li>SELinux：Android8.0实现SELinux策略的模块化和兼容性，目标是使SOC供应商和ODM生产商能够以隔离方式自定义SELinux配置，而无需跨分区修改。</li></ul><h2 id="修改历史"><a href="#修改历史" class="headerlink" title="修改历史"></a>修改历史</h2><ul><li>2023&#x2F;01&#x2F;14：首次编写《Android-Treble计划》</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何搭建hexo部署到github</title>
    <link href="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/"/>
    <url>/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/</url>
    
    <content type="html"><![CDATA[<blockquote><p>🏓本文的内容是记录搭建hexo博客，并且部署到github上<br>🐖哈哈哈，我就是课代表<br>🍔所有内容均来自于：<strong>B站CodeSheep</strong></p></blockquote><h2 id="1-安装Nodejs"><a href="#1-安装Nodejs" class="headerlink" title="1.安装Nodejs"></a>1.安装Nodejs</h2><h3 id="1-1-安装Nodejs"><a href="#1-1-安装Nodejs" class="headerlink" title="1.1 安装Nodejs"></a>1.1 安装Nodejs</h3><p>Nodejs官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/nodejs安装.png" alt="image-20230114121402814" style="zoom: 67%;"><p>直接无脑下一步安装，安装完成后<code>node -v</code>查看版本确认是否安装成功</p><h3 id="1-2-更换镜像"><a href="#1-2-更换镜像" class="headerlink" title="1.2 更换镜像"></a>1.2 更换镜像</h3><p>由于npm包管理工具实在太慢了，所以打算使用淘宝镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>最后可以通过<code>cnpm -v</code>查看一下cnpm是否安装成功</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/安装npm.png" alt="image-20230114121402814" style="zoom: 67%;"><h2 id="2-安装Hexo并初始化hexo项目"><a href="#2-安装Hexo并初始化hexo项目" class="headerlink" title="2.安装Hexo并初始化hexo项目"></a>2.安装Hexo并初始化hexo项目</h2><h3 id="2-1-安装hexo"><a href="#2-1-安装hexo" class="headerlink" title="2.1 安装hexo"></a>2.1 安装hexo</h3><p>先通过npm安装hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装完成以后，可以通过<code>hexo -v</code> 查看是否安装成功</p><h3 id="2-2-初始化hexo项目"><a href="#2-2-初始化hexo项目" class="headerlink" title="2.2 初始化hexo项目"></a>2.2 初始化hexo项目</h3><ol><li>本地创建一个文件夹，用于存放hexo的所有内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir hexo-blog<br></code></pre></td></tr></table></figure><ol start="2"><li>进入该项目文件夹，进行初始化</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br></code></pre></td></tr></table></figure><ol start="3"><li>本地打开该项目</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>通过<code>localhost:4000</code>进行访问</p><h3 id="2-3-创建一个新的项目"><a href="#2-3-创建一个新的项目" class="headerlink" title="2.3 创建一个新的项目"></a>2.3 创建一个新的项目</h3><p>创建自己的新博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new &quot;如何搭建hexo部署到github&quot;<br></code></pre></td></tr></table></figure><p>生成静态文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><p>启动项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>通过<code>localhost:4000</code>进行访问</p><h2 id="3-将hexo部署到github"><a href="#3-将hexo部署到github" class="headerlink" title="3.将hexo部署到github"></a>3.将hexo部署到github</h2><h3 id="3-1-新建一个github仓库"><a href="#3-1-新建一个github仓库" class="headerlink" title="3.1 新建一个github仓库"></a>3.1 新建一个github仓库</h3><blockquote><p>这里需要注意一下，创建的仓库名必须与你的username是一样的，比如我的usrname是anmuxixixi，则创建的仓库名为anmuxixixi.github.io；详情见GitHub如何创建一个Page</p></blockquote><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/创建github.jpg" alt="image-20230114121402814" style="zoom: 60%;"><h3 id="3-2-安卓hexo针对git的deploy组件"><a href="#3-2-安卓hexo针对git的deploy组件" class="headerlink" title="3.2 安卓hexo针对git的deploy组件"></a>3.2 安卓hexo针对git的deploy组件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/安装插件.png" alt="image-20230114121402814" style="zoom: 80%;"><h3 id="3-2-部署到github"><a href="#3-2-部署到github" class="headerlink" title="3.2 部署到github"></a>3.2 部署到github</h3><p>打开项目的<code>_config.xml</code>，设置<code>deploy</code>属性</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/设置deploy.png" alt="image-20230114121402814" style="zoom: 80%;"><blockquote><p> 这个repo对应的仓库名就是我们的<strong>github仓库地址</strong></p></blockquote><p>将其部署到github上</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo cl</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>浏览器输入<code>https://anmuxixixi.github.io/</code></p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/打开仓库.png" alt="image-20230114121402814" style="zoom: 50%;"><h2 id="4-设置主题"><a href="#4-设置主题" class="headerlink" title="4.设置主题"></a>4.设置主题</h2><h3 id="4-1-安装主题"><a href="#4-1-安装主题" class="headerlink" title="4.1 安装主题"></a>4.1 安装主题</h3><ul><li>Hexo官方设置主题的网站：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></li><li>Fluid主题：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></li><li>Fluid主题文档：<a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></li></ul><p>打开github，下载好Fluid主题，将其解压放在themes文件夹下</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/下载主题.png" alt="image-20230114121402814" style="zoom: 80%;"><p>打开<code>_config.xml</code>，设置<code>theme</code>为<code>fluid</code>，设置<code>language</code>为<code>zh-CN</code></p><p>启动后看下整体的效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><h3 id="4-2-简单的页面设置"><a href="#4-2-简单的页面设置" class="headerlink" title="4.2 简单的页面设置"></a>4.2 简单的页面设置</h3><ol><li>修改网页导航栏标题</li></ol><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/修改网页标题.png" alt="image-20230114203236266" style="zoom:67%;"><p>其对应的效果如下</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/标题栏.png"><ol start="2"><li>修改背景图片</li></ol><p>自己复制一张图片，将名字修改为<code>default.png</code></p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/背景.png"><ol start="3"><li>修改中间打字机文字</li></ol><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/打字机.png" alt="image-20230114203653973" style="zoom:79%;"><ol start="4"><li>整体效果如下</li></ol><p><a href="https://anmuxixixi.github.io/">https://anmuxixixi.github.io/</a></p><p>欢迎品尝🌭</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/zhengti.png">]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
