<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>樱桃cherry键盘Win键失灵</title>
    <link href="/2024/04/21/%E6%A8%B1%E6%A1%83cherry%E9%94%AE%E7%9B%98Win%E9%94%AE%E5%A4%B1%E7%81%B5/"/>
    <url>/2024/04/21/%E6%A8%B1%E6%A1%83cherry%E9%94%AE%E7%9B%98Win%E9%94%AE%E5%A4%B1%E7%81%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="樱桃cherry键盘Win键失灵"><a href="#樱桃cherry键盘Win键失灵" class="headerlink" title="樱桃cherry键盘Win键失灵"></a>樱桃cherry键盘Win键失灵</h1><p>cherry键盘win键不能用。是因为有两种模式：办公模式和游戏模式。</p><ul><li>办公模式： Windows 指令能用。</li><li>游戏模式：Windows键锁定，防止意外执行Windows指令。</li></ul><p><code>Fn + F9</code>切换模式。</p><p>我的键盘是Cherry G80-3000s皮卡丘，按住<strong>Fn + F9</strong>就可以了。【官方宣传图里面就有屏幕WIN键，可恶啊🧸】</p><img src="/2024/04/21/%E6%A8%B1%E6%A1%83cherry%E9%94%AE%E7%9B%98Win%E9%94%AE%E5%A4%B1%E7%81%B5/image-20240421202815207.png" alt="image-20240421202815207" style="zoom: 67%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rcu_read_lock和down_read_trylock区别</title>
    <link href="/2024/04/06/rcu-read-lock%E5%92%8Cdown-read-trylock%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/04/06/rcu-read-lock%E5%92%8Cdown-read-trylock%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="两种锁机制区别"><a href="#两种锁机制区别" class="headerlink" title="两种锁机制区别"></a>两种锁机制区别</h2><p><code>rcu_read_lock</code> 和 <code>down_read_trylock</code> 都是 Linux 内核中的读锁机制，但它们用于不同的上下文和目的。</p><ol><li><strong>rcu_read_lock 和 rcu_read_unlock</strong>:<ul><li>这对函数用于 RCU (Read-Copy Update) 机制。RCU 是一种用于同步读者和写者的技术，它允许多个读者同时访问数据，同时只有一个写者可以修改数据。RCU 机制的核心思想是，在写者修改数据之前，它会首先为数据创建一个副本，然后修改这个副本。读者在此期间可以继续读取原始数据，而不需要任何阻塞。当所有读者都完成了对原始数据的读取后，写者会更新指针，使其指向新的、已修改的数据。</li><li><code>rcu_read_lock</code> 用于标记 RCU 读操作的开始，而 <code>rcu_read_unlock</code> 用于标记读操作的结束。</li><li>RCU 非常适合读多写少的场景，因为它允许读者在写者进行更新时继续访问数据。</li></ul></li><li><strong>down_read_trylock</strong>:<ul><li>这个函数是读写锁（read-write lock）机制的一部分，用于尝试获取读锁，但不会阻塞。如果读锁当前可用（即没有被写锁持有，也没有其他读锁持有者），则 <code>down_read_trylock</code> 会成功获取读锁并返回 true。否则，它会立即返回 false，而不会使调用者进入睡眠状态。</li><li>读写锁通常用于有多个读者和一个或多个写者的场景。与互斥锁（mutex）不同，读写锁允许多个读者同时访问数据，但在有写者访问时，它会阻止其他读者和写者。</li></ul></li></ol><p><strong>区别</strong>:</p><ul><li><strong>用途和上下文</strong>: RCU 和读写锁都是用于同步的机制，但它们的用途和上下文有所不同。RCU 主要用于读多写少的场景，而读写锁则更通用，适用于各种读写比例的场景。</li><li><strong>阻塞行为</strong>: <code>rcu_read_lock</code> 不会阻塞，它只是标记 RCU 读操作的开始。而 <code>down_read_trylock</code> 尝试获取读锁，如果锁不可用，它会立即返回 false，不会阻塞。</li><li><strong>复杂性</strong>: RCU 的实现比读写锁更复杂，因为它涉及到数据副本的创建和指针的更新。而读写锁的实现相对简单，主要关注于读者和写者之间的同步。</li></ul><p>总的来说，选择使用 RCU 还是读写锁取决于具体的应用场景和需求。在需要高效处理大量并发读操作的场景中，RCU 可能是一个更好的选择。而在其他读写比例更为均衡的场景中，读写锁可能更合适。</p><h2 id="rw-semaphore-原理与代码分析"><a href="#rw-semaphore-原理与代码分析" class="headerlink" title="rw_semaphore 原理与代码分析"></a>rw_semaphore 原理与代码分析</h2><p><a href="https://blog.csdn.net/feisezaiyue/article/details/127809980">https://blog.csdn.net/feisezaiyue/article/details/127809980</a></p><img src="/2024/04/06/rcu-read-lock%E5%92%8Cdown-read-trylock%E5%8C%BA%E5%88%AB/image-20240406225928168.png" alt="image-20240406225928168" style="zoom:80%;"><h2 id="rcu-机制简介"><a href="#rcu-机制简介" class="headerlink" title="rcu 机制简介"></a>rcu 机制简介</h2><p><a href="https://zhuanlan.zhihu.com/p/113999842">https://zhuanlan.zhihu.com/p/113999842</a></p><img src="/2024/04/06/rcu-read-lock%E5%92%8Cdown-read-trylock%E5%8C%BA%E5%88%AB/image-20240406230704661.png" alt="image-20240406230704661" style="zoom: 80%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统与等待队列</title>
    <link href="/2024/03/17/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97/"/>
    <url>/2024/03/17/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统与等待队列"><a href="#f2fs文件系统与等待队列" class="headerlink" title="f2fs文件系统与等待队列"></a>f2fs文件系统与等待队列</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_wait_on_all_pages</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">int</span> type)</span><br>&#123;<br>DEFINE_WAIT(wait);<br><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">if</span> (!get_pages(sbi, type))<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">if</span> (type == F2FS_DIRTY_META)<br>f2fs_sync_meta_pages(sbi, META, LONG_MAX, FS_CP_META_IO);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == F2FS_WB_CP_DATA)<br>f2fs_submit_merged_write(sbi, DATA);<br><br>prepare_to_wait(&amp;sbi-&gt;cp_wait, &amp;wait, TASK_UNINTERRUPTIBLE);<br>io_schedule_timeout(DEFAULT_IO_TIMEOUT);<br>&#125;<br>finish_wait(&amp;sbi-&gt;cp_wait, &amp;wait);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>DEFINE_WAIT：定义一个等待队列项</li><li>f2fs_submit_merged_write：提交写IO</li><li>prepare_to_wait：将定义的等待队列项插入到等待队列头<code>sbi-&gt;cp_wait</code>中</li><li>io_schedule_timeout：睡眠一小会后唤醒f2fs checkpoint线程f2fs_ckpt【即使不在其他地方主动唤醒，也会超时唤醒】</li><li>finish_wait：将等待队列项从等待队列头里面删除</li></ul><p><strong>这里循环会一直进行，直到f2fs文件系统中不存在type类型的页</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> s64 <span class="hljs-title function_">get_pages</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">int</span> count_type)</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">atomic_read</span>(&amp;sbi-&gt;nr_pages[count_type]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当写IO完成以后，会将该类型的页从sbi-&gt;nr_pages中删除</strong></p><img src="/2024/03/17/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97/image-20240317224353560.png" alt="image-20240317224353560" style="zoom:50%;"><p>🧸<strong>因此，f2fs文件系统整段与等待队列的操作就是在等待所有的写IO完成，这也与函数名f2fs_wait_on_all_pages一致。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux等待队列(驱动和文件系统)</title>
    <link href="/2024/03/17/Linux%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97-%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/03/17/Linux%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97-%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux等待队列-驱动和文件系统"><a href="#Linux等待队列-驱动和文件系统" class="headerlink" title="Linux等待队列(驱动和文件系统)"></a>Linux等待队列(驱动和文件系统)</h1><h2 id="1-等待队列"><a href="#1-等待队列" class="headerlink" title="1.等待队列"></a>1.等待队列</h2><h2 id="2-驱动使用等待队列"><a href="#2-驱动使用等待队列" class="headerlink" title="2.驱动使用等待队列"></a>2.驱动使用等待队列</h2><p><a href="https://blog.csdn.net/qq_37596943/article/details/103795769">https://blog.csdn.net/qq_37596943/article/details/103795769</a></p><h2 id="3-文件系统使用等待队列"><a href="#3-文件系统使用等待队列" class="headerlink" title="3.文件系统使用等待队列"></a>3.文件系统使用等待队列</h2><p>当文件系统中的某个操作（如读取或写入文件）需要等待某个条件满足时（例如，等待磁盘I&#x2F;O操作完成或等待锁释放），线程可以将自己加入等待队列并进入休眠状态。这样，线程不会继续占用CPU资源，而是等待事件发生时由内核自动唤醒。这种机制有助于避免忙等待（busy-waiting），提高了系统的整体性能。</p><p>✅文件系统常常使用等待队列的模板为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">DEFINE_WAIT(wait);<br>prepare_to_wait(wq, &amp;wait, TASK_UNINTERRUPTIBLE);<br>schedule();<br>finish_wait(&amp;ei-&gt;i_fc_wait, &amp;wait);<br></code></pre></td></tr></table></figure><p>这只是简单的一个模板，中间可能会有信号量的判断或者一些读写锁添加。</p><ul><li><p><code>DEFINE_WAIT(wait)</code>：定义了一个<strong>等待队列项</strong><code>wait</code></p></li><li><p><code>prepare_to_wait</code>：将当前进程添加到<strong>等待队列 头</strong><code>wq</code> 中，并设置进程状态为 <code>TASK_UNINTERRUPTIBLE</code>，意味着进程可以在等待期间不可以被信号中断</p></li><li><p><code>schedule</code>：将当前线程调度走，进入睡眠状态</p></li><li><p><code>finish_wait</code>：（当调度到当前线程，唤醒以后）将当前等待队列项从等待队列头中删除</p></li></ul><p>文件系统中常见的等待队列使用如下：</p><img src="/2024/03/17/Linux%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97-%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20240317210425801.png" alt="image-20240317210425801" style="zoom:67%;"><hr><img src="/2024/03/17/Linux%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97-%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20240317210449444.png" alt="image-20240317210449444" style="zoom: 60%;"><hr><blockquote><p>可以发现btrfs文件系统与f2fs文件系统相比，f2fs文件系统调用的是io_schedule_timeout，而非shedule，也就是说指挥小睡一会会，会里面唤醒当前的线程确保IO完成下发。</p></blockquote><img src="/2024/03/17/Linux%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97-%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20240317210515200.png" alt="image-20240317210515200" style="zoom:60%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>港诡实录成就--线索</title>
    <link href="/2024/03/17/%E6%B8%AF%E8%AF%A1%E5%AE%9E%E5%BD%95%E6%88%90%E5%B0%B1-%E7%BA%BF%E7%B4%A2/"/>
    <url>/2024/03/17/%E6%B8%AF%E8%AF%A1%E5%AE%9E%E5%BD%95%E6%88%90%E5%B0%B1-%E7%BA%BF%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="港诡实录成就–线索"><a href="#港诡实录成就–线索" class="headerlink" title="港诡实录成就–线索"></a>港诡实录成就–线索</h1><p>这个成就不需要做全搜集那些文件，只需要在最后一章《诡秘屋邨(cun)》的摩天轮那边拿到一份文件《古书页四》</p><ol><li>从铁轨调到摩天轮上，然后等摩天轮缓缓上升后，调到黄色铁轨上</li></ol><img src="/2024/03/17/%E6%B8%AF%E8%AF%A1%E5%AE%9E%E5%BD%95%E6%88%90%E5%B0%B1-%E7%BA%BF%E7%B4%A2/20240317104541_1.jpg" alt="20240317104541_1" style="zoom: 50%;"><ol start="2"><li>从黄色铁轨走到第一个可以去的楼层，走几步就会打雷，桌子上放了一份文件，打开后关闭就可以解锁成就《线索》</li></ol><img src="/2024/03/17/%E6%B8%AF%E8%AF%A1%E5%AE%9E%E5%BD%95%E6%88%90%E5%B0%B1-%E7%BA%BF%E7%B4%A2/20240317104602_1.jpg" alt="20240317104602_1" style="zoom: 50%;"><img src="/2024/03/17/%E6%B8%AF%E8%AF%A1%E5%AE%9E%E5%BD%95%E6%88%90%E5%B0%B1-%E7%BA%BF%E7%B4%A2/20240317105128_1.jpg" alt="20240317105128_1" style="zoom: 50%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内存回收命令drop_caches大全</title>
    <link href="/2024/03/10/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E5%91%BD%E4%BB%A4drop-caches%E5%A4%A7%E5%85%A8/"/>
    <url>/2024/03/10/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E5%91%BD%E4%BB%A4drop-caches%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="内存回收命令drop-caches大全"><a href="#内存回收命令drop-caches大全" class="headerlink" title="内存回收命令drop_caches大全"></a>内存回收命令drop_caches大全</h1><h2 id="1-drop-caches命令"><a href="#1-drop-caches命令" class="headerlink" title="1.drop caches命令"></a>1.drop caches命令</h2><h2 id="2-f2fs-drop-inode调用栈"><a href="#2-f2fs-drop-inode调用栈" class="headerlink" title="2.f2fs_drop_inode调用栈"></a>2.f2fs_drop_inode调用栈</h2><img src="/2024/03/10/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E5%91%BD%E4%BB%A4drop-caches%E5%A4%A7%E5%85%A8/image-20240310221621378.png" alt="image-20240310221621378" style="zoom: 67%;"><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">=&gt; drop_caches_sysctl_handler<br>=&gt; drop_slab<br>=&gt; shrink_slab<br>=&gt; prune_dcache_sb<br>=&gt; prune_dentry_list<br>=&gt; _dentry_kill<br>=&gt; dentry_unlink_inode<br>=&gt; iput<br>=&gt; f2fs_drop_inode<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">=&gt; drop_caches_sysctl_handler<br>=&gt; drop_slab<br>=&gt; shrink_slab<br>=&gt; prube_icache_sb<br>=&gt; list_lru_walk_sb<br>=&gt; _list_lru_walk_sb<br>=&gt; inode_lru_isolate<br>=&gt; iput<br>=&gt; f2fs_drop_inode<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 遍历 s_dentry_lru 链表  </span><br>list_for_each(lru, &amp;sb-&gt;s_dentry_lru) &#123;  <br>    dentry = list_entry(lru, <span class="hljs-keyword">struct</span> dentry, d_lru);  <br>    printk(KERN_INFO <span class="hljs-string">&quot;dentry: inode=%p, name=%s\n&quot;</span>,  <br>           dentry-&gt;d_inode, dentry-&gt;d_name.name);  <br>&#125;<br></code></pre></td></tr></table></figure><p>Linux中的VFS实现 [二]：<a href="https://zhuanlan.zhihu.com/p/107247475">https://zhuanlan.zhihu.com/p/107247475</a></p><p>inode生命周期：<a href="https://blog.csdn.net/u010039418/article/details/115234532?spm=1001.2014.3001.5506">https://blog.csdn.net/u010039418/article/details/115234532?spm=1001.2014.3001.5506</a></p><p>drop_caches原理：<a href="https://zhuanlan.zhihu.com/p/93962657">https://zhuanlan.zhihu.com/p/93962657</a></p><p>vfs dentry cache 模块实现分析：<a href="https://zhuanlan.zhihu.com/p/457005511?utm_id=0">https://zhuanlan.zhihu.com/p/457005511?utm_id=0</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>io研究备忘录</title>
    <link href="/2024/03/04/io%E7%A0%94%E7%A9%B6%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2024/03/04/io%E7%A0%94%E7%A9%B6%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="http://www.lenzhao.com/topic/5acf20c5bedc2a8b075a6072">电梯算法及IO调度的源码分析</a>：主要讲电梯队列和request队列函数blk_queue_bio</li><li><a href="https://www.cnblogs.com/Linux-tech/p/12961286.html">linux IO Block layer 解析</a>：主要里面的图画的不错，且bio结构讲的比较清晰</li><li><a href="https://www.cnblogs.com/felton/p/10624947.html">Linux Block子系统——IO调度层</a>：主要里面这张图不错</li></ul><img src="/2024/03/04/io%E7%A0%94%E7%A9%B6%E5%A4%87%E5%BF%98%E5%BD%95/1624300-20190331223524431-790777662.jpg" alt="img"><img src="/2024/03/04/io%E7%A0%94%E7%A9%B6%E5%A4%87%E5%BF%98%E5%BD%95/1624300-20190330232530720-1691499771.png" alt="img" style="zoom:80%;"><ul><li><a href="https://github.com/0voice/linux_kernel_wiki/blob/main/%E6%96%87%E7%AB%A0/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%20IO%20%E4%B9%8B%20%E5%9D%97IO%E6%B5%81%E7%A8%8B%E4%B8%8EIO%E8%B0%83%E5%BA%A6%E5%99%A8.md">块I&#x2F;O流程与 I&#x2F;O调度器</a>：工具blktrace、工具blkparse、工具ftrace</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令解析大全</title>
    <link href="/2024/03/03/Linux%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90%E5%A4%A7%E5%85%A8/"/>
    <url>/2024/03/03/Linux%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令解析大全"><a href="#Linux命令解析大全" class="headerlink" title="Linux命令解析大全"></a>Linux命令解析大全</h1><ul><li><p>df命令：<a href="https://anmuxixixi.github.io/2024/03/03/Linux%E5%91%BD%E4%BB%A4df%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"> Linux命令df原理解析</a></p></li><li><p>blkid命令：<a href="https://anmuxixixi.github.io/2023/12/12/blkid%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">blkid二进制源码解析</a></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令df原理解析</title>
    <link href="/2024/03/03/Linux%E5%91%BD%E4%BB%A4df%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/03/03/Linux%E5%91%BD%E4%BB%A4df%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令df原理解析"><a href="#Linux命令df原理解析" class="headerlink" title="Linux命令df原理解析"></a>Linux命令df原理解析</h1><h2 id="1-df命令原理"><a href="#1-df命令原理" class="headerlink" title="1.df命令原理"></a>1.df命令原理</h2><p>使用<code>statfs</code>这个系统调用，直接读取分区的超级块信息获取分区使用情况。它的数据是基于分区元数据的，</p><p>所以只能针对整个分区。由于df直接读取超级块，所以运行速度不受文件多少影响。</p><blockquote><p>下面我们进行实验，通过**df命令打印 **和 <strong>statfs</strong> 函数调用，比较两者是不是相同的</p></blockquote><h3 id="1-1-实验环境准备"><a href="#1-1-实验环境准备" class="headerlink" title="1.1 实验环境准备"></a>1.1 实验环境准备</h3><blockquote><p>直接拿之前的实验品吧：<a href="https://anmuxixixi.github.io/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/">f2fs文件系统文件查找</a></p></blockquote><img src="/2024/03/03/Linux%E5%91%BD%E4%BB%A4df%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20240303111412902.png" alt="image-20240303111412902" style="zoom:80%;"><h3 id="1-2-df命令结果"><a href="#1-2-df命令结果" class="headerlink" title="1.2 df命令结果"></a>1.2 df命令结果</h3><img src="/2024/03/03/Linux%E5%91%BD%E4%BB%A4df%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20240303111312649.png" alt="image-20240303111312649" style="zoom: 80%;"><p>129024是所有1K大小的block数目，所以得到的总大小为：<strong>129024 &#x2F;1024 &#x3D; 126M</strong></p><p><strong>Q：为什么比我们格式化的128M小了2M</strong></p><p><strong>A：</strong>可以看第2章的解析，因为f2fs文件系统的第一个segment是给superblock用的，总大小是从segment0开始算的。而一个segment的大小为2M</p><h3 id="1-3-statfs函数调用结果"><a href="#1-3-statfs函数调用结果" class="headerlink" title="1.3 statfs函数调用结果"></a>1.3 statfs函数调用结果</h3><p>首先编写下面的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/statfs.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span>* path = <span class="hljs-string">&quot;/home/amx/Desktop/f2fs/root_dir&quot;</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">statfs</span> <span class="hljs-title">stStatfs</span>;</span><br>    <span class="hljs-type">int</span> percentage;<br>    statfs(path, &amp;stStatfs);<br>    percentage = (stStatfs.f_blocks - stStatfs.f_bfree) * <span class="hljs-number">100</span> / <br>                    (stStatfs.f_blocks - stStatfs.f_bfree + stStatfs.f_bavail) + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Filesystem   1K-blocks   Used   Available   Use%%   Mounted on\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld %ld %ld %ld %d%% %s\n&quot;</span>, stStatfs.f_type, <br>        <span class="hljs-number">4</span>*stStatfs.f_blocks, <span class="hljs-number">4</span>*(stStatfs.f_blocks - stStatfs.f_bfree), <br>        <span class="hljs-number">4</span>*stStatfs.f_bavail, percentage, path);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行后的结果如下：</p><img src="/2024/03/03/Linux%E5%91%BD%E4%BB%A4df%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20240303111139313.png" alt="image-20240303111139313" style="zoom:80%;"><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">statfs</span>&#123;</span><br><span class="hljs-type">long</span> f_type;     <span class="hljs-comment">//文件系统的类型</span><br><span class="hljs-type">long</span> f_bsize;   <span class="hljs-comment">//经优化后的传输块的大小</span><br><span class="hljs-type">long</span> f_blocks;  <span class="hljs-comment">//文件系统数据块总数</span><br><span class="hljs-type">long</span> f_bfree;    <span class="hljs-comment">//可用块数</span><br><span class="hljs-type">long</span> f_bavail;   <span class="hljs-comment">//普通用户能够获得的块数</span><br><span class="hljs-type">long</span> f_files;      <span class="hljs-comment">//文件结点总数</span><br><span class="hljs-type">long</span> f_ffree;     <span class="hljs-comment">//可用文件结点数</span><br><span class="hljs-type">fisd_t</span> f_fsid;     <span class="hljs-comment">//文件系统标识</span><br><span class="hljs-type">long</span> f_namelen;  <span class="hljs-comment">//文件名的最大长度</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-不同文件系统对应的statfs系统调用"><a href="#2-不同文件系统对应的statfs系统调用" class="headerlink" title="2.不同文件系统对应的statfs系统调用"></a>2.不同文件系统对应的statfs系统调用</h2><img src="/2024/03/03/Linux%E5%91%BD%E4%BB%A4df%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20240303111916590.png" alt="image-20240303111916590" style="zoom: 80%;"><p>本文以我最熟悉的f2fs文件系统为例，说明这些数值是怎么得到的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_statfs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dentry *dentry, <span class="hljs-keyword">struct</span> kstatfs *buf)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> dentry-&gt;d_sb;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_sb_info</span> *<span class="hljs-title">sbi</span> =</span> F2FS_SB(sb);<br>u64 id = huge_encode_dev(sb-&gt;s_bdev-&gt;bd_dev);<br><span class="hljs-type">block_t</span> total_count, user_block_count, start_count;<br>u64 avail_node_count;<br><br>total_count = le64_to_cpu(sbi-&gt;raw_super-&gt;block_count);  <span class="hljs-comment">// 整个f2fs.img包含的block数</span><br>user_block_count = sbi-&gt;user_block_count;<br>start_count = le32_to_cpu(sbi-&gt;raw_super-&gt;segment0_blkaddr);  <span class="hljs-comment">// superblock位于第一个segment，占2M</span><br>buf-&gt;f_type = F2FS_SUPER_MAGIC;<br>buf-&gt;f_bsize = sbi-&gt;blocksize;<br><br>buf-&gt;f_blocks = total_count - start_count;<br>buf-&gt;f_bfree = user_block_count - valid_user_blocks(sbi) -<br>sbi-&gt;current_reserved_blocks;<br><br>    buf-&gt;f_bfree -= sbi-&gt;unusable_block_count;<br><br><br><span class="hljs-keyword">if</span> (buf-&gt;f_bfree &gt; F2FS_OPTION(sbi).root_reserved_blocks)<br>buf-&gt;f_bavail = buf-&gt;f_bfree -<br>F2FS_OPTION(sbi).root_reserved_blocks;<br><span class="hljs-keyword">else</span><br>buf-&gt;f_bavail = <span class="hljs-number">0</span>;<br><br>avail_node_count = sbi-&gt;total_node_count - F2FS_RESERVED_NODE_NUM;<br><br><span class="hljs-keyword">if</span> (avail_node_count &gt; user_block_count) &#123;<br>buf-&gt;f_files = user_block_count;<br>buf-&gt;f_ffree = buf-&gt;f_bavail;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>buf-&gt;f_files = avail_node_count;<br>buf-&gt;f_ffree = min(avail_node_count - valid_node_count(sbi),<br>buf-&gt;f_bavail);<br>&#125;<br><br>buf-&gt;f_namelen = F2FS_NAME_LEN;<br>buf-&gt;f_fsid    = u64_to_fsid(id);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SSD固态硬盘Trim命令</title>
    <link href="/2024/02/19/SSD%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98Trim%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/02/19/SSD%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98Trim%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="SSD固态硬盘Trim命令"><a href="#SSD固态硬盘Trim命令" class="headerlink" title="SSD固态硬盘Trim命令"></a>SSD固态硬盘Trim命令</h1><h2 id="为啥我们需要Trim？"><a href="#为啥我们需要Trim？" class="headerlink" title="为啥我们需要Trim？"></a>为啥我们需要Trim？</h2><p> 在闪存内，数据存储一般是以page（页）为最小单位存储的（典型的为4KB），而128个page组成了一个block（块），数据可以以4KB大小的页来读取和写入，但却只能以512KB(128 page)的块大小来删除。当读取数据或者写入到一个没有被使用过的page上时，固态硬盘的速度是很快的，但是覆写数据的话，就比较复杂了，需要许多步骤来完成。步骤可见下图：</p><img src="/2024/02/19/SSD%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98Trim%E5%91%BD%E4%BB%A4/1_120607163326_1.jpg" alt="img" style="zoom:90%;"><p>当SSD的所有空闲块都被使用后，再有写入操作，它只能覆写数据到之前被操作系统标记为删除的区域。这也是速度下降的开始：</p><p>要覆写一个4KB 页的文件系统，首先要把整个512KB 块复制进缓存里。然后，在缓存里删除这个4KB页，替换成新的数据。接下来，清空整个闪存内的这个512KB区域，并从缓存里把新的数据写回去。如果你需要同时覆写很多的块 - ”例如是一系列小文件随机写入操作或者只是简单的写入一个大文件到SSD“。你会让你的SSD缓存快速过载，然后你的写入速度就会”垂直落体“。。。告诉你，你能体会到会有多慢，早期缓存少的SSD甚至会延迟接近1秒（JMF602之流），为了修复这个问题，SSD厂商一个个都在新主控制器上加入了越来越大的外置缓存，这虽然一定程度上解决了随机写入卡的问题，但是却不能解决SSD在覆写时速度下降的问题。</p><h2 id="Trim命令到底做了什么？"><a href="#Trim命令到底做了什么？" class="headerlink" title="Trim命令到底做了什么？"></a>Trim命令到底做了什么？</h2><p>简而言之，这个问题是因为操作系统和文件系统不能和SSD的主控进行删除文件的交流造成的，如果有之前没清除干净的数据，所有写入的页的操作都要先清除块再改写，将严重影响写入速度。有2种途径来修复这个问题：</p><p>第一个就是定期运行垃圾回收程序(GC)（这个操作有点像整理，在SSD空闲时，全盘扫描有效的页并合并整理起来变为一个包含全部有效页的块，而那些无效的页和块都将被完全的清除）。</p><p>第二个更好的途径就是当数据删除时候让系统告诉SSD数据没了，让SSD立即擦掉那些数据占用的块，这就是Trim命令做的事。<br>当一个文件在支持Trim的系统里被删除后，操作系统会发个命令给SSD，让他知道这个数据所在的这个page可以直接被写入，等于把控制权从操作系统变为了SSD主控制器固件。SSD一样会复制整个包含删除数据的块到缓存，清空块并写入有效数据的页回去，<strong>区别是这样等于把这个延迟时间从覆写数据的那个时间提前到了删除数据的时候</strong>（这个时候你对速度不敏感，如果你删除了很大很大的数据，可以去观察硬盘灯在你删除之后几秒内狂闪），自然就会显得SSD的速度回来了，因为你写入的时候有可用的空块。</p><p>所以我们可以说，Trim保证速度不下跌的真正秘密是： 把将来要做的事提前做掉了。 但是这件事迟早要做，所以基本不会影响SSD原有的写入次数（寿命）。<br>有很多人说，Trim是为测试而生的，这话其实没错，因为 1.Trim不能提速，只是保证速度尽可能不下降。（实际是SSD上没被使用的容量那里的速度不下降。Trim提前把那里的块清空了。下次直接可以写当然快了。）2.Trim没改变原本要做的事，只是提前做掉了，测试软件测试时候就不需要做了，从而“显得”速度上去了。<br>对于GC来说，由于是移动，整理，合并了旧页到新块，删除了无效的旧块，会牺牲点写入次数（寿命）。但是GC支持RAID，也算有利有弊吧。</p><blockquote><p><a href="https://bbs.pceva.com.cn/thread-20195-1-1.html">https://bbs.pceva.com.cn/thread-20195-1-1.html</a></p></blockquote><img src="/2024/02/19/SSD%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98Trim%E5%91%BD%E4%BB%A4/image-20240219221341603.png" alt="image-20240219221341603" style="zoom:80%;"><h2 id="TRIM工具：IOBit公司的Smart-Defrag"><a href="#TRIM工具：IOBit公司的Smart-Defrag" class="headerlink" title="TRIM工具：IOBit公司的Smart Defrag"></a>TRIM工具：IOBit公司的Smart Defrag</h2><p><a href="https://www.bilibili.com/video/BV1Jv4y1T7zH">https://www.bilibili.com/video/BV1Jv4y1T7zH</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统dentry与inode学习笔记</title>
    <link href="/2024/02/16/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fdentry%E4%B8%8Einode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/02/16/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fdentry%E4%B8%8Einode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统dentry与inode学习笔记"><a href="#f2fs文件系统dentry与inode学习笔记" class="headerlink" title="f2fs文件系统dentry与inode学习笔记"></a>f2fs文件系统dentry与inode学习笔记</h1><h2 id="inode相关"><a href="#inode相关" class="headerlink" title="inode相关"></a>inode相关</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">block_operations</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">writeback_control</span> <span class="hljs-title">wbc</span> =</span> &#123;<br>.sync_mode = WB_SYNC_ALL,<br>.nr_to_write = LONG_MAX,<br>.for_reclaim = <span class="hljs-number">0</span>,<br>&#125;;<br><span class="hljs-type">int</span> err = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br><br>f2fs_flush_inline_data(sbi);<br><br>retry_flush_dents:<br><span class="hljs-keyword">if</span> (get_pages(sbi, F2FS_DIRTY_DENTS)) &#123;<br>f2fs_unlock_all(sbi);<br>err = f2fs_sync_dirty_inodes(sbi, DIR_INODE);<br><span class="hljs-keyword">goto</span> retry_flush_quotas;<br>&#125;<br><br>down_write(&amp;sbi-&gt;node_change);<br><br><span class="hljs-keyword">if</span> (get_pages(sbi, F2FS_DIRTY_IMETA)) &#123;<br>up_write(&amp;sbi-&gt;node_change);<br>f2fs_unlock_all(sbi);<br>err = f2fs_sync_inode_meta(sbi);<br><span class="hljs-keyword">goto</span> retry_flush_quotas;<br>&#125;<br><br>retry_flush_nodes:<br>down_write(&amp;sbi-&gt;node_write);<br><br><span class="hljs-keyword">if</span> (get_pages(sbi, F2FS_DIRTY_NODES)) &#123;<br>up_write(&amp;sbi-&gt;node_write);<br><span class="hljs-type">atomic_inc</span>(&amp;sbi-&gt;wb_sync_req[NODE]);<br>err = f2fs_sync_node_pages(sbi, &amp;wbc, <span class="hljs-literal">false</span>, FS_CP_NODE_IO);<br><span class="hljs-type">atomic_dec</span>(&amp;sbi-&gt;wb_sync_req[NODE]);<br><span class="hljs-keyword">goto</span> retry_flush_nodes;<br>&#125;<br><br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="f2fs-sync-dirty-inodes：刷写inode文件对应的《脏数据页》"><a href="#f2fs-sync-dirty-inodes：刷写inode文件对应的《脏数据页》" class="headerlink" title="f2fs_sync_dirty_inodes：刷写inode文件对应的《脏数据页》"></a>f2fs_sync_dirty_inodes：刷写inode文件对应的《脏数据页》</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_sync_dirty_inodes</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-keyword">enum</span> inode_type type)</span><br>&#123;<br><span class="hljs-comment">// ...</span><br>fi = list_first_entry(head, <span class="hljs-keyword">struct</span> f2fs_inode_info, dirty_list);<br>inode = igrab(&amp;fi-&gt;vfs_inode);<br>spin_unlock(&amp;sbi-&gt;inode_lock[type]);<br><span class="hljs-keyword">if</span> (inode) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cur_ino = inode-&gt;i_ino;<br>F2FS_I(inode)-&gt;cp_task = current;<br><span class="hljs-comment">// filemap_fdatawrite作用类似于fdatasync:</span><br>        <span class="hljs-comment">// filemap_fdatawrite的主要作用是将一个文件的所有脏页写回到存储设备。</span><br>        <span class="hljs-comment">// *****filemap_fdatawrite函数本身不是阻塞式的。它不会使调用者（通常是文件系统层或页缓存层）等待写操作完成*****</span><br>        <span class="hljs-comment">// *****调用时，它只是确保所有脏页都被标记为需要写回*****</span><br>filemap_fdatawrite(inode-&gt;i_mapping);<br>F2FS_I(inode)-&gt;cp_task = <span class="hljs-literal">NULL</span>;<br>iput(inode);<br><span class="hljs-keyword">if</span> (ino == cur_ino)<br>cond_resched();<br><span class="hljs-keyword">else</span><br>ino = cur_ino;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>f2fs_submit_merged_write(sbi, DATA);<br>cond_resched();<br>&#125;<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="f2fs-sync-inode-meta：刷写inode对应的《脏元数据页》"><a href="#f2fs-sync-inode-meta：刷写inode对应的《脏元数据页》" class="headerlink" title="f2fs_sync_inode_meta：刷写inode对应的《脏元数据页》"></a>f2fs_sync_inode_meta：刷写inode对应的《脏元数据页》</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_sync_inode_meta</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">head</span> =</span> &amp;sbi-&gt;inode_list[DIRTY_META];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_inode_info</span> *<span class="hljs-title">fi</span>;</span><br>s64 total = get_pages(sbi, F2FS_DIRTY_IMETA);<br><br><span class="hljs-keyword">while</span> (total--) &#123;<br>fi = list_first_entry(head, <span class="hljs-keyword">struct</span> f2fs_inode_info,<br>gdirty_list);<br>inode = igrab(&amp;fi-&gt;vfs_inode);<br>spin_unlock(&amp;sbi-&gt;inode_lock[DIRTY_META]);<br><span class="hljs-keyword">if</span> (inode) &#123;<br>sync_inode_metadata(inode, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (is_inode_flag_set(inode, FI_DIRTY_INODE))<br>f2fs_update_inode_page(inode);<br>iput(inode);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会调用sync_inode_metadata去刷写inode对应的元数据信息，也就是inode信息，其最终的调用栈为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sync_inode_metadata<br>-&gt; sync_inode_metadata<br>-&gt; sync_inode<br>-&gt; writeback_single_inode<br>-&gt; __writeback_single_inode<br></code></pre></td></tr></table></figure><h3 id="f2fs-sync-node-pages：回写《所有脏node-page页》"><a href="#f2fs-sync-node-pages：回写《所有脏node-page页》" class="headerlink" title="f2fs_sync_node_pages：回写《所有脏node page页》"></a>f2fs_sync_node_pages：回写《所有脏node page页》</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_sync_node_pages</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> writeback_control *wbc,</span><br><span class="hljs-params"><span class="hljs-type">bool</span> do_balance, <span class="hljs-keyword">enum</span> iostat_type io_type)</span><br>&#123;<br>    <span class="hljs-comment">// f2fs文件系统的1号元数据node inode用来管理所有缓存的node page页信息，读取里面的脏页异步回写</span><br><span class="hljs-keyword">while</span> (!done &amp;&amp; (nr_pages = pagevec_lookup_tag(&amp;pvec,<br>NODE_MAPPING(sbi), &amp;index, PAGECACHE_TAG_DIRTY))) &#123;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nr_pages; i++) &#123;<br>            <span class="hljs-comment">// 找到对应的node page新块地址，然后下发bio</span><br>ret = __write_node_page(page, <span class="hljs-literal">false</span>, &amp;submitted, wbc, do_balance, io_type, <span class="hljs-literal">NULL</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2024/02/16/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fdentry%E4%B8%8Einode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240216225600102.png" alt="image-20240216225600102" style="zoom:80%;"><h3 id="page页状态和基数树"><a href="#page页状态和基数树" class="headerlink" title="page页状态和基数树"></a>page页状态和基数树</h3><blockquote><p>摘自：<a href="https://zhuanlan.zhihu.com/p/68071761?utm_source=wechat_session">https://zhuanlan.zhihu.com/p/68071761?utm_source=wechat_session</a></p></blockquote><p>如何在radix tree中找到一个指定的page呢？那就要回顾下struct page中的<strong>mapping</strong>和<strong>index</strong>域了，mapping指向page所属文件对应的address_space，进而可以找到address_space的radix tree，index既是page在文件内的offset，也可作为查找这个radix tree的索引，因为radix tree就是按page的index来组织struct page的。</p><p>Linux中radix tree的每个slot除了存放指针，还存放着<strong>page的标志flag和磁盘文件同步状态的tag</strong>。如果page cache中一个page在内存中被修改后没有同步到磁盘，就说这个page是dirty的，此时tag就是PAGECACHE_TAG_DIRTY。如果正在同步，tag就是PAGECACHE_TAG_WRITEBACK。</p><p>只要下一层中有一个slot指向的page是dirty的，那么上一层的这个slot的tag就是”dirty”的（就像一滴墨水一样，放入清水后，清水也就不再完全清澈了）。前面介绍struct page中的<strong>flags</strong>时提到，flags可以是PG_dirty或PG_writeback，既然struct page中已经有了标识同步状态的信息，为什么这里radix tree还要再加上tag来标记呢？</p><p>因为page数量众多，内核不可能为每一个page维护一个timer，因此在判断是否应该writeback时，是以inode为单位的，而一个inode对应的address space中，有很多是dirty的page，很多是clean的，clean的page不需要writeback。</p><p>在遍历radix tree的过程中，如果去逐一比对每个page的”PG_dirty”标志位，将做很多无用功。而当slot也加上”dirty”标志位后，那么如果slot是clean的，就没有必要再扫描其下一层的slot和page了，这样可以减少开销。</p><blockquote><p>🔴现在address_space中radix tree已经被xarray取代了（参考<a href="https://link.zhihu.com/?target=https://lwn.net/Articles/745073/">这篇文章</a>）。</p><p>xarray相关的API：<a href="https://blog.csdn.net/Rong_Toa/article/details/106441355?spm=1001.2014.3001.5506">https://blog.csdn.net/Rong_Toa/article/details/106441355?spm=1001.2014.3001.5506</a></p></blockquote><h3 id="清除脏页状态PAGECACHE-TAG-DIRTY"><a href="#清除脏页状态PAGECACHE-TAG-DIRTY" class="headerlink" title="清除脏页状态PAGECACHE_TAG_DIRTY"></a>清除脏页状态PAGECACHE_TAG_DIRTY</h3><p>清除脏页状态PAGECACHE_TAG_DIRTY的调用栈如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">set_page_writeback<br>=&gt; test_set_page_writeback<br>=&gt; __test_set_page_writeback(page, false)<br>=&gt; if (!PageDirty(page) [条件成立] xas_clear_mark(&amp;xas, PAGECACHE_TAG_DIRTY);<br></code></pre></td></tr></table></figure><img src="/2024/02/16/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fdentry%E4%B8%8Einode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240218203147942.png" alt="image-20240218203147942" style="zoom:80%;"><p>❓<strong>这里有2个疑问需要去解答：</strong></p><p><strong>Q1：什么时候调用set_page_writeback</strong></p><blockquote><p>A1：简单写一下f2fs文件系统相关的调用栈：f2fs_write_cache_pages -&gt; f2fs_write_single_data_page -&gt; f2fs_do_write_data_page -&gt; set_page_writeback</p></blockquote><p><strong>Q2：判断条件不成立的时候才会走到xas_clear_mark，那什么时候清除脏页标记呢</strong></p><blockquote><p>A2：下面一章节就开始写</p></blockquote><h3 id="清除脏页标记PG-dirty"><a href="#清除脏页标记PG-dirty" class="headerlink" title="清除脏页标记PG_dirty"></a>清除脏页标记PG_dirty</h3><p>清除脏页标记PG_dirty的调用栈如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">调用writepages接口<br>=&gt; f2fs_write_data_pages<br>=&gt; __f2fs_write_data_pages<br>=&gt; f2fs_write_cache_pages<br>=&gt; clear_page_dirty_for_io<br>=&gt; TestClearPageDirty<br></code></pre></td></tr></table></figure><img src="/2024/02/16/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fdentry%E4%B8%8Einode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240218210103084.png" alt="image-20240218210103084" style="zoom:80%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内核文件加密</title>
    <link href="/2024/01/19/%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86/"/>
    <url>/2024/01/19/%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="内核文件加密"><a href="#内核文件加密" class="headerlink" title="内核文件加密"></a>内核文件加密</h1><h2 id="加密策略-fscrypt-policy"><a href="#加密策略-fscrypt-policy" class="headerlink" title="加密策略(fscrypt policy)"></a>加密策略(fscrypt policy)</h2><p>加密策略V1：v1策略的秘钥通过一个8字节的标识符”descriptor”从keyring中识别</p><p>加密策略V2：v2策略的秘钥通过一个16字节的标识符”identifier”从keyring中识别</p><img src="/2024/01/19/%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86/image-20240119224248512.png" alt="image-20240119224248512" style="zoom:50%;"><h2 id="FBE秘钥简介"><a href="#FBE秘钥简介" class="headerlink" title="FBE秘钥简介"></a>FBE秘钥简介</h2><p>密钥管理中有以下关键对象：</p><img src="/2024/01/19/%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86/image-20240119225051283.png" alt="image-20240119225051283" style="zoom:67%;"><p>这三者的关系可以用一个例子来说明：</p><ol><li>在 userdata 分区中， 位于 System DE Storage 中的每个文件和文件夹都有自己的 System DE Encryption Policy，被记录到文件的扩展属性中；</li><li>System DE Encryption Policy 记录了：<ol><li>加密使用的 key ，即 System DE Master Key；</li><li>文件内容的加密算法；</li><li>文件名的加密算法；</li></ol></li><li>在 I&#x2F;O 时，底层驱动根据文件或文件夹的 System DE Encryption Policy 加密和解密数据；</li></ol><h2 id="fscrypt-ctl命令解析"><a href="#fscrypt-ctl命令解析" class="headerlink" title="fscrypt_ctl命令解析"></a>fscrypt_ctl命令解析</h2><h3 id="添加秘钥add-key"><a href="#添加秘钥add-key" class="headerlink" title="添加秘钥add_key"></a>添加秘钥add_key</h3><p>一句话总结：用户态构造fscrypt_add_key_arg参数结构体，通过ioctl的FS_IOC_ADD_ENCRYPTION_KEY安装秘钥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cmd_add_key</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span> &#123;<br>  handle_no_options(&amp;argc, &amp;argv);<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mountpoint = argv[<span class="hljs-number">0</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fscrypt_add_key_arg</span> *<span class="hljs-title">arg</span> =</span><br>      <span class="hljs-built_in">calloc</span>(<span class="hljs-keyword">sizeof</span>(*arg) + FSCRYPT_MAX_KEY_SIZE, <span class="hljs-number">1</span>);<br><br>  <span class="hljs-type">int</span> status = EXIT_FAILURE;<br>  arg-&gt;raw_size = read_key(arg-&gt;raw);<br>  arg-&gt;key_spec.type = FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER;<br><br>  <span class="hljs-type">int</span> fd = open(mountpoint, O_RDONLY | O_CLOEXEC);<br><br>  <span class="hljs-comment">// 向挂载点的super block的keyring中安装arg-&gt;raw(也就是用户设置的key)</span><br>  <span class="hljs-keyword">if</span> (ioctl(fd, FS_IOC_ADD_ENCRYPTION_KEY, arg) != <span class="hljs-number">0</span>) &#123;<br>    close(fd);<br>    <span class="hljs-keyword">goto</span> cleanup;<br>  &#125;<br>  close(fd);<br><br>  <span class="hljs-comment">// 内核返回的identifier，可以通过这个identifier在内核的keyring中找到对应的key</span><br>  <span class="hljs-type">char</span> identifier_hex[FSCRYPT_KEY_IDENTIFIER_HEX_SIZE];<br>  bytes_to_hex(arg-&gt;key_spec.u.identifier, FSCRYPT_KEY_IDENTIFIER_SIZE,<br>               identifier_hex);<br>  <span class="hljs-built_in">puts</span>(identifier_hex);<br>  status = EXIT_SUCCESS;<br>cleanup:<br>  secure_wipe(arg-&gt;raw, arg-&gt;raw_size);<br>  <span class="hljs-built_in">free</span>(arg);<br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-comment">// 作用: read_until_limit_or_eof读取输入的秘钥</span><br><span class="hljs-comment">//      这里的STDIN_FILENO通过重定向的文件读取</span><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">read_key</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> raw_key[FSCRYPT_MAX_KEY_SIZE])</span> &#123;<br>  <span class="hljs-type">uint8_t</span> buf[FSCRYPT_MAX_KEY_SIZE + <span class="hljs-number">1</span>];<br>  <span class="hljs-type">ssize_t</span> ret = read_until_limit_or_eof(STDIN_FILENO, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>  <span class="hljs-built_in">memcpy</span>(raw_key, buf, ret);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体示例如下：</p><img src="/2024/01/19/%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86/image-20240119225545849.png" alt="image-20240119225545849" style="zoom:67%;"><p>内核处理IOCTL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fscrypt_ioctl_add_key</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">void</span> __user *_uarg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> file_inode(filp)-&gt;i_sb;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fscrypt_add_key_arg</span> __<span class="hljs-title">user</span> *<span class="hljs-title">uarg</span> =</span> _uarg;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fscrypt_add_key_arg</span> <span class="hljs-title">arg</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fscrypt_master_key_secret</span> <span class="hljs-title">secret</span>;</span><br><span class="hljs-type">int</span> err;<br><br><span class="hljs-keyword">if</span> (copy_from_user(&amp;arg, uarg, <span class="hljs-keyword">sizeof</span>(arg)))<br><span class="hljs-keyword">return</span> -EFAULT;<br>    <br><span class="hljs-built_in">memset</span>(&amp;secret, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(secret));<br><span class="hljs-keyword">if</span> (arg.key_id) &#123;<br>err = get_keyring_key(arg.key_id, arg.key_spec.type, &amp;secret);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>secret.size = arg.raw_size;<br>        <span class="hljs-comment">// 用户态传进来的key</span><br>copy_from_user(secret.raw, uarg-&gt;raw, secret.size)<br>&#125;<br><br>err = add_master_key(sb, &amp;secret, &amp;arg.key_spec);<br><br><span class="hljs-keyword">if</span> (arg.key_spec.type == FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER &amp;&amp;<br>    copy_to_user(uarg-&gt;key_spec.u.identifier, arg.key_spec.u.identifier,<br> FSCRYPT_KEY_IDENTIFIER_SIZE))<br><span class="hljs-keyword">goto</span> out_wipe_secret;<br>err = <span class="hljs-number">0</span>;<br>out_wipe_secret:<br>wipe_master_key_secret(&amp;secret);<br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>真正的向keyring中添加key的函数为add_master_key</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add_master_key</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> fscrypt_master_key_secret *secret,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> fscrypt_key_specifier *key_spec)</span><br>&#123;<br><span class="hljs-type">int</span> err;<br><br>    <span class="hljs-comment">// hkdf: 是一种密钥派生函数,用于从较短的输入密钥中派生出更长的输出密钥。</span><br><span class="hljs-keyword">if</span> (key_spec-&gt;type == FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER) &#123;<br>        <span class="hljs-comment">// 初始化 KDF 函数，设置 KDF Key；</span><br>err = fscrypt_init_hkdf(&amp;secret-&gt;hkdf, secret-&gt;raw,<br>secret-&gt;size);<br><br>memzero_explicit(secret-&gt;raw, secret-&gt;size);<br><br>        <span class="hljs-comment">// 通过 KDF ，从 KDF Key 派生出新的 key，作为 master_key_identifier并返回给上层用户</span><br>err = fscrypt_hkdf_expand(&amp;secret-&gt;hkdf,<br>  HKDF_CONTEXT_KEY_IDENTIFIER, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>,<br>  key_spec-&gt;u.identifier,<br>  FSCRYPT_KEY_IDENTIFIER_SIZE);<br>&#125;<br><span class="hljs-keyword">return</span> do_add_master_key(sb, secret, key_spec);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Block模块之IO合并代码解析</title>
    <link href="/2024/01/04/Block%E6%A8%A1%E5%9D%97%E4%B9%8BIO%E5%90%88%E5%B9%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/01/04/Block%E6%A8%A1%E5%9D%97%E4%B9%8BIO%E5%90%88%E5%B9%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Block模块之IO合并代码解析"><a href="#Block模块之IO合并代码解析" class="headerlink" title="Block模块之IO合并代码解析"></a>Block模块之IO合并代码解析</h1><p><a href="https://www.cnblogs.com/jrchyang/p/16795368.html">https://www.cnblogs.com/jrchyang/p/16795368.html</a></p><p><a href="https://www.ubuntukylin.com/news/791-cn.html">https://www.ubuntukylin.com/news/791-cn.html</a></p><h2 id="逻辑入口"><a href="#逻辑入口" class="headerlink" title="逻辑入口"></a>逻辑入口</h2><h2 id="Plug合并"><a href="#Plug合并" class="headerlink" title="Plug合并"></a>Plug合并</h2><p>Plug合并是内核通用块层提供的机制，如果需要开启则在提交IO前执行 <code>blk_start_plug()</code> 函数启动蓄流，IO全部提交完成后执行 <code>blk_finish_plug()</code> 函数进行泄流。启动蓄流主要是为当前进程（ <code>current</code> 宏）分配plug链表，提交IO时plug链表存在则IO先缓存到该链表中，执行泄流时将该链表中缓存的IO下发。执行plug合并的函数为 <code>blk_attempt_plug_merge()</code> ，该函数的主要逻辑为遍历 <code>current-&gt;plug-&gt;list</code> 中的所有请求，将属于同一个底层设备队列且位置相邻的请求合并在一起，代码逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">blk_attempt_plug_merge</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-keyword">struct</span> bio *bio,</span><br><span class="hljs-params">    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *request_count,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> request **same_queue_rq)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_plug</span> *<span class="hljs-title">plug</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span>;</span><br><span class="hljs-type">bool</span> ret = <span class="hljs-literal">false</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">plug_list</span>;</span><br> <br>plug = current-&gt;plug;<br><span class="hljs-keyword">if</span> (!plug)<br><span class="hljs-keyword">goto</span> out;<br>*request_count = <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">if</span> (q-&gt;mq_ops)<br>plug_list = &amp;plug-&gt;mq_list;<br><span class="hljs-keyword">else</span><br>plug_list = &amp;plug-&gt;<span class="hljs-built_in">list</span>;<br> <br>list_for_each_entry_reverse(rq, plug_list, queuelist) &#123;<br><span class="hljs-type">int</span> el_ret;<br> <br><span class="hljs-comment">/* 给plug_list中同一个设备的请求计数 */</span><br><span class="hljs-keyword">if</span> (rq-&gt;q == q) &#123;<br>(*request_count)++;<br><span class="hljs-keyword">if</span> (same_queue_rq)<br>*same_queue_rq = rq;<br>&#125;<br> <br><span class="hljs-comment">/* 同一队列，满足合并的才能合并 */</span><br><span class="hljs-keyword">if</span> (rq-&gt;q != q || !blk_rq_merge_ok(rq, bio))<br><span class="hljs-keyword">continue</span>;<br> <br><span class="hljs-comment">/* 判断能进行合并的位置 */</span><br>el_ret = blk_try_merge(rq, bio);<br><span class="hljs-keyword">if</span> (el_ret == ELEVATOR_BACK_MERGE) &#123;<br>ret = bio_attempt_back_merge(q, rq, bio);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el_ret == ELEVATOR_FRONT_MERGE) &#123;<br>ret = bio_attempt_front_merge(q, rq, bio);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>out:<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>该逻辑中有两点需要注意。一是 <code>request_count</code> 计数，该变量统计plug链表中与当前IO属于同一队列的请求个数，当数量超过 <code>BLK_MAX_REQUEST_COUNT</code> （当前定义为16）时则主动下刷plug中的请求；二是函数 <code>blk_rq_merge_ok()</code> 与函数 <code>blk_try_merge()</code> ，其中 <code>blk_rq_merge_ok()</code> 检查req及bio属性是否支持合并， <code>blk_try_merge()</code> 则是根据req及bio的起始位置与长度来检查是否相邻，以判断能否合并以及合并的类型（前向&#x2F;后向），代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">blk_rq_merge_ok</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *rq, <span class="hljs-keyword">struct</span> bio *bio)</span><br>&#123;<br><span class="hljs-comment">/* rq_mergeable - 判断rq是否有不允许合并的标记</span><br><span class="hljs-comment"> * bio_mergeable - 判断bio是否有不允许合并的标记</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!rq_mergeable(rq) || !bio_mergeable(bio))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> <br><span class="hljs-comment">/* 判断rq和bio是否是特殊的请求，</span><br><span class="hljs-comment"> * 如果是特殊请求并且两者相同则不允许合并</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!blk_check_merge_flags(rq-&gt;cmd_flags, bio-&gt;bi_rw))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> <br><span class="hljs-comment">/* 请求方向不同，不能合并 */</span><br><span class="hljs-keyword">if</span> (bio_data_dir(bio) != rq_data_dir(rq))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> <br><span class="hljs-comment">/* 指向的通用磁盘不同或者rq是特殊请求，不能合并 */</span><br><span class="hljs-keyword">if</span> (rq-&gt;rq_disk != bio-&gt;bi_bdev-&gt;bd_disk || req_no_special_merge(rq))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> <br><span class="hljs-comment">/* 完整性保护不同的请求和bio，不能合并 */</span><br><span class="hljs-keyword">if</span> (bio_integrity(bio) != blk_integrity_rq(rq))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> <br><span class="hljs-comment">/* REQ_WRITE_SAME请求，来自不同的page，不能合并 */</span><br><span class="hljs-keyword">if</span> (rq-&gt;cmd_flags &amp; REQ_WRITE_SAME &amp;&amp;<br>    !blk_write_same_mergeable(rq-&gt;bio, bio))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">blk_try_merge</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *rq, <span class="hljs-keyword">struct</span> bio *bio)</span><br>&#123;<br><span class="hljs-comment">/* rq结束位置等于bio起始位置返回后向合并 */</span><br><span class="hljs-keyword">if</span> (blk_rq_pos(rq) + blk_rq_sectors(rq) == bio-&gt;bi_sector)<br><span class="hljs-keyword">return</span> ELEVATOR_BACK_MERGE;<br><span class="hljs-comment">/* bio结束位置等于rq起始位置返回前向合并 */</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (blk_rq_pos(rq) - bio_sectors(bio) == bio-&gt;bi_sector)<br><span class="hljs-keyword">return</span> ELEVATOR_FRONT_MERGE;<br><span class="hljs-keyword">return</span> ELEVATOR_NO_MERGE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="bio向后合并"><a href="#bio向后合并" class="headerlink" title="bio向后合并"></a>bio向后合并</h3><p>为了验证IO请求在通用块层的各种合并形式，准备了以下测试程序，该测试程序使用内核原生支持的异步IO引擎，可异步地向内核一次提交多个IO请求。为了减少page cache和文件系统的干扰，使用O_DIRECT的方式直接向裸设备派发IO。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// iotc.c</span><br><br><span class="hljs-comment">/* dispatch 3 4k-size ios using the io_type specified by user */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_EVENTS  3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALIGN_SIZE  4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WR_SIZE  4096</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">io_type</span> &#123;</span><br>SEQUENCE_IO,<span class="hljs-comment">/* dispatch 3 ios: 0-4k(0+8), 4-8k(8+8), 8-12k(16+8) */</span><br>REVERSE_IO,<span class="hljs-comment">/* dispatch 3 ios: 8-12k(16+8), 4-8k(8+8),0-4k(0+8) */</span><br>INTERLEAVE_IO, <span class="hljs-comment">/* dispatch 3 ios: 8-12k(16+8), 0-4k(0+8),4-8k(8+8) */</span> ,<br>IO_TYPE_END<br>&#125;;<br><br><span class="hljs-type">int</span> io_units[IO_TYPE_END][NUM_EVENTS] = &#123;<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<span class="hljs-comment">/* corresponding to SEQUENCE_IO */</span><br>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<span class="hljs-comment">/* corresponding to REVERSE_IO */</span><br>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<span class="hljs-comment">/* corresponding to INTERLEAVE_IO */</span><br>&#125;;<br><br><span class="hljs-type">char</span> *io_opt = <span class="hljs-string">&quot;srid:&quot;</span>;<span class="hljs-comment">/* acceptable options */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">io_context_t</span> ctx;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">tms</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_event</span> <span class="hljs-title">events</span>[<span class="hljs-title">NUM_EVENTS</span>];</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iocb</span> <span class="hljs-title">iocbs</span>[<span class="hljs-title">NUM_EVENTS</span>],</span><br><span class="hljs-class">                *<span class="hljs-title">iocbp</span>[<span class="hljs-title">NUM_EVENTS</span>];</span><br><span class="hljs-type">int</span> i, io_flag = <span class="hljs-number">-1</span>;;<br><span class="hljs-type">void</span> *buf;<br><span class="hljs-type">bool</span> hit = <span class="hljs-literal">false</span>;<br><span class="hljs-type">char</span> *dev = <span class="hljs-literal">NULL</span>, opt;<br><br><span class="hljs-comment">/* io_flag and dev got set according the options passed by user , don’t paste the code of parsing here to shrink space */</span><br>fd = open(dev, O_RDWR | __O_DIRECT);<br><br><span class="hljs-comment">/* we can dispatch 32 IOs at 1 systemcall */</span><br>ctx = <span class="hljs-number">0</span>;<br><br>io_setup(<span class="hljs-number">32</span>, &amp;ctx);<br>posix_memalign(&amp;buf,ALIGN_SIZE,WR_SIZE);<br><br><span class="hljs-comment">/* prepare IO request according to io_type */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_EVENTS; iocbp[i] = iocbs + i, ++i)<br>io_prep_pwrite(&amp;iocbs[i], fd, buf, WR_SIZE, io_units[io_flag][i] * WR_SIZE);<br><br><span class="hljs-comment">/* submit IOs using io_submit systemcall */</span><br>io_submit(ctx, NUM_EVENTS, iocbp);<br><br><span class="hljs-comment">/* get the IO result with a timeout of 1S*/</span><br>tms.tv_sec = <span class="hljs-number">1</span>;<br>tms.tv_nsec = <span class="hljs-number">0</span>;<br>io_getevents(ctx, <span class="hljs-number">1</span>, NUM_EVENTS, events, &amp;tms);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试程序接收两个参数，第一个为作用的设备，第二个为IO类型，定义了三种IO类型：SEQUENCE_IO（顺序），REVERSE_IO（逆序），INTERLEAVE_IO（交替）分别用来验证蓄流阶段的bio后向合并、前向合并和泄流阶段的request合并。为了减少篇幅，此处贴出的源码删除了选项解析和容错处理，只保留主干，原版位于： <a href="https://github.com/liuzhengyuan/iotc%E3%80%82">https://github.com/liuzhengyuan/iotc。</a></p><p>为验证bio在蓄流阶段的后向合并，用上面的测试程序iotc顺序派发三个写io:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ./iotc -d /dev/sdb -s</span><br></code></pre></td></tr></table></figure><p>-d指定作用的设备sdb，-s指定IO方式为SEQUENCE_IO（顺序），表示顺序发起三个写请求：bio0(0 + 8), bio1(8 + 8), bio2(16 + 8)。通过blktrace来观察iotc派发的bio请求在通用块层蓄流链表中的合并情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">blktrace -d /dev/sdb -o - | blkparse -i -<br></code></pre></td></tr></table></figure><img src="/2024/01/04/Block%E6%A8%A1%E5%9D%97%E4%B9%8BIO%E5%90%88%E5%B9%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/1528254084160608.png" alt="Linux通用块层之IO合并"><p>上面的输出可以简单解析为：</p><img src="/2024/01/04/Block%E6%A8%A1%E5%9D%97%E4%B9%8BIO%E5%90%88%E5%B9%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/1528254095647471.png" alt="Linux通用块层之IO合并"><p>第一个bio(bio0)进入通用块层时，此时蓄流链表为空，于是申请一个request并用bio0初始化，再将request添加进蓄流链表，同时告诉blktrace蓄流已正式工作。第二个bio(bio1)到来的时候会走blk_attempt_plug_merge的逻辑，尝试调用bio_attempt_back_merge与蓄流链表中的request合并，发现正好能合并到第一个bio所在的request尾部，于是直接返回。第三个bio(bio2)的处理与第二个同理。通过蓄流合并之后，三个IO请求最终合并成了一个request(0 + 24)。用一副图来展示整个合并过程：</p><img src="/2024/01/04/Block%E6%A8%A1%E5%9D%97%E4%B9%8BIO%E5%90%88%E5%B9%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/1528254105303637.png" alt="Linux通用块层之IO合并" style="zoom: 80%;"><h3 id="bio向前合并"><a href="#bio向前合并" class="headerlink" title="bio向前合并"></a>bio向前合并</h3><p>为验证bio在蓄流阶段的前向合并，使用iotc逆序派发三个写io:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ./iotc -d /dev/sdb -r</span><br></code></pre></td></tr></table></figure><p>-r指定IO方式为REVERSE_IO（逆序），表示逆序发起三个写请求：bio0(16 + 8),bio1(8 + 8), bio2(0 + 8)。blktrace的观察结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">blktrace -d /dev/sdb -o - | blkparse -i -<br></code></pre></td></tr></table></figure><img src="/2024/01/04/Block%E6%A8%A1%E5%9D%97%E4%B9%8BIO%E5%90%88%E5%B9%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/1528254118631038.png" alt="Linux通用块层之IO合并"><p>上面的输出可以简单解析为：</p><img src="/2024/01/04/Block%E6%A8%A1%E5%9D%97%E4%B9%8BIO%E5%90%88%E5%B9%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/1528254143306219.png" alt="Linux通用块层之IO合并"><p>与前面的后向合并相比，唯一的区别是合并方式由之前的”M”变成了现在的”F”，即在blk_attempt_plug_merge中走的是bio_attempt_front_merge分支。通过下面的图来展示前向合并过程：</p><img src="/2024/01/04/Block%E6%A8%A1%E5%9D%97%E4%B9%8BIO%E5%90%88%E5%B9%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/1528254164616153.png" alt="Linux通用块层之IO合并" style="zoom:80%;"><p>“plug合并”不会做request与request的进阶合并，蓄流链表中的request之间的合并会在泄流的时候做，即在下面介绍的“elevator合并”中做。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kernel-4.1.15的bio流程</title>
    <link href="/2024/01/03/kernel-4-1-15%E7%9A%84bio%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/01/03/kernel-4-1-15%E7%9A%84bio%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="kernel-4-1-15的bio流程"><a href="#kernel-4-1-15的bio流程" class="headerlink" title="kernel-4.1.15的bio流程"></a>kernel-4.1.15的bio流程</h1><p>块设备驱动：<a href="https://blog.csdn.net/morecrazylove/article/details/128712522">https://blog.csdn.net/morecrazylove/article/details/128712522</a></p><p>block层演变：<a href="https://blog.csdn.net/weixin_30522983/article/details/112331407">https://blog.csdn.net/weixin_30522983/article/details/112331407</a></p><p>linux块设备驱动blk-mq：<a href="https://www.cnblogs.com/zyly/p/16690841.html">https://www.cnblogs.com/zyly/p/16690841.html</a></p><h2 id="1-发送bio的过程"><a href="#1-发送bio的过程" class="headerlink" title="1.发送bio的过程"></a>1.发送bio的过程</h2><h3 id="submit-bio"><a href="#submit-bio" class="headerlink" title="submit_bio"></a>submit_bio</h3><p>submit_bio是提交bio的总的接口，在块层之上，即文件系统层根据实际场景有很多对submit_bio的不同封装，submit_bio主要调用generic_make_request把bio转换成request。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">submit_bio</span><span class="hljs-params">(<span class="hljs-type">int</span> rw, <span class="hljs-keyword">struct</span> bio *bio)</span><br>&#123;<br>    generic_make_request(bio);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="generic-make-request"><a href="#generic-make-request" class="headerlink" title="generic_make_request"></a>generic_make_request</h3><blockquote><p>注意：current在kernel是一个全局变量，表示当前正在运行的线程，每一个进程维护了一个bio_list</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">generic_make_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bio *bio)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_list</span> <span class="hljs-title">bio_list_on_stack</span>;</span><br>    <br>    <span class="hljs-keyword">if</span> (current-&gt;bio_list) &#123;<br>bio_list_add(current-&gt;bio_list, bio);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>    <br>    bio_list_init(&amp;bio_list_on_stack);<br>current-&gt;bio_list = &amp;bio_list_on_stack;<br><span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 获取块设备对应的I/O请求队列</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">q</span> =</span> bdev_get_queue(bio-&gt;bi_bdev);<br>        <span class="hljs-comment">// 调用请求处理函数，本文为blk_queue_bio</span><br>q-&gt;make_request_fn(q, bio);<br>bio = bio_list_pop(current-&gt;bio_list);<br>&#125; <span class="hljs-keyword">while</span> (bio);<br>current-&gt;bio_list = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* deactivate */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>🔴<strong>为什么每一个进程要设置一个bio_list</strong></p><blockquote><p>详解：<a href="https://blog.csdn.net/flyingnosky/article/details/121362813">https://blog.csdn.net/flyingnosky/article/details/121362813</a></p></blockquote><p><strong>对于每个线程，存在成员current-&gt;bio_list来放置本线程发送的BIO。这里有三条路径发送IO到底层：</strong></p><ul><li>路径一，使能了plug&#x2F;unplug机制，此时会等待plug池中存取足够的IO后统一往调度器插入IO，并选取IO下发；</li><li>路径二，没有使能plug&#x2F;unplug机制，此时会将IO插入调度器中，并选取IO下发；</li><li>路径三，跳过调度层，直接下发IO；</li></ul><img src="/2024/01/03/kernel-4-1-15%E7%9A%84bio%E6%B5%81%E7%A8%8B/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZmx5aW5nbm9za3k=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img" style="zoom:80%;"><h3 id="blk-queue-io"><a href="#blk-queue-io" class="headerlink" title="blk_queue_io"></a>blk_queue_io</h3><p><code>blk_queue_io()</code> 函数是通用块层进行IO合并的入口函数，该函数内先尝试Plug合并，合并成功返回，合并失败则继续尝试Elevator合并，合并成功返回，合并失败则为bio创建一个新的request插入到调度队列中，尝试IO合并部分的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">blk_queue_io</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-keyword">struct</span> bio *bio)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> sync = !!(bio-&gt;bi_rw &amp; REQ_SYNC);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_plug</span> *<span class="hljs-title">plug</span>;</span><br><span class="hljs-type">int</span> el_ret, rw_flags, where = ELEVATOR_INSERT_SORT;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">req</span>, *<span class="hljs-title">free</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> request_count = <span class="hljs-number">0</span>;<br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 做DMA时的相关地址限制，可能该bio只能访问低端内存，</span><br><span class="hljs-comment"> * 因此需要将高端内存中的bio数据拷贝到低端内存中</span><br><span class="hljs-comment"> */</span><br>blk_queue_bounce(q, &amp;bio);<br> <br><span class="hljs-comment">/* 完整性校验 */</span><br><span class="hljs-keyword">if</span> (bio_integrity_enabled(bio) &amp;&amp; bio_integrity_prep(bio)) &#123;<br>bio_endio(bio, -EIO);<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-comment">/* FLUSH和FUA直接生成新的请求处理 */</span><br><span class="hljs-keyword">if</span> (bio-&gt;bi_rw &amp; (REQ_FLUSH | REQ_FUA)) &#123;<br>spin_lock_irq(q-&gt;queue_lock);<br>where = ELEVATOR_INSERT_FLUSH;<br><span class="hljs-keyword">goto</span> get_rq;<br>&#125;<br> <br><span class="hljs-comment">/* 先尝试plug合并，plug中为当前进程的req链表，合并成功直接返回 */</span><br><span class="hljs-keyword">if</span> (!blk_queue_nomerges(q)) &#123;<br><span class="hljs-keyword">if</span> (blk_attempt_plug_merge(q, bio, &amp;request_count, <span class="hljs-literal">NULL</span>))<br><span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span><br>request_count = blk_plug_queued_count(q);<br> <br><span class="hljs-comment">/* 不管是与队列中的请求合并还是插入新的请求都需要加锁 */</span><br>spin_lock_irq(q-&gt;queue_lock);<br> <br><span class="hljs-comment">/* 这里记录下电梯哈希和调度算法调度队列</span><br><span class="hljs-comment"> * bio生成新的请求后，会插入两个地方</span><br><span class="hljs-comment"> * 1.电梯的通用哈希表，以请求的结束为止为哈希值进行哈希，</span><br><span class="hljs-comment"> *   便于查找可以向后合并的请求</span><br><span class="hljs-comment"> *   q-&gt;elevator-&gt;hash</span><br><span class="hljs-comment"> * 2.具体调度算法的调度队列，用于调度算法进行调度，以deadline为例</span><br><span class="hljs-comment"> *   q-&gt;elevator-&gt;elevator_data-&gt;sort_list/fifo_expire</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 调度算法派发请求后，请求会进入q的派发队列，</span><br><span class="hljs-comment"> *   同时从哈希和调度队列中移除</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-comment">/* 在请求队列的哈希表中查找可以向后合并的请求，在调度算法</span><br><span class="hljs-comment"> * 的调度队列中查找可以合并的请求（deadline算法中只有向前合并）</span><br><span class="hljs-comment"> */</span><br>el_ret = elv_merge(q, &amp;req, bio);<br><span class="hljs-keyword">if</span> (el_ret == ELEVATOR_BACK_MERGE) &#123;<br><span class="hljs-comment">/* 尝试进行bio与req的合并 */</span><br><span class="hljs-keyword">if</span> (bio_attempt_back_merge(q, req, bio)) &#123;<br><span class="hljs-comment">/* 合并成功的话，调用具体调度算法的后续处理（deadline中并没有实现接口） */</span><br>elv_bio_merged(q, req, bio);<br><span class="hljs-comment">/* 这次合并的bio可能会弥补两个bio之间的空隙，所以这里查找根据</span><br><span class="hljs-comment"> * 给定req后边的一个请求，判断能否进行合并</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">free</span> = attempt_back_merge(q, req);<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">free</span>)<br><span class="hljs-comment">/* 如果上边没有检测到可以合并的request，则调用接口处理</span><br><span class="hljs-comment"> * bio合并到request之后的处理：</span><br><span class="hljs-comment"> *   1.调用调度算法的回调函数处理调度算法需要执行的操作</span><br><span class="hljs-comment"> *   2.如果是向后合并还需要更新电梯哈希</span><br><span class="hljs-comment"> */</span><br>elv_merged_request(q, req, el_ret);<br><span class="hljs-keyword">else</span><br>__blk_put_request(q, <span class="hljs-built_in">free</span>);<br><span class="hljs-keyword">goto</span> out_unlock;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el_ret == ELEVATOR_FRONT_MERGE) &#123;<br><span class="hljs-keyword">if</span> (bio_attempt_front_merge(q, req, bio)) &#123;<br>elv_bio_merged(q, req, bio);<br><span class="hljs-built_in">free</span> = attempt_front_merge(q, req);<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">free</span>)<br>elv_merged_request(q, req, el_ret);<br><span class="hljs-keyword">else</span><br>__blk_put_request(q, <span class="hljs-built_in">free</span>);<br><span class="hljs-keyword">goto</span> out_unlock;<br>&#125;<br>&#125;<br> <br>get_rq:<br><span class="hljs-comment">/* bio无法合并，为其申请一个新的request */</span><br>rw_flags = bio_data_dir(bio);<br><span class="hljs-keyword">if</span> (sync)<br>rw_flags |= REQ_SYNC;<br> <br>blk_queue_enter_live(q);<br><span class="hljs-comment">/* 获取空闲的请求 */</span><br>req = get_request(q, rw_flags, bio, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (IS_ERR(req)) &#123;<br>blk_queue_exit(q);<br>bio_endio(bio, PTR_ERR(req));<span class="hljs-comment">/* @q is dead */</span><br><span class="hljs-keyword">goto</span> out_unlock;<br>&#125;<br> <br><span class="hljs-comment">/* 根据bio初始化request */</span><br>init_request_from_bio(req, bio);<br> <br><span class="hljs-keyword">if</span> (test_bit(QUEUE_FLAG_SAME_COMP, &amp;q-&gt;queue_flags))<br>req-&gt;cpu = raw_smp_processor_id();<br> <br><span class="hljs-comment">/* 如果当前进程有plug_list，首先插入到plug_list中 */</span><br>plug = current-&gt;plug;<br><span class="hljs-keyword">if</span> (plug) &#123;<br><span class="hljs-keyword">if</span> (!request_count || list_empty(&amp;plug-&gt;<span class="hljs-built_in">list</span>))<br>trace_block_plug(q);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">struct</span> request *last = list_entry_rq(plug-&gt;<span class="hljs-built_in">list</span>.prev);<br><span class="hljs-keyword">if</span> (request_count &gt;= BLK_MAX_REQUEST_COUNT ||<br>    blk_rq_bytes(last) &gt;= BLK_PLUG_FLUSH_SIZE) &#123;<br>blk_flush_plug_list(plug, <span class="hljs-literal">false</span>);<br>trace_block_plug(q);<br>&#125;<br>&#125;<br><span class="hljs-comment">/* 插入到plug链表 */</span><br>list_add_tail(&amp;req-&gt;queuelist, &amp;plug-&gt;<span class="hljs-built_in">list</span>);<br>blk_account_io_start(req, <span class="hljs-literal">true</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>spin_lock_irq(q-&gt;queue_lock);<br><span class="hljs-comment">/* 插入到电梯及调度算法中 */</span><br>add_acct_request(q, req, where);<br><span class="hljs-comment">/* 执行q-&gt;request_fn(q)，调用底层驱动的策略例程处理请求。</span><br><span class="hljs-comment"> * 以SCSI为例，request_fn初始化为scsi_request_fn</span><br><span class="hljs-comment"> * scsi_request_fn-&gt;blk_peek_request-&gt;__elv_next_request</span><br><span class="hljs-comment"> * __elv_next_request中会使用调度具体算法的</span><br><span class="hljs-comment"> * dispatch回调函数取出请求进行处理</span><br><span class="hljs-comment"> */</span><br>__blk_run_queue(q);<br>out_unlock:<br>spin_unlock_irq(q-&gt;queue_lock);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ufs与bio流程备忘</title>
    <link href="/2024/01/03/ufs%E4%B8%8Ebio%E6%B5%81%E7%A8%8B%E5%A4%87%E5%BF%98/"/>
    <url>/2024/01/03/ufs%E4%B8%8Ebio%E6%B5%81%E7%A8%8B%E5%A4%87%E5%BF%98/</url>
    
    <content type="html"><![CDATA[<h1 id="ufs与bio流程备忘"><a href="#ufs与bio流程备忘" class="headerlink" title="ufs与bio流程备忘"></a>ufs与bio流程备忘</h1><p><strong>疑问1：UFS与Scsi的关系</strong></p><img src="/2024/01/03/ufs%E4%B8%8Ebio%E6%B5%81%E7%A8%8B%E5%A4%87%E5%BF%98/wps1.jpg" alt="img"> <p><a href="https://blog.csdn.net/marlos/article/details/130212441">https://blog.csdn.net/marlos/article/details/130212441</a></p><p><strong>疑问2：UFS和MMC处理request的区别</strong></p><p>每个块设备在生成时，会设置自己的request_queue及其属性，回调函数，比如mmc和ufs设备分别设定了mmc_request_fn和scsi_request_fn作为这个request_queue的request_fn，从而实现了block层和设备驱动层的解耦。</p><img src="/2024/01/03/ufs%E4%B8%8Ebio%E6%B5%81%E7%A8%8B%E5%A4%87%E5%BF%98/wps2.jpg" alt="img"> <p><a href="https://mp.weixin.qq.com/s/2TphQjyCkKeN5jy2kGHfoA">https://mp.weixin.qq.com/s/2TphQjyCkKeN5jy2kGHfoA</a></p><p><strong>疑问3：ufs设备和scsi驱动加载流程，在scsi加载的过程中会设置request_fn</strong></p><p><a href="http://www.taodudu.cc/news/show-2094536.html?action=onClick">http://www.taodudu.cc/news/show-2094536.html?action=onClick</a></p><p><img src="/ufs%E4%B8%8Ebio%E6%B5%81%E7%A8%8B%E5%A4%87%E5%BF%98/wps3.jpg" alt="img"> </p><p>scsi_probe_and_add_lun</p><p>scsi_alloc_sdev</p><p>scsi_alloc_queue</p><p>__scsi_alloc_queue</p><p>blk_init_queue</p><p>blk_init_queue_node</p><p>blk_alloc_queue_node</p><img src="/2024/01/03/ufs%E4%B8%8Ebio%E6%B5%81%E7%A8%8B%E5%A4%87%E5%BF%98/wps4.jpg" alt="img"> <p>此时会传递scsi_request_fn为最终在blk_init_allocated_queue中设置为request_queue的request_fn值</p><img src="/2024/01/03/ufs%E4%B8%8Ebio%E6%B5%81%E7%A8%8B%E5%A4%87%E5%BF%98/wps5.jpg" alt="img"> ]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs.fsck简记</title>
    <link href="/2023/12/28/f2fs-fsck%E7%AE%80%E8%AE%B0/"/>
    <url>/2023/12/28/f2fs-fsck%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs-fsck简记"><a href="#f2fs-fsck简记" class="headerlink" title="f2fs.fsck简记"></a>f2fs.fsck简记</h1><img src="/2023/12/28/f2fs-fsck%E7%AE%80%E8%AE%B0/1.png" alt="在这里插入图片描述" style="zoom:80%;"><p>文件校验流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"># 根目录开始: fsck_chk_node_blk(sbi, <span class="hljs-literal">NULL</span>, sbi-&gt;root_ino_num, F2FS_FT_DIR, TYPE_INODE, &amp;blk_cnt, <span class="hljs-literal">NULL</span>);<br># 找到根目录对应的Node block，文件夹对应f2fs_inode: 以fsck_chk_inode_blk(sbi, nid, ftype, node_blk, blk_cnt, &amp;ni, child);<br># 找到i_addr为对应的data block: fsck_chk_data_blk(sbi,IS_CASEFOLDED(&amp;node_blk-&gt;i),blkaddr,...)<br># 此data block为dentry block，处理目录项: __chk_dentries<br># 建立目录树，开始校验子文件【逐步递归，检验所有】: fsck_chk_node_blk(sbi,<span class="hljs-literal">NULL</span>, le32_to_cpu(dentry[i].ino), ftype, TYPE_INODE,...)<br></code></pre></td></tr></table></figure><p>校验到一个node块损坏的块有以下现象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sanity_check_nid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, u32 nid,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> f2fs_node *node_blk,</span><br><span class="hljs-params"><span class="hljs-keyword">enum</span> FILE_TYPE ftype, <span class="hljs-keyword">enum</span> NODE_TYPE ntype,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> node_info *ni)</span><br>&#123;<br>    <br>    get_node_info(sbi, nid, ni);<br>    ret = dev_read_block(node_blk, ni-&gt;blk_addr);<br>    <br>    <span class="hljs-comment">// 问题出在这里</span><br>    <span class="hljs-keyword">if</span> (le32_to_cpu(node_blk-&gt;footer.nid) != nid) &#123;<br>ASSERT_MSG(<span class="hljs-string">&quot;nid[0x%x] blk_addr[0x%x] footer.nid[0x%x]&quot;</span>,<br>nid, ni-&gt;blk_addr,<br>le32_to_cpu(node_blk-&gt;footer.nid));<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/12/28/f2fs-fsck%E7%AE%80%E8%AE%B0/image-20231228233647975.png" alt="image-20231228233647975" style="zoom:67%;"><p>可以看到此处把位图清理了。</p><p>下次索引的时候就不会再检查了</p><img src="/2023/12/28/f2fs-fsck%E7%AE%80%E8%AE%B0/image-20231228235700614.png" alt="image-20231228235700614" style="zoom:67%;"><hr><p>一个dentry block可以记录214个dentry和文件名，成员包括：一个位图、预留空间、dentries 部分 和 文件名部分，共4KB。<br>Dentry Block(4 K) &#x3D; bitmap (27 bytes) + reserved (3 bytes) + dentries(11 * 214 bytes) + file name (8 * 214 bytes)<br>具体结构如下：</p><img src="/2023/12/28/f2fs-fsck%E7%AE%80%E8%AE%B0/image-20231228235527206.png" alt="image-20231228235527206" style="zoom:67%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android应用启动全流程分析（源码深度剖析）</title>
    <link href="/2023/12/26/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%85%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%EF%BC%89/"/>
    <url>/2023/12/26/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%85%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Android应用启动全流程分析（源码深度剖析）"><a href="#Android应用启动全流程分析（源码深度剖析）" class="headerlink" title="Android应用启动全流程分析（源码深度剖析）"></a>Android应用启动全流程分析（源码深度剖析）</h1><blockquote><p>作者：努比亚技术团队<br>源码来源：努比亚技术团队</p></blockquote><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>从用户手指点击桌面上的应用图标到屏幕上显示出应用主Activity界面而完成应用启动，快的话往往都不需要一秒钟，但是这整个过程却是十分复杂的，其中涉及了Android系统的几乎所有核心知识点。同时应用的启动速度也绝对是系统的核心用户体验指标之一，多少年来，无论是谷歌或是手机系统厂商们还是各个Android应用开发者，都在为实现应用打开速度更快一点的目标而不断努力。但是要想真正做好应用启动速度优化这件事情，我想是必须要对应用启动的整个流程有充分的认识和理解的，所以无论作为Android系统或应用开发者，都有必要好好的学习和了解一下这个过程的。网上有很多介绍应用启动流程源码的文章，但是总感觉大多数都不太全面，很多只是介绍了应用启动过程中的部分流程，而没有总体清晰的认识应用启动过程的总体脉络与系统架构设计思想。所以本文将结合笔者多年来的工作经历，结合systrace分析工具，基于Android R AOSP源码完整的分析一下这个从用户手指触控点击屏幕应用图标到应用界面展示到屏幕上的整个应用启动过程，也是对之前所做所学的一个总结与归纳。</p><h2 id="2-大纲"><a href="#2-大纲" class="headerlink" title="2.大纲"></a>2.大纲</h2><ul><li><strong>Android触控事件处理机制</strong></li><li><strong>Zygote进程启动和应用进程创建流程</strong></li><li><strong>Handler消息机制</strong></li><li><strong>AMS的Activity组件管理</strong></li><li><strong>应用Application和Activity组件创建与初始化</strong></li><li><strong>应用UI布局与绘制</strong></li><li><strong>RenderThread渲染</strong></li><li><strong>SurfaceFlinger合成显示</strong></li><li><strong>写在最后</strong></li><li><strong>参考</strong></li></ul><h2 id="3-Input触控事件处理流程"><a href="#3-Input触控事件处理流程" class="headerlink" title="3.Input触控事件处理流程"></a>3.Input触控事件处理流程</h2><h2 id="4-应用进程的创建与启动"><a href="#4-应用进程的创建与启动" class="headerlink" title="4.应用进程的创建与启动"></a>4.应用进程的创建与启动</h2><h3 id="4-1-Pause桌面应用"><a href="#4-1-Pause桌面应用" class="headerlink" title="4.1 Pause桌面应用"></a>4.1 Pause桌面应用</h3><p>接着上一节继续往下看，桌面进程收到input触控事件并处理后<code>binder</code>调用框架<code>AMS</code>的的<code>startActivity</code>接口启动应用，相关简化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">startActivityUnchecked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="hljs-params">                                   IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="hljs-params">                                   <span class="hljs-type">int</span> startFlags, <span class="hljs-type">boolean</span> doResume, ActivityOptions options, Task inTask,</span><br><span class="hljs-params">                                   <span class="hljs-type">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br>        <span class="hljs-comment">// 添加“startActivityInner”的systrace tag</span><br>        Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, <span class="hljs-string">&quot;startActivityInner&quot;</span>);<br>        <span class="hljs-comment">// 执行startActivityInner启动应用的逻辑</span><br>        result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,<br>                                    startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在执行<code>startActivityInner</code>启动应用逻辑中，<code>AMS</code>中的<code>Activity</code>栈管理的逻辑，<strong>检查发现当前处于前台<code>Resume</code>状态的<code>Activity</code>是桌面应用，所以第一步需要通知桌面应用的<code>Activity</code>进入<code>Paused</code>状态</strong>，相关简化代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/services/core/java/com/android/server/wm/ActivityStack.java*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">resumeTopActivityInnerLocked</span><span class="hljs-params">(ActivityRecord prev, ActivityOptions options)</span> &#123;<br>   ...<br>   <span class="hljs-comment">// mResumedActivity不为null，说明当前存在处于resume状态的Activity且不是新需要启动的应用</span><br>   <span class="hljs-keyword">if</span> (mResumedActivity != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 执行startPausingLocked通知桌面应用进入paused状态</span><br>      pausing |= startPausingLocked(userLeaving, <span class="hljs-literal">false</span> <span class="hljs-comment">/* uiSleeping */</span>, next);<br>   &#125;<br>   ...<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startPausingLocked</span><span class="hljs-params">(<span class="hljs-type">boolean</span> userLeaving, <span class="hljs-type">boolean</span> uiSleeping,</span><br><span class="hljs-params">            ActivityRecord resuming)</span> &#123;<br>    ...<br>    <span class="hljs-type">ActivityRecord</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> mResumedActivity;<br>    ...<br>    <span class="hljs-keyword">if</span> (prev.attachedToProcess()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>             ...<br>             <span class="hljs-comment">// 相关执行动作封装事务，binder通知mResumedActivity也就是桌面执行pause动作</span><br>             mAtmService.getLifecycleManager().scheduleTransaction(prev.app.getThread(),<br>                        prev.appToken, PauseActivityItem.obtain(prev.finishing, userLeaving,<br>                        prev.configChangeFlags, pauseImmediately));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>           ...<br>        &#125;<br>     &#125;<br>     ...<br>&#125;<br></code></pre></td></tr></table></figure><p>桌面应用进程这边执行收到<code>pause</code>消息后执行<code>Activity</code>的<code>onPause</code>生命周期，并在执行完成后，会<code>binder</code>调用<code>AMS</code>的<code>activityPaused</code>接口通知系统执行完<code>activity</code>的<code>pause</code>动作，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postExecute</span><span class="hljs-params">(ClientTransactionHandler client, IBinder token,</span><br><span class="hljs-params">                        PendingTransactionActions pendingActions)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// binder通知AMS当前应用activity已经执行完pause的流程</span><br>        ActivityTaskManager.getService().activityPaused(token);<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>        <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AMS</code>这边收到应用的<code>activityPaused</code>调用后，继续执行启动应用的逻辑，<strong>判断需要启动的应用<code>Activity</code>所在的进程不存在，所以接下来需要先<code>startProcessAsync</code>创建应用进程</strong>，相关简化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java*/</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startSpecificActivity</span><span class="hljs-params">(ActivityRecord r, <span class="hljs-type">boolean</span> andResume, <span class="hljs-type">boolean</span> checkConfig)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">WindowProcessController</span> <span class="hljs-variable">wpc</span> <span class="hljs-operator">=</span><br>                mService.getProcessController(r.processName, r.info.applicationInfo.uid);<br>     ...<br>     <span class="hljs-comment">// 1.如果wpc不为null且hasThread表示应用Activity所属进程存在，直接realStartActivityLocked启动Activity</span><br>     <span class="hljs-keyword">if</span> (wpc != <span class="hljs-literal">null</span> &amp;&amp; wpc.hasThread()) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             realStartActivityLocked(r, wpc, andResume, checkConfig);<br>             <span class="hljs-keyword">return</span>;<br>         &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>             Slog.w(TAG, <span class="hljs-string">&quot;Exception when starting activity &quot;</span><br>                    + r.intent.getComponent().flattenToShortString(), e);<br>         &#125;<br>         ...<br>     &#125;<br>     ...<br>     <span class="hljs-comment">// 2.否则，调用AMS的startProcessAsync正式开始创建应用进程 </span><br>     mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? <span class="hljs-string">&quot;top-activity&quot;</span> : <span class="hljs-string">&quot;activity&quot;</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p>以上过程从systrace上看，如下图所示：</p><ol><li>通知pause桌面应用</li></ol><img src="/2023/12/26/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%85%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%EF%BC%89/9d1d580904014f5094bacd9c18b1fe81.webp" alt="img" style="zoom:80%;"><ol start="2"><li>确认桌面<code>activityPaused</code>状态之后，开始创建应用进程：</li></ol><img src="/2023/12/26/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%85%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%EF%BC%89/da7a06facb0a4155b795d8c1464ed71d.webp" alt="img" style="zoom:80%;"><h3 id="4-2-创建应用进程"><a href="#4-2-创建应用进程" class="headerlink" title="4.2 创建应用进程"></a>4.2 创建应用进程</h3><p>接上一小节的分析可以知道，Android应用进程的启动是被动式的，在桌面点击图标启动一个应用的组件如Activity时，如果Activity所在的进程不存在，就会创建并启动进程。<strong>Android系统中一般应用进程的创建都是统一由zygote进程fork创建的，AMS在需要创建应用进程时，会通过socket连接并通知到到zygote进程在开机阶段就创建好的socket服务端，然后由zygote进程fork创建出应用进程。</strong>整体架构如下图所示：</p><img src="/2023/12/26/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%85%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%EF%BC%89/3067c5b0d9284ef7b41f32c758ec3a24.webp" alt="img" style="zoom:80%;"><p>我们接着上节中的分析，继续从<code>AMS#startProcessAsync</code>创建进程函数入手，继续看一下应用进程创建相关简化流程代码：</p><h4 id="4-2-1-AMS-发送socket请求"><a href="#4-2-1-AMS-发送socket请求" class="headerlink" title="4.2.1 AMS 发送socket请求"></a>4.2.1 AMS 发送socket请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java*/</span>  <br> <span class="hljs-meta">@GuardedBy(&quot;this&quot;)</span><br> <span class="hljs-keyword">final</span> ProcessRecord <span class="hljs-title function_">startProcessLocked</span><span class="hljs-params">(...)</span> &#123;<br>      <span class="hljs-keyword">return</span> mProcessList.startProcessLocked(...);<br> &#125;<br> <br> <span class="hljs-comment">/*frameworks/base/services/core/java/com/android/server/am/ProcessList.java*/</span><br> <span class="hljs-keyword">private</span> Process.ProcessStartResult <span class="hljs-title function_">startProcess</span><span class="hljs-params">(HostingRecord hostingRecord, String entryPoint,</span><br><span class="hljs-params">          ProcessRecord app, <span class="hljs-type">int</span> uid, <span class="hljs-type">int</span>[] gids, <span class="hljs-type">int</span> runtimeFlags, <span class="hljs-type">int</span> zygotePolicyFlags,</span><br><span class="hljs-params">          <span class="hljs-type">int</span> mountExternal, String seInfo, String requiredAbi, String instructionSet,</span><br><span class="hljs-params">          String invokeWith, <span class="hljs-type">long</span> startTime)</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 原生标识应用进程创建所加的systrace tag</span><br>          Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;Start proc: &quot;</span> +<br>                  app.processName);<br>          ...<br>          <span class="hljs-comment">// 调用Process的start方法创建进程</span><br>          startResult = Process.start(...);<br>          ...<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>      &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">/*frameworks/base/core/java/android/os/Process.java*/</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ProcessStartResult <span class="hljs-title function_">start</span><span class="hljs-params">(...)</span> &#123;<br>      <span class="hljs-comment">// 调用ZygoteProcess的start函数</span><br>      <span class="hljs-keyword">return</span> ZYGOTE_PROCESS.start(...);<br>  &#125;<br>  <br>  <span class="hljs-comment">/*frameworks/base/core/java/android/os/ZygoteProcess.java*/</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Process.ProcessStartResult <span class="hljs-title function_">start</span><span class="hljs-params">(...)</span>&#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">return</span> startViaZygote(...);<br>      &#125; <span class="hljs-keyword">catch</span> (ZygoteStartFailedEx ex) &#123;<br>         ...<br>      &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> Process.ProcessStartResult <span class="hljs-title function_">startViaZygote</span><span class="hljs-params">(...)</span>&#123;<br>      ArrayList&lt;String&gt; argsForZygote = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>      ...<br>      <span class="hljs-keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);<br>  &#125;<br></code></pre></td></tr></table></figure><p>在ZygoteProcess#startViaZygote中，最后创建应用进程的逻辑：</p><ol><li>openZygoteSocketIfNeeded函数中打开本地socket客户端连接到zygote进程的socket服务端；</li><li>zygoteSendArgsAndGetResult发送socket请求参数，带上了创建的应用进程参数信息；</li><li>return返回的数据结构ProcessStartResult中会有新创建的进程的pid字段。</li></ol><p>从systrace上看这个过程如下：</p><img src="/2023/12/26/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%85%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%EF%BC%89/831376e8bd384f588e52d31b3907bc41.webp" alt="img" style="zoom:80%;"><h3 id="4-2-2-Zygote-处理socket请求"><a href="#4-2-2-Zygote-处理socket请求" class="headerlink" title="4.2.2 Zygote 处理socket请求"></a>4.2.2 Zygote 处理socket请求</h3><p>其实早在系统开机阶段，<code>zygote</code>进程创建时，就会在<code>ZygoteInit#main</code>入口函数中创建服务端<code>socket</code>，<strong>并预加载系统资源和框架类（加速应用进程启动速度）</strong>，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/core/java/com/android/internal/os/ZygoteInit.java*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> &#123;<br>       <span class="hljs-type">ZygoteServer</span> <span class="hljs-variable">zygoteServer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        ...<br>       <span class="hljs-keyword">try</span> &#123;<br>           ...<br>           <span class="hljs-comment">// 1.preload提前加载框架通用类和系统资源到进程，加速进程启动</span><br>           preload(bootTimingsTraceLog);<br>           ...<br>           <span class="hljs-comment">// 2.创建zygote进程的socket server服务端对象</span><br>           zygoteServer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZygoteServer</span>(isPrimaryZygote);<br>           ...<br>           <span class="hljs-comment">// 3.进入死循环，等待AMS发请求过来</span><br>           caller = zygoteServer.runSelectLoop(abiList);<br>       &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>           ...<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           ...<br>       &#125;<br>       ...<br>   &#125;<br></code></pre></td></tr></table></figure><p>继续往下看<code>ZygoteServer#runSelectLoop</code>如何监听并处理AMS客户端的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/core/java/com/android/internal/os/ZygoteServer.java*/</span><br>Runnable <span class="hljs-title function_">runSelectLoop</span><span class="hljs-params">(String abiList)</span> &#123;<br>    <span class="hljs-comment">// 进入死循环监听</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>       <span class="hljs-keyword">while</span> (--pollIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">if</span> (pollIndex == <span class="hljs-number">0</span>) &#123;<br>            ...<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pollIndex &lt; usapPoolEventFDIndex) &#123;<br>            <span class="hljs-comment">// Session socket accepted from the Zygote server socket</span><br>            <span class="hljs-comment">// 得到一个请求连接封装对象ZygoteConnection</span><br>            <span class="hljs-type">ZygoteConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> peers.get(pollIndex);<br>            <span class="hljs-comment">// processCommand函数中处理AMS客户端请求</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> connection.processCommand(<span class="hljs-built_in">this</span>, multipleForksOK);<br>          &#125;<br>       &#125;<br>    &#125;<br>&#125;<br><br>Runnable <span class="hljs-title function_">processCommand</span><span class="hljs-params">(ZygoteServer zygoteServer, <span class="hljs-type">boolean</span> multipleOK)</span> &#123;<br>        ...<br>        <span class="hljs-comment">// 1.fork创建应用子进程</span><br>        pid = Zygote.forkAndSpecialize(...);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>                ...<br>                <span class="hljs-comment">// 2.pid为0，当前处于新创建的子应用进程中，处理请求参数</span><br>                <span class="hljs-keyword">return</span> handleChildProc(parsedArgs, childPipeFd, parsedArgs.mStartChildZygote);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ...<br>                handleParentProc(pid, serverPipeFd);<br>            &#125;<br>         &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ...<br>         &#125;<br>&#125;<br><br> <span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">handleChildProc</span><span class="hljs-params">(ZygoteArguments parsedArgs,</span><br><span class="hljs-params">           FileDescriptor pipeFd, <span class="hljs-type">boolean</span> isZygote)</span> &#123;<br>       ...<br>       <span class="hljs-comment">// 关闭从父进程zygote继承过来的ZygoteServer服务端地址</span><br>       closeSocket();<br>       ...<br>       <span class="hljs-keyword">if</span> (parsedArgs.mInvokeWith != <span class="hljs-literal">null</span>) &#123;<br>          ...<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">if</span> (!isZygote) &#123;<br>               <span class="hljs-comment">// 继续进入ZygoteInit#zygoteInit继续完成子应用进程的相关初始化工作</span><br>               <span class="hljs-keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,<br>                       parsedArgs.mDisabledCompatChanges,<br>                       parsedArgs.mRemainingArgs, <span class="hljs-literal">null</span> <span class="hljs-comment">/* classLoader */</span>);<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               ...<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>以上过程从systrace上看如下图所示：</p><img src="/2023/12/26/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%85%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%EF%BC%89/a789b961b94945a2bc1cff228350c927.webp" alt="img" style="zoom:80%;"><h4 id="4-2-3-应用进程初始化"><a href="#4-2-3-应用进程初始化" class="headerlink" title="4.2.3 应用进程初始化"></a>4.2.3 应用进程初始化</h4><p>接上一节中的分析，<code>zygote</code>进程监听接收<code>AMS</code>的请求，<code>fork</code>创建子应用进程，然后<code>pid</code>为0时进入子进程空间，然后在 <code>ZygoteInit#zygoteInit</code>中完成进程的初始化动作，相关简化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/core/java/com/android/internal/os/ZygoteInit.java*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title function_">zygoteInit</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSdkVersion, <span class="hljs-type">long</span>[] disabledCompatChanges,</span><br><span class="hljs-params">            String[] argv, ClassLoader classLoader)</span> &#123;<br>        ...<br>        <span class="hljs-comment">// 原生添加名为“ZygoteInit ”的systrace tag以标识进程初始化流程</span><br>        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;ZygoteInit&quot;</span>);<br>        RuntimeInit.redirectLogStreams();<br>        <span class="hljs-comment">// 1.RuntimeInit#commonInit中设置应用进程默认的java异常处理机制</span><br>        RuntimeInit.commonInit();<br>        <span class="hljs-comment">// 2.ZygoteInit#nativeZygoteInit函数中JNI调用启动进程的binder线程池</span><br>        ZygoteInit.nativeZygoteInit();<br>        <span class="hljs-comment">// 3.RuntimeInit#applicationInit中反射创建ActivityThread对象并调用其“main”入口方法</span><br>        <span class="hljs-keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,<br>                classLoader);<br> &#125;<br></code></pre></td></tr></table></figure><p>应用进程启动后，初始化过程中主要依次完成以下几件事情：</p><ol><li>应用进程默认的java异常处理机制（可以实现监听、拦截应用进程所有的Java crash的逻辑）；</li><li>JNI调用启动进程的binder线程池（注意应用进程的binder线程池资源是自己创建的并非从zygote父进程继承的）；</li><li>通过反射创建ActivityThread对象并调用其“main”入口方法。</li></ol><p>我们继续看<code>RuntimeInit#applicationInit</code>简化的代码流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*frameworks/base/core/java/com/android/internal/os/RuntimeInit.java*/</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title function_">applicationInit</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSdkVersion, <span class="hljs-type">long</span>[] disabledCompatChanges,</span><br><span class="hljs-params">           String[] argv, ClassLoader classLoader)</span> &#123;<br>       ...<br>       <span class="hljs-comment">// 结束“ZygoteInit ”的systrace tag</span><br>       Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>       <span class="hljs-comment">// Remaining arguments are passed to the start class&#x27;s static main</span><br>       <span class="hljs-keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);<br> &#125;<br> <br> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title function_">findStaticMain</span><span class="hljs-params">(String className, String[] argv,</span><br><span class="hljs-params">           ClassLoader classLoader)</span> &#123;<br>       Class&lt;?&gt; cl;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 1.反射加载创建ActivityThread类对象</span><br>           cl = Class.forName(className, <span class="hljs-literal">true</span>, classLoader);<br>       &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>           ...<br>       &#125;<br>       Method m;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 2.反射调用其main方法</span><br>           m = cl.getMethod(<span class="hljs-string">&quot;main&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String[].class &#125;);<br>       &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException ex) &#123;<br>           ...<br>       &#125; <span class="hljs-keyword">catch</span> (SecurityException ex) &#123;<br>           ...<br>       &#125;<br>       ...<br>       <span class="hljs-comment">// 3.触发执行以上逻辑</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodAndArgsCaller</span>(m, argv);<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>可以看到进程<code>ActivityThread#main</code>函数初始化的主要逻辑是：</p><ol><li><strong>创建并启动主线程的<code>loop</code>消息循环；</strong></li><li><strong>通过<code>binder</code>调用<code>AMS</code>的<code>attachApplication</code>接口将自己<code>attach</code>注册到<code>AMS</code>中。</strong></li></ol><p>以上初始化过程。从systrace上看如下图所示：</p><img src="/2023/12/26/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%85%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%EF%BC%89/e729f9e2f20d43a8a9e4853ec09e2e76.webp" alt="img" style="zoom:80%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ext2文件系统格式化mke2fs</title>
    <link href="/2023/12/25/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E5%8C%96mke2fs/"/>
    <url>/2023/12/25/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E5%8C%96mke2fs/</url>
    
    <content type="html"><![CDATA[<h1 id="ext2文件系统格式化mke2fs"><a href="#ext2文件系统格式化mke2fs" class="headerlink" title="ext2文件系统格式化mke2fs"></a>ext2文件系统格式化mke2fs</h1><h2 id="ext2磁盘布局"><a href="#ext2磁盘布局" class="headerlink" title="ext2磁盘布局"></a>ext2磁盘布局</h2><img src="/2023/12/25/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E5%8C%96mke2fs/Center.gif" alt="img" style="zoom: 90%;"><p>格式化的代码都是围绕这张图来进行的</p><h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">errcode_t</span> <span class="hljs-title function_">ext2fs_initialize</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> ext2_super_block *param,</span><br><span class="hljs-params">    io_manager manager, ext2_filsys *ret_fs)</span><br>&#123;<br>    ext2_filsysfs;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext2_super_block</span> *<span class="hljs-title">super</span>;</span><br>    <br>    retval = ext2fs_get_mem(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> struct_ext2_filsys), &amp;fs);<br>    <span class="hljs-built_in">memset</span>(fs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> struct_ext2_filsys));<br>fs-&gt;magic = EXT2_ET_MAGIC_EXT2FS_FILSYS;<br>fs-&gt;flags = flags | EXT2_FLAG_RW;<br>fs-&gt;umask = <span class="hljs-number">022</span>;<br>fs-&gt;default_bitmap_type = EXT2FS_BMAP64_RBTREE;<br>    <br>    <span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/12/25/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E5%8C%96mke2fs/image-20231225232019834.png" alt="image-20231225232019834" style="zoom: 67%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handle_bad_blocks</span><span class="hljs-params">(ext2_filsys fs, badblocks_list bb_list)</span><br>&#123;<br>    <span class="hljs-comment">// 块组0的超级块和块组描述符必须是好块</span><br>    <span class="hljs-comment">// fs-&gt;super-&gt;s_first_data_block表示块组0的起始块</span><br>    <span class="hljs-comment">// fs-&gt;desc_blocks表示块组描述符占用的块数</span><br>must_be_good = fs-&gt;super-&gt;s_first_data_block + <span class="hljs-number">1</span> + fs-&gt;desc_blocks;<br><span class="hljs-keyword">for</span> (i = fs-&gt;super-&gt;s_first_data_block; i &lt;= must_be_good; i++) &#123;<br>        <span class="hljs-comment">// 当前的块在坏块位图中是否置位</span><br><span class="hljs-keyword">if</span> (ext2fs_badblocks_list_test(bb_list, i)) &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// group_block为块组1的起始块</span><br>group_block = fs-&gt;super-&gt;s_first_data_block + fs-&gt;super-&gt;s_blocks_per_group;<br><br>    <span class="hljs-comment">// 从块组1开始，检验所有块组的超级块和块组描述符</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; fs-&gt;group_desc_count; i++) &#123;<br>group_bad = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j &lt; fs-&gt;desc_blocks+<span class="hljs-number">1</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (ext2fs_badblocks_list_test(bb_list, group_block + j)) &#123;<br>group_bad++;<br>group = ext2fs_group_of_blk2(fs, group_block+j);<br>ext2fs_bg_free_blocks_count_set(fs, group, ext2fs_bg_free_blocks_count(fs, group) + <span class="hljs-number">1</span>);<br>ext2fs_group_desc_csum_set(fs, group);<br>ext2fs_free_blocks_count_add(fs-&gt;super, <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>group_block += fs-&gt;super-&gt;s_blocks_per_group;<br>&#125;<br><br>retval = ext2fs_badblocks_list_iterate_begin(bb_list, &amp;bb_iter);<br><br>    <span class="hljs-comment">// 将所有的坏块标记为已使用</span><br><span class="hljs-keyword">while</span> (ext2fs_badblocks_list_iterate(bb_iter, &amp;blk))<br>ext2fs_mark_block_bitmap2(fs-&gt;block_map, EXT2FS_B2C(fs, blk));<br>ext2fs_badblocks_list_iterate_end(bb_iter);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="坏块位图中二分查找"><a href="#坏块位图中二分查找" class="headerlink" title="坏块位图中二分查找"></a>坏块位图中二分查找</h2><p>在mke2fs源码里面调用了libe2fs.so中提供的位图查询接口：<code>ext2fs_badblocks_list_test</code></p><p>ext2fs_u32_list_find结构体中的变量list存放了所有坏块的索引，例如现在坏块的位置为6,76,289,409。那么bb-&gt;list即为[6,76,289,409]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ext2fs_badblocks_list_test</span><span class="hljs-params">(ext2_badblocks_list bb, <span class="hljs-type">blk_t</span> blk)</span><br>&#123;<br><span class="hljs-keyword">return</span> ext2fs_u32_list_test((ext2_u32_list) bb, (__u32) blk);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">ext2fs_u32_list_test</span><span class="hljs-params">(ext2_u32_list bb, __u32 blk)</span><br>&#123;<br><span class="hljs-keyword">if</span> (ext2fs_u32_list_find(bb, blk) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">ext2fs_u32_list_find</span><span class="hljs-params">(ext2_u32_list bb, __u32 blk)</span><br>&#123;<br><span class="hljs-type">int</span>low, high, mid;<br><br><span class="hljs-keyword">if</span> (bb-&gt;magic != EXT2_ET_MAGIC_BADBLOCKS_LIST)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">if</span> (bb-&gt;num == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>low = <span class="hljs-number">0</span>;<br>high = bb-&gt;num<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span> (blk == bb-&gt;<span class="hljs-built_in">list</span>[low])<br><span class="hljs-keyword">return</span> low;<br><span class="hljs-keyword">if</span> (blk == bb-&gt;<span class="hljs-built_in">list</span>[high])<br><span class="hljs-keyword">return</span> high;<br><br><span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>mid = ((<span class="hljs-type">unsigned</span>)low + (<span class="hljs-type">unsigned</span>)high)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (mid == low || mid == high)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span> (blk == bb-&gt;<span class="hljs-built_in">list</span>[mid])<br><span class="hljs-keyword">return</span> mid;<br><span class="hljs-keyword">if</span> (blk &lt; bb-&gt;<span class="hljs-built_in">list</span>[mid])<br>high = mid;<br><span class="hljs-keyword">else</span><br>low = mid;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是典型的二分查找算法，在坏块列表中查找目标元素是否存在，存在则返回列表索引，失败返回-1。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>yaffs文件系统坏块处理简记</title>
    <link href="/2023/12/20/yaffs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9D%8F%E5%9D%97%E5%A4%84%E7%90%86%E7%AE%80%E8%AE%B0/"/>
    <url>/2023/12/20/yaffs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9D%8F%E5%9D%97%E5%A4%84%E7%90%86%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="yaffs文件系统坏块处理简记"><a href="#yaffs文件系统坏块处理简记" class="headerlink" title="yaffs文件系统坏块处理简记"></a>yaffs文件系统坏块处理简记</h1><p>先看下<strong>林子雨老师《闪存数据库概念与技术》</strong>中的描述：</p><p>NAND 闪存被设计成具有很低的代价和很高的密度。为了获得更高的产出，从而减小产品成本，NAND 闪存通常都会在出厂时包含一些坏块，此外，在闪存设备使用过程中，也会出现一些新的坏块。因此，对于任何闪存文件系统而言，如果不具备坏块处理机制，就不适合用来管理闪存。</p><p>Yaffs1 使用 SM 卡类型的坏块标记，它会检查闪存页的带外区域的第6 个字节（字节 5），如果是一个好块，这个字节应该是 0XFF，如果一个块在出厂时已经被标记为坏块，这个字节应该是 0X00。当闪存设备在后续使用过程中出现坏块时，Yaffs1 会使用自己的方式对坏块进行标记，从而和工厂标记的坏块加以区分。当读或写操作失败的时候，或者当三个 ECC错误被探测到的时候，Yaffs 就会把一个块标记为―坏块‖。ECC 可以通过硬件实现，也可以通过软件驱动实现，或者在 Yaffs 自身内部实现。需要再次强调的是，任何缺乏有效 ECC处理机制的闪存文件系统，是不适合作为闪存管理的。如果 Yaffs1 确定一个块是坏块，它就会把该块标记为 0X59（’Y’）。一个块被标记为坏块以后，就会退出使用，从而改进了文件系统的鲁棒性。</p><p>Yaffs2 模式被设计成支持更大范围的设备和带外区域布局。因此，Yaffs2 没有确定带外区域的哪个字节作为标记位，而是调用驱动函数来确定一个块是否是坏块以及标记它为坏块。Yaffs2 没有提供内置的 ECC，而是需要由驱动程序提供 ECC</p><hr><p>在yaffs文件系统中标记坏块并且退出使用的函数调用栈为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">yaffs_block_became_dirty<br>    yaffs_retire_block<br>    yaffs_mark_bad<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>yaffs文件系统布局</title>
    <link href="/2023/12/18/yaffs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/"/>
    <url>/2023/12/18/yaffs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="yaffs文件系统布局"><a href="#yaffs文件系统布局" class="headerlink" title="yaffs文件系统布局"></a>yaffs文件系统布局</h1><h2 id="nand-flash结构"><a href="#nand-flash结构" class="headerlink" title="nand flash结构"></a>nand flash结构</h2><img src="/2023/12/18/yaffs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/Center.png" alt="这里写图片描述" style="zoom:75%;"><p>nand flash的存储结构为：一个flash由许多个block组成，一个block又是有许多个page组成，一个page又是由有效的数据区和spare area区（即oob区）。 </p><p>如上图flash有1024个block，一个block有64个page，一个page有2Kbytes的有效数据+64bytes的oob数据。<br>我们通常计算nand flash容量大小为：总共的block数 * 一个block中的page数 * 一个page中的有效数据区。oob区为特殊数据，用作硬件纠错和坏块管理的。</p><blockquote><p>详细的可以参考：<a href="https://blog.csdn.net/davion_zhang/article/details/79013293?spm=1001.2014.3001.5506">https://blog.csdn.net/davion_zhang/article/details/79013293?spm=1001.2014.3001.5506</a></p></blockquote><h2 id="什么是chunk"><a href="#什么是chunk" class="headerlink" title="什么是chunk"></a>什么是chunk</h2><p>chunk在英文中的解释是”组块”，它的布局方式完全是按照nand flash的结构来的，这里以yaffs文件系统为例</p><blockquote><p>yaffs文件系统是针对page中数据区位512Byte设计的，而yaffs2文件系统则是针对page中数据区为2048Byte设计的（也就是上图）</p></blockquote><img src="/2023/12/18/yaffs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20231218230704748.png" alt="image-20231218230704748" style="zoom:67%;"><blockquote><p>要说明的是：yaffs对文件系统上的所有内容（比如正常文件，目录，链接，设备文件等等）都统一当做文件来处理，每个文件都有一个页面专门存放文件头，文件头保存了文件的模式，所有者ID，组ID，长度，文件名，Parent Object ID等信息。</p></blockquote><p>因此，yaffs文件系统中的chunk又分为<strong>header chunk</strong>和<strong>data chunk</strong>，</p><ul><li>header的chunk_id为0</li><li>每文件的chunk都有一个chunk_id，如果一个文件占据了多个chunk(page)，那么chunk_id从1开始计数</li></ul><h2 id="chunk-id与obj-id的区分"><a href="#chunk-id与obj-id的区分" class="headerlink" title="chunk_id与obj_id的区分"></a>chunk_id与obj_id的区分</h2><p>每一个chunk都是一个object，所以都有一个obj_id，根目录header chunk对应的chunk其obj_id为1，其余的所有文件对应的一个个chunk从257(<code>YAFFS_NOBJECT_BUCKETS + 1</code>)开始依次递增</p><p>而每一个完整的文件都是由<strong>header + data</strong>的形式构成，文件的头(header chunk)，其chunk_id为0，真正的文件内容(data chunk)，其chunk_id从1开始递增，直到文件结束</p><h2 id="文件布局"><a href="#文件布局" class="headerlink" title="文件布局"></a>文件布局</h2><p>每一个正常文件的布局都应该是header chunk，然后接下来是所有文件的data chunk</p><img src="/2023/12/18/yaffs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20231218232136406.png" alt="image-20231218232136406" style="zoom:80%;"><p>代码依据来自于：<code>yaffs2\utils\mkyaffsimage.c</code></p><img src="/2023/12/18/yaffs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20231218232317681.png" alt="image-20231218232317681" style="zoom: 60%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统特性标志位</title>
    <link href="/2023/12/18/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%80%A7%E6%A0%87%E5%BF%97%E4%BD%8D/"/>
    <url>/2023/12/18/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%80%A7%E6%A0%87%E5%BF%97%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统特性标志位"><a href="#f2fs文件系统特性标志位" class="headerlink" title="f2fs文件系统特性标志位"></a>f2fs文件系统特性标志位</h1><p>在f2fs文件系统挂载的时候会调用<code>parse_options</code>解析挂载选项：</p><img src="/2023/12/18/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%80%A7%E6%A0%87%E5%BF%97%E4%BD%8D/image-20231218213547571.png" alt="image-20231218213547571" style="zoom:67%;"><p>这里有一些检查特性的函数例如：f2fs_sb_has_quota_ino、f2fs_sb_has_casefold等函数死活在f2fs源码里面找不到实现。</p><p>其实，这些特性函数校验函数都有一个规律，都是以<code>f2fs_sb_has</code>开头，因此联想到会不是是宏控制的。</p><blockquote><p>确实是这样的，这边用宏去定义了所有的特性校验函数</p></blockquote><img src="/2023/12/18/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%80%A7%E6%A0%87%E5%BF%97%E4%BD%8D/image-20231218220358355.png" alt="image-20231218220358355" style="zoom: 67%;"><p>上面的代码可以翻译成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_sb_has_encrypt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-keyword">return</span> F2FS_HAS_FEATURE(sbi, F2FS_FEATURE_ENCRYPT);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_sb_has_blkzoned</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-keyword">return</span> F2FS_HAS_FEATURE(sbi, F2FS_FEATURE_BLKZONED);<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_sb_has_compression</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-keyword">return</span> F2FS_HAS_FEATURE(sbi, F2FS_FEATURE_COMPRESSION);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以最终的 <strong>f2fs_sb_has</strong> 的特性校验函数会调用到 <strong>F2FS_HAS_FEATURE</strong></p><img src="/2023/12/18/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%80%A7%E6%A0%87%E5%BF%97%E4%BD%8D/image-20231218221212511.png" alt="image-20231218221212511" style="zoom:67%;"><p>最终会去super_block中拿到属性位做<strong>与操作</strong></p><blockquote><p>我们有两种方式去确定挂载f2fs文件系统的镜像有哪些特性：</p><ul><li>hexdump -s 0xc80 -n 1024 xxx；第0xC84~0xC87就是属性标志位，把16进制转化成二进制与特性做与操作就能确定是否含有该特性</li><li>调用fsck.f2fs去跑一遍校验，也会打印所有特性，好处就是比较明显，一眼就知道有哪些特性</li></ul><img src="/2023/12/18/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%80%A7%E6%A0%87%E5%BF%97%E4%BD%8D/image-20231218223414141.png" alt="image-20231218223414141" style="zoom: 67%;"></blockquote><p>✅ <strong>一句话总结：类似于f2fs_sb_has_casecold这种特性校验函数，最终都只是去看super_block中的属性校验位feature，位于0xc84~0xc87；</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32f103闪存flash读写</title>
    <link href="/2023/12/13/stm32f103%E9%97%AA%E5%AD%98flash%E8%AF%BB%E5%86%99/"/>
    <url>/2023/12/13/stm32f103%E9%97%AA%E5%AD%98flash%E8%AF%BB%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="stm32f103闪存flash读写"><a href="#stm32f103闪存flash读写" class="headerlink" title="stm32f103闪存flash读写"></a>stm32f103闪存flash读写</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>闪存（Flash Memory）是一种长寿命的非易失性（在断电情况下仍能保持所存储的数据信息）的存储器。用途SD卡、固态硬盘、芯片内存存储单元存储代码。</p><img src="/2023/12/13/stm32f103%E9%97%AA%E5%AD%98flash%E8%AF%BB%E5%86%99/image-20231213222937519.png" alt="image-20231213222937519" style="zoom:67%;"><h2 id="2-STM32内部Flash"><a href="#2-STM32内部Flash" class="headerlink" title="2.STM32内部Flash"></a>2.STM32内部Flash</h2><p><strong>1.主要特性</strong></p><img src="/2023/12/13/stm32f103%E9%97%AA%E5%AD%98flash%E8%AF%BB%E5%86%99/image-20231213223036882.png" alt="image-20231213223036882" style="zoom:67%;"><p><strong>2.操作技巧</strong></p><img src="/2023/12/13/stm32f103%E9%97%AA%E5%AD%98flash%E8%AF%BB%E5%86%99/image-20231213223059908.png" alt="image-20231213223059908" style="zoom:67%;"><p><strong>3.编程&#x2F;擦除位数与电压之间的关系</strong></p><img src="/2023/12/13/stm32f103%E9%97%AA%E5%AD%98flash%E8%AF%BB%E5%86%99/image-20231213223124094.png" alt="image-20231213223124094" style="zoom:67%;"><h2 id="3-闪存读写实验"><a href="#3-闪存读写实验" class="headerlink" title="3.闪存读写实验"></a>3.闪存读写实验</h2><ol><li>以分区形式进行规划，配置数据最好从最后扇区进行操作，防止覆盖扇区0的代码。</li></ol><img src="/2023/12/13/stm32f103%E9%97%AA%E5%AD%98flash%E8%AF%BB%E5%86%99/image-20231213223211555.png" alt="image-20231213223211555" style="zoom:67%;"><ol start="2"><li>F103的闪存是以页为单位的【每个页2Kb】</li></ol><img src="/2023/12/13/stm32f103%E9%97%AA%E5%AD%98flash%E8%AF%BB%E5%86%99/image-20231213223303433.png" alt="image-20231213223303433" style="zoom:67%;"><img src="/2023/12/13/stm32f103%E9%97%AA%E5%AD%98flash%E8%AF%BB%E5%86%99/image-20231213223321033.png" alt="image-20231213223321033" style="zoom:67%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PBout(x) *(volatile uint32_t *)(0x42000000 + ((uint32_t)&amp;GPIOB-&gt;ODR - 0x40000000)*32 + x * 4)</span><br><br><span class="hljs-type">static</span>   GPIO_InitTypeDef    GPIO_InitStructure;<br><span class="hljs-type">static</span>   USART_InitTypeDef   USART_InitStructure;<br><span class="hljs-type">static</span>   NVIC_InitTypeDef    NVIC_InitStructure;<br><br><br><span class="hljs-comment">// 1ms的粒度</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">delay_ms</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> ms)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(ms --)<br>    &#123;<br>        SysTick-&gt;CTRL = <span class="hljs-number">0</span>;                         <span class="hljs-comment">// 关闭系统定时器后才能配置寄存器</span><br>        SysTick-&gt;LOAD = <span class="hljs-number">72000</span><span class="hljs-number">-1</span>;                   <span class="hljs-comment">// 设置计数值，用于设置定时的时间</span><br>        SysTick-&gt;VAL = <span class="hljs-number">0</span>;                         <span class="hljs-comment">// 清空当前值还有计数标志位</span><br>        SysTick-&gt;CTRL = <span class="hljs-number">5</span>;                         <span class="hljs-comment">// 使能系统定时器工作</span><br>        <span class="hljs-keyword">while</span> ((SysTick-&gt;CTRL &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>))==<span class="hljs-number">0</span>);      <span class="hljs-comment">// 等待系统定时器计数完毕 </span><br>    &#125;<br>    SysTick-&gt;CTRL = <span class="hljs-number">0</span>;                         <span class="hljs-comment">// 关闭系统定时器       </span><br>&#125;   <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">usart1_init</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> baud)</span><br>&#123;<br>    <span class="hljs-comment">// 打开PA硬件时钟</span><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_AFIO, ENABLE);<br>    <br>    <span class="hljs-comment">// 打开串口1硬件时钟</span><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);<br>    <br>    <span class="hljs-comment">//USART1_TX GPIOA_9</span><br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;     <span class="hljs-comment">// 输出模式为多功能复用模式</span><br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;  <span class="hljs-comment">// 第9根引脚</span><br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 50MHz告诉响应</span><br>    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<br>    <br>    <br>    <span class="hljs-comment">//USART1_RX GPIOA_10</span><br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;     <span class="hljs-comment">// 输出模式为多功能复用模式</span><br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;  <span class="hljs-comment">// 第10根引脚</span><br>    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<br>    <br>    <br>    <span class="hljs-comment">// 配置串口1相关参数：波特率、无奇偶校验、8位数据位、1个停止位……</span><br>    USART_InitStructure.USART_BaudRate = baud;   <span class="hljs-comment">// 波特率</span><br>    USART_InitStructure.USART_WordLength = USART_WordLength_8b;  <span class="hljs-comment">// 8数据位</span><br>    USART_InitStructure.USART_StopBits = USART_StopBits_1;  <span class="hljs-comment">// 1个停止位</span><br>    USART_InitStructure.USART_Parity = USART_Parity_No; <span class="hljs-comment">// 无奇偶校验位 </span><br>    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;  <span class="hljs-comment">// 无硬件流控制</span><br>    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;  <span class="hljs-comment">// 允许接收/发送数据</span><br>    USART_Init(USART1, &amp;USART_InitStructure);<br><br>    <span class="hljs-comment">// 配置串口1的中断触发方法：接口一个字节</span><br>    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);<br>    <br>    <span class="hljs-comment">// 配置串口1的中断优先级</span><br>    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;  <span class="hljs-comment">// 打开外部中断0的请求通道</span><br>    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 抢占优先级</span><br>    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 响应优先级</span><br>    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<br>    NVIC_Init(&amp;NVIC_InitStructure);<br>    <br>    <span class="hljs-comment">// 使能串口1工作</span><br>    USART_Cmd(USART1, ENABLE);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">FILE</span> &#123;</span> <span class="hljs-type">int</span> handle; <span class="hljs-comment">/* Add whatever you need here */</span> &#125;;<br>FILE __stdout;<br>FILE __stdin;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> &#123;<br>        <br>    USART_SendData(USART1,ch);<br>    <span class="hljs-keyword">while</span>(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET); <span class="hljs-comment">// 避免数据缓冲区数据覆盖</span><br>    <br>    <span class="hljs-keyword">return</span> ch;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br>    u32 d;<br>    <br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<br><br>    <span class="hljs-comment">// 串口1通信初始化</span><br>    usart1_init(<span class="hljs-number">9600</span>);<br>    <br>    <span class="hljs-comment">// 初始化GPIO引脚</span><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    <br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="hljs-comment">// 输出模式为推挽模式</span><br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;         <span class="hljs-comment">// 第5根引脚</span><br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="hljs-comment">// 50MHz告诉响应</span><br>    <br>    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<br>    <br>    PBout(<span class="hljs-number">5</span>) = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 解除写访问</span><br>    FLASH_UnlockBank1();<br><br>    <span class="hljs-comment">// 清除标志位</span><br>    FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);<br>    <br>    <span class="hljs-comment">// 擦除页4</span><br>    <span class="hljs-keyword">if</span>(FLASH_COMPLETE != FLASH_ErasePage(<span class="hljs-number">0x08001800</span>))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Flash Erase Page 3 Failed!!\n&quot;</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 向页3首地址写入一个32位的数据</span><br>    <span class="hljs-keyword">if</span>(FLASH_COMPLETE != FLASH_ProgramWord(<span class="hljs-number">0x08001800</span>, <span class="hljs-number">0x8723</span>))        <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Flash Write Data to Page 3 Failed!!\n&quot;</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">// 添加写保护</span><br>    FLASH_LockBank1();<br>    <br>    <span class="hljs-comment">// 读取页3的首地址数据，读取4个字节就是32Bit数据</span><br>    d = *(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span>*)<span class="hljs-number">0x08001800</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Flash Read Data From Page 3 is 0x%X!!\n&quot;</span>,d);<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/12/13/stm32f103%E9%97%AA%E5%AD%98flash%E8%AF%BB%E5%86%99/image-20231213223409417.png" alt="image-20231213223409417" style="zoom:67%;"><h2 id="4-思考题"><a href="#4-思考题" class="headerlink" title="4.思考题"></a>4.思考题</h2><p>思考题1：擦除完之后，扇区里面所有的数据是什么？</p><p>答：所有的数据都是为0xFF，所有bit位都是1。</p><img src="/2023/12/13/stm32f103%E9%97%AA%E5%AD%98flash%E8%AF%BB%E5%86%99/image-20231213223433935.png" alt="image-20231213223433935" style="zoom:67%;"><p>思考题2：假如说现在已经擦除完扇区，先写入了1个字，然后在<strong>下一个偏移地址</strong>再次写入新的字是否在需要擦除扇区？</p><p>答案：不需要的。</p><p>思考题3：假如说现在已经擦除完扇区，先写了1个字，然后在<strong>同一个地址</strong>再次写入新的字是否需要擦除扇区？</p><p>答案：需要进行擦除！</p><p>例子，已经写入数据为0x12345678，然后再写入新的数据为0x1111111，最后得到的数据居然是0x101010.</p><img src="/2023/12/13/stm32f103%E9%97%AA%E5%AD%98flash%E8%AF%BB%E5%86%99/image-20231213223448164.png" alt="image-20231213223448164" style="zoom:67%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>blkid二进制源码解析</title>
    <link href="/2023/12/12/blkid%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/12/12/blkid%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="blkid二进制源码解析"><a href="#blkid二进制源码解析" class="headerlink" title="blkid二进制源码解析"></a>blkid二进制源码解析</h1><p>blkid用于查看块设备UUID、Label、挂载、文件系统类型等信息</p><p>blkid的源码位于：<code>external\e2fsprogs\misc\blkid.c</code></p><p><strong>在安卓vold源码中会通过blkid去预读卷的元数据信息</strong></p><img src="/2023/12/12/blkid%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20231212220132527.png" alt="image-20231212220132527" style="zoom:50%;"><p>可以看到这条命令实际的执行结果如下：</p><img src="/2023/12/12/blkid%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20231212221419697.png" alt="image-20231212221419697" style="zoom:67%;"><blockquote><p>以下的源码解析将基于这条命令!</p></blockquote><h2 id="blkid二进制主入口"><a href="#blkid二进制主入口" class="headerlink" title="blkid二进制主入口"></a>blkid二进制主入口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-keyword">while</span> ((c = getopt (argc, argv, <span class="hljs-string">&quot;c:f:ghlLo:s:t:w:v&quot;</span>)) != EOF)<br><span class="hljs-keyword">switch</span> (c) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>read = optarg;<br><span class="hljs-keyword">if</span> (!write)<br>write = read;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>show[numtag++] = optarg;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 这里只有一个设备：因此device[0] = &quot;/dev/block/vold/public:252,80&quot;</span><br><span class="hljs-keyword">while</span> (optind &lt; argc)<br>devices[numdev++] = argv[optind++];<br><br><span class="hljs-keyword">if</span> (lookup) &#123;<br><span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!numdev) &#123;<br><span class="hljs-comment">// ..</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; numdev; i++) &#123;  <span class="hljs-comment">/*这边我就指明了一个外置存储设备public:252,80，所以只会遍历一次*/</span><br>blkid_dev dev = blkid_get_dev(cache, devices[i], BLKID_DEV_NORMAL);  <span class="hljs-comment">// (BLKID_DEV_CREATE | BLKID_DEV_VERIFY)</span><br><br><span class="hljs-keyword">if</span> (dev) &#123;<br>            <span class="hljs-comment">// 打印我们-s指明的需要show的参数：TYPE,UUID,LABEL</span><br>print_tags(dev, show, numtag, output_format);<br>err = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="获取设备属性信息"><a href="#获取设备属性信息" class="headerlink" title="获取设备属性信息"></a>获取设备属性信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">blkid_dev <span class="hljs-title function_">blkid_get_dev</span><span class="hljs-params">(blkid_cache cache, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *devname, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>blkid_dev dev = <span class="hljs-literal">NULL</span>, tmp;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">p</span>, *<span class="hljs-title">pnext</span>;</span><br><br><span class="hljs-keyword">if</span> (!dev &amp;&amp; (flags &amp; BLKID_DEV_CREATE)) &#123;<br><span class="hljs-keyword">if</span> (access(devname, F_OK) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        dev = blkid_new_dev();<br>dev-&gt;bid_time = INT_MIN;<br>dev-&gt;bid_name = blkid_strdup(devname);<br>dev-&gt;bid_cache = cache;<br>        cache-&gt;bic_flags |= BLKID_BIC_FL_CHANGED;<br>&#125;<br><br><span class="hljs-keyword">if</span> (flags &amp; BLKID_DEV_VERIFY) &#123;<br>dev = blkid_verify(cache, dev);<br>&#125;<br><span class="hljs-keyword">return</span> dev;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过blkid_new_dev函数初始化blkid_dev结构体，最终通过blkid_verify校验该设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c">blkid_dev <span class="hljs-title function_">blkid_verify</span><span class="hljs-params">(blkid_cache cache, blkid_dev dev)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blkid_probe</span> <span class="hljs-title">probe</span>;</span><br>    <br><span class="hljs-keyword">if</span> (stat(dev-&gt;bid_name, &amp;st) &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><br>    <span class="hljs-comment">// 打开设备，获取文件描述符</span><br><span class="hljs-keyword">if</span> ((probe.fd = open(dev-&gt;bid_name, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br>probe.cache = cache;<br>probe.dev = dev;<br>probe.sbbuf = <span class="hljs-number">0</span>;<br>probe.buf = <span class="hljs-number">0</span>;<br>probe.buf_max = <span class="hljs-number">0</span>;<br><br>type = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 遍历所有支持的文件系统类型(下面有)</span><br><span class="hljs-keyword">for</span> (id = type_array; id-&gt;bim_type; id++) &#123;<br><span class="hljs-keyword">if</span> (dev-&gt;bid_type &amp;&amp; <span class="hljs-built_in">strcmp</span>(id-&gt;bim_type, dev-&gt;bid_type))<br><span class="hljs-keyword">continue</span>;<br><br>idx = id-&gt;bim_kboff + (id-&gt;bim_sboff &gt;&gt; <span class="hljs-number">10</span>);<br>buf = get_buffer(&amp;probe, (__u64) idx &lt;&lt; <span class="hljs-number">10</span>, <span class="hljs-number">1024</span>); <span class="hljs-comment">// 拿到不同文件系统在不同位置存储的魔术字</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(id-&gt;bim_magic, buf + (id-&gt;bim_sboff &amp; <span class="hljs-number">0x3ff</span>), id-&gt;bim_len))<br><span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">// 魔术字校验通过，说明找到了该设备对应的文件系统，下面就是正式拿到那些属性值了:TYPE UUID LABEL</span><br><span class="hljs-keyword">if</span> ((id-&gt;bim_probe == <span class="hljs-literal">NULL</span>) ||<br>    (id-&gt;bim_probe(&amp;probe, id, buf) == <span class="hljs-number">0</span>)) &#123;<br>type = id-&gt;bim_type;<br><span class="hljs-keyword">goto</span> found_type;<br>&#125;<br>&#125;<br><br>found_type:<br><span class="hljs-keyword">if</span> (dev &amp;&amp; type) &#123;<br>dev-&gt;bid_devno = st.st_rdev;<br>dev-&gt;bid_time = time(<span class="hljs-number">0</span>);<br>dev-&gt;bid_flags |= BLKID_BID_FL_VERIFIED;<br>cache-&gt;bic_flags |= BLKID_BIC_FL_CHANGED;<br><br>blkid_set_tag(dev, <span class="hljs-string">&quot;TYPE&quot;</span>, type, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> dev;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>type_array存储了所有类型的文件系统和对应处理函数</li></ul><img src="/2023/12/12/blkid%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20231212223241899.png" alt="image-20231212223241899" style="zoom:67%;"><p>上面可以看到魔术字校验通过后会去调用对应的probe函数去拿到属性值，以我的外置SD卡为例，说明一下魔术字校验和对应的处理函数</p><ul><li>我的SD卡0x52开始的4个字节魔术字为：FAT32</li></ul><img src="/2023/12/12/blkid%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20231212224912193.png" alt="image-20231212224912193" style="zoom: 67%;"><ul><li>正好与预设数组中的能够对上</li></ul><img src="/2023/12/12/blkid%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20231212225111226.png" alt="image-20231212225111226" style="zoom:80%;"><blockquote><p>🤖这里其实也解答了我个人的一些疑问：<strong>到底什么是vfat文件系统，从源码角度理解，所有fat文件系的都是vfat文件系统</strong></p></blockquote><p>调用文件系统处理函数，即<strong>probe_fat</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 把前面读到的buffer传过来</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">probe_fat</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blkid_probe *probe, <span class="hljs-keyword">struct</span> blkid_magic *id __BLKID_ATTR((unused)),</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vfat_super_block</span> *<span class="hljs-title">vs</span> =</span> (<span class="hljs-keyword">struct</span> vfat_super_block *) buf;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msdos_super_block</span> *<span class="hljs-title">ms</span> =</span> (<span class="hljs-keyword">struct</span> msdos_super_block *) buf;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vfat_dir_entry</span> *<span class="hljs-title">dir</span>;</span><br><span class="hljs-type">char</span> serno[<span class="hljs-number">10</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *label = <span class="hljs-number">0</span>, *vol_label = <span class="hljs-number">0</span>, *tmp;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*vol_serno;<br><span class="hljs-type">int</span> label_len = <span class="hljs-number">0</span>, maxloop = <span class="hljs-number">100</span>;<br>__u16 sector_size, dir_entries, reserved;<br>__u32 sect_count, fat_size, dir_size, cluster_count, fat_length;<br>__u32 buf_size, start_data_sect, next, root_start, root_dir_entries;<br><br><span class="hljs-comment">/* sector size check */</span><br>tmp = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)&amp;ms-&gt;ms_sector_size;<br>sector_size = tmp[<span class="hljs-number">0</span>] + (tmp[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>);<br><span class="hljs-keyword">if</span> (sector_size != <span class="hljs-number">0x200</span> &amp;&amp; sector_size != <span class="hljs-number">0x400</span> &amp;&amp;<br>    sector_size != <span class="hljs-number">0x800</span> &amp;&amp; sector_size != <span class="hljs-number">0x1000</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>tmp = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)&amp;ms-&gt;ms_dir_entries;<br>dir_entries = tmp[<span class="hljs-number">0</span>] + (tmp[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>);<br>reserved =  blkid_le16(ms-&gt;ms_reserved);<br>tmp = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)&amp;ms-&gt;ms_sectors;<br>sect_count = tmp[<span class="hljs-number">0</span>] + (tmp[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>);<br><span class="hljs-keyword">if</span> (sect_count == <span class="hljs-number">0</span>)<br>sect_count = blkid_le32(ms-&gt;ms_total_sect);<br><br>fat_length = blkid_le16(ms-&gt;ms_fat_length);<br><span class="hljs-keyword">if</span> (fat_length == <span class="hljs-number">0</span>)<br>fat_length = blkid_le32(vs-&gt;vs_fat32_length);<br><br>fat_size = fat_length * ms-&gt;ms_fats;<br>dir_size = ((dir_entries * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> vfat_dir_entry)) +<br>(sector_size<span class="hljs-number">-1</span>)) / sector_size;<br><br>cluster_count = sect_count - (reserved + fat_size + dir_size);<br><span class="hljs-keyword">if</span> (ms-&gt;ms_cluster_size == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>cluster_count /= ms-&gt;ms_cluster_size;<br><br><span class="hljs-keyword">if</span> (cluster_count &gt; FAT32_MAX)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (ms-&gt;ms_fat_length) &#123;<br><span class="hljs-comment">/* the label may be an attribute in the root directory */</span><br>root_start = (reserved + fat_size) * sector_size;<br>root_dir_entries = vs-&gt;vs_dir_entries[<span class="hljs-number">0</span>] +<br>(vs-&gt;vs_dir_entries[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>);<br><br>buf_size = root_dir_entries * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> vfat_dir_entry);<br>dir = (<span class="hljs-keyword">struct</span> vfat_dir_entry *) get_buffer(probe, root_start,<br>   buf_size);<br><span class="hljs-keyword">if</span> (dir)<br>vol_label = search_fat_label(dir, root_dir_entries);<br><br><span class="hljs-keyword">if</span> (!vol_label || !<span class="hljs-built_in">memcmp</span>(vol_label, no_name, <span class="hljs-number">11</span>))<br>vol_label = ms-&gt;ms_label;<br>vol_serno = ms-&gt;ms_serno;<br><br>blkid_set_tag(probe-&gt;dev, <span class="hljs-string">&quot;SEC_TYPE&quot;</span>, <span class="hljs-string">&quot;msdos&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;msdos&quot;</span>));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Search the FAT32 root dir for the label attribute */</span><br>buf_size = vs-&gt;vs_cluster_size * sector_size;<br>start_data_sect = reserved + fat_size;<br><br>next = blkid_le32(vs-&gt;vs_root_cluster);<br><span class="hljs-keyword">while</span> (next &amp;&amp; --maxloop) &#123;<br>__u32 next_sect_off;<br>__u64 next_off, fat_entry_off;<br><span class="hljs-type">int</span> count;<br><br>next_sect_off = (next - <span class="hljs-number">2</span>) * vs-&gt;vs_cluster_size;<br>next_off = (__u64) (start_data_sect + next_sect_off) *<br>sector_size;<br><br>dir = (<span class="hljs-keyword">struct</span> vfat_dir_entry *)<br>get_buffer(probe, next_off, buf_size);<br><span class="hljs-keyword">if</span> (dir == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">break</span>;<br><br>count = buf_size / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> vfat_dir_entry);<br><br>vol_label = search_fat_label(dir, count);<br><span class="hljs-keyword">if</span> (vol_label)<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-comment">/* get FAT entry */</span><br>fat_entry_off =<br>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) reserved *<br> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) sector_size) +<br>(next * <span class="hljs-keyword">sizeof</span>(__u32));<br>buf = get_buffer(probe, fat_entry_off, buf_size);<br><span class="hljs-keyword">if</span> (buf == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-comment">/* set next cluster */</span><br>next = blkid_le32(*((__u32 *) buf) &amp; <span class="hljs-number">0x0fffffff</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (!vol_label || !<span class="hljs-built_in">memcmp</span>(vol_label, no_name, <span class="hljs-number">11</span>))<br>vol_label = vs-&gt;vs_label;<br>vol_serno = vs-&gt;vs_serno;<br>&#125;<br><br><span class="hljs-keyword">if</span> (vol_label &amp;&amp; <span class="hljs-built_in">memcmp</span>(vol_label, no_name, <span class="hljs-number">11</span>)) &#123;<br><span class="hljs-keyword">if</span> ((label_len = figure_label_len(vol_label, <span class="hljs-number">11</span>)))<br>label = vol_label;<br>&#125;<br><br><span class="hljs-comment">/* We can&#x27;t just print them as %04X, because they are unaligned */</span><br><span class="hljs-built_in">sprintf</span>(serno, <span class="hljs-string">&quot;%02X%02X-%02X%02X&quot;</span>, vol_serno[<span class="hljs-number">3</span>], vol_serno[<span class="hljs-number">2</span>],<br>vol_serno[<span class="hljs-number">1</span>], vol_serno[<span class="hljs-number">0</span>]);<br><br>blkid_set_tag(probe-&gt;dev, <span class="hljs-string">&quot;LABEL&quot;</span>, (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *) label, label_len);<br>blkid_set_tag(probe-&gt;dev, <span class="hljs-string">&quot;UUID&quot;</span>, serno, <span class="hljs-keyword">sizeof</span>(serno)<span class="hljs-number">-1</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>☃️<strong>结论：</strong>说白了每个文件系统都有固定的位置去存储这些属性值，blkid也只是从磁盘里面读出来放到buffer里面，交由各自文件系统去固定的位置拿出来而已。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HDD和SSD硬盘读写测试fio与CrystalDiskMark</title>
    <link href="/2023/12/11/HDD%E5%92%8CSSD%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95fio%E4%B8%8ECrystalDiskMark/"/>
    <url>/2023/12/11/HDD%E5%92%8CSSD%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95fio%E4%B8%8ECrystalDiskMark/</url>
    
    <content type="html"><![CDATA[<h1 id="HDD和SSD硬盘读写测试fio与CrystalDiskMark"><a href="#HDD和SSD硬盘读写测试fio与CrystalDiskMark" class="headerlink" title="HDD和SSD硬盘读写测试fio与CrystalDiskMark"></a>HDD和SSD硬盘读写测试fio与CrystalDiskMark</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/jony_online/article/details/132296821">HDD&amp;SSD 硬盘读写测试：fio 与 CrystalDiskMark —— 在 linux 与 windows 环境_去山的那边看海啊的博客-CSDN博客</a></p></blockquote><h2 id="CrystalDiskMark-是什么？"><a href="#CrystalDiskMark-是什么？" class="headerlink" title="CrystalDiskMark 是什么？"></a>CrystalDiskMark 是什么？</h2><p>官网：<a href="https://crystalmark.info/en/">https://crystalmark.info/en/</a></p><img src="/2023/12/11/HDD%E5%92%8CSSD%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95fio%E4%B8%8ECrystalDiskMark/977c6e2af9db4b34bacb689449dc1fa3.png" alt="img" style="zoom:50%;"><p>大名鼎鼎的 CrystalDiskMark，也就是常说的 CDM 软件，操作简单好用，颜值高。还可以换皮肤玩。但在只能在 windows 环境下使用，不支持linux。</p><h2 id="fio是什么"><a href="#fio是什么" class="headerlink" title="fio是什么"></a>fio是什么</h2><p>官网：<a href="https://fio.readthedocs.io/en/latest/">https://fio.readthedocs.io/en/latest/</a></p><p>fio 是 Linux下开源的一款IOPS测试工具，主要用来对磁盘进行压力测试和性能验证。 类似的工具，简单的例如有 dd、hdparm 这些，但与 fio 相比，功能上都太简陋了。</p><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt instal fio<br></code></pre></td></tr></table></figure><p>常用参数：</p><p>以这样一个测试为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fio -direct=1 -iodepth=1 -rw=randrw -ioengine=libaio -bs=4k -size=64M -numjobs=1 -runtime=60 -group_reporting -filename=/home/test.temp -name=Q1T1-RND4K64M<br></code></pre></td></tr></table></figure><ul><li>-direct 是否忽略缓存，</li><li>-iodepth 读写队列深度</li><li>-rw 读写测试模式，randrw 随机读写，readwrite 连续读写</li><li>-ioengine 读写方式：libaio：linux 异步读写；</li><li>-bs 读写块大小</li><li>-size 读写数据总量</li><li>-numjobs 线程数量</li><li>-runtime 运行时间，与 -size 一起，满足条件时，测试退出</li><li>-group_reporting 聚合输出报告形式</li><li>-filename 读写测试文件；如果读测试可以直接指定IO设备例如；&#x2F;dev&#x2F;sda ; 写测试必须为文件；</li><li>-name 测试报告标题</li></ul><p>注意：</p><p>读写测试时，需要指定一个可以读写的文件；此时需要使用 dd 生成一个测试文件；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/home/test.temp bs=4k count=100000<br></code></pre></td></tr></table></figure><h2 id="使用-fio-模拟-CrystalDiskMark-的测试"><a href="#使用-fio-模拟-CrystalDiskMark-的测试" class="headerlink" title="使用 fio 模拟 CrystalDiskMark 的测试"></a>使用 fio 模拟 CrystalDiskMark 的测试</h2><p>那么我想在 Linux 下测试硬盘读写性能，并且想和之前在 windows 下用 CDM 测试的结果进行比对，就需要使用 fio 对 CDM 的测试项目进行模拟；</p><p>测试项目：</p><img src="/2023/12/11/HDD%E5%92%8CSSD%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95fio%E4%B8%8ECrystalDiskMark/1c49676ef35f4236b40a613fe7d4fd23.png" alt="img" style="zoom:50%;"><h3 id="Q8T1-SEQ1M：多队列连续读写"><a href="#Q8T1-SEQ1M：多队列连续读写" class="headerlink" title="Q8T1-SEQ1M：多队列连续读写"></a>Q8T1-SEQ1M：多队列连续读写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fio -iodepth=1 -iodepth=8 -rw=readwrite -ioengine=libaio -bs=1M -size=64M -numjobs=1 -runtime=60 -group_reporting -filename=/home/test.temp -name=Q8T1-SEQ1M64M<br> <br>sudo fio -iodepth=1 -iodepth=8 -rw=readwrite -ioengine=libaio -bs=1M -size=1G -numjobs=1 -runtime=60 -group_reporting -filename=/home/test.temp -name=Q8T1-SEQ1M1G<br></code></pre></td></tr></table></figure><h3 id="Q1T1-SEQ1M：单队列连续读写"><a href="#Q1T1-SEQ1M：单队列连续读写" class="headerlink" title="Q1T1-SEQ1M：单队列连续读写"></a>Q1T1-SEQ1M：单队列连续读写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fio -iodepth=1 -iodepth=1 -rw=readwrite -ioengine=libaio -bs=1M -size=64M -numjobs=1 -runtime=60 -group_reporting -filename=/home/test.temp -name=Q1T1-SEQ1M64M<br> <br>sudo fio -iodepth=1 -iodepth=1 -rw=readwrite -ioengine=libaio -bs=1M -size=1G -numjobs=1 -runtime=60 -group_reporting -filename=/home/test.temp -name=Q1T1-SEQ1M1G<br></code></pre></td></tr></table></figure><h3 id="Q32T1-RND4K：4K多队列随机读写"><a href="#Q32T1-RND4K：4K多队列随机读写" class="headerlink" title="Q32T1-RND4K：4K多队列随机读写"></a>Q32T1-RND4K：4K多队列随机读写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fio -iodepth=1 -iodepth=32 -rw=randrw -ioengine=libaio -bs=4k -size=64M -numjobs=1 -runtime=60 -group_reporting -filename=/home/test.temp -name=Q32T1-RND4K64M<br> <br>sudo fio -iodepth=1 -iodepth=32 -rw=randrw -ioengine=libaio -bs=4k -size=1G -numjobs=1 -runtime=60 -group_reporting -filename=/home/test.temp -name=Q32T1-RND4K1G<br></code></pre></td></tr></table></figure><h3 id="Q1T1-RND4K：4K单队列随机读写"><a href="#Q1T1-RND4K：4K单队列随机读写" class="headerlink" title="Q1T1-RND4K：4K单队列随机读写"></a>Q1T1-RND4K：4K单队列随机读写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fio -iodepth=1 -iodepth=1 -rw=randrw -ioengine=libaio -bs=4k -size=64M -numjobs=1 -runtime=60 -group_reporting -filename=/home/test.temp -name=Q1T1-RND4K64M<br> <br>sudo fio -iodepth=1 -iodepth=1 -rw=randrw -ioengine=libaio -bs=4k -size=1G -numjobs=1 -runtime=60 -group_reporting -filename=/home/test.temp -name=Q1T1-RND4K1G<br></code></pre></td></tr></table></figure><p>注意：</p><p>以上测试项目，fio 可以配置 -direct&#x3D;1 屏蔽缓存，非常方便地测得硬盘的缓存外读写性能。</p><p>CDM 并没有这样直接的设置，所以测试结果是包含缓存内性能的。可以通过将 -size&#x3D;1G 设置为更大的读写文件，耗尽缓存空间，以及增加 测试轮次（默认是5）来达到类似效果。</p><h3 id="测试结果比较"><a href="#测试结果比较" class="headerlink" title="测试结果比较"></a>测试结果比较</h3><p>windows 中对 西数 SN550 的测试结果：</p><img src="/2023/12/11/HDD%E5%92%8CSSD%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95fio%E4%B8%8ECrystalDiskMark/12bbee026824410591a07be8bffa6d8e.png" alt="img" style="zoom:50%;"><img src="/2023/12/11/HDD%E5%92%8CSSD%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95fio%E4%B8%8ECrystalDiskMark/f440df0c764c45caad6af7c640b56957.png" alt="img" style="zoom:50%;"><p>linux 中对 西数 SN550 的测试结果：</p><p>Q32T1-RND4K64M 不使用缓存</p><img src="/2023/12/11/HDD%E5%92%8CSSD%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95fio%E4%B8%8ECrystalDiskMark/1957f495708b448f845e300e9ef8fa9d.png" alt="img" style="zoom: 50%;"><p> Q32T1-RND4K64M 使用缓存</p><img src="/2023/12/11/HDD%E5%92%8CSSD%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95fio%E4%B8%8ECrystalDiskMark/246b4bebb5184553850b76fa5904836c.png" alt="img" style="zoom:50%;"><p>Q8T1-SEQ1M64M 使用缓存：</p><img src="/2023/12/11/HDD%E5%92%8CSSD%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95fio%E4%B8%8ECrystalDiskMark/7550cd132c7642339fbf20ba3b26c089.png" alt="img" style="zoom:50%;"><p> Q8T1-SEQ1M64M 不使用缓存：</p><img src="/2023/12/11/HDD%E5%92%8CSSD%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95fio%E4%B8%8ECrystalDiskMark/790072ea3e474eab825ba0b4420abd35.png" alt="img" style="zoom:50%;"><p>结果分析：</p><p>缓存是个非常复杂的东西，从结果可以看到，有些 fio 测试在缓存参与时和CDM的结果一致，另外一些却是无缓存参与的与CDM一致。原因可能是多样的，系统任务调度的问题，文件系统NTFS、ext4之间的差异，系统缓存调度差异等等。目前来看测试结果仅供参考。但同时，fio 的实力还未真正得到发挥。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>存储器件性能测试</title>
    <link href="/2023/12/11/%E5%AD%98%E5%82%A8%E5%99%A8%E4%BB%B6%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/12/11/%E5%AD%98%E5%82%A8%E5%99%A8%E4%BB%B6%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="存储器件性能测试"><a href="#存储器件性能测试" class="headerlink" title="存储器件性能测试"></a>存储器件性能测试</h1><ul><li><a href="https://anmuxixixi.github.io/2023/12/11/HDD%E5%92%8CSSD%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95fio%E4%B8%8ECrystalDiskMark/">HDD和SSD硬盘读写测试fio与CrystalDiskMark</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>坏块检测二进制badblocks源码分析</title>
    <link href="/2023/12/09/%E5%9D%8F%E5%9D%97%E6%A3%80%E6%B5%8B%E4%BA%8C%E8%BF%9B%E5%88%B6badblocks%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/12/09/%E5%9D%8F%E5%9D%97%E6%A3%80%E6%B5%8B%E4%BA%8C%E8%BF%9B%E5%88%B6badblocks%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="坏块检测二进制badblocks源码分析"><a href="#坏块检测二进制badblocks源码分析" class="headerlink" title="坏块检测二进制badblocks源码分析"></a>坏块检测二进制badblocks源码分析</h1><p>在Linux经常使用badblocks去检查磁盘的坏块&#x2F;坏道，其源码位于<code>external\e2fsprogs\misc\badblocks.c</code></p><p>常见的检查坏道的方式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">badblocks -v /dev/sda1 &gt; badsectors.txt <br></code></pre></td></tr></table></figure><p>-v：表示开启日志模式</p><blockquote><p>注：以下的源码分析都基于上面的命令进行</p></blockquote><h2 id="badblocks二进制主入口"><a href="#badblocks二进制主入口" class="headerlink" title="badblocks二进制主入口"></a>badblocks二进制主入口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span><br>&#123;    <br>    <span class="hljs-comment">// test_func是一个函数指针，默认是ro模式</span><br>    test_func = test_ro;<br>    <span class="hljs-keyword">if</span> (argc &amp;&amp; *argv)<br>        program_name = *argv;<br>    <span class="hljs-keyword">while</span> ((c = getopt (argc, argv, <span class="hljs-string">&quot;b:d:e:fi:o:svwnc:p:h:t:BX&quot;</span>)) != EOF) &#123;<br><span class="hljs-keyword">switch</span> (c) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:<br>v_flag++;<br><span class="hljs-keyword">break</span>;   <br>        &#125;<br>    &#125;<br>    device_name = argv[optind++];<br>    <span class="hljs-comment">// 获取最后一个块的索引</span><br>    errcode = ext2fs_get_device_size2(device_name, block_size, &amp;last_block); <span class="hljs-comment">// block_size调用时不指明为1024Byte(1Kb)</span><br>    first_block = <span class="hljs-number">0</span>;<br>    <br>    open_flag = O_LARGEFILE | (w_flag ? O_RDWR : O_RDONLY);<br>dev = open (device_name, open_flag);<br>    <br>    <span class="hljs-comment">// 这个do while循环只会执行一次</span><br>    <span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bb_count;<br><br>        <span class="hljs-comment">// 这边是badblocks实现的核心【检测坏块】</span><br>bb_count = test_func(dev, last_block, block_size, first_block, blocks_at_once);  <span class="hljs-comment">// blocks_at_once调用时不指明默认64</span><br><span class="hljs-keyword">if</span> (bb_count)<br>passes_clean = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>++passes_clean;<br><br><span class="hljs-keyword">if</span> (v_flag)<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,_(<span class="hljs-string">&quot;Pass completed, %u bad blocks found. (%d/%d/%d errors)\n&quot;</span>),<br>bb_count, num_read_errors, num_write_errors, num_corruption_errors);<br><br>&#125; <span class="hljs-keyword">while</span> (passes_clean &lt; num_passes);<br><br>close (dev);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="只读写检测坏道"><a href="#只读写检测坏道" class="headerlink" title="只读写检测坏道"></a>只读写检测坏道</h2><p>这边的写法实在巧妙，主要的逻辑如下：</p><ul><li>每次读取64个block，如果返回的数量小于64个block，说明中间遇到了坏块，则：<ul><li>下面每次重新读取一个block【总共读取64次】，如果读不到数据，则这1个block就是<strong>坏块</strong></li><li>当读取的数量达到64时，重新恢复一次性读取64个block的节奏</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test_ro</span> <span class="hljs-params">(<span class="hljs-type">int</span> dev, <span class="hljs-type">blk_t</span> last_block,</span><br><span class="hljs-params">     <span class="hljs-type">int</span> block_size, <span class="hljs-type">blk_t</span> first_block,</span><br><span class="hljs-params">     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> blocks_at_once)</span><br>&#123;<br>    <span class="hljs-comment">// blkbuf的默认大小为64K</span><br>    blkbuf = allocate_buffer(blocks_at_once * block_size);<br><br><span class="hljs-keyword">if</span> (v_flag) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, _(<span class="hljs-string">&quot;Checking blocks %lu to %lu\n&quot;</span>),<br>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)first_block,<br>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)last_block - <span class="hljs-number">1</span>);<br>&#125;<br><br>try = blocks_at_once;<br>currently_testing = first_block;<br>num_blocks = last_block - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (!t_flag &amp;&amp; (s_flag || v_flag))<br><span class="hljs-built_in">fputs</span>(_(<span class="hljs-string">&quot;Checking for bad blocks (read-only test): &quot;</span>), <span class="hljs-built_in">stderr</span>);<br><span class="hljs-keyword">while</span> (currently_testing &lt; last_block)<br>&#123;<br>        <span class="hljs-comment">// 最大支持的坏块数量为 INT_MAX/2</span><br><span class="hljs-keyword">if</span> (bb_count &gt;= max_bb) &#123;<br><span class="hljs-keyword">if</span> (s_flag || v_flag) &#123;<br><span class="hljs-built_in">fputs</span>(_(<span class="hljs-string">&quot;Too many bad blocks, aborting test\n&quot;</span>), <span class="hljs-built_in">stderr</span>);<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>        <span class="hljs-comment">// 最后一次读可能不满try个</span><br><span class="hljs-keyword">if</span> (currently_testing + try &gt; last_block)<br>try = last_block - currently_testing;<br>        <br>        <span class="hljs-comment">// 调用do_read接口测试[下面有解析]</span><br>got = do_read (dev, blkbuf, try, block_size, currently_testing);<br><br><span class="hljs-keyword">if</span> (got == <span class="hljs-number">0</span> &amp;&amp; try == <span class="hljs-number">1</span>)<br>bb_count += bb_output(currently_testing++, READ_ERROR);<br>currently_testing += got;<br><span class="hljs-keyword">if</span> (got != try) &#123;<br>try = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (recover_block == ~<span class="hljs-number">0U</span>)<br>recover_block = currently_testing - got + blocks_at_once;<br><span class="hljs-keyword">continue</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currently_testing == recover_block) &#123;<br>try = blocks_at_once;<br>recover_block = ~<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (s_flag || v_flag)<br><span class="hljs-built_in">fputs</span>(_(done_string), <span class="hljs-built_in">stderr</span>);<br><br>fflush (<span class="hljs-built_in">stderr</span>);<br><br><span class="hljs-keyword">return</span> bb_count;<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试读try个大小为1k的block，返回成功读取的block数目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_read</span> <span class="hljs-params">(<span class="hljs-type">int</span> dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * buffer, <span class="hljs-type">int</span> try, <span class="hljs-type">int</span> block_size,</span><br><span class="hljs-params">    <span class="hljs-type">blk_t</span> current_block)</span><br>&#123;<br><span class="hljs-type">long</span> got;<br><br>    <span class="hljs-comment">// dev读写指针current_block * block_size</span><br>ext2fs_llseek (dev, (<span class="hljs-type">ext2_loff_t</span>) current_block * block_size,SEEK_SET);<br><br>    <span class="hljs-comment">// 系统调用read接口</span><br>got = read (dev, buffer, try * block_size);<br><br>got /= block_size;<br><br><span class="hljs-keyword">return</span> got;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>fuse文件系统学习资料</title>
    <link href="/2023/12/04/fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <url>/2023/12/04/fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<h1 id="fuse文件系统学习资料"><a href="#fuse文件系统学习资料" class="headerlink" title="fuse文件系统学习资料"></a>fuse文件系统学习资料</h1><ul><li><p><a href="https://fishpi.cn/article/1640420458343">详解 FUSE 用户态文件系统</a></p></li><li><p><a href="https://www.jianshu.com/p/c2b77d0bbc43">FUSE架构</a></p></li><li><p><a href="https://zhoubofsy.github.io/2017/01/13/linux/filesystem-userspace-usage/">FUSE使用实例</a></p></li><li><p><a href="https://juejin.cn/post/7260746629396152379?searchId=20231205221857A49D19E7DB8503104AF8">深入分析Android 11 FUSE文件系统</a></p></li><li><p>✅<a href="https://developer.aliyun.com/article/1164554">基于FUSE的简单文件系统</a></p></li><li><p><a href="https://www.cnblogs.com/pengdonglin137/p/17893209.html">fuse死锁案例</a></p></li><li><p><a href="https://github.com/wuzhouhui/fs_on_fuse">github上实现基于fuse的自定义文件系统全源码</a></p></li><li><p><a href="https://juejin.cn/post/7206239276894748733">Android Fuse的paththrough方案</a></p></li><li><p><a href="https://www.jianshu.com/p/9602b3b93528">Android Fuse USB文件系统问题分析</a></p></li><li><p>✅<a href="https://article.juejin.cn/post/7205928315588313146">安卓fuse文件系统核心原理</a></p></li></ul><hr><h3 id="为什么要有ntfs-3g"><a href="#为什么要有ntfs-3g" class="headerlink" title="为什么要有ntfs-3g"></a>为什么要有ntfs-3g</h3><p>ntfs是Windows的文件系统，在Linux如果要读取ntfs格式的U盘就失效了，所以有大神开发了一个ntfs-3g文件系统，该文件系统基于fuse架构</p><img src="/2023/12/04/fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/webp.webp" alt="img" style="zoom:67%;"><p>ntfs-3g里面其实就是直接对裸设备即类似&#x2F;dev&#x2F;sdb直接读写，那为什么还要封装一层libfuse呢？因为read&#x2F;write的系统调用都会走到内核VFS层，在这里会走到fuse驱动中，由fuse驱动转发给上层用户态的ntfs-3g。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统头文件f2fs.h管理的位图和_I内存信息</title>
    <link href="/2023/12/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6f2fs-h%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%92%8C-I%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/"/>
    <url>/2023/12/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6f2fs-h%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%92%8C-I%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统头文件f2fs-h管理的位图和-I内存信息"><a href="#f2fs文件系统头文件f2fs-h管理的位图和-I内存信息" class="headerlink" title="f2fs文件系统头文件f2fs.h管理的位图和_I内存信息"></a>f2fs文件系统头文件f2fs.h管理的位图和_I内存信息</h1><h2 id="1-I内存信息"><a href="#1-I内存信息" class="headerlink" title="1._I内存信息"></a>1._I内存信息</h2><h3 id="SIT内存管理-SM-I"><a href="#SIT内存管理-SM-I" class="headerlink" title="SIT内存管理(SM_I)"></a>SIT内存管理(SM_I)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> f2fs_sm_info *<span class="hljs-title function_">SM_I</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> f2fs_sm_info *)(sbi-&gt;sm_info);<br>&#125;<br></code></pre></td></tr></table></figure><p>sbi管理了SIT在内存中表现形式：即结构体f2fs_sm_info</p><blockquote><p>以下内容来源于知乎LZT：<a href="https://zhuanlan.zhihu.com/p/637700821">https://zhuanlan.zhihu.com/p/637700821</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_sm_info</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_info</span> *<span class="hljs-title">sit_info</span>;</span>      <span class="hljs-comment">/* whole segment information */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_segmap_info</span> *<span class="hljs-title">free_info</span>;</span> <span class="hljs-comment">/* free segment information */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirty_seglist_info</span> *<span class="hljs-title">dirty_info</span>;</span>  <span class="hljs-comment">/* dirty segment information */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg_array</span>;</span>   <span class="hljs-comment">/* active segment information */</span><br><br>    <span class="hljs-type">block_t</span> seg0_blkaddr;       <span class="hljs-comment">/* block address of 0&#x27;th segment */</span><br>    <span class="hljs-type">block_t</span> main_blkaddr;       <span class="hljs-comment">/* start block address of main area */</span><br>    <span class="hljs-type">block_t</span> ssa_blkaddr;        <span class="hljs-comment">/* start block address of SSA area */</span><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> segment_count; <span class="hljs-comment">/* total # of segments */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> main_segments; <span class="hljs-comment">/* # of segments in main area */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> reserved_segments; <span class="hljs-comment">/* # of reserved segments */</span><br><br>    <span class="hljs-comment">/* a threshold to reclaim prefree segments */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rec_prefree_segments;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">sit_entry_set</span>;</span> <span class="hljs-comment">/* sit entry set list */</span><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ipu_policy;    <span class="hljs-comment">/* in-place-update policy */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> min_ipu_util;  <span class="hljs-comment">/* in-place-update threshold */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> min_fsync_blocks;  <span class="hljs-comment">/* threshold for fsync */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> min_hot_blocks;    <span class="hljs-comment">/* threshold for hot block allocation */</span><br><br>    <span class="hljs-comment">/* for flush command control */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flush_cmd_control</span> *<span class="hljs-title">fcc_info</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>f2fs_sm_info是内存中管理segment的总体结构，主要是为了方便查找可用的block以及高效执行gc、discard等操作。</p><ul><li>sit_info：对应的是盘上结构，将内存中修改的内容定期落盘。同时还有gc相关的内容。</li><li>free_info：记录Main Area各个segment是否被使用，在mount的时候遍历SIT表，将每个segment的使用状态记录在该bitmap上。</li><li>dirty_info：脏segment的基础信息，包括segment所属类型，使用block统计等等。在mount的时候，遍历free_segmap找到已经被使用但还有空闲空间的segment，记录到dirty_info中。</li><li>curseg_array：记录当前正在使用的segment的基本信息，包括segno、journal、seg_type等等，每种类型的segment对应一个curseg_info信息。</li><li>seg0_blkaddr：与SuperBlock的介绍一样，是第一个segment的地址。</li><li>main_blkaddr：Main Area的开始地址。</li><li>ssa_blkaddr：SSA区域的开始地址。</li><li>segment_count：存储设备的segment数量。</li><li>main_segments：Main Area的segment数量。</li><li>reserved_segments：为gc流程保留的segment数量。</li><li>rec_prefree_segments：PRE类型的segment的阈值，一般是Main Area的5%，如果超过4096个，则最大只能是4096。如果PRE的segment过多，会导致系统内存紧张，需要及时释放。</li><li>sit_entry_set：sit_entry的集合，用于CP下刷流程。</li><li>ipu_policy：IPU写方式的策略，包括FORCE、SSR、UTIL、FSYNC、ASYNC等等。</li><li>min_ipu_util：最小执行IPU写策略阈值，默认是70，表示当block使用量超过70%后，转化成IPU模式。</li><li>min_fsync_blocks：默认是8，表示inode的脏数据小于8个block，在fsync的时候，优先考虑IPU模式。</li><li>min_hot_blocks：默认是16，表示某个inode中脏数据超过16个block，则将inode设置成HOT_DATA类型（vfs层有优化？？？）。</li><li>fcc_info：对设备执行flush命令的任务，对于不能保证cache落盘的设备，这种设备一般提供flush命令，需要文件系统在适当时候将cache落盘。</li></ul><h3 id="NAT内存管理-NM-I"><a href="#NAT内存管理-NM-I" class="headerlink" title="NAT内存管理(NM_I)"></a>NAT内存管理(NM_I)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> f2fs_nm_info *<span class="hljs-title function_">NM_I</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> f2fs_nm_info *)(sbi-&gt;nm_info);<br>&#125;<br></code></pre></td></tr></table></figure><p>sbi管理了NAT在内存中表现形式：即结构体f2fs_nm_info</p><blockquote><p>以下内容来源于知乎LZT：<a href="https://zhuanlan.zhihu.com/p/638025789">https://zhuanlan.zhihu.com/p/638025789</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nm_info</span> &#123;</span><br>    <span class="hljs-type">block_t</span> nat_blkaddr;        <span class="hljs-comment">/* base disk address of NAT */</span><br>    <span class="hljs-type">nid_t</span> max_nid;          <span class="hljs-comment">/* maximum possible node ids */</span><br>    <span class="hljs-comment">// 下一个将要被扫面的node id，用于轮询NAT区域（为了磨损均衡？）</span><br>    <span class="hljs-type">nid_t</span> next_scan_nid;        <span class="hljs-comment">/* the next nid to be scanned */</span><br><br>    <span class="hljs-comment">/* NAT cache management */</span><br>    <span class="hljs-comment">// 缓存部分nat_entry，用于加快查找效率，避免总是要从存储介质中读取</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_root</span> <span class="hljs-title">nat_root</span>;</span><span class="hljs-comment">/* root of the nat entry cache */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">nat_entries</span>;</span>   <span class="hljs-comment">/* cached nat entry list (clean) */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nat_cnt[MAX_NAT_STATE]; <span class="hljs-comment">/* the # of cached nat entries */</span><br>    <span class="hljs-comment">// NAT区域所包含的block数目，在mkfs的时候已经确定</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nat_blocks;    <span class="hljs-comment">/* # of nat blocks */</span><br><br>    <span class="hljs-comment">/* free node ids management */</span><br>    <span class="hljs-comment">// TODO：通过红黑树缓存free nid，为了加快查找速度？</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_root</span> <span class="hljs-title">free_nid_root</span>;</span><span class="hljs-comment">/* root of the free_nid cache */</span><br>    <span class="hljs-comment">// TODO：缓存一些已经被释放的node block？</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">free_nid_list</span>;</span>     <span class="hljs-comment">/* list for free nids excluding preallocated nids */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nid_cnt[MAX_NID_STATE];    <span class="hljs-comment">/* the number of free node id */</span><br>    <span class="hljs-comment">// bitmap: 记录data区域每个node是否被使用（或者说每个node id是否被占用）</span><br>    <span class="hljs-comment">// 注意：free_nid_bitmap要配合nat_block_bitmap使用</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> **free_nid_bitmap;<br>    <span class="hljs-comment">// 记录当前可用的nat block</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *nat_block_bitmap;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *free_nid_count; <span class="hljs-comment">/* free nid count of NAT block */</span><br><br>    <span class="hljs-comment">/* for checkpoint */</span><br>    <span class="hljs-type">char</span> *nat_bitmap;       <span class="hljs-comment">/* NAT bitmap pointer */</span><br>    <span class="hljs-type">int</span> bitmap_size;        <span class="hljs-comment">/* bitmap size */</span><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nat_bits_blocks;   <span class="hljs-comment">/* # of nat bits blocks */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *nat_bits;    <span class="hljs-comment">/* NAT bits blocks */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *full_nat_bits;   <span class="hljs-comment">/* full NAT pages */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *empty_nat_bits;  <span class="hljs-comment">/* empty NAT pages */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>f2fs_nm_info是内存中管理NAT的总体结构。对应node的修改，会被缓存在内存中，等到合适时机才会真正落盘。</p><ul><li>nat_blkaddr：NAT区域的开始地址。</li><li>max_nid：系统中能使用的最大node id号。</li><li>next_scan_nid：下一个待扫描的node id号。</li><li>nat_root：通过红黑树的方式缓存nat entry，可以快速找到某个node的信息。</li><li>nat_entries：缓存正在使用的nat_entry。</li><li>nat_cnt：正在缓存net_entry的统计信息，包括脏entry个数、待回收的个数等等。</li><li>nat_blocks：NAT区域所占用的block数量。</li><li>free_nid_bitmap：记录每个nat_entry的使用情况。</li><li>nat_block_bitmap：记录每个nat_entry block的使用情况。</li><li>free_nid_count：记录每个nat_block空闲的nat entry数量。</li><li>nat_bitmap：记录nat_entry使用的是主区还是备区。</li><li>bitmap_size：记录nat_bitmap的大小。</li><li>nat_bits_blocks：存放在CP区域的nat_bits所占用的block数目。</li><li>nat_bits：存放在CP区域，包括cp_version + full_nat_bits + empty_nat_bits三部分。</li><li>full_nat_bits：记录NAT区域某个block可用nat_entry已经用完。</li><li>empty_nat_bits：记录NAT区域某个block还没有使用过nat_entry。</li></ul><h3 id="脏Segment管理-DIRTY-I"><a href="#脏Segment管理-DIRTY-I" class="headerlink" title="脏Segment管理(DIRTY_I)"></a>脏Segment管理(DIRTY_I)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> dirty_seglist_info *<span class="hljs-title function_">DIRTY_I</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> dirty_seglist_info *)(SM_I(sbi)-&gt;dirty_info);<br>&#125;<br></code></pre></td></tr></table></figure><p>sbi管理了segment info(即结构体f2fs_sm_info)对应的内存信息，而f2fs_sm_info又管理了脏segment信息dirty_seglist_info</p><img src="/2023/12/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6f2fs-h%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%92%8C-I%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/image-20231203221359946.png" alt="image-20231203221359946" style="zoom:67%;"><ul><li><p>v_ops为victim选择的钩子函数</p></li><li><p>dirty_segment用来管理脏segment的位图，总共管理了6种类型的脏Segment(HOT&#x2F;WARM&#x2F;COLD × NODE&#x2F;DATA)和2种状态的Segment（pre-free和dirty）；每个位图的大小都是相等的，都等于main_segments的数量</p><ul><li><p>以下为6种类型的脏Segment位图</p></li><li><img src="/2023/12/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6f2fs-h%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%92%8C-I%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/image-20231127224936323.png" alt="image-20231127224936323" style="zoom:67%;"></li><li><p>位图的初始化位于f2fs文件系统时填充super block时建立segment管理器的时候调用<code>build_dirty_segmap</code></p></li></ul></li></ul><img src="/2023/12/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6f2fs-h%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%92%8C-I%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/image-20231203222111509.png" alt="image-20231203222111509" style="zoom:67%;"><ul><li>nr_dirty管理了6种脏Segment和2种状态的脏Segment的个数。</li></ul><h3 id="空闲Segment管理-FREE-I"><a href="#空闲Segment管理-FREE-I" class="headerlink" title="空闲Segment管理(FREE_I)"></a>空闲Segment管理(FREE_I)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> free_segmap_info *<span class="hljs-title function_">FREE_I</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> free_segmap_info *)(SM_I(sbi)-&gt;free_info);<br>&#125;<br></code></pre></td></tr></table></figure><p>sbi管理了segment info(即结构体f2fs_sm_info)对应的内存信息，而f2fs_sm_info又管理了脏segment信息free_segmap_info</p><img src="/2023/12/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6f2fs-h%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%92%8C-I%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/image-20231203222634516.png" alt="image-20231203222634516" style="zoom:67%;"><h2 id="2-位图管理"><a href="#2-位图管理" class="headerlink" title="2.位图管理"></a>2.位图管理</h2><h3 id="脏Segment位图-dirty-segment"><a href="#脏Segment位图-dirty-segment" class="headerlink" title="脏Segment位图(dirty_segment)"></a>脏Segment位图(dirty_segment)</h3><ul><li><p>dirty_segment用来管理脏segment的位图，总共管理了6种类型的脏Segment(HOT&#x2F;WARM&#x2F;COLD × NODE&#x2F;DATA)和2种状态的Segment（pre-free和dirty）；每个位图的大小都是相等的，都等于main_segments的数量</p><ul><li><p>以下为6种类型的脏Segment位图</p></li><li><img src="/2023/12/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6f2fs-h%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%92%8C-I%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/image-20231127224936323.png" alt="image-20231127224936323" style="zoom:67%;"></li><li><p>位图的初始化位于f2fs文件系统时填充super block时建立segment管理器的时候调用<code>build_dirty_segmap</code></p></li></ul></li></ul><img src="/2023/12/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6f2fs-h%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%92%8C-I%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/image-20231203222111509.png" alt="image-20231203222111509" style="zoom:67%;"><h2 id="3-基数树映射"><a href="#3-基数树映射" class="headerlink" title="3.基数树映射"></a>3.基数树映射</h2><img src="/2023/12/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6f2fs-h%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%92%8C-I%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/image-20231203225436920.png" alt="image-20231203225436920" style="zoom:67%;"><h3 id="Node页映射"><a href="#Node页映射" class="headerlink" title="Node页映射"></a>Node页映射</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> address_space *<span class="hljs-title function_">NODE_MAPPING</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-keyword">return</span> sbi-&gt;node_inode-&gt;i_mapping;<br>&#125;<br></code></pre></td></tr></table></figure><p>f2fs文件系统的1号元数据node inode用管理所有缓存的node page页信息</p><img src="/2023/12/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6f2fs-h%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%92%8C-I%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/image-20231203230542715.png" alt="image-20231203230542715" style="zoom: 67%;"><h3 id="元数据映射"><a href="#元数据映射" class="headerlink" title="元数据映射"></a>元数据映射</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> address_space *<span class="hljs-title function_">META_MAPPING</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-keyword">return</span> sbi-&gt;meta_inode-&gt;i_mapping;<br>&#125;<br></code></pre></td></tr></table></figure><p>f2fs文件系统的2号元数据mode inode用管理所有缓存的元数据页信息</p><img src="/2023/12/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6f2fs-h%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%92%8C-I%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF/image-20231203225928807.png" alt="image-20231203225928807" style="zoom: 67%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统gc垃圾回收</title>
    <link href="/2023/11/30/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fgc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2023/11/30/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fgc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统gc垃圾回收"><a href="#f2fs文件系统gc垃圾回收" class="headerlink" title="f2fs文件系统gc垃圾回收"></a>f2fs文件系统gc垃圾回收</h1><h2 id="1-SSD垃圾回收简介"><a href="#1-SSD垃圾回收简介" class="headerlink" title="1.SSD垃圾回收简介"></a>1.SSD垃圾回收简介</h2><img src="/2023/11/30/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fgc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/v2-887eb43aa793e4ddd190ffeb53a1f66b_r.jpg" alt="img" style="zoom:67%;"><p>图片源自：<a href="https://zhuanlan.zhihu.com/p/639777178">https://zhuanlan.zhihu.com/p/639777178</a></p><h2 id="2-垃圾回收思想及论文描述"><a href="#2-垃圾回收思想及论文描述" class="headerlink" title="2.垃圾回收思想及论文描述"></a>2.垃圾回收思想及论文描述</h2><h3 id="2-1-垃圾回收基本思想"><a href="#2-1-垃圾回收基本思想" class="headerlink" title="2.1 垃圾回收基本思想"></a>2.1 垃圾回收基本思想</h3><p>我们把F2FS的垃圾回收比作工厂大迁移，假设在京肯德基门店，由于生意不好，准备迁移到上海去，那么作为老板肯定要做以下几件事情：</p><ul><li>【目标选择】选择哪些门店要迁走，在南京有许多的肯德基，肯定是选择人流量最少的迁走，比如说雨花台区的肯德基</li><li>【数据迁移】清点一下雨花台区总共有多少家门店，然后将他迁移到上海的门店中去</li><li>【后续清理】雨花台区的肯德基门店已经搬走了，我们得把门面装修啥的统统清理一遍，这样才会有其他商家招商入驻</li></ul><h3 id="2-2-论文描述"><a href="#2-2-论文描述" class="headerlink" title="2.2 论文描述"></a>2.2 论文描述</h3><p>f2fs论文是这么描述垃圾回收机制的：</p><ol><li>Victim Selection：【目标选择】</li></ol><img src="/2023/11/30/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fgc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20231130223739664.png" alt="image-20231130223739664" style="zoom: 67%;"><ol start="2"><li>Valid block identfication and migration：【数据迁移】</li></ol><img src="/2023/11/30/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fgc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20231130223754438.png" alt="image-20231130223754438" style="zoom: 67%;"><ol start="3"><li>Post-cleaning process：【后续清理】</li></ol><img src="/2023/11/30/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fgc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20231130223841049.png" alt="image-20231130223841049" style="zoom:67%;"><h2 id="3-垃圾回收基础知识"><a href="#3-垃圾回收基础知识" class="headerlink" title="3.垃圾回收基础知识"></a>3.垃圾回收基础知识</h2><h3 id="3-1-垃圾回收分类"><a href="#3-1-垃圾回收分类" class="headerlink" title="3.1 垃圾回收分类"></a>3.1 垃圾回收分类</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * BG_GC means the background cleaning job.</span><br><span class="hljs-comment"> * FG_GC means the on-demand cleaning job.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    BG_GC = <span class="hljs-number">0</span>,<br>    FG_GC,<br>&#125;;<br></code></pre></td></tr></table></figure><p>f2fs支持两种类型的GC，分别是后台GC（BG_GC）和前台GC（FG_GC）。后台GC以线程化执行的方式进行，在后台任务中定期执行，不会阻塞系统，在系统空闲（没有IO操作）时执行，可被随时被终止，并且不能保证能回收到空间。前台GC是在系统空间紧缺时，为了确保回收到空间而执行的阻塞操作，最新的实现中，前台空间也支持线程化执行（如果使用GC_MERGE挂载选项）。</p><h3 id="3-2-GC策略"><a href="#3-2-GC策略" class="headerlink" title="3.2 GC策略"></a>3.2 GC策略</h3><h4 id="3-2-1-Greedy算法"><a href="#3-2-1-Greedy算法" class="headerlink" title="3.2.1 Greedy算法"></a>3.2.1 Greedy算法</h4><p>F2FS 执行 foreground gc 时采用 Greedy 算法。</p><p>为实现 Greedy 算法，F2FS 维护一张记录每一个 section 中有效 block 数的元数据表，执行 gc 操作时，根据这个元数据表找出有效 block 数最少的 n 个 section 作为 victim。</p><p>直观地说，Greedy算法能使gc时迁移的有效块数最少，从而开销最小，所以 F2FS 在 foreground gc 时采用 Greedy 算法，最小化应用能感知的延迟。</p><h4 id="3-2-2-Cost-Benefit-算法"><a href="#3-2-2-Cost-Benefit-算法" class="headerlink" title="3.2.2 Cost-Benefit 算法"></a>3.2.2 Cost-Benefit 算法</h4><p>F2FS 在执行 background gc 时采用 Cost-Benefit 算法，主要思想是计算出每个 section 的迁移开销，选在开销最小的 n 个section 作为 victim，开销的计算方法如下：<code>cost = (1−μ) / 2μ ∗ age</code>，其中：</p><ul><li>u 代表 valid block 在该 section 中的比例，age 代表该 section 距离最近一次修改的时间；</li><li>1-u 是对这个 section 进行 gc 以后能够获得 free block 的数量；</li><li>2u 是对这个 section 进行 gc 的开销，读取 Valid block（1个u）然后写入到新的 section （再1个u）；</li></ul><p>所以（1-u）&#x2F; 2u 可以理解为投入产出比。</p><p>F2FS 需要在维护的元数据表里，记录每个 section 最后一次被写入的时间，gc 时选择更久没有被修改的section（冷数据）作为 victim。</p><p>该策略就是选择投入产出比更高，未修改时间更长的 section 进行 gc，两者相乘数字更大的优先被 gc。</p><h3 id="3-3-脏Segment维护的数据结构"><a href="#3-3-脏Segment维护的数据结构" class="headerlink" title="3.3 脏Segment维护的数据结构"></a>3.3 脏Segment维护的数据结构</h3><p><code>struct f2fs_sm_info</code> 主要维护了文件系统的脏segment信息，包括 dirty 和 prefree，具体数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirty_seglist_info</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">victim_selection</span> *<span class="hljs-title">v_ops</span>;</span><span class="hljs-comment">/* victim selction operation */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *dirty_segmap[NR_DIRTY_TYPE];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *dirty_secmap;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">seglist_lock</span>;</span><span class="hljs-comment">/* lock for segment bitmaps */</span><br><span class="hljs-type">int</span> nr_dirty[NR_DIRTY_TYPE];<span class="hljs-comment">/* # of dirty segments */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *victim_secmap;<span class="hljs-comment">/* background GC victims */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>f2fs文件系统使用结构体dirty_seglist_info维护脏Segment，其中有2个比较重要的变量需要留意：dirty_segmap和nr_dirty；</p><ul><li>dirty_segmap中维护的是脏Segment的状态，Segment分为Node和Data两种类型，又分为三种状态：dirty-&gt;pre-free-&gt;free</li></ul><img src="/2023/11/30/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fgc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20231202203311290.png" alt="image-20231202203311290" style="zoom: 67%;"><p>在<a href="https://anmuxixixi.github.io/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/#3-1-%E7%A1%AE%E5%AE%9Avictim-sel-policy%E5%8F%82%E6%95%B0">确定victim_sel_policy参数</a>文章中，我阐述了6种DIRTY的Node&#x2F;Data Segement，这次介绍DIRTY和PRE两种状态（状态不区分Data&#x2F;Node）</p><img src="/2023/11/30/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fgc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20231202204113251.png" alt="image-20231202204113251" style="zoom:67%;"><p>当一个Segment中使用的块valid_blocks为0，待下刷的块为ckpt_valid_blocks为512时，说明这个Segment中的block已经迁移完成等待清理，此时状态为PRE-FREE！</p><ul><li>nr_dirty为列表，保存了脏Segment的个数，例如nr_dirty[DIRTY_HOT_DATA]表示的是当前环境中脏的HOT_DATA的Segment的个数</li></ul><h2 id="4-硬啃代码"><a href="#4-硬啃代码" class="headerlink" title="4.硬啃代码"></a>4.硬啃代码</h2><p>理解了垃圾回收的基本思想，我们把垃圾回收定义为三步走：【目标选择】-&gt; 【数据迁移】-&gt; 【后续清流】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_gc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">bool</span> sync,</span><br><span class="hljs-params"><span class="hljs-type">bool</span> background, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> segno)</span><br>&#123;<br><span class="hljs-type">int</span> gc_type = sync ? FG_GC : BG_GC;<br><br>cpc.reason = __get_cp_reason(sbi);<br><br>ret = __get_victim(sbi, &amp;segno, gc_type);<br><br>seg_freed = do_garbage_collect(sbi, segno, &amp;gc_list, gc_type);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-【目标选择】"><a href="#4-1-【目标选择】" class="headerlink" title="4.1 【目标选择】"></a>4.1 【目标选择】</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __get_victim(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *victim,<br><span class="hljs-type">int</span> gc_type)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_info</span> *<span class="hljs-title">sit_i</span> =</span> SIT_I(sbi);<br>    <span class="hljs-type">int</span> ret;<br>ret = DIRTY_I(sbi)-&gt;v_ops-&gt;get_victim(sbi, victim, gc_type, NO_CHECK_TYPE, LFS, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/30/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fgc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20231130225728130.png" alt="image-20231130225728130" style="zoom:67%;"><p>如何选择我们要回收的Victim【注意，GC的基本单位为Section，但是通常Section&#x3D;Segment】，参考我的另外一篇文章：<a href="https://anmuxixixi.github.io/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/#3-Victim%E9%80%89%E6%8B%A9">Victim选择</a></p><h3 id="4-2-【数据迁移】"><a href="#4-2-【数据迁移】" class="headerlink" title="4.2 【数据迁移】"></a>4.2 【数据迁移】</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_garbage_collect</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> start_segno,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> gc_inode_list *gc_list, <span class="hljs-type">int</span> gc_type)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">sum_page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_summary_block</span> *<span class="hljs-title">sum</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_plug</span> <span class="hljs-title">plug</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> segno = start_segno;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> end_segno = start_segno + sbi-&gt;segs_per_sec;<br><span class="hljs-type">int</span> seg_freed = <span class="hljs-number">0</span>, migrated = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> type = IS_DATASEG(get_seg_entry(sbi, segno)-&gt;type) ? SUM_TYPE_DATA : SUM_TYPE_NODE;<br><br><span class="hljs-keyword">for</span> (segno = start_segno; segno &lt; end_segno; segno++) &#123;<br>        <span class="hljs-comment">// 找到summary page页</span><br>sum_page = find_get_page(META_MAPPING(sbi), GET_SUM_BLOCK(sbi, segno));<br>sum = page_address(sum_page);<br><br><span class="hljs-keyword">if</span> (type == SUM_TYPE_NODE)<br>submitted += gc_node_segment(sbi, sum-&gt;entries, segno, gc_type);<br><span class="hljs-keyword">else</span><br>submitted += gc_data_segment(sbi, sum-&gt;entries, gc_list, segno, gc_type);<br>&#125;<br><br><span class="hljs-keyword">return</span> seg_freed;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-1-node页迁移"><a href="#4-2-1-node页迁移" class="headerlink" title="4.2.1 node页迁移"></a>4.2.1 node页迁移</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gc_node_segment</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> f2fs_summary *sum, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> segno, <span class="hljs-type">int</span> gc_type)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_summary</span> *<span class="hljs-title">entry</span>;</span><br><span class="hljs-type">block_t</span> start_addr;<br><span class="hljs-type">int</span> off;<br><span class="hljs-type">int</span> phase = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> fggc = (gc_type == FG_GC);<br><span class="hljs-type">int</span> submitted = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 这里的usable_blks_in_seg就是一个segment中含有的block数目，固定为512</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> usable_blks_in_seg = f2fs_usable_blks_in_seg(sbi, segno);<br><br>start_addr = START_BLOCK(sbi, segno);<br><br>next_step:<br>entry = sum;<br><br><span class="hljs-keyword">for</span> (off = <span class="hljs-number">0</span>; off &lt; usable_blks_in_seg; off++, entry++) &#123;<br><span class="hljs-type">nid_t</span> nid = le32_to_cpu(entry-&gt;nid);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">node_page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_info</span> <span class="hljs-title">ni</span>;</span><br><br>        <span class="hljs-comment">// 首先判断这个block在位图中是否为1</span><br><span class="hljs-keyword">if</span> (check_valid_map(sbi, segno, off) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-keyword">if</span> (phase == <span class="hljs-number">0</span>) &#123;<br>f2fs_ra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), <span class="hljs-number">1</span>, META_NAT, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (phase == <span class="hljs-number">1</span>) &#123;<br>f2fs_ra_node_page(sbi, nid);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">/* phase == 2 */</span><br>node_page = f2fs_get_node_page(sbi, nid);<br><br>err = f2fs_move_node_page(node_page, gc_type);<br>&#125;<br><br><span class="hljs-keyword">if</span> (++phase &lt; <span class="hljs-number">3</span>)<br><span class="hljs-keyword">goto</span> next_step;<br><br><span class="hljs-keyword">return</span> submitted;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有两次预读，分别是METADATA区域中NAT的页预读，和node page的预读，这里要说一下预读的目的：</p><ul><li><code>f2fs_ra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), 1, META_NAT, true)</code>：NAT_BLOCK_OFFSET通过nid定位属于哪一个f2fs_nat_block，然后将其加载到Page Cache中，提前预读的目的后面要迁移node page，那么nid和blkaddr的映射关系肯定需要修改。【在**(f2fs_move_node_page -&gt; )write node page**流程中会调用set_node_addr更新nat中对应的new_blkaddr】下面的流程可以清除的看到set_node_addr时首先会去cache中找，当然更新new_blkaddr后也是更新到page cache中，要等到checkpoint流程才会刷写到cp journal或nat中。</li></ul><img src="/2023/11/30/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fgc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20231202211013776.png" alt="image-20231202211013776" style="zoom: 60%;"><ul><li><code>f2fs_ra_node_page(sbi, nid)</code>：根据nid读取node page加载到Page Cache，提前预读的目的是后面会调用f2fs_get_node_page拿到这个页然后进行move page。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_move_node_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *node_page, <span class="hljs-type">int</span> gc_type)</span><br>&#123;<br><span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (gc_type == FG_GC) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">writeback_control</span> <span class="hljs-title">wbc</span> =</span> &#123;<br>.sync_mode = WB_SYNC_ALL,<br>.nr_to_write = <span class="hljs-number">1</span>,<br>.for_reclaim = <span class="hljs-number">0</span>,<br>&#125;;<br><br>f2fs_wait_on_page_writeback(node_page, NODE, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);<br><br>set_page_dirty(node_page);<br><br><span class="hljs-keyword">if</span> (!clear_page_dirty_for_io(node_page)) &#123;<br>err = -EAGAIN;<br><span class="hljs-keyword">goto</span> out_page;<br>&#125;<br><br><span class="hljs-keyword">if</span> (__write_node_page(node_page, <span class="hljs-literal">false</span>, <span class="hljs-literal">NULL</span>,<br>&amp;wbc, <span class="hljs-literal">false</span>, FS_GC_NODE_IO, <span class="hljs-literal">NULL</span>)) &#123;<br>err = -EAGAIN;<br>unlock_page(node_page);<br>&#125;<br><span class="hljs-keyword">goto</span> release_page;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (!PageWriteback(node_page))<br>set_page_dirty(node_page);<br>&#125;<br><br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>如果是前台GC，那么会立即调用__write_node_page把node page页迁移到CURSEG中的next_blkoff中【参考我的<a href="https://anmuxixixi.github.io/2023/11/28/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E4%BA%8Enode-page%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C/#%E5%86%99node-page">写node page</a>】</p></li><li><p>如果是后台GC，只需要将node page置为脏，等待定期下刷。</p></li></ul><h3 id="4-3-【后续清理】"><a href="#4-3-【后续清理】" class="headerlink" title="4.3 【后续清理】"></a>4.3 【后续清理】</h3><p>从f2fs的论文里面写的很清楚，当victim里面的block全部迁移完成以后，里面的块会变成pre-free的状态，当完成checkpoint以后才会变成真的free状态，此时才可以重新分配。</p><p><strong>为什么这么设计？</strong></p><blockquote><p>我们知道在4.2 数据章节中，只是把页移到了CURSEG的位置，它其实还是保存在缓存中。假设当前迁移的是Node Page，里面保存了所有数据块的block addr，这个时候我们还没有CP，也就是缓存还没真正落盘，如果在没落盘的情况下充分分配给了其他的Node page，那岂不是所有的索引都乱套了吗？</p></blockquote><p><strong>靠什么去维护这种设计？</strong></p><blockquote><p>从f2fs_clear_prefree_segments中我们可以发现，是靠位图prefree_map维护的prefree状态的block</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_write_checkpoint</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-keyword">struct</span> cp_control *cpc)</span><br>&#123;<br>    f2fs_flush_nat_entries(sbi, cpc);<br><br>f2fs_flush_sit_entries(sbi, cpc);<br>    <br>    do_checkpoint(sbi, cpc);<br><br>    f2fs_clear_prefree_segments(sbi, cpc);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在f2fs的chekpoint流程中，完成了checkpoint之后会调用f2fs_clear_prefree_segments去清理prefree状态的segment</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_clear_prefree_segments</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> cp_control *cpc)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">discard_cmd_control</span> *<span class="hljs-title">dcc</span> =</span> SM_I(sbi)-&gt;dcc_info;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">head</span> =</span> &amp;dcc-&gt;entry_list;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">discard_entry</span> *<span class="hljs-title">entry</span>, *<span class="hljs-title">this</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirty_seglist_info</span> *<span class="hljs-title">dirty_i</span> =</span> DIRTY_I(sbi);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *prefree_map = dirty_i-&gt;dirty_segmap[PRE];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">-1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> secno, start_segno;<br><span class="hljs-type">bool</span> force = (cpc-&gt;reason &amp; CP_DISCARD);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-type">int</span> i;<br><br>start = find_next_bit(prefree_map, MAIN_SEGS(sbi), end + <span class="hljs-number">1</span>);<br>end = find_next_zero_bit(prefree_map, MAIN_SEGS(sbi), start + <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (i = start; i &lt; end; i++) &#123;<br><span class="hljs-keyword">if</span> (test_and_clear_bit(i, prefree_map))<br>dirty_i-&gt;nr_dirty[PRE]--;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!f2fs_lfs_mode(sbi) || !__is_large_section(sbi)) &#123;<br>f2fs_issue_discard(sbi, START_BLOCK(sbi, start), (end - start) &lt;&lt; sbi-&gt;log_blocks_per_seg);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>    &#125;<br><br>wake_up_discard_thread(sbi, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里最后会唤醒discard线程开始清理，此时会去向器件层发送TRIM命令开始进行擦除操作。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统就地更新与异地更新</title>
    <link href="/2023/11/28/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B0%B1%E5%9C%B0%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%BC%82%E5%9C%B0%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/11/28/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B0%B1%E5%9C%B0%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%BC%82%E5%9C%B0%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统对于node page的读写操作</title>
    <link href="/2023/11/28/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E4%BA%8Enode-page%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/28/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E4%BA%8Enode-page%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统对于node-page的读写操作"><a href="#f2fs文件系统对于node-page的读写操作" class="headerlink" title="f2fs文件系统对于node page的读写操作"></a>f2fs文件系统对于node page的读写操作</h1><h2 id="读node-page"><a href="#读node-page" class="headerlink" title="读node page"></a>读node page</h2><h2 id="写node-page"><a href="#写node-page" class="headerlink" title="写node page"></a>写node page</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_do_write_node_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nid, <span class="hljs-keyword">struct</span> f2fs_io_info *fio)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_summary</span> <span class="hljs-title">sum</span>;</span><br><br>set_summary(&amp;sum, nid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>do_write_page(&amp;sum, fio);<br><br>f2fs_update_iostat(fio-&gt;sbi, fio-&gt;io_type, F2FS_BLKSIZE);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-更新映射关系f2fs-summary"><a href="#2-1-更新映射关系f2fs-summary" class="headerlink" title="2.1 更新映射关系f2fs_summary"></a>2.1 更新映射关系f2fs_summary</h3><p>✅因为只有data block才有寻找ofs_in_node反向映射的意义【备忘：node block的i_addr存放了每一个data block的地址，所以我们知道了data block的地址想反向推导在哪一个node block中，需要用到f2fs_summary】，所以更新node block的时候，ofs_in_node和version直接初始化为0即可!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">set_summary</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_summary *sum, <span class="hljs-type">nid_t</span> nid,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ofs_in_node, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> version)</span><br>&#123;<br>sum-&gt;nid = cpu_to_le32(nid);<br>sum-&gt;ofs_in_node = cpu_to_le16(ofs_in_node);<br>sum-&gt;version = version;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-开始写页"><a href="#2-2-开始写页" class="headerlink" title="2.2 开始写页"></a>2.2 开始写页</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">do_write_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_summary *sum, <span class="hljs-keyword">struct</span> f2fs_io_info *fio)</span><br>&#123;<br><span class="hljs-type">int</span> type = __get_segment_type(fio);<br><br>f2fs_allocate_data_block(fio-&gt;sbi, fio-&gt;page, fio-&gt;old_blkaddr, &amp;fio-&gt;new_blkaddr, sum, type, fio);<br><br>f2fs_submit_page_write(fio);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-1-分配新的块"><a href="#2-2-1-分配新的块" class="headerlink" title="2.2.1 分配新的块"></a>2.2.1 分配新的块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_allocate_data_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-keyword">struct</span> page *page,</span><br><span class="hljs-params"><span class="hljs-type">block_t</span> old_blkaddr, <span class="hljs-type">block_t</span> *new_blkaddr,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> f2fs_summary *sum, <span class="hljs-type">int</span> type,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> f2fs_io_info *fio, <span class="hljs-type">bool</span> add_list)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_info</span> *<span class="hljs-title">sit_i</span> =</span> SIT_I(sbi);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg</span> =</span> CURSEG_I(sbi, type);<br><br>*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg); <span class="hljs-comment">// 获取新的物理地址</span><br><br>__add_sum_entry(sbi, type, sum); <span class="hljs-comment">// 将当前summary更新到CURSEG中</span><br><br>__refresh_next_blkoff(sbi, curseg); <span class="hljs-comment">// 更新下一次可以用的物理地址</span><br><br><span class="hljs-comment">// 下面更新主要是更新SIT区域的segment信息</span><br><br><span class="hljs-comment">// 根据new_blkaddr找到对应的sit_entry，然后更新状态为valid(值为1)，表示被用户使用，不可被其他人所使用</span><br>update_sit_entry(sbi, *new_blkaddr, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 根据old_blkaddr找到对应的sit_entry，然后更新状态为invalid(值为-1)，表示被覆盖了，等待GC回收后重新投入使用</span><br><span class="hljs-keyword">if</span> (GET_SEGNO(sbi, old_blkaddr) != NULL_SEGNO)<br>update_sit_entry(sbi, old_blkaddr, <span class="hljs-number">-1</span>);<br><br><span class="hljs-comment">// 如果当前segment没有空间进行下一次分配了，就分配一个新的segment给CURSEG</span><br><span class="hljs-keyword">if</span> (!__has_curseg_space(sbi, type))<br>sit_i-&gt;s_ops-&gt;allocate_segment(sbi, type, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 将segment设置为脏，等CP写回磁盘</span><br>locate_dirty_segment(sbi, GET_SEGNO(sbi, old_blkaddr));<br>locate_dirty_segment(sbi, GET_SEGNO(sbi, *new_blkaddr    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-提交写io请求"><a href="#2-2-2-提交写io请求" class="headerlink" title="2.2.2 提交写io请求"></a>2.2.2 提交写io请求</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">f2fs_submit_page_write(fio);<br></code></pre></td></tr></table></figure><p>具体怎么下发bio，会另外开章节写！[TODO: 在这里更新一下bio的文章索引]</p><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><p>写node页其实很简单：</p><ul><li>【更新索引】分配一个f2fs_summary，写入nid</li><li>【找到新块】找到CURSEG指向的下一个可用块，将fio-&gt;new_blkaddr执行该可用块</li><li>【未雨绸缪】为了下一次写入作准备，判断一下当前的CURSEG还有足够的空间；没有的话得分配新的块</li><li>【下发写io】下发bio写入真正要写入的页内容</li></ul><h2 id="3-扩展：如何分配一个新的块"><a href="#3-扩展：如何分配一个新的块" class="headerlink" title="3.扩展：如何分配一个新的块"></a>3.扩展：如何分配一个新的块</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_allocate_data_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-keyword">struct</span> page *page,</span><br><span class="hljs-params"><span class="hljs-type">block_t</span> old_blkaddr, <span class="hljs-type">block_t</span> *new_blkaddr,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> f2fs_summary *sum, <span class="hljs-type">int</span> type,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> f2fs_io_info *fio, <span class="hljs-type">bool</span> add_list)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_info</span> *<span class="hljs-title">sit_i</span> =</span> SIT_I(sbi);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg</span> =</span> CURSEG_I(sbi, type);<br><br>*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg); <span class="hljs-comment">// 获取新的物理地址</span><br><br>__add_sum_entry(sbi, type, sum); <span class="hljs-comment">// 将当前summary更新到CURSEG中</span><br><br>__refresh_next_blkoff(sbi, curseg); <span class="hljs-comment">// 更新下一次可以用的物理地址</span><br><br><span class="hljs-comment">// 下面更新主要是更新SIT区域的segment信息</span><br><br><span class="hljs-comment">// 根据new_blkaddr找到对应的sit_entry，然后更新状态为valid(值为1)，表示被用户使用，不可被其他人所使用</span><br>update_sit_entry(sbi, *new_blkaddr, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 根据old_blkaddr找到对应的sit_entry，然后更新状态为invalid(值为-1)，表示被覆盖了，等待GC回收后重新投入使用</span><br><span class="hljs-keyword">if</span> (GET_SEGNO(sbi, old_blkaddr) != NULL_SEGNO)<br>update_sit_entry(sbi, old_blkaddr, <span class="hljs-number">-1</span>);<br><br><span class="hljs-comment">// 如果当前segment没有空间进行下一次分配了，就分配一个新的segment给CURSEG</span><br><span class="hljs-keyword">if</span> (!__has_curseg_space(sbi, type))<br>sit_i-&gt;s_ops-&gt;allocate_segment(sbi, type, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 将segment设置为脏，等CP写回磁盘</span><br>locate_dirty_segment(sbi, GET_SEGNO(sbi, old_blkaddr));<br>locate_dirty_segment(sbi, GET_SEGNO(sbi, *new_blkaddr    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-获取CURSEG中下一个可用的block"><a href="#3-1-获取CURSEG中下一个可用的block" class="headerlink" title="3.1 获取CURSEG中下一个可用的block"></a>3.1 获取CURSEG中下一个可用的block</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEXT_FREE_BLKADDR(sbi, curseg)(START_BLOCK(sbi, (curseg)-&gt;segno) + (curseg)-&gt;next_blkoff)</span><br></code></pre></td></tr></table></figure><p>这里有人会有疑问，会不会当前segment占满了，next_blkoff木有了，不可能！！！因为整个流程的最后会调用__has_curseg_space，如果上一次分配的时候占满了，会重新分配新的Segment给CURSEG。</p><h3 id="3-2-更新CURSEG中的summary信息"><a href="#3-2-更新CURSEG中的summary信息" class="headerlink" title="3.2 更新CURSEG中的summary信息"></a>3.2 更新CURSEG中的summary信息</h3><p>因为前面2.1节更新了summary信息，所以我们要更新到CURSEG中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __add_sum_entry(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">int</span> type,<br><span class="hljs-keyword">struct</span> f2fs_summary *sum)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg</span> =</span> CURSEG_I(sbi, type);<br><span class="hljs-type">void</span> *addr = curseg-&gt;sum_blk;<br>addr += curseg-&gt;next_blkoff * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> f2fs_summary);<br><span class="hljs-built_in">memcpy</span>(addr, sum, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> f2fs_summary));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-更新CURSEG的next-blkoff"><a href="#3-3-更新CURSEG的next-blkoff" class="headerlink" title="3.3 更新CURSEG的next_blkoff"></a>3.3 更新CURSEG的next_blkoff</h3><p>因为当前的next_blkoff已被本次占用了，所以提前分配下一个可用的block，这里有2种情况“</p><ul><li>如果分配方式是SSR，那么需要同时寻找ckpt_valid_map和cur_valid_map中同时不为0的位置</li><li>如果分配方式是LFS，那么直接+1即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __refresh_next_blkoff(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-keyword">struct</span> curseg_info *seg)<br>&#123;<br><span class="hljs-keyword">if</span> (seg-&gt;alloc_type == SSR)<br>__next_free_blkoff(sbi, seg, seg-&gt;next_blkoff + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span><br>seg-&gt;next_blkoff++;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __next_free_blkoff(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi,<br><span class="hljs-keyword">struct</span> curseg_info *seg, <span class="hljs-type">block_t</span> start)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seg_entry</span> *<span class="hljs-title">se</span> =</span> get_seg_entry(sbi, seg-&gt;segno);<br><span class="hljs-type">int</span> entries = SIT_VBLOCK_MAP_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *target_map = SIT_I(sbi)-&gt;tmp_map;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *ckpt_map = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)se-&gt;ckpt_valid_map;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *cur_map = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)se-&gt;cur_valid_map;<br><span class="hljs-type">int</span> i, pos;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; entries; i++)<br>target_map[i] = ckpt_map[i] | cur_map[i];<br><br>pos = __find_rev_next_zero_bit(target_map, sbi-&gt;blocks_per_seg, start);<br><br>seg-&gt;next_blkoff = pos;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-更新SIT区域的信息"><a href="#3-4-更新SIT区域的信息" class="headerlink" title="3.4 更新SIT区域的信息"></a>3.4 更新SIT区域的信息</h3><p>因为我们使用了一个Node segment中的block，而SIT区域维护了每一个Segment的信息，如这个segment使用了多少个block，哪几个block使用了，所以我们要更新SIT。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* del: 理解成查分的意思，也就是说本次Segment中有del个发生了变化</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">update_sit_entry</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">block_t</span> blkaddr, <span class="hljs-type">int</span> del)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seg_entry</span> *<span class="hljs-title">se</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> segno, offset;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> new_vblocks;<br><span class="hljs-type">bool</span> exist;<br><br>segno = GET_SEGNO(sbi, blkaddr);<br><br>se = get_seg_entry(sbi, segno);<br>new_vblocks = se-&gt;valid_blocks + del;<br>offset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);<br><br>    <span class="hljs-comment">// 更新seg_entry中的有效block数目</span><br>se-&gt;valid_blocks = new_vblocks;<br><br><span class="hljs-keyword">if</span> (del &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 更新位图</span><br>exist = f2fs_test_and_set_bit(offset, se-&gt;cur_valid_map);<br><br><span class="hljs-keyword">if</span> (!is_sbi_flag_set(sbi, SBI_CP_DISABLED)) &#123;<br>            <span class="hljs-comment">// 这里需要设置ckpt_valid_map位图</span><br><span class="hljs-keyword">if</span> (!f2fs_test_and_set_bit(offset, se-&gt;ckpt_valid_map))<br>se-&gt;ckpt_valid_blocks++;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果将offset对应的block标记为无效，则在位图中进行清理</span><br>exist = f2fs_test_and_clear_bit(offset, se-&gt;cur_valid_map);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-当前CURSEG是否还有空间"><a href="#3-5-当前CURSEG是否还有空间" class="headerlink" title="3.5 当前CURSEG是否还有空间"></a>3.5 当前CURSEG是否还有空间</h3><p>为了下一次分配时next_blkoff还是有效的，需要提前判断一下CURSEG是否还有足够的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> __has_curseg_space(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi,<br><span class="hljs-keyword">struct</span> curseg_info *curseg)<br>&#123;<br><span class="hljs-keyword">return</span> curseg-&gt;next_blkoff &lt; f2fs_usable_blks_in_seg(sbi,<br>curseg-&gt;segno);<br>&#125;<br></code></pre></td></tr></table></figure><p>原理其实也比较简单，就是判断3.3中获取的next_blkoff是不是在范围之内。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使命召唤17黑色行动解锁混沌行动</title>
    <link href="/2023/11/28/%E4%BD%BF%E5%91%BD%E5%8F%AC%E5%94%A417%E9%BB%91%E8%89%B2%E8%A1%8C%E5%8A%A8%E8%A7%A3%E9%94%81%E6%B7%B7%E6%B2%8C%E8%A1%8C%E5%8A%A8/"/>
    <url>/2023/11/28/%E4%BD%BF%E5%91%BD%E5%8F%AC%E5%94%A417%E9%BB%91%E8%89%B2%E8%A1%8C%E5%8A%A8%E8%A7%A3%E9%94%81%E6%B7%B7%E6%B2%8C%E8%A1%8C%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="使命召唤17黑色行动解锁混沌行动"><a href="#使命召唤17黑色行动解锁混沌行动" class="headerlink" title="使命召唤17黑色行动解锁混沌行动"></a>使命召唤17黑色行动解锁混沌行动</h1><p>前期没看成就和攻略，导致没有搜集完整证据，所以没有解锁《混沌行动》</p><h2 id="证据搜集"><a href="#证据搜集" class="headerlink" title="证据搜集"></a>证据搜集</h2><h2 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h2><p>错过了之后，要回到《东柏林简报》章节去重新检视线索</p><img src="/2023/11/28/%E4%BD%BF%E5%91%BD%E5%8F%AC%E5%94%A417%E9%BB%91%E8%89%B2%E8%A1%8C%E5%8A%A8%E8%A7%A3%E9%94%81%E6%B7%B7%E6%B2%8C%E8%A1%8C%E5%8A%A8/image-20231128221203072.png" alt="image-20231128221203072" style="zoom: 33%;"><ul><li>选择混沌行动</li></ul><img src="/2023/11/28/%E4%BD%BF%E5%91%BD%E5%8F%AC%E5%94%A417%E9%BB%91%E8%89%B2%E8%A1%8C%E5%8A%A8%E8%A7%A3%E9%94%81%E6%B7%B7%E6%B2%8C%E8%A1%8C%E5%8A%A8/image-20231128221305743.png" alt="image-20231128221305743" style="zoom: 33%;"><ul><li>检视证据</li></ul><img src="/2023/11/28/%E4%BD%BF%E5%91%BD%E5%8F%AC%E5%94%A417%E9%BB%91%E8%89%B2%E8%A1%8C%E5%8A%A8%E8%A7%A3%E9%94%81%E6%B7%B7%E6%B2%8C%E8%A1%8C%E5%8A%A8/image-20231128221410168.png" alt="image-20231128221410168" style="zoom:33%;"><ul><li>报纸线索：我的是<strong>亚特兰大</strong></li></ul><img src="/2023/11/28/%E4%BD%BF%E5%91%BD%E5%8F%AC%E5%94%A417%E9%BB%91%E8%89%B2%E8%A1%8C%E5%8A%A8%E8%A7%A3%E9%94%81%E6%B7%B7%E6%B2%8C%E8%A1%8C%E5%8A%A8/image-20231128221335098.png" alt="image-20231128221335098" style="zoom: 33%;"><ul><li>加密信息：红色的规律为间隔数字差为1,2,3,…，所以红色？为41；蓝色的规律为间隔数组差为8，所以蓝色？为78；组合起来为4178</li></ul><img src="/2023/11/28/%E4%BD%BF%E5%91%BD%E5%8F%AC%E5%94%A417%E9%BB%91%E8%89%B2%E8%A1%8C%E5%8A%A8%E8%A7%A3%E9%94%81%E6%B7%B7%E6%B2%8C%E8%A1%8C%E5%8A%A8/image-20231128221511272.png" alt="image-20231128221511272" style="zoom: 33%;"><ul><li>数位电台：上面的加密信息对应电台为奥兰多，报纸上亚特兰大对应的数字为1541</li></ul><img src="/2023/11/28/%E4%BD%BF%E5%91%BD%E5%8F%AC%E5%94%A417%E9%BB%91%E8%89%B2%E8%A1%8C%E5%8A%A8%E8%A7%A3%E9%94%81%E6%B7%B7%E6%B2%8C%E8%A1%8C%E5%8A%A8/image-20231128221646934.png" alt="image-20231128221646934" style="zoom:33%;"><ul><li>开始破译</li></ul><img src="/2023/11/28/%E4%BD%BF%E5%91%BD%E5%8F%AC%E5%94%A417%E9%BB%91%E8%89%B2%E8%A1%8C%E5%8A%A8%E8%A7%A3%E9%94%81%E6%B7%B7%E6%B2%8C%E8%A1%8C%E5%8A%A8/image-20231128221751205.png" alt="image-20231128221751205" style="zoom:33%;"><ul><li>密码输入：报纸上的城市在数位电台的数字，通讯城市为解密后的数组在数位电台上的城市。</li></ul><img src="/2023/11/28/%E4%BD%BF%E5%91%BD%E5%8F%AC%E5%94%A417%E9%BB%91%E8%89%B2%E8%A1%8C%E5%8A%A8%E8%A7%A3%E9%94%81%E6%B7%B7%E6%B2%8C%E8%A1%8C%E5%8A%A8/image-20231128221806688.png" alt="image-20231128221806688" style="zoom:33%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统分配segment</title>
    <link href="/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/"/>
    <url>/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统分配segment"><a href="#f2fs文件系统分配segment" class="headerlink" title="f2fs文件系统分配segment"></a>f2fs文件系统分配segment</h1><h2 id="1-segment分配方式概述"><a href="#1-segment分配方式概述" class="headerlink" title="1.segment分配方式概述"></a>1.segment分配方式概述</h2><p>f2fs文件系统分配segment的方式主要分为LFS和SSR</p><img src="/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/webp.webp" alt="img" style="zoom: 50%;"><ul><li>LFS Alloc：找到一个Free的Segment，也就是这个Segment没有被使用，里面的block都是全新未写入内容的</li><li>SSR Alloc（Slack Space Recycling）：找到一个Used Segment，也就是说这个Segment里面有一些Block是已经使用了的，我们将要写的内容写入到这个Segment的未使用的block中。至于选择哪一个Used Segment，是有选择策略的。</li></ul><h2 id="2-GC策略"><a href="#2-GC策略" class="headerlink" title="2.GC策略"></a>2.GC策略</h2><h3 id="2-1-Greedy算法"><a href="#2-1-Greedy算法" class="headerlink" title="2.1 Greedy算法"></a>2.1 Greedy算法</h3><p>F2FS 执行 foreground gc 时采用 Greedy 算法。</p><p>为实现 Greedy 算法，F2FS 维护一张记录每一个 section 中有效 block 数的元数据表，执行 gc 操作时，根据这个元数据表找出有效 block 数最少的 n 个 section 作为 victim。</p><p>直观地说，Greedy算法能使gc时迁移的有效块数最少，从而开销最小，所以 F2FS 在 foreground gc 时采用 Greedy 算法，最小化应用能感知的延迟。</p><h3 id="2-2-Cost-Benefit-算法"><a href="#2-2-Cost-Benefit-算法" class="headerlink" title="2.2 Cost-Benefit 算法"></a>2.2 Cost-Benefit 算法</h3><p>F2FS 在执行 background gc 时采用 Cost-Benefit 算法，主要思想是计算出每个 section 的迁移开销，选在开销最小的 n 个section 作为 victim，开销的计算方法如下：<code>cost = (1−μ) / 2μ ∗ age</code>，其中：</p><ul><li>u 代表 valid block 在该 section 中的比例，age 代表该 section 距离最近一次修改的时间；</li><li>1-u 是对这个 section 进行 gc 以后能够获得 free block 的数量；</li><li>2u 是对这个 section 进行 gc 的开销，读取 Valid block（1个u）然后写入到新的 section （再1个u）；</li></ul><p>所以（1-u）&#x2F; 2u 可以理解为投入产出比。</p><p>F2FS 需要在维护的元数据表里，记录每个 section 最后一次被写入的时间，gc 时选择更久没有被修改的section（冷数据）作为 victim。</p><p>该策略就是选择投入产出比更高，未修改时间更长的 section 进行 gc，两者相乘数字更大的优先被 gc。</p><h2 id="3-Victim选择"><a href="#3-Victim选择" class="headerlink" title="3.Victim选择"></a>3.Victim选择</h2><p>f2fs文件系统中victim的选择是一个钩子函数（函数指针）</p><img src="/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/image-20231127222156495.png" alt="image-20231127222156495" style="zoom:67%;"><p>🎆<strong>需要特别注意的是</strong>：victim可以是section，也可以是segment</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_victim_by_default</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *result, <span class="hljs-type">int</span> gc_type, <span class="hljs-type">int</span> type,</span><br><span class="hljs-params"><span class="hljs-type">char</span> alloc_mode, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> age)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirty_seglist_info</span> *<span class="hljs-title">dirty_i</span> =</span> DIRTY_I(sbi);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_info</span> *<span class="hljs-title">sm</span> =</span> SIT_I(sbi);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">victim_sel_policy</span> <span class="hljs-title">p</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> secno, last_victim;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> last_segment;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nsearched;<br><span class="hljs-type">bool</span> is_atgc;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>last_segment = MAIN_SECS(sbi) * sbi-&gt;segs_per_sec;<br><br>    <span class="hljs-comment">// ------------------------------ 区域1：确定victim_sel_policy参数 ------------------------------</span><br>    <br>p.alloc_mode = alloc_mode;<br>p.age = age;<br>p.age_threshold = sbi-&gt;am.age_threshold;<br><br>retry:<br>select_policy(sbi, gc_type, type, &amp;p);<br>p.min_segno = NULL_SEGNO;<br>p.oldest_age = <span class="hljs-number">0</span>;<br>p.min_cost = get_max_cost(sbi, &amp;p);<br><br>last_victim = sm-&gt;last_victim[p.gc_mode];<br><br>    <span class="hljs-comment">// ------------------------------ 区域2：循环遍历所有的segment ------------------------------</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cost, *dirty_bitmap;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> unit_no, segno;<br><br>dirty_bitmap = p.dirty_bitmap;<br>unit_no = find_next_bit(dirty_bitmap, last_segment / p.ofs_unit, p.offset / p.ofs_unit);<br>segno = unit_no * p.ofs_unit;<br><span class="hljs-keyword">if</span> (segno &gt;= last_segment) &#123;<br><span class="hljs-keyword">if</span> (sm-&gt;last_victim[p.gc_mode]) &#123;<br>last_segment = sm-&gt;last_victim[p.gc_mode];<br>sm-&gt;last_victim[p.gc_mode] = <span class="hljs-number">0</span>;<br>p.offset = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>p.offset = segno + p.ofs_unit;<br>nsearched++;<br><br><span class="hljs-comment">// ------------------------------ 区域3：找到cost最小的segno ------------------------------</span><br>secno = GET_SEC_FROM_SEG(sbi, segno);<br><br>cost = get_gc_cost(sbi, segno, &amp;p);<br><br><span class="hljs-keyword">if</span> (p.min_cost &gt; cost) &#123;<br>p.min_segno = segno;<br>p.min_cost = cost;<br>&#125;<br>next:<br><span class="hljs-keyword">if</span> (nsearched &gt;= p.max_search) &#123;<br><span class="hljs-keyword">if</span> (!sm-&gt;last_victim[p.gc_mode] &amp;&amp; segno &lt;= last_victim)<br>sm-&gt;last_victim[p.gc_mode] = last_victim + p.ofs_unit;<br><span class="hljs-keyword">else</span><br>sm-&gt;last_victim[p.gc_mode] = segno + p.ofs_unit;<br>sm-&gt;last_victim[p.gc_mode] %=<br>(MAIN_SECS(sbi) * sbi-&gt;segs_per_sec);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// ------------------------------ 区域4：找到后赋值退出 ------------------------------</span><br><span class="hljs-keyword">if</span> (p.min_segno != NULL_SEGNO) &#123;<br>got_it:<br>*result = (p.min_segno / p.ofs_unit) * p.ofs_unit;<br>got_result:<br><span class="hljs-keyword">if</span> (p.alloc_mode == LFS) &#123;<br>secno = GET_SEC_FROM_SEG(sbi, p.min_segno);<br><span class="hljs-keyword">if</span> (gc_type == FG_GC) sbi-&gt;cur_victim_sec = secno;<br><span class="hljs-keyword">else</span> set_bit(secno, dirty_i-&gt;victim_secmap);<br>&#125;<br>ret = <span class="hljs-number">0</span>;<br><br>&#125;<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码略长，分片处理：</p><ul><li>区域1：确定victim_sel_policy参数，其中最重要的是select_policy函数</li><li>区域2：循环遍历segment，需要主要的是退出条件</li><li>区域3：根据select_policy中确定的gc_mode，结合第二节的GC策略找到最小分配代价min_cost对应的segment</li><li>区域4：赋值找到的min_segno</li></ul><h3 id="3-1-确定victim-sel-policy参数"><a href="#3-1-确定victim-sel-policy参数" class="headerlink" title="3.1 确定victim_sel_policy参数"></a>3.1 确定victim_sel_policy参数</h3><p>确定victim_sel_policy参数，其中最重要的是select_policy函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">select_policy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">int</span> gc_type,</span><br><span class="hljs-params"><span class="hljs-type">int</span> type, <span class="hljs-keyword">struct</span> victim_sel_policy *p)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirty_seglist_info</span> *<span class="hljs-title">dirty_i</span> =</span> DIRTY_I(sbi);<br><br><span class="hljs-keyword">if</span> (p-&gt;alloc_mode == SSR) &#123;<br>p-&gt;gc_mode = GC_GREEDY;<br>p-&gt;dirty_bitmap = dirty_i-&gt;dirty_segmap[type];<br>p-&gt;max_search = dirty_i-&gt;nr_dirty[type];<br>p-&gt;ofs_unit = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p-&gt;gc_mode = select_gc_type(sbi, gc_type);<br>p-&gt;ofs_unit = sbi-&gt;segs_per_sec;<br><span class="hljs-keyword">if</span> (__is_large_section(sbi)) &#123;<br>p-&gt;dirty_bitmap = dirty_i-&gt;dirty_secmap;<br>p-&gt;max_search = count_bits(p-&gt;dirty_bitmap, <span class="hljs-number">0</span>, MAIN_SECS(sbi));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p-&gt;dirty_bitmap = dirty_i-&gt;dirty_segmap[DIRTY];<br>p-&gt;max_search = dirty_i-&gt;nr_dirty[DIRTY];<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (test_opt(sbi, NOHEAP) &amp;&amp;<br>(type == CURSEG_HOT_DATA || IS_NODESEG(type)))<br>p-&gt;offset = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>p-&gt;offset = SIT_I(sbi)-&gt;last_victim[p-&gt;gc_mode];<br>&#125;<br></code></pre></td></tr></table></figure><p>这种需要区分LFS和SSR：</p><ul><li>LFS：p-&gt;gc_mode通过select_gc_type一般为Cost-Benefit，p-&gt;ofs_unit为一个Section含有的segment</li><li>SSR：p-&gt;gc_mode为GC_GREEDY，p-&gt;ofs_unit为1（也就是一个Segment）</li></ul><p>这里需要注意<strong>dirty_segmap</strong>位图：</p><blockquote><p>dirty_seglist_info结构体维护了6个位图，DIRTY HOT&#x2F;WARM&#x2F;COLD × NODE&#x2F;DATA，其中每一个位图的大小均为Segment的总数</p><ul><li>当这个Segment为Dirty的时候，对应的SegNo在位图中的Bit位为1</li><li>一个类型有多少个Dirty的Segment，其维护在nr_dirty中，例如下图中所有的HOT DATA类型的Segment中总共有3个Dirty的，那么dirty_i-&gt;nr_dirty[DIRTY_HOT_DATA]&#x3D;3</li><li>🔴<strong>自然最大的搜寻次数对应于有多少个脏的segment</strong></li></ul></blockquote><img src="/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/image-20231127224936323.png" alt="image-20231127224936323" style="zoom:80%;"><h3 id="3-2-循环遍历所有的segment"><a href="#3-2-循环遍历所有的segment" class="headerlink" title="3.2 循环遍历所有的segment"></a>3.2 循环遍历所有的segment</h3><p>每次循环的时候，通过<strong>find_next_bit</strong>找到位图中为1的位置（假如没找到会返回位图的长度）</p><p>循环遍历segment，需要主要的是退出条件，退出条件有2中可能性：</p><ol><li>segno &gt;&#x3D; last_segment且sm-&gt;last_victim[p.gc_mode]为0</li><li>循环次数达到了p.max_search，即达到了dirty_i-&gt;nr_dirty[type]</li></ol><blockquote><p>这里有一种特殊的情况，当初始的last_victim为4的时候，先向右寻找到索引7的Bit位为1，下一次遍历的时候会发现返回的了位图的长度会走进if分支，但此时会将offset和last_victim重新赋值为0后重头开始遍历。</p><img src="/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/image-20231127232637008.png" alt="image-20231127232637008" style="zoom: 67%;"></blockquote><ul><li><strong>情况1：向有遍历到边界后重头开始</strong></li></ul><img src="/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/image-20231127232439084.png" alt="image-20231127232439084" style="zoom:67%;"><ul><li><strong>情况2：正常遍历完正好达到max_search后结束</strong></li></ul><img src="/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/image-20231127233012926.png" alt="image-20231127233012926" style="zoom:67%;"><h3 id="3-3-找到最小代价的segment"><a href="#3-3-找到最小代价的segment" class="headerlink" title="3.3 找到最小代价的segment"></a>3.3 找到最小代价的segment</h3><img src="/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/image-20231127233247450.png" alt="image-20231127233247450" style="zoom:67%;"><h3 id="3-4-赋值后退出"><a href="#3-4-赋值后退出" class="headerlink" title="3.4 赋值后退出"></a>3.4 赋值后退出</h3><p>✅<strong>两段赋值代码值得注意：</strong></p><ul><li><strong>sm-&gt;last_victim[p.gc_mode]：</strong>遍历结束后，根据segNo和上一次搜索的最终位置last_victim取最大值后 + of_unit，将其保存为这次搜素的最终位置，这样下次搜索就可以直接从这个位置开始【记忆化搜索，节省时间复杂度】。</li><li><strong>*result &#x3D; (p.min_segno &#x2F; p.ofs_unit) * p.ofs_unit</strong>：将找到的最小代价的segmentNo返回。<strong>这里为什么先除后乘</strong>，主要是针对victim为section的场景【这里的result返回的都是一个section中的第一个segno，min_segno&#x3D;9，一个section有4个segment（即ofs_unit&#x3D;4），最终结果为(9&#x2F;4)*4&#x3D;8，也就是找到了最小代价的那个section的起始segNo】</li></ul><h2 id="4-代码角度解析LFS和SSR"><a href="#4-代码角度解析LFS和SSR" class="headerlink" title="4.代码角度解析LFS和SSR"></a>4.代码角度解析LFS和SSR</h2><p>f2fs文件系统中分配segment是一个钩子函数（函数指针）</p><img src="/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/image-20231127221230546.png" alt="image-20231127221230546" style="zoom:67%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">allocate_segment_by_default</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi,</span><br><span class="hljs-params"><span class="hljs-type">int</span> type, <span class="hljs-type">bool</span> force)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg</span> =</span> CURSEG_I(sbi, type);<br><br><span class="hljs-keyword">if</span> (force)<br>new_curseg(sbi, type, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!is_set_ckpt_flags(sbi, CP_CRC_RECOVERY_FLAG) &amp;&amp;<br>curseg-&gt;seg_type == CURSEG_WARM_NODE)<br>new_curseg(sbi, type, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curseg-&gt;alloc_type == LFS &amp;&amp;<br>is_next_segment_free(sbi, curseg, type) &amp;&amp;<br>likely(!is_sbi_flag_set(sbi, SBI_CP_DISABLED)))<br>new_curseg(sbi, type, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f2fs_need_SSR(sbi) &amp;&amp;<br>get_ssr_segment(sbi, type, SSR, <span class="hljs-number">0</span>))<br>change_curseg(sbi, type, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">else</span><br>new_curseg(sbi, type, <span class="hljs-literal">false</span>);<br><br>stat_inc_seg_type(sbi, curseg);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/image-20231127221624982.png" alt="image-20231127221624982" style="zoom:80%;"><h3 id="4-1-LFS分配函数get-new-segment"><a href="#4-1-LFS分配函数get-new-segment" class="headerlink" title="4.1 LFS分配函数get_new_segment"></a>4.1 LFS分配函数get_new_segment</h3><p>LFS分配新的Segment的方式为：<code>new_curseg(sbi, type, false)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">new_curseg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">int</span> type, <span class="hljs-type">bool</span> new_sec)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg</span> =</span> CURSEG_I(sbi, type);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> seg_type = curseg-&gt;seg_type;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> segno = curseg-&gt;segno;<br><span class="hljs-type">int</span> dir = ALLOC_LEFT;<br><br>    <span class="hljs-comment">// 省略一些细枝末节的代码和dir方向选择</span><br>    <br>get_new_segment(sbi, &amp;segno, new_sec, dir);<br>curseg-&gt;next_segno = segno;<br>curseg-&gt;alloc_type = LFS;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中寻找到Free Segment的主要函数为<strong>get_new_segment</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">get_new_segment</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *newseg, <span class="hljs-type">bool</span> new_sec, <span class="hljs-type">int</span> dir)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_segmap_info</span> *<span class="hljs-title">free_i</span> =</span> FREE_I(sbi);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> segno, secno, zoneno;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> total_zones = MAIN_SECS(sbi) / sbi-&gt;secs_per_zone;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hint = GET_SEC_FROM_SEG(sbi, *newseg);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_zoneno = GET_ZONE_FROM_SEG(sbi, *newseg);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> left_start = hint;<br><span class="hljs-type">bool</span> init = <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> go_left = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i;<br><br>spin_lock(&amp;free_i-&gt;segmap_lock);<br><br><span class="hljs-keyword">if</span> (!new_sec &amp;&amp; ((*newseg + <span class="hljs-number">1</span>) % sbi-&gt;segs_per_sec)) &#123;<br>segno = find_next_zero_bit(free_i-&gt;free_segmap,<br>GET_SEG_FROM_SEC(sbi, hint + <span class="hljs-number">1</span>), *newseg + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (segno &lt; GET_SEG_FROM_SEC(sbi, hint + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">goto</span> got_it;<br>&#125;<br>find_other_zone:<br>secno = find_next_zero_bit(free_i-&gt;free_secmap, MAIN_SECS(sbi), hint);<br><span class="hljs-keyword">if</span> (secno &gt;= MAIN_SECS(sbi)) &#123;<br><span class="hljs-keyword">if</span> (dir == ALLOC_RIGHT) &#123;<br>secno = find_next_zero_bit(free_i-&gt;free_secmap,<br>MAIN_SECS(sbi), <span class="hljs-number">0</span>);<br>f2fs_bug_on(sbi, secno &gt;= MAIN_SECS(sbi));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>go_left = <span class="hljs-number">1</span>;<br>left_start = hint - <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (go_left == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> skip_left;<br><br><span class="hljs-keyword">while</span> (test_bit(left_start, free_i-&gt;free_secmap)) &#123;<br><span class="hljs-keyword">if</span> (left_start &gt; <span class="hljs-number">0</span>) &#123;<br>left_start--;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>left_start = find_next_zero_bit(free_i-&gt;free_secmap,<br>MAIN_SECS(sbi), <span class="hljs-number">0</span>);<br>f2fs_bug_on(sbi, left_start &gt;= MAIN_SECS(sbi));<br><span class="hljs-keyword">break</span>;<br>&#125;<br>secno = left_start;<br>skip_left:<br>segno = GET_SEG_FROM_SEC(sbi, secno);<br>zoneno = GET_ZONE_FROM_SEC(sbi, secno);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NR_CURSEG_TYPE; i++)<br><span class="hljs-keyword">if</span> (CURSEG_I(sbi, i)-&gt;zone == zoneno)<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">if</span> (i &lt; NR_CURSEG_TYPE) &#123;<br><span class="hljs-comment">/* zone is in user, try another */</span><br><span class="hljs-keyword">if</span> (go_left)<br>hint = zoneno * sbi-&gt;secs_per_zone - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (zoneno + <span class="hljs-number">1</span> &gt;= total_zones)<br>hint = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>hint = (zoneno + <span class="hljs-number">1</span>) * sbi-&gt;secs_per_zone;<br>init = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">goto</span> find_other_zone;<br>&#125;<br>got_it:<br><span class="hljs-comment">/* set it as dirty segment in free segmap */</span><br>f2fs_bug_on(sbi, test_bit(segno, free_i-&gt;free_segmap));<br>__set_inuse(sbi, segno);<br>*newseg = segno;<br>spin_unlock(&amp;free_i-&gt;segmap_lock);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-SSR分配函数get-ssr-segment"><a href="#4-2-SSR分配函数get-ssr-segment" class="headerlink" title="4.2 SSR分配函数get_ssr_segment"></a>4.2 SSR分配函数get_ssr_segment</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_ssr_segment</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">int</span> type,</span><br><span class="hljs-params"><span class="hljs-type">int</span> alloc_mode, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> age)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg</span> =</span> CURSEG_I(sbi, type);<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">victim_selection</span> *<span class="hljs-title">v_ops</span> =</span> DIRTY_I(sbi)-&gt;v_ops;<br><span class="hljs-type">unsigned</span> segno = NULL_SEGNO;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> seg_type = curseg-&gt;seg_type;<br><span class="hljs-type">int</span> i, cnt;<br><span class="hljs-type">bool</span> reversed = <span class="hljs-literal">false</span>;<br><br>sanity_check_seg_type(sbi, seg_type);<br><br><span class="hljs-comment">/* f2fs_need_SSR() already forces to do this */</span><br><span class="hljs-keyword">if</span> (!v_ops-&gt;get_victim(sbi, &amp;segno, BG_GC, seg_type, alloc_mode, age)) &#123;<br>curseg-&gt;next_segno = segno;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会去调用第三节中的victim选择算法找到一个cost最小的victim(segment)，然后将curseg指向的下一个segment即next_segno赋值为找到的segno</p><img src="/2023/11/27/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8Dsegment/image-20231202211805015.png" alt="image-20231202211805015" style="zoom:67%;"><p>随后要改变当前segment也就是CURSEG的指向。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">change_curseg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">int</span> type, <span class="hljs-type">bool</span> flush)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirty_seglist_info</span> *<span class="hljs-title">dirty_i</span> =</span> DIRTY_I(sbi);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg</span> =</span> CURSEG_I(sbi, type);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> new_segno = curseg-&gt;next_segno;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_summary_block</span> *<span class="hljs-title">sum_node</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">sum_page</span>;</span><br><br>__set_test_and_inuse(sbi, new_segno);<br><br>reset_curseg(sbi, type, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 更新curseg-&gt;segno为curseg-&gt;next_segno，也就是通过get_Victim找到的segment</span><br>curseg-&gt;alloc_type = SSR;<br>__next_free_blkoff(sbi, curseg, <span class="hljs-number">0</span>);<br><br>   <span class="hljs-comment">// 相应的更新CURSEG对应的f2fs_summary_block</span><br>sum_page = f2fs_get_sum_page(sbi, new_segno);<br>sum_node = (<span class="hljs-keyword">struct</span> f2fs_summary_block *)page_address(sum_page);<br><span class="hljs-built_in">memcpy</span>(curseg-&gt;sum_blk, sum_node, SUM_ENTRY_SIZE);<br>f2fs_put_page(sum_page, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>🎯<strong>总结：SSR分配的方式就是从dirty segment中找到一个迁移代价最小的segment，然后将curseg指向此segment</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核数据结构之Radix Tree</title>
    <link href="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/"/>
    <url>/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux内核数据结构之Radix-Tree"><a href="#Linux内核数据结构之Radix-Tree" class="headerlink" title="Linux内核数据结构之Radix Tree"></a>Linux内核数据结构之Radix Tree</h1><blockquote><p>⛷️转载自：<a href="https://zhuanlan.zhihu.com/p/533338300">https://zhuanlan.zhihu.com/p/533338300</a></p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>radix tree，又称做基数树，是一种适合于构建key与value相关联的数据结构。在linux内核中，radix tree由 include&#x2F;linux&#x2F;radix-tree.h和lib&#x2F;radix-tree.c两个文件实现。</p><p>在linux内核中pagecache就是用radix tree构建的page index与page ptr (指向struct page)的关联。详见struct address_space 中的page_tree。这里的(key,value)对， 就是(index， ptr)对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>*<span class="hljs-title">host</span>;</span><span class="hljs-comment">/* owner: inode, block_device */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_root</span><span class="hljs-title">page_tree</span>;</span><br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>radix tree中的每一个内部节点最多拥有r个child，r&#x3D;2^n (n&gt;&#x3D;1), 这里的n被称做基数。 n个bit称作一个bit簇。</p><p>在linux内核的radix tree实现代码中，基数最为最关键的参数被定义成6（RADIX_TREE_MAP_SHIFT），也就是说一个bit簇是6个bit。所以linux内核中radix tree的一个内部节点最多可以有64个child。</p><p>radix tree的所有叶子节点都在最下面一层（图中红色节点），其他节点都是为了构建radix tree树而创建出来的内部节点。叶子节点包含index-ptr对中的ptr item， 下图中将ptr用红色来标记为item。</p><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-7930d31f29a67d19368b67ae6ef01f9e_720w.webp" alt="img" style="zoom: 100%;"><p>假设key值等于0x840FF, 其二进制按照6bit一簇可以写成，000010-000100 -000011 -111111，从左到右的index值分别为2, 4, 3, 63。那么根据key值0x840FF找到value的过程就只需要4步：</p><p>第一步，在最上层的节点A中找到index为2的slot，其slot[2]指针指向第二层节点中的节点B。</p><p>第二步，在节点B中找到index为4的slot，其slot[4]指针指向第三层节点中的节点C。</p><p>第三步，在节点C中找到index为3的slot，其slot[3]指针指向第三层节点中的节点D。</p><p>第四步，在节点D中找到index为63的slot，其slot[63]指针指向叶子节点item E。</p><h2 id="2-数据结构初识"><a href="#2-数据结构初识" class="headerlink" title="2.数据结构初识"></a>2.数据结构初识</h2><h3 id="struct-radix-tree-root"><a href="#struct-radix-tree-root" class="headerlink" title="struct radix_tree_root"></a>struct radix_tree_root</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* root tags are stored in gfp_mask, shifted by __GFP_BITS_SHIFT */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_root</span> &#123;</span><br><span class="hljs-type">gfp_t</span>gfp_mask;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span>__<span class="hljs-title">rcu</span> *<span class="hljs-title">rnode</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>每一棵radix tree都必须有struct radix_tree_root这样一个数据结构。其中</p><ul><li>gfp_mask：bit 0-bit24 用做内存分配的标记，在分配struct radix_tree_node结构时，传递给内存分配函数kmem_cache_alloc。bit25-27用作root tags。tag的作用下文再细说。</li><li>rnode： rnode用来指向顶层的struct radix_tree_node，也就是radix tree的第一个内部节点；当radix tree 只有一个叶子节点，并且叶子节点的index为0时，也可以可以直接指向一个叶子节点，即(index，ptr)对中的ptr。</li></ul><h3 id="struct-radix-tree-node"><a href="#struct-radix-tree-node" class="headerlink" title="struct radix_tree_node"></a>struct radix_tree_node</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The radix_tree_node structure is never embedded in other data structures.</span><br><span class="hljs-comment"> * As a result, there&#x27;s no need to preserve the size.  Because the structure</span><br><span class="hljs-comment"> * is reachable via others, though, we need to preserve the original contents</span><br><span class="hljs-comment"> * for the kabi checker.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shift, <span class="hljs-comment">/* Bits remaining in each slot */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> offset<span class="hljs-comment">/* Slot offset in parent */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>count;<br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-comment">/* Used when ascending tree */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">parent</span>;</span><br><span class="hljs-comment">/* For tree user */</span><br><span class="hljs-type">void</span> *private_data;<br>&#125;;<br><span class="hljs-comment">/* Used when freeing node */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span><span class="hljs-title">rcu_head</span>;</span><br>&#125;;<br><span class="hljs-comment">/* For tree user */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">private_list</span>;</span><br><span class="hljs-type">void</span> __rcu*slots[RADIX_TREE_MAP_SIZE];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS];<br>&#125;;<br></code></pre></td></tr></table></figure><p>struct radix_tree_node结构代表radix tree的一个内部节点。</p><ul><li>shift：与当前内部节点在radix tree中所处的层级相关，最低一层的节点，shift为0，倒数第二层shift为6。 shift从低往高， 逐层递增6</li><li>offset：表示与当前内部节点相关联的父节点slot数组下标</li><li>count：表示当前节点包含的child节点的个数，child节点可以是内部节点也可以是叶子节点。</li><li>parent：指向parent 节点</li><li>tags：这里的tags是二维数组，在64bit系统中，这个数组的定义tag[3][1]相当于一维数组</li><li>slots：指针数组slot[64]， 每个元素指向一个下一级的radix_tree_node结构，或者是叶子节点</li></ul><h2 id="3-radix-tree的几种形态"><a href="#3-radix-tree的几种形态" class="headerlink" title="3.radix tree的几种形态"></a>3.radix tree的几种形态</h2><h3 id="形态1：空树"><a href="#形态1：空树" class="headerlink" title="形态1：空树"></a>形态1：空树</h3><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-5c589cf83d7cedaf904f868a70d180da_720w.webp" alt="img" style="zoom: 100%;"><h3 id="形态2：只有一个index为0的叶子结点"><a href="#形态2：只有一个index为0的叶子结点" class="headerlink" title="形态2：只有一个index为0的叶子结点"></a>形态2：只有一个index为0的叶子结点</h3><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-ba5eb6f207a226081887c7538385946f_720w.webp" alt="img" style="zoom:100%;"><h3 id="形态3：层高为1的情形"><a href="#形态3：层高为1的情形" class="headerlink" title="形态3：层高为1的情形"></a>形态3：层高为1的情形</h3><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-f6d4715694b6319c8c382409e9661b71_720w.webp" alt="img" style="zoom:100%;"><h3 id="形态4：层高为2的情形"><a href="#形态4：层高为2的情形" class="headerlink" title="形态4：层高为2的情形"></a>形态4：层高为2的情形</h3><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-2d55465cd47c99ae29ada718c9f71872_720w.webp" alt="img" style="zoom:100%;"><h3 id="形态5：层高为3的情形"><a href="#形态5：层高为3的情形" class="headerlink" title="形态5：层高为3的情形"></a>形态5：层高为3的情形</h3><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-ced652319751af276ab00cb7cb73fc2c_720w.webp" alt="img" style="zoom:100%;"><h2 id="4-节点内存管理"><a href="#4-节点内存管理" class="headerlink" title="4.节点内存管理"></a>4.节点内存管理</h2><h3 id="节点内存的分配"><a href="#节点内存的分配" class="headerlink" title="节点内存的分配"></a>节点内存的分配</h3><p><strong>radix_tree_node_alloc</strong></p><p>分配struct radix_tree_node内存时，radix_tree_node_alloc优先选择从当前cpu上的内存池分配内存。如果内存池没有内存了，这时才会直接调用kmem_cache_alloc函数从radix_tree_node_cachep slab分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This assumes that the caller has performed appropriate preallocation, and</span><br><span class="hljs-comment"> * that the caller has pinned this thread of control to the current CPU.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> radix_tree_node *<br><span class="hljs-title function_">radix_tree_node_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> radix_tree_root *root)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">ret</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">gfp_t</span> gfp_mask = root_gfp_mask(root);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Preload code isn&#x27;t irq safe and it doesn&#x27;t make sense to use</span><br><span class="hljs-comment"> * preloading during an interrupt anyway as all the allocations have</span><br><span class="hljs-comment"> * to be atomic. So just do normal allocation when in interrupt.</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">/* 优先从percpu的内存池分配内存 */</span><br><span class="hljs-keyword">if</span> (!(gfp_mask &amp; __GFP_WAIT) &amp;&amp; !in_interrupt()) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_preload</span> *<span class="hljs-title">rtp</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Provided the caller has preloaded here, we will always</span><br><span class="hljs-comment"> * succeed in getting a node here (and never reach</span><br><span class="hljs-comment"> * kmem_cache_alloc)</span><br><span class="hljs-comment"> */</span><br>rtp = this_cpu_ptr(&amp;radix_tree_preloads);<br><span class="hljs-keyword">if</span> (rtp-&gt;nr) &#123;<br>ret = rtp-&gt;nodes;<br>rtp-&gt;nodes = ret-&gt;private_data;<br>ret-&gt;private_data = <span class="hljs-literal">NULL</span>;<br>rtp-&gt;nr--;<br>&#125;<br>&#125;<br>        <span class="hljs-comment">/*percpu的内存池不能满足要求时，才直接从radix_tree_node_cachep这个slab申请内存 */</span><br><span class="hljs-keyword">if</span> (ret == <span class="hljs-literal">NULL</span>)<br>ret = kmem_cache_alloc(radix_tree_node_cachep, gfp_mask);<br><br>BUG_ON(radix_tree_is_internal_node(ret));<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>radix_tree_preload_end</strong></p><p>分配struct radix_tree_node内存时，radix_tree_node_alloc优先选择从当前cpu上的内存池分配内存。如果内存池没有内存了，这时才会直接调用kmem_cache_alloc函数从radix_tree_node_cachep slab分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This assumes that the caller has performed appropriate preallocation, and</span><br><span class="hljs-comment"> * that the caller has pinned this thread of control to the current CPU.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> radix_tree_node *<br><span class="hljs-title function_">radix_tree_node_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> radix_tree_root *root)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">ret</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">gfp_t</span> gfp_mask = root_gfp_mask(root);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Preload code isn&#x27;t irq safe and it doesn&#x27;t make sense to use</span><br><span class="hljs-comment"> * preloading during an interrupt anyway as all the allocations have</span><br><span class="hljs-comment"> * to be atomic. So just do normal allocation when in interrupt.</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">/* 优先从percpu的内存池分配内存 */</span><br><span class="hljs-keyword">if</span> (!(gfp_mask &amp; __GFP_WAIT) &amp;&amp; !in_interrupt()) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_preload</span> *<span class="hljs-title">rtp</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Provided the caller has preloaded here, we will always</span><br><span class="hljs-comment"> * succeed in getting a node here (and never reach</span><br><span class="hljs-comment"> * kmem_cache_alloc)</span><br><span class="hljs-comment"> */</span><br>rtp = this_cpu_ptr(&amp;radix_tree_preloads);<br><span class="hljs-keyword">if</span> (rtp-&gt;nr) &#123;<br>ret = rtp-&gt;nodes;<br>rtp-&gt;nodes = ret-&gt;private_data;<br>ret-&gt;private_data = <span class="hljs-literal">NULL</span>;<br>rtp-&gt;nr--;<br>&#125;<br>&#125;<br>        <span class="hljs-comment">/*percpu的内存池不能满足要求时，才直接从radix_tree_node_cachep这个slab申请内存 */</span><br><span class="hljs-keyword">if</span> (ret == <span class="hljs-literal">NULL</span>)<br>ret = kmem_cache_alloc(radix_tree_node_cachep, gfp_mask);<br><br>BUG_ON(radix_tree_is_internal_node(ret));<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>radix_tree_load_root</strong></p><p>radix tree的实现文件中很多重要的函数， 比如__radix_tree_lookup、__radix_tree_create等函数，其开始部分都要调用radix_tree_load_root。那么radix_tree_load_root这个函数是干什么呢？ 在分析__radix_tree_lookup之前，我们有必要把radix_tree_load_root函数先看一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-title function_">radix_tree_load_root</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> radix_tree_root *root,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> radix_tree_node **nodep, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *maxindex)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">node</span> =</span> rcu_dereference_raw(root-&gt;rnode);<br><br>*nodep = node;<br><br><span class="hljs-keyword">if</span> (likely(radix_tree_is_internal_node(node))) &#123;<br>node = entry_to_node(node);<br>*maxindex = node_maxindex(node);<br><span class="hljs-keyword">return</span> node-&gt;shift + RADIX_TREE_MAP_SHIFT;<br>&#125;<br><br>*maxindex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数radix_tree_load_root的参数：</p><ul><li>root：标识radix tree的root</li><li>nodep：输出参数，用来返回radix tree的第一个节点的地址</li><li>maxindex：输出参数，用来返回radix tree的当前能容纳的最大的inde值</li></ul><p>函数返回值：</p><ul><li>如果radix tree目前是空树（形态1）或者只有一个index为0的叶子结点，此时返回0</li><li>其他形态，返回值等于第一个节点的shift值+6.</li></ul><p>函数radix_tree_load_root，先取得struct radix_tree_root的rnode指针。因为一棵radix tree有且仅有一个struct radix_tree_root结构，而rnode指向radix tree 的第一个节点，通过它才能遍历整棵radix tree。</p><p>从前文radix的形态介绍中，我们知道rnode可以等于NULL， 此时表示一棵空树；rnode也可以直接指向一个叶子节点； rnode大多数情况是指向一个内部节点。rnode&#x3D;&#x3D;NULL很好判断，那么rnode不等于NULL时，如何判断其指向一个内部节点还是叶子节点呢？目前程序利用指针的最后两个bit来进行判断。</p><p>radix_tree_is_internal_node用来判断节点是否为内部节点，返回值为true表示ptr指向的节点是内部节点，false表示ptr为NULL值或者是叶子节点。这里假定叶子节点的内存地址至少是按照4字节对齐的，也就是说，bit0~1需要为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RADIX_TREE_ENTRY_MASK3UL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RADIX_TREE_INTERNAL_NODE1UL</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">radix_tree_is_internal_node</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span><br>&#123;<br><span class="hljs-keyword">return</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ptr &amp; RADIX_TREE_ENTRY_MASK) ==<br>RADIX_TREE_INTERNAL_NODE;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数entry_to_node用来实现将ptr指针的bit0~1掩掉，也就是将ptr转换为radix_tree_node结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> radix_tree_node *<span class="hljs-title function_">entry_to_node</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ptr &amp; ~RADIX_TREE_INTERNAL_NODE);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="节点查找过程"><a href="#节点查找过程" class="headerlink" title="节点查找过程"></a>节点查找过程</h3><p><strong>radix_tree_descend</strong></p><p>要查找index对应的ptr item，需要从第一个节点开始逐层下降，最终寻找到radix tree的叶子节点。已知需要经由某一层级的parent节点，该函数计算经由parent节点的哪一个slot才能继续往下进展一层。</p><p>函数radix_tree_descend的参数：</p><ul><li>parent：输入参数，标识radix tree的一个中间节点，要查找index对应的ptr item，需要经由此节点</li><li>nodep：输出参数，要查找index对应的ptr item，需要经由parent节点的下一级节点</li><li>index：输入参数，待查找节点的index</li></ul><p>函数返回值：经由当前parent节点的slot</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">radix_tree_descend</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> radix_tree_node *parent,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> radix_tree_node **nodep, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> index)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset = (index &gt;&gt; parent-&gt;shift) &amp; RADIX_TREE_MAP_MASK;<br><span class="hljs-type">void</span> **entry = rcu_dereference_raw(parent-&gt;slots[offset]);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_RADIX_TREE_MULTIORDER</span><br><span class="hljs-keyword">if</span> (radix_tree_is_internal_node(entry)) &#123;<br><span class="hljs-keyword">if</span> (is_sibling_entry(parent, entry)) &#123;<br><span class="hljs-type">void</span> **sibentry = (<span class="hljs-type">void</span> **) entry_to_node(entry);<br>offset = get_slot_offset(parent, sibentry);<br>entry = rcu_dereference_raw(*sibentry);<br>&#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>*nodep = (<span class="hljs-type">void</span> *)entry;<br><span class="hljs-keyword">return</span> offset;<br>&#125;<br></code></pre></td></tr></table></figure><p>offset &#x3D; (index &gt;&gt; parent-&gt;shift) &amp; RADIX_TREE_MAP_MASK； 这句话计算index在当前层级的6bit 索引， 也就是在parent节点中的slot编号。parent-&gt;slots[offset]指向下一级中间节点或者叶子节点。</p><p><strong>__radix_tree_lookup</strong></p><p>函数__radix_tree_lookup查找radix tree中与index对应的ptr item。</p><p>函数__radix_tree_lookup的参数：</p><ul><li>root：输入参数，标识radix tree的root</li><li>index：输入参数，待查找节点的index</li><li>nodep：输出参数，用来返回index对应的ptr item的parent节点</li><li>slotp：输出参数，用来返回index对应的ptr item关联的slot的地址</li></ul><p>函数返回值：index对应的ptr item</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *__radix_tree_lookup-lookup an item in a radix tree</span><br><span class="hljs-comment"> *@root:radix tree root</span><br><span class="hljs-comment"> *@index:index key</span><br><span class="hljs-comment"> *@nodep:returns node</span><br><span class="hljs-comment"> *@slotp:returns slot</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *Lookup and return the item at position @index in the radix</span><br><span class="hljs-comment"> *tree @root.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *Until there is more than one item in the tree, no nodes are</span><br><span class="hljs-comment"> *allocated and @root-&gt;rnode is used as a direct slot instead of</span><br><span class="hljs-comment"> *pointing to a node, in which case *@nodep will be NULL.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> *__radix_tree_lookup(<span class="hljs-keyword">struct</span> radix_tree_root *root, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> index,<br>  <span class="hljs-keyword">struct</span> radix_tree_node **nodep, <span class="hljs-type">void</span> ***slotp)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">node</span>, *<span class="hljs-title">parent</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> maxindex;<br><span class="hljs-type">void</span> **slot;<br><br> restart:<br>parent = <span class="hljs-literal">NULL</span>;<br>slot = (<span class="hljs-type">void</span> **)&amp;root-&gt;rnode;<br>radix_tree_load_root(root, &amp;node, &amp;maxindex);<br><span class="hljs-keyword">if</span> (index &gt; maxindex)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">while</span> (radix_tree_is_internal_node(node)) &#123;<br><span class="hljs-type">unsigned</span> offset;<br><br><span class="hljs-keyword">if</span> (node == RADIX_TREE_RETRY)<br><span class="hljs-keyword">goto</span> restart;<br>parent = entry_to_node(node);<br>offset = radix_tree_descend(parent, &amp;node, index);<br>slot = parent-&gt;slots + offset;<br>&#125;<br><br><span class="hljs-keyword">if</span> (nodep)<br>*nodep = parent;<br><span class="hljs-keyword">if</span> (slotp)<br>*slotp = slot;<br><br><span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="节点插入"><a href="#节点插入" class="headerlink" title="节点插入"></a>节点插入</h3><p><strong>radix_tree_extend</strong></p><p>函数radix_tree_extend实现radix tree纵向的生长，也就是让radix tree的高度值变大。因为每升高一层，radix tree的第一个节点的shift值都会递增6，从而使得radix tree能容纳的最大index扩大64倍，最终实现index &lt;&#x3D;( (1 &lt;&lt; shift) - 1)。</p><p>函数radix_tree_extend的参数：</p><ul><li>root：输入参数，标识radix tree的root</li><li>index：输入参数，待查找节点的index。在radix tree中要有足够的高度能够容纳该index</li><li>shift：与当前radixtree第一个节点的shift值相关联，这个值决定了树的高度。如果radix tree为空树（形态1）或者radix tree只有一个index为0的叶子节点(形态2)，则shift &#x3D; 0；其他的情况，shift &#x3D; 第一个内部节点的shift值+ 6</li></ul><p>radix tree最多能够容纳的index的最大值，取决于radix tree第一个内部节点的shift值。不同的shift值，能够覆盖的index最大值如下表：</p><table><thead><tr><th>shift</th><th>index的最大值</th></tr></thead><tbody><tr><td>0</td><td>2^6 - 1</td></tr><tr><td>6</td><td>2^12 - 1</td></tr><tr><td>12</td><td>2^18 - 1</td></tr><tr><td>…</td><td>…</td></tr><tr><td>6*n</td><td>2^(shift+6) - 1</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *Extend a radix tree so it can store key @index.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">radix_tree_extend</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> radix_tree_root *root,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> index, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shift)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">slot</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> maxshift;<br><span class="hljs-type">int</span> tag;<br><br><span class="hljs-comment">/* Figure out what the shift should be.  */</span><br>        <span class="hljs-comment">/* 该while循环用来计算，radix tree 需要生长到的高度 */</span><br>maxshift = shift;<br><span class="hljs-keyword">while</span> (index &gt; shift_maxindex(maxshift))<br>maxshift += RADIX_TREE_MAP_SHIFT;<br><br>       <span class="hljs-comment">/* 对于空树，跳过下面的树纵向生长的过程 */</span><br>slot = root-&gt;rnode;<br><span class="hljs-keyword">if</span> (!slot)<br><span class="hljs-keyword">goto</span> out;<br><br>        <span class="hljs-comment">/* 下面是树纵向生长的过程</span><br><span class="hljs-comment">           程序走到这里， 表示root-&gt;rnode已经存在 */</span><br><span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">/* 分配一个node, 该新分配的node将关联到root-&gt;rnode</span><br><span class="hljs-comment">  也就是说这个新分配的node将成为根节点，原先的根节点反而成为新分</span><br><span class="hljs-comment">                  配节点的子节点 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">node</span> =</span> radix_tree_node_alloc(root);<br><br><span class="hljs-keyword">if</span> (!node)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br><span class="hljs-comment">/* Propagate the aggregated tag info into the new root */</span><br><span class="hljs-keyword">for</span> (tag = <span class="hljs-number">0</span>; tag &lt; RADIX_TREE_MAX_TAGS; tag++) &#123;<br><span class="hljs-keyword">if</span> (root_tag_get(root, tag))<br>tag_set(node, tag, <span class="hljs-number">0</span>);<br>&#125;<br><br>BUG_ON(shift &gt; BITS_PER_LONG);<br>node-&gt;shift = shift;<br>node-&gt;offset = <span class="hljs-number">0</span>;<br>node-&gt;count = <span class="hljs-number">1</span>;<br>node-&gt;parent = <span class="hljs-literal">NULL</span>;<br><br>                <span class="hljs-comment">/* slot是之前的根节点， 现在变成了node的子节点 */</span><br><span class="hljs-keyword">if</span> (radix_tree_is_internal_node(slot))<br>entry_to_node(slot)-&gt;parent = node;<br>                <span class="hljs-comment">/* 原先的根节点关联到新分配节点的slot[0]上 */</span><br>node-&gt;slots[<span class="hljs-number">0</span>] = slot;<br>slot = node_to_entry(node);<br>rcu_assign_pointer(root-&gt;rnode, slot);<br>shift += RADIX_TREE_MAP_SHIFT;<br>&#125; <span class="hljs-keyword">while</span> (shift &lt;= maxshift);<br>out:<br>        <span class="hljs-comment">/* 这里最后返回的时候，maxshift还要在加6，因为__radix_tree_create</span><br><span class="hljs-comment">          函数在while循环的判断条件是，当order=0，且shift=0， 循环就结束了 */</span><br><span class="hljs-keyword">return</span> maxshift + RADIX_TREE_MAP_SHIFT;<br>&#125;<br></code></pre></td></tr></table></figure><p>考虑场景1：radix_tree_extend函数执行前，只有一个叶子节点</p><ul><li>调用radix_tree_extend函数时，index &#x3D; 60，shift &#x3D; 0</li><li>maxshift &#x3D; 0，index &#x3D; 60，shift &#x3D;0，while (index &gt; shift_maxindex(maxshift))条件不能满足，所以maxshift 不需要递增了</li><li>root-&gt;rnode 不等于NULL，slot &#x3D; root-&gt;rnode。开始执行do{}while循环,</li><li>分配一个内部节点node(图中A节点)，node-&gt;shift &#x3D; 0, node-&gt;count &#x3D; 1，node-&gt;slot[0]&#x3D;item0， root-&gt;rnode &#x3D; node</li><li>返回值是（0 + RADIX_TREE_MAP_SHIFT）&#x3D; 6</li></ul><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-979fe6a7d6d0381c1fa395bec719ad4e_720w.webp" alt="img" style="zoom:80%;"><p>考虑场景2：radix_tree_extend函数执行前，已经有一个内部节点A</p><ul><li>调用radix_tree_extend函数时，index &#x3D; 64，shift &#x3D; 6</li><li>maxshift &#x3D; 6，index &#x3D; 64, shift &#x3D; 6, while(index &gt; shift_maxindex(maxshift))条件不能满足，所以maxshift 不需要递增了</li><li>root-&gt;rnode 不等于NULL，slot &#x3D; root-&gt;rnode， 即slot指向A节点。执行do{}while循环</li><li>分配一个内部节点node (图中B节点)，node-&gt;shift &#x3D; 6, node-&gt;count &#x3D; 1, node-&gt;slot[0]&#x3D;item0， root-&gt;rnode &#x3D; node； A的父节点指向B；</li><li>返回值是（maxshift + RADIX_TREE_MAP_SHIFT）&#x3D; 12</li></ul><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-44a3bd4416f1139bfd6c04f0160f3871_720w.webp" alt="img" style="zoom:80%;"><p><strong>__radix_tree_create</strong></p><p>函数__radix_tree_create在保持现有高度的基础上，在查找index的路径上添加中间节点。其实这里所说的保持现有高度并不准确，比如对于一个空树，在查找index的路径上添加中间节点的过程中，实现了树高度的生长。</p><p>函数radix_tree_extend的参数：</p><ul><li>root：输入参数，标识radix tree的root</li><li>index：输入参数，待查找节点的index</li><li>order， 这是在CONFIG_RADIX_TREE_MULTIORDER使能时才使用的参数，正常情况下order &#x3D; 0</li><li>shift：与当前radixtree第一个节点的shift值相关联，这个值决定了树的高度。如果radix tree为空树（形态1）或者radix tree只有一个index为0的叶子节点(形态2)，则shift &#x3D; 0；其他的情况，shift &#x3D; 第一个内部节点的shift值+ 6</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"> *__radix_tree_create-create a slot in a radix tree<br> *@root:radix tree root<br> *@index:index key<br> *@order:index occupies <span class="hljs-number">2</span>^order aligned slots<br> *@nodep:returns node<br> *@slotp:returns slot<br> *<br> *Create, <span class="hljs-keyword">if</span> necessary, and <span class="hljs-keyword">return</span> the node and slot <span class="hljs-keyword">for</span> an item<br> *at position @index in the radix tree @root.<br> *<br> *Until there is more than one item in the tree, no nodes are<br> *allocated and @root-&gt;rnode is used as a direct slot instead of<br> *pointing to a node, in which <span class="hljs-keyword">case</span> *@nodep will be <span class="hljs-literal">NULL</span>.<br> *<br> *Returns -ENOMEM, or <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> success.<br> */<br><span class="hljs-type">int</span> __radix_tree_create(<span class="hljs-keyword">struct</span> radix_tree_root *root, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> index,<br><span class="hljs-type">unsigned</span> order, <span class="hljs-keyword">struct</span> radix_tree_node **nodep,<br><span class="hljs-type">void</span> ***slotp)<br>&#123;<br><span class="hljs-keyword">struct</span> radix_tree_node *node = <span class="hljs-literal">NULL</span>, *child;<br><span class="hljs-type">void</span> **slot = (<span class="hljs-type">void</span> **)&amp;root-&gt;rnode;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> maxindex;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shift, offset = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> max = index | ((<span class="hljs-number">1UL</span> &lt;&lt; order) - <span class="hljs-number">1</span>);<br><br>       <span class="hljs-comment">/* radix_tree_load_root函数获取root-&gt;rnode,  获取当前root-&gt;rnode所能覆盖的最大的</span><br><span class="hljs-comment">          index值</span><br><span class="hljs-comment">          对于返回值shift：如果radix tree为空树(形态1)或者radix tree只有一个index为0的</span><br><span class="hljs-comment">          叶子节点(形态2),则shift为0；</span><br><span class="hljs-comment">          其他的情况，shift为radix tree第一个内部节点的shift值+6  */</span><br>shift = radix_tree_load_root(root, &amp;child, &amp;maxindex);<br><br><span class="hljs-comment">/* Make sure the tree is high enough.  */</span><br>        <span class="hljs-comment">/* 如果要查找的index值比当前node所能覆盖的最大index值还要大，这时需要实现radix </span><br><span class="hljs-comment">           tree高度的生长, 这项任务由radix_tree_extend函数完成</span><br><span class="hljs-comment">           radix_tree_extend函数返回时，我们期望radix tree 已经有足够的高度能够容纳</span><br><span class="hljs-comment">           输入参数index。但是有一种例外，就是当root-&gt;rnode为NULL时，树的高度还不能够</span><br><span class="hljs-comment">           容纳输入参数index */</span><br><span class="hljs-keyword">if</span> (max &gt; maxindex) &#123;<br><span class="hljs-type">int</span> error = radix_tree_extend(root, max, shift);<br><span class="hljs-keyword">if</span> (error &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> error;<br>shift = error;<br>child = root-&gt;rnode;<br><span class="hljs-keyword">if</span> (order == shift)<br>shift += RADIX_TREE_MAP_SHIFT;<br>&#125;<br><br><span class="hljs-keyword">while</span> (shift &gt; order) &#123;<br>shift -= RADIX_TREE_MAP_SHIFT;<br>                <span class="hljs-comment">/* 如果当前节点为NULL，表示到达与index对应的item路径上中间节点缺失，</span><br><span class="hljs-comment">                   这时需要把中间节点补上 */</span><br><span class="hljs-keyword">if</span> (child == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-comment">/* Have to add a child node.  */</span><br>child = radix_tree_node_alloc(root);<br><span class="hljs-keyword">if</span> (!child)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>child-&gt;shift = shift;<br>child-&gt;offset = offset;<br>child-&gt;parent = node;<br>rcu_assign_pointer(*slot, node_to_entry(child));<br><span class="hljs-keyword">if</span> (node)<br>node-&gt;count++;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!radix_tree_is_internal_node(child)) <span class="hljs-comment">/* 到达叶子节点，停止 */</span><br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-comment">/* Go a level down */</span><br>                <span class="hljs-comment">/* 往树叶方向下降一级，这里调用radix_tree_descend找到下一级内部节点 */</span><br>node = entry_to_node(child);<br>offset = radix_tree_descend(node, &amp;child, index);<br>slot = &amp;node-&gt;slots[offset];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_RADIX_TREE_MULTIORDER</span><br><span class="hljs-comment">/* Insert pointers to the canonical entry */</span><br><span class="hljs-keyword">if</span> (order &gt; shift) &#123;<br><span class="hljs-type">unsigned</span> i, n = <span class="hljs-number">1</span> &lt;&lt; (order - shift);<br>offset = offset &amp; ~(n - <span class="hljs-number">1</span>);<br>slot = &amp;node-&gt;slots[offset];<br>child = node_to_entry(slot);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">if</span> (slot[i])<br><span class="hljs-keyword">return</span> -EEXIST;<br>&#125;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>rcu_assign_pointer(slot[i], child);<br>node-&gt;count++;<br>&#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>         <span class="hljs-comment">/* 函数返回时，要填写item所在的父内部节点，以及与item对应slot的地址 */</span><br><span class="hljs-keyword">if</span> (nodep)<br>*nodep = node;<br><span class="hljs-keyword">if</span> (slotp)<br>*slotp = slot;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>考虑场景1：__radix_tree_create函数执行前，radix tree 是一个空树，如下左图； 参数index &#x3D; 63， order &#x3D; 0</p><ul><li>调用radix_tree_load_root函数前，max &#x3D; 63</li><li>调用radix_tree_load_root函数后，child &#x3D; NULL，maxindex &#x3D; 0, shift &#x3D; 0</li><li>max &gt; maxindex 条件满足，调用radix_tree_extend函数; 由于root-&gt;rnode &#x3D;&#x3D;NULL, radix_tree_extend函数里面do while{}循环被跳过，函数返回值是6</li><li>回到__radix_tree_create函数，shift &#x3D;6，child&#x3D;NULL， 开始执行while循环</li><li>shift递减后，shift&#x3D; 0，由于child&#x3D;&#x3D;NULL，分配一个内部节点child（图中A节点），child-&gt;shift &#x3D; 0, child-&gt;offset &#x3D; 0， child-&gt;parent &#x3D; NULL。root-&gt;rnode &#x3D; child</li><li>往树叶方向下降一级，调用radix_tree_descend后,offset&#x3D;63，child &#x3D;NULL, slot &#x3D; &amp;root-&gt;rnode-&gt;slots[63]</li><li>nodep&#x3D;root-&gt;rnode,即图中A节点；slotp&#x3D;&amp;root-&gt;rnode-&gt;slots[63]，即A节点的slots[63]的地址</li></ul><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-003fd8d09948205b03761f50c3b73fed_720w.webp" alt="img" style="zoom:80%;"><p>考虑场景2：__radix_tree_create函数执行前，radix tree 已经有两层内部节点，如下左图。 参数index &#x3D; 64， order &#x3D; 0</p><ul><li>调用radix_tree_load_root函数前，max &#x3D; 64</li><li>调用radix_tree_load_root函数后，child &#x3D;B节点，maxindex &#x3D; 64*64-1, shift &#x3D; 12</li><li>max &gt; maxindex 条件不满足</li><li>开始执行while循环， shift&#x3D;12</li><li>shift递减后，shift&#x3D; 6，由于child！&#x3D;NULL，需要往树叶方向下降一级。node &#x3D; B，调用radix_tree_descend后, offset&#x3D;1，child &#x3D;NULL, slot &#x3D; &amp;root-&gt;rnode-&gt;slots[1]</li><li>再次循环，shift递减后，shift&#x3D; 0， 由于child&#x3D;&#x3D;NULL， 分配内部节点C, C-&gt;shift &#x3D; 0, C-&gt;offset&#x3D; 1, C-&gt;parent &#x3D; B, B-&gt;slot[1] &#x3D; C</li><li>往树叶方向下降一级。node &#x3D; C，调用radix_tree_descend后, offset&#x3D;0，child &#x3D;NULL, slot &#x3D; &amp;C-&gt;-&gt;slots[0]</li></ul><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-31c0362e3f9dac199b884733f6086d42_r.jpg" alt="img" style="zoom:80%;"><p><strong>__radix_tree_insert</strong></p><p>函数__radix_tree_insert的参数：</p><ul><li>root：输入参数，标识radix tree的root</li><li>index：输入参数，待查找节点的index</li><li>order， 这是在CONFIG_RADIX_TREE_MULTIORDER使能时才使用的参数，正常情况下order &#x3D; 0</li><li>item：与index关联的指针，需要插入到radix tree的合适位置</li></ul><p>有了前文的各种铺垫，__radix_tree_insert函数就很简单了，__radix_tree_create函数之后，node指向了待插入指针item的父节点，slot是item插入位置的slot的地址。调用rcu_assign_pointer(<em>slot, item)操作相当于</em>slot &#x3D; item。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *__radix_tree_insert    -    insert into a radix tree</span><br><span class="hljs-comment"> *@root:radix tree root</span><br><span class="hljs-comment"> *@index:index key</span><br><span class="hljs-comment"> *@order:key covers the 2^order indices around index</span><br><span class="hljs-comment"> *@item:item to insert</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *Insert an item into the radix tree at position @index.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> __radix_tree_insert(<span class="hljs-keyword">struct</span> radix_tree_root *root, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> index,<br><span class="hljs-type">unsigned</span> order, <span class="hljs-type">void</span> *item)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">node</span>;</span><br><span class="hljs-type">void</span> **slot;<br><span class="hljs-type">int</span> error;<br><br>BUG_ON(radix_tree_is_internal_node(item));<br><br>         <span class="hljs-comment">/* 调用__radix_tree_create函数，用来获取item插入的位置。函数返回后，slot变量保存着item插入位置的地址  */</span><br>error = __radix_tree_create(root, index, order, &amp;node, &amp;slot);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br><span class="hljs-keyword">if</span> (*slot != <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> -EEXIST;<br><br>         <span class="hljs-comment">/* 将item填写到待插入位置 */</span><br>rcu_assign_pointer(*slot, item);<br><br><span class="hljs-keyword">if</span> (node) &#123;<br><span class="hljs-type">unsigned</span> offset = get_slot_offset(node, slot);<br>node-&gt;count++;<span class="hljs-comment">/* node为item所关联的父节点， item插入后node的子节点个数递增 */</span><br>BUG_ON(tag_get(node, <span class="hljs-number">0</span>, offset));<br>BUG_ON(tag_get(node, <span class="hljs-number">1</span>, offset));<br>BUG_ON(tag_get(node, <span class="hljs-number">2</span>, offset));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>BUG_ON(root_tags_get(root));<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>EXPORT_SYMBOL(__radix_tree_insert);<br></code></pre></td></tr></table></figure><img src="/2023/11/20/Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BRadix-Tree/v2-818b4dcba36f5ef364e719b08840c665_r.jpg" alt="img" style="zoom:80%;"><ul><li>上左图是radix tree的初始形态：树高两层，最大能容纳的index为64*64-1。</li><li>调用__radix_tree_create函数， 函数参数index&#x3D;64， order&#x3D;0；index为64二进制表示为0000 0000-0100 0000，按照没6bit为一个簇来表示，则变成 000001-000000， 所以idnex64在radix tree在第一层中的offset是1， 第二层中的offset是0。 __radix_tree_create函数指向后，radix tree变成了上中图的形态，即在第二层添加了一个中间节点C，C关联到B节点的offset&#x3D;1的slot上。C节点的offset为0的slot位置是index 64要插入的位置。</li><li>将index 64 的item插入后，变成了上右图的形状。C节点的offset为0的slot位置上插入了item64。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统文件查找</title>
    <link href="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统文件查找"><a href="#f2fs文件系统文件查找" class="headerlink" title="f2fs文件系统文件查找"></a>f2fs文件系统文件查找</h1><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h2><ul><li>创建一个128M大小的镜像f2fs.img</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/f2fs$ <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=f2fs.img bs=4k count=32768<br></code></pre></td></tr></table></figure><ul><li>格式化镜像成f2fs文件系统</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/f2fs$ mkfs.f2fs -l f2fs f2fs.img <br></code></pre></td></tr></table></figure><ul><li>挂载到root_dir目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/f2fs$ sudo mount -t f2fs f2fs.img root_dir/<br></code></pre></td></tr></table></figure><ul><li>根目录下创建文件夹system，文件hello.txt（并写入内容amxixixi）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/f2fs/root_dir$ <span class="hljs-built_in">mkdir</span> system<br>amx@amxxxx:~/Desktop/f2fs/root_dir$ <br>amx@amxxxx:~/Desktop/f2fs/root_dir$ <span class="hljs-built_in">touch</span> hello.txt<br>amx@amxxxx:~/Desktop/f2fs/root_dir$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;amxixixi&quot;</span> &gt; hello.txt<br></code></pre></td></tr></table></figure><ul><li>在system目录下创建文件PublicVolume.cpp</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/f2fs/root_dir/system$ <span class="hljs-built_in">touch</span> PublicVolume.cpp<br></code></pre></td></tr></table></figure><ul><li>整体的结构如下所示：</li></ul><img src="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231114220202440.png" alt="image-20231114220202440" style="zoom:80%;"><h2 id="2-解析文件系统镜像"><a href="#2-解析文件系统镜像" class="headerlink" title="2.解析文件系统镜像"></a>2.解析文件系统镜像</h2><p>查看根目录的inode号：</p><ul><li><strong>法1：</strong>dump.f2fs -d 1 f2fs.img</li></ul><img src="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231114220531107.png" alt="image-20231114220531107" style="zoom: 67%;"><ul><li><strong>法2：</strong>查看f2fs_super_block结构体（root_ino位于0x460）</li></ul><img src="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231114221513867.png" alt="image-20231114221513867" style="zoom: 67%;"><h2 id="3-查找文件"><a href="#3-查找文件" class="headerlink" title="3.查找文件"></a>3.查找文件</h2><h3 id="3-1-查找根目录的node-block"><a href="#3-1-查找根目录的node-block" class="headerlink" title="3.1 查找根目录的node block"></a>3.1 查找根目录的node block</h3><p>我们通过nat查看一下根目录对应的blk addr，</p><ul><li><strong>dump.f2fs -n 0~-1 f2fs.img</strong>：把nat的映射关系dump下来</li></ul><img src="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231114222207479.png" alt="image-20231114222207479" style="zoom:67%;"><p>发现根目录ino&#x3D;3对应的blkaddr为4097，则真正的地址为4097 * 4096 &#x3D; 16,781,312 &#x3D; 0x1001000</p><img src="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231114222433646.png" alt="image-20231114222433646" style="zoom:67%;"><p>根节点的node block必然为f2fs_inode类型，对应的结构体为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_inode</span> &#123;</span><br>__le16 i_mode;<span class="hljs-comment">/* file mode */</span><br>__u8 i_advise;<span class="hljs-comment">/* file hints */</span><br>__u8 i_inline;<span class="hljs-comment">/* file inline flags */</span><br>__le32 i_uid;<span class="hljs-comment">/* user ID */</span><br>__le32 i_gid;<span class="hljs-comment">/* group ID */</span><br>__le32 i_links;<span class="hljs-comment">/* links count */</span><br>__le64 i_size;<span class="hljs-comment">/* file size in bytes */</span><br>__le64 i_blocks;<span class="hljs-comment">/* file size in blocks */</span><br>__le64 i_atime;<span class="hljs-comment">/* access time */</span><br>__le64 i_ctime;<span class="hljs-comment">/* change time */</span><br>__le64 i_mtime;<span class="hljs-comment">/* modification time */</span><br>__le32 i_atime_nsec;<span class="hljs-comment">/* access time in nano scale */</span><br>__le32 i_ctime_nsec;<span class="hljs-comment">/* change time in nano scale */</span><br>__le32 i_mtime_nsec;<span class="hljs-comment">/* modification time in nano scale */</span><br>__le32 i_generation;<span class="hljs-comment">/* file version (for NFS) */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__le32 i_current_depth;<span class="hljs-comment">/* only for directory depth */</span><br>__le16 i_gc_failures;<span class="hljs-comment">/*</span><br><span class="hljs-comment"> * # of gc failures on pinned file.</span><br><span class="hljs-comment"> * only for regular files.</span><br><span class="hljs-comment"> */</span><br>&#125;;<br>__le32 i_xattr_nid;<span class="hljs-comment">/* nid to save xattr */</span><br>__le32 i_flags;<span class="hljs-comment">/* file attributes */</span><br>__le32 i_pino;<span class="hljs-comment">/* parent inode number */</span><br>__le32 i_namelen;<span class="hljs-comment">/* file name length */</span><br>__u8 i_name[F2FS_NAME_LEN];<span class="hljs-comment">/* file name for SPOR */</span><br>__u8 i_dir_level;<span class="hljs-comment">/* dentry_level for large dir */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_extent</span> <span class="hljs-title">i_ext</span>;</span><span class="hljs-comment">/* caching a largest extent */</span><br><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__le16 i_extra_isize;<span class="hljs-comment">/* extra inode attribute size */</span><br>__le16 i_inline_xattr_size;<span class="hljs-comment">/* inline xattr size, unit: 4 bytes */</span><br>__le32 i_projid;<span class="hljs-comment">/* project id */</span><br>__le32 i_inode_checksum;<span class="hljs-comment">/* inode meta checksum */</span><br>__le64 i_crtime;<span class="hljs-comment">/* creation time */</span><br>__le32 i_crtime_nsec;<span class="hljs-comment">/* creation time in nano scale */</span><br>__le64 i_compr_blocks;<span class="hljs-comment">/* # of compressed blocks */</span><br>__u8 i_compress_algrithm;<span class="hljs-comment">/* compress algrithm */</span><br>__u8 i_log_cluster_size;<span class="hljs-comment">/* log of cluster size */</span><br>__le16 i_padding;<span class="hljs-comment">/* padding */</span><br>__le32 i_extra_end[<span class="hljs-number">0</span>];<span class="hljs-comment">/* for attribute size calculation */</span><br>&#125; __attribute__((packed));<br>__le32 i_addr[DEF_ADDRS_PER_INODE];<span class="hljs-comment">/* Pointers to data blocks */</span><br>&#125;;<br>__le32 i_nid[<span class="hljs-number">5</span>];<span class="hljs-comment">/* direct(2), indirect(2),</span><br><span class="hljs-comment">double_indirect(1) node id */</span><br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure><p>结构体中i_addr即为对应的data block的起始位置。</p><ul><li>i_addr[0]位于0x1001168位置，其值为0x1601</li><li>得到的有效信息为根目录只需要一个data block就可以存放根目录所有信息</li><li>唯一的一个data block起始位置为：0x1601 * 4096Byte &#x3D; 0x1601000</li></ul><img src="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231114223000472.png" alt="image-20231114223000472" style="zoom:80%;"><h3 id="3-2-根目录的data-block找到system文件夹"><a href="#3-2-根目录的data-block找到system文件夹" class="headerlink" title="3.2 根目录的data block找到system文件夹"></a>3.2 根目录的data block找到system文件夹</h3><p>我们知道这个data block里面存放的其实都是dentry，所以这个data block是文件夹对应的<strong>f2fs_dentry_block</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_dentry_block</span> &#123;</span><br><span class="hljs-comment">/* validity bitmap for directory entries in each block */</span><br>__u8 dentry_bitmap[SIZE_OF_DENTRY_BITMAP];<br>__u8 reserved[SIZE_OF_RESERVED];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_dir_entry</span> <span class="hljs-title">dentry</span>[<span class="hljs-title">NR_DENTRY_IN_BLOCK</span>];</span><br>__u8 filename[NR_DENTRY_IN_BLOCK][F2FS_SLOT_LEN];<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure><p>其中一个f2fs_dentry_block可以存放NR_DENTRY_IN_BLOCK（214）个目录项，如果超过需要扩展data block，且需要在前面的node block中通过i_addr[1]指明下一个data block的地址。</p><p>每一个目录项对应的结构体为<strong>f2fs_dir_entry</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_dir_entry</span> &#123;</span><br>__le32 hash_code;<span class="hljs-comment">/* hash code of file name */</span><br>__le32 ino;<span class="hljs-comment">/* inode number */</span><br>__le16 name_len;<span class="hljs-comment">/* lengh of file name */</span><br>__u8 file_type;<span class="hljs-comment">/* file type */</span><br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure><blockquote><p>结构体f2fs_dir_entry占用11个字节</p></blockquote><p>前面的目录项分别为<code>.</code> 和<code> ..</code>，system文件夹对应的结构体信息为</p><img src="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231114223646727.png" alt="image-20231114223646727" style="zoom:80%;"><p>可以分析出如下结果：</p><ul><li>hashcode为0x27e420bb</li><li>ino为0x04【可以自己通过ls -li查看，发现结果一致】</li><li>namelen为0x06【system总共6个字符，也就是6个字节，发现结果一致】</li><li>filetype为0x02</li></ul><h3 id="3-3-查找system目录的node-block"><a href="#3-3-查找system目录的node-block" class="headerlink" title="3.3 查找system目录的node block"></a>3.3 查找system目录的node block</h3><p>我们知道了system的inode为4，再去dump_nat查看一下，</p><img src="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231114222207479.png" alt="image-20231114222207479" style="zoom:67%;"><p>发现system目录ino&#x3D;4对应的blkaddr为4099，则真正的地址为4099 * 4096 &#x3D; 16,789,504 &#x3D; 0x1003000</p><p>system目录为f2fs_inode类型，其其实地址为0x1003000，对应结构体<strong>f2fs_inode</strong></p><img src="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231114225130883.png" alt="image-20231114225130883" style="zoom:67%;"><h4 id="3-3-1-system目录中内联目录"><a href="#3-3-1-system目录中内联目录" class="headerlink" title="3.3.1 system目录中内联目录"></a>3.3.1 system目录中内联目录</h4><p>可以发现f2fs_inode结构体的第3个字节为i_inline，其包含了inline flag，即内联标志位，我了解的有下面这几个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> F2FS_INLINE_XATTR0x01<span class="hljs-comment">/* file inline xattr flag */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> F2FS_INLINE_DATA0x02<span class="hljs-comment">/* file inline data flag */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> F2FS_INLINE_DENTRY0x04<span class="hljs-comment">/* file inline dentry flag */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> F2FS_DATA_EXIST0x08<span class="hljs-comment">/* file inline data exist flag */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> F2FS_INLINE_DOTS0x10<span class="hljs-comment">/* file having implicit dot dentries */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> F2FS_EXTRA_ATTR0x20<span class="hljs-comment">/* file having extra attribute */</span></span><br></code></pre></td></tr></table></figure><p>在本文案例中，system目录对应的Node block（f2fs_inode）中i_inline为</p><img src="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231114230809363.png" alt="image-20231114230809363" style="zoom:67%;"><p>其标志位为0x5，与<code>#define F2FS_INLINE_DENTRY0x04</code> 相与后为1，则其中包含了内联目录项</p><p>内联目录的处理为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">* i_addr[0]为保留的，真正的inline data addr为i_addr[1]【当然前提是i_inline没有F2FS_EXTRA_ATTR】<br>* 最终的inline dentry block addr为 &amp;i_addr[1] + <br>INLINE_DENTRY_BITMAP_SIZE(node_blk) +<br>INLINE_RESERVED_SIZE(node_blk)<br><br>/* <span class="hljs-keyword">for</span> inline <span class="hljs-built_in">dir</span> */<br><span class="hljs-comment">#define NR_INLINE_DENTRY(node)(MAX_INLINE_DATA(node) * BITS_PER_BYTE / \</span><br>((SIZE_OF_DIR_ENTRY + F2FS_SLOT_LEN) * \<br>BITS_PER_BYTE + <span class="hljs-number">1</span>))<br><span class="hljs-comment">#define INLINE_DENTRY_BITMAP_SIZE(node)((NR_INLINE_DENTRY(node) + \</span><br>BITS_PER_BYTE - 1) / BITS_PER_BYTE)<br><span class="hljs-comment">#define INLINE_RESERVED_SIZE(node)(MAX_INLINE_DATA(node) - \</span><br>((SIZE_OF_DIR_ENTRY + F2FS_SLOT_LEN) * \<br>NR_INLINE_DENTRY(node) + \<br>INLINE_DENTRY_BITMAP_SIZE(node)))<br></code></pre></td></tr></table></figure><h3 id="3-4-查找PublicVolume-cpp文件"><a href="#3-4-查找PublicVolume-cpp文件" class="headerlink" title="3.4 查找PublicVolume.cpp文件"></a>3.4 查找PublicVolume.cpp文件</h3><p>计算得：</p><ul><li>INLINE_DENTRY_BITMAP_SIZE(node_blk)&#x3D;23</li><li>INLINE_RESERVED_SIZE(node_blk)&#x3D;7</li><li>因此inline data block的起始位置为&amp;i_addr[1] + 30，即为0x100318a</li></ul><img src="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231115193022779.png" alt="image-20231115193022779" style="zoom:67%;"><p>前面2个f2fs_dir_entry结构体分别为.和..的。</p><p>而内联文件PublcVolume.cpp的起始地址为0x10031a0：</p><img src="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231114233113356.png" alt="image-20231114233113356" style="zoom:80%;"><p>可以分析出如下结果：</p><ul><li>hashcode为0xc9a6a599</li><li>ino为0x06【可以自己通过ls -li查看，发现结果一致】</li><li>namelen为0x06【PublicVolume.cpp总共16个字符，也就是16个字节，发现结果一致】</li><li>filetype为0x01【表示常规文件，发现结果一致】</li></ul><h2 id="4-代码流程"><a href="#4-代码流程" class="headerlink" title="4.代码流程"></a>4.代码流程</h2><p>我是在fsck.f2fs看到了这一块的代码，所以自己写了个Demo验证一下，才有了此文。代码流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"># 根目录开始: fsck_chk_node_blk(sbi, <span class="hljs-literal">NULL</span>, sbi-&gt;root_ino_num, F2FS_FT_DIR, TYPE_INODE, &amp;blk_cnt, <span class="hljs-literal">NULL</span>);<br># 找到根目录对应的Node block，文件夹对应f2fs_inode: 以fsck_chk_inode_blk(sbi, nid, ftype, node_blk, blk_cnt, &amp;ni, child);<br># 找到i_addr为对应的data block: fsck_chk_data_blk(sbi,IS_CASEFOLDED(&amp;node_blk-&gt;i),blkaddr,...)<br># 此data block为dentry block，处理目录项: __chk_dentries<br># 建立目录树，开始校验子文件【逐步递归，检验所有】: fsck_chk_node_blk(sbi,<span class="hljs-literal">NULL</span>, le32_to_cpu(dentry[i].ino), ftype, TYPE_INODE,...)<br></code></pre></td></tr></table></figure><p>node block为<strong>f2fs_inode</strong>类型时处理内联数据和内联文件夹为：</p><img src="/2023/11/14/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231115000055194.png" alt="image-20231115000055194" style="zoom:67%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>存储介质备忘</title>
    <link href="/2023/11/12/%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%A4%87%E5%BF%98/"/>
    <url>/2023/11/12/%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%A4%87%E5%BF%98/</url>
    
    <content type="html"><![CDATA[<h1 id="存储介质备忘"><a href="#存储介质备忘" class="headerlink" title="存储介质备忘"></a>存储介质备忘</h1><p><strong>闪存：</strong></p><ul><li><p>【视频】<a href="https://www.bilibili.com/video/BV1U94y1v7o5/?spm_id_from=333.337.search-card.all.click&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">手机存储数据都靠它！闪存到底说的是什么？</a></p></li><li><p>【博客】<a href="https://blog.51cto.com/u_15077549/4295050">存储设备Flash和MTD、SD、TF、MMC、eMMC、UFS</a></p></li></ul><p><strong>SD卡：</strong></p><ul><li>【视频】<a href="https://www.bilibili.com/video/BV1t14y1H71v/?spm_id_from=333.999.0.0&vd_source=f509314d3ae36120a07762a088f1a038">重新认识存储卡 — SD卡</a></li></ul><p><u>三星970EVO PLSU 2TB固态硬盘</u>【图片来源：硬件茶谈】</p><img src="/2023/11/12/%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%A4%87%E5%BF%98/image-20231220214636955.png" alt="image-20231220214636955" style="zoom:67%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓模拟器虚拟SD卡</title>
    <link href="/2023/11/09/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%99%9A%E6%8B%9FSD%E5%8D%A1/"/>
    <url>/2023/11/09/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%99%9A%E6%8B%9FSD%E5%8D%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓模拟器虚拟SD卡"><a href="#安卓模拟器虚拟SD卡" class="headerlink" title="安卓模拟器虚拟SD卡"></a>安卓模拟器虚拟SD卡</h1><blockquote><p>官方指导：<a href="https://developer.android.com/studio/command-line/mksdcard?hl=zh-cn">https://developer.android.com/studio/command-line/mksdcard?hl=zh-cn</a></p></blockquote><h2 id="1-找到Android-SDK"><a href="#1-找到Android-SDK" class="headerlink" title="1.找到Android SDK"></a>1.找到Android SDK</h2><p>有些时候真的忘记自己的Android SDK装在哪里了，我是通过Android Studio找到的！</p><img src="/2023/11/09/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%99%9A%E6%8B%9FSD%E5%8D%A1/image-20231109233418477.png" alt="image-20231109233418477" style="zoom: 60%;"><h2 id="2-创建SD卡镜像"><a href="#2-创建SD卡镜像" class="headerlink" title="2.创建SD卡镜像"></a>2.创建SD卡镜像</h2><p>找到刚刚的Android SDK目录，进入emulator子目录，开始创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\...\Android\Sdk\emulator&gt; mksdcard 1024M G:\CarSotrage\sdcard.img<br></code></pre></td></tr></table></figure><h2 id="3-启动模拟器"><a href="#3-启动模拟器" class="headerlink" title="3.启动模拟器"></a>3.启动模拟器</h2><p>不知道自己的模拟器叫啥，可以通过<code>emulator -list-avds</code>查看</p><img src="/2023/11/09/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%99%9A%E6%8B%9FSD%E5%8D%A1/image-20231109233802922.png" alt="image-20231109233802922" style="zoom:80%;"><p>启动模拟器</p><img src="/2023/11/09/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%99%9A%E6%8B%9FSD%E5%8D%A1/image-20231109233837265.png" alt="image-20231109233837265" style="zoom:80%;"><p>启动完成后，拉起通知栏，并且将SD卡作为便携设备即可！</p><h2 id="4-往模拟SD卡中推入文件"><a href="#4-往模拟SD卡中推入文件" class="headerlink" title="4.往模拟SD卡中推入文件"></a>4.往模拟SD卡中推入文件</h2><h3 id="4-0-看一下模拟的SD卡的卷标"><a href="#4-0-看一下模拟的SD卡的卷标" class="headerlink" title="4.0 看一下模拟的SD卡的卷标"></a>4.0 看一下模拟的SD卡的卷标</h3><p>adb shell进去<strong>cd &#x2F;storage</strong></p><img src="/2023/11/09/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%99%9A%E6%8B%9FSD%E5%8D%A1/image-20231109235716290.png" alt="image-20231109235716290" style="zoom:80%;"><h3 id="4-1-推入图片"><a href="#4-1-推入图片" class="headerlink" title="4.1 推入图片"></a>4.1 推入图片</h3><img src="/2023/11/09/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%99%9A%E6%8B%9FSD%E5%8D%A1/image-20231109234817733.png" alt="image-20231109234817733" style="zoom:80%;"><p>拉下通知栏，查看模拟SD卡</p><img src="/2023/11/09/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%99%9A%E6%8B%9FSD%E5%8D%A1/image-20231109234403637.png" alt="image-20231109234403637" style="zoom:80%;"><p>图片推入成功</p><img src="/2023/11/09/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%99%9A%E6%8B%9FSD%E5%8D%A1/image-20231109235011754.png" alt="image-20231109235011754" style="zoom:67%;"><h3 id="4-2-推入文件"><a href="#4-2-推入文件" class="headerlink" title="4.2 推入文件"></a>4.2 推入文件</h3><p>创建Document目录：</p><img src="/2023/11/09/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%99%9A%E6%8B%9FSD%E5%8D%A1/image-20231109235437422.png" alt="image-20231109235437422" style="zoom:80%;"><p>推入文件：</p><img src="/2023/11/09/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%99%9A%E6%8B%9FSD%E5%8D%A1/image-20231109235503904.png" alt="image-20231109235503904" style="zoom:80%;"><p>正常打开文件：</p><img src="/2023/11/09/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%99%9A%E6%8B%9FSD%E5%8D%A1/image-20231109235524949.png" alt="image-20231109235524949" style="zoom:80%;"><p>打开后正常阅读：</p><img src="/2023/11/09/%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%99%9A%E6%8B%9FSD%E5%8D%A1/image-20231109235543175.png" alt="image-20231109235543175" style="zoom:80%;"><blockquote><p>起始直接推到&#x2F;storage&#x2F;16FC-0C09也行，只不过现在安卓有分区存储的概念，就习惯性的放到了Documents下面</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vfat文件系统目录占用多个簇</title>
    <link href="/2023/11/07/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%8D%A0%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%B0%87/"/>
    <url>/2023/11/07/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%8D%A0%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%B0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="vfat文件系统目录占用多个簇"><a href="#vfat文件系统目录占用多个簇" class="headerlink" title="vfat文件系统目录占用多个簇"></a>vfat文件系统目录占用多个簇</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在读fsck_msdos代码的时候，这里很迷惑，<code>readDosDirSection</code>这个是用来建立目录树的，到底在什么样的情况下do while循环会读多个簇，然后将簇里面所有的目录项进行处理，今天探究一下！</p><img src="/2023/11/07/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%8D%A0%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%B0%87/image-20231107225831715.png" alt="image-20231107225831715" style="zoom:67%;"><h2 id="环境构造"><a href="#环境构造" class="headerlink" title="环境构造"></a>环境构造</h2><p><strong>1）创建128M的vfat.img</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/vfat$ <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=vfat.img bs=4k count=32768<br>32768+0 records <span class="hljs-keyword">in</span><br>32768+0 records out<br>134217728 bytes (134 MB, 128 MiB) copied, 0.367814 s, 365 MB/s<br></code></pre></td></tr></table></figure><p><strong>2）格式化为vfat格式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/vfat$ mkfs.vfat -F 32 vfat.img <br>mkfs.fat 4.1 (2017-01-24)<br></code></pre></td></tr></table></figure><p><strong>3）进行挂载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/vfat$ <span class="hljs-built_in">mkdir</span> root_dir<br>amx@amxxxx:~/Desktop/vfat$ sudo mount -t vfat vfat.img root_dir/<br></code></pre></td></tr></table></figure><p><strong>4）运行脚本，创建多个文件</strong></p><p>通过<strong>bootblock</strong>结构体可以读出 <strong>bpbSecPerClust</strong> 和 <strong>bpbBytesPerSec</strong></p><img src="/2023/11/07/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%8D%A0%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%B0%87/image-20231107231225501.png" alt="image-20231107231225501" style="zoom:80%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">iosize = boot-&gt;bpbSecPerClust * boot-&gt;bpbBytesPerSec;<br>entries = iosize / <span class="hljs-number">32</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 这里我的:</span><br><span class="hljs-comment">* boot-&gt;bpbSecPerClust = 1    boot-&gt;bpbBytesPerSec = 512</span><br><span class="hljs-comment">* 因此 entries = 512 / 32 = 16</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>所以我这里只要创建大于16个文件，编写脚本<code>touch_vfat.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>for i in &#123;1..20&#125;<br>do<br>    name=&#x27;hello&#x27;$i&#x27;.txt&#x27;<br>    sudo touch $name<br>done<br></code></pre></td></tr></table></figure><p>创建成功：</p><img src="/2023/11/07/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%8D%A0%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%B0%87/image-20231107230945625.png" alt="image-20231107230945625" style="zoom:80%;"><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="找到根目录"><a href="#找到根目录" class="headerlink" title="找到根目录"></a>找到根目录</h3><p>根目录开始地址 &#x3D; ((保留扇区数) + (每 FAT 扇区数) * (FAT 数)) * 扇区字节数<br>根目录开始地址 &#x3D; (0x20 + 0x07E1 * 0x02) * 512 &#x3D; <strong>0x1FC400</strong> Bytes</p><img src="/2023/11/07/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%8D%A0%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%B0%87/image-20231107234334629.png" alt="image-20231107234334629" style="zoom: 70%;"><p>可以看到system目录起始簇号的高16位（0x14<del>0x15）为00 00，起始簇号的低16位（0x1A</del>0x1B）为03 00，转换成小端模式后，起始簇号为0x03。</p><h3 id="找到system目录"><a href="#找到system目录" class="headerlink" title="找到system目录"></a>找到system目录</h3><p>前面我们发现system目录的起始目录号为03，那么system目录的起始地址为：</p><blockquote><p>文件地址 &#x3D; 根目录开始地址 + ((起始簇号 - 根目录簇号(Root Cluster Number)) * 每簇扇区数(Sectors Per Cluster) * 扇区字节数(Bytes Per Sector))</p></blockquote><p>文件地址 &#x3D; 0x1FC400 + (3 - 2) * 1 * 512 &#x3D; 0x1FC400  + 0x200 &#x3D; <strong>0x1FC600</strong> </p><img src="/2023/11/07/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%8D%A0%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%B0%87/image-20231109223907034.png" alt="image-20231109223907034" style="zoom:80%;"><p>我这里的一个簇为512字节，肯定容纳不下所有的子文件，因此肯定会在下一个簇里面，我们去FAT表看看system有没有形成簇链！</p><img src="/2023/11/07/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%8D%A0%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%B0%87/image-20231109224227324.png" alt="image-20231109224227324" style="zoom:80%;"><p>可以发现system目录形成了簇链 <strong>3 -&gt; 5 -&gt;7 -&gt; EOF</strong>，那么5号簇应该也存放的是system目录下的子文件，也就是hello(x).txt</p><p>5号簇的地址为 &#x3D;  0x1FC400 + (5 - 2) * 1 * 512 &#x3D; 0x1FC400  + 0x200 &#x3D; 0x1FCA00</p><img src="/2023/11/07/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%8D%A0%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%B0%87/image-20231109224516740.png" alt="image-20231109224516740" style="zoom:80%;"><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>一个目录项也会存在簇链，当一个目录下面的子目录或者子文件过多，一个簇放不下，那么就会形成簇链，此时我们可以从FAT表中看目录的簇链。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下格式化 FAT32 分区，只是一个 mkfs.vfat 就行了吗？</title>
    <link href="/2023/11/07/Linux-%E4%B8%8B%E6%A0%BC%E5%BC%8F%E5%8C%96-FAT32-%E5%88%86%E5%8C%BA%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA-mkfs-vfat-%E5%B0%B1%E8%A1%8C%E4%BA%86%E5%90%97%EF%BC%9F/"/>
    <url>/2023/11/07/Linux-%E4%B8%8B%E6%A0%BC%E5%BC%8F%E5%8C%96-FAT32-%E5%88%86%E5%8C%BA%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA-mkfs-vfat-%E5%B0%B1%E8%A1%8C%E4%BA%86%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-下格式化-FAT32-分区，只是一个-mkfs-vfat-就行了吗？"><a href="#Linux-下格式化-FAT32-分区，只是一个-mkfs-vfat-就行了吗？" class="headerlink" title="Linux 下格式化 FAT32 分区，只是一个 mkfs.vfat 就行了吗？"></a>Linux 下格式化 FAT32 分区，只是一个 mkfs.vfat 就行了吗？</h1><blockquote><p>版权声明：本文为CSDN博主「Icy_Ybk」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Icy_Ybk/article/details/88619890">https://blog.csdn.net/Icy_Ybk/article/details/88619890</a></p></blockquote><h4 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h4><p>首先不得不说的是，当年在我不了解如何格式化一个分区到 FAT32 类型时，我选择了百度，当时得到的答案是 <code>mkfs.vfat device</code>。虽然惊奇于为何如此简单，但却没做深究，后来学会了如何看 infopage、manpage，也没仔细研究这里面的问题。</p><p>直到现在，在种种偶然情况下，我恰好在研究制作启动盘中出现的问题，恰好在研究 windows bootsect.exe 原理，恰好用 qemu 模拟了不同的磁盘去在虚拟机里做实验，又恰好地注意到一个问题：我测试的是 FAT32，为什么有一部分盘，引导代码与其他的不一样？经过详细的分析，反推出了 bootsect.exe 的相关源码，这才知道，其中有一部分，是 FAT（准确说是 FAT16），而非 FAT32。</p><h4 id="真实答案"><a href="#真实答案" class="headerlink" title="真实答案"></a>真实答案</h4><p>经过查看了 <code>man mkfs.vfat</code>，我发现了其中有这么一个参数：</p><blockquote><p>-F FAT-SIZE<br>    Specifies the type of file allocation tables used (12, 16 or 32 bit). If nothing is<br>    specified, mkfs.fat will automatically select between 12, 16 and 32 bit, whatever fits<br>    better for the filesystem size.</p></blockquote><p>-F 参数指定 FAT 的类型，可选的值有 12 位、16 位以及 32 位。当未指定时，<code>mkfs.fat</code> 会自动选择其中最合适的。</p><p>所以，<code>mkfs.vfat device</code> 不能保证你格式化得到的分区一定是 FAT32，它会自动决定。真正有效的方案，应该是使用 <code>mkfs.vfat -F 32 device</code> 才可。<br>（注：由于 FAT32 的设定限制，<strong>不支持小于 32MB 的分区</strong>，否则会导致簇数达不到要求，在某些情况可能导致系统识别出错。）</p><h4 id="详细探究"><a href="#详细探究" class="headerlink" title="详细探究"></a>详细探究</h4><p>或许让 mkfs.vfat 自己决定最佳的情况并不理想，但为什么有些情况下，就是 FAT32，而有些情况却不行？</p><p>经过研究发现，在 dosfstools 源码的 mkfs.fat.c 文件中，有两个函数起到了关键作用：<code>establish_params</code> 和 <code>setup_tables</code>。</p><p>函数 <code>establish_params</code> 对各种参数，比如每个扇区的字节数、一个簇有多少个扇区等，进行了初始设定，设定的来源包括用户指定参数、分区大小等。由代码中看出来，在用户未通过 -F 参数指定类型，且分区的大小达到了 512MB 时，程序自动采用 FAT32 类型。</p><p>而在 <code>setup_tables</code> 中的决定分区类型部分，则是根据之前函数中设置的簇大小，以及分区的信息，分别计算出使用 FAT12、FAT16、FAT32 时簇数目是多少。判断得到的簇数是否满足要求，如果是，则进行之后的检查及决定。如果不是，在一个确定的簇大小范围内（用户指定或者自动判断），它会尝试增加簇大小，直到满足要求。最后，根据何种情况下能取得更多的簇数，选择是使用 FAT12 或者 FAT16。</p><p>可见，<code>mkfs.vfat</code> 除了判断分区大小达到 512MB 时才使用 FAT32 类型，小于这个值，则只在 FAT12 或 FAT16 之间选择，就连源码中都有这么一个注释：</p><blockquote><p>FAT32 is (not yet) choosen automatically</p></blockquote><p>就实际状况而言，我们的存储介质一般并不小，不大可能低于 512MB，或许不指定 -F 参数的答案并非错误，只是不严谨；而当我们进行一些研究时，或者恰好碰上小于 512MB 的存储介质时，问题才得以显现。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ext2文件系统学习路径</title>
    <link href="/2023/11/05/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/11/05/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<ol><li><a href="https://anmuxixixi.github.io/2023/11/05/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/">如何在ext2文件系统中查找自己的文件</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ext2文件系统学习笔记</title>
    <link href="/2023/11/05/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/11/05/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="ext2文件系统学习笔记"><a href="#ext2文件系统学习笔记" class="headerlink" title="ext2文件系统学习笔记"></a>ext2文件系统学习笔记</h1><blockquote><p>参考：<a href="https://www.bilibili.com/read/cv17345430/">https://www.bilibili.com/read/cv17345430/</a></p></blockquote><h2 id="1-准备文件系统镜像"><a href="#1-准备文件系统镜像" class="headerlink" title="1.准备文件系统镜像"></a>1.准备文件系统镜像</h2><p><strong>1）制作128K大小的镜像文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/ext2$ <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=ext2.img bs=1k count=128<br>128+0 records <span class="hljs-keyword">in</span><br>128+0 records out<br>131072 bytes (131 kB, 128 KiB) copied, 0.000203712 s, 643 MB/s<br></code></pre></td></tr></table></figure><p><strong>2）格式化为ext2文件系统格式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/ext2$ mkfs.ext2 ext2.img <br>mke2fs 1.44.5 (15-Dec-2018)<br>Discarding device blocks: <span class="hljs-keyword">done</span>                            <br>Creating filesystem with 128 1k blocks and 16 inodes<br><br>Allocating group tables: <span class="hljs-keyword">done</span>                            <br>Writing inode tables: <span class="hljs-keyword">done</span>                            <br>Writing superblocks and filesystem accounting information: <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><strong>3）查看文件系统信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/ext2$ dumpe2fs ext2.img <br>dumpe2fs 1.44.5 (15-Dec-2018)<br>Filesystem volume name:   &lt;none&gt;<br>Last mounted on:          &lt;not available&gt;<br>Filesystem UUID:          f3e761bb-a73f-405b-9753-ebb9c66bff9f<br>Filesystem magic number:  0xEF53<br>Filesystem revision <span class="hljs-comment">#:    1 (dynamic)</span><br>Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_file<br>Filesystem flags:         signed_directory_hash <br>Default mount options:    user_xattr acl<br>Filesystem state:         clean<br>Errors behavior:          Continue<br>Filesystem OS <span class="hljs-built_in">type</span>:       Linux<br>Inode count:              16<br>Block count:              128<br>Reserved block count:     6<br>Free blocks:              107<br>Free inodes:              5<br>First block:              1<br>Block size:               1024<br>Fragment size:            1024<br>Blocks per group:         8192<br>Fragments per group:      8192<br>Inodes per group:         16<br>Inode blocks per group:   2<br>Filesystem created:       Sun Nov  5 23:30:07 2023<br>Last mount time:          n/a<br>Last write time:          Sun Nov  5 23:30:07 2023<br>Mount count:              0<br>Maximum mount count:      -1<br>Last checked:             Sun Nov  5 23:30:07 2023<br>Check interval:           0 (&lt;none&gt;)<br>Reserved blocks uid:      0 (user root)<br>Reserved blocks gid:      0 (group root)<br>First inode:              11<br>Inode size:               128<br>Default directory <span class="hljs-built_in">hash</span>:   half_md4<br>Directory Hash Seed:      74e00af1-b33a-44a6-bc36-184f882b344b<br><br><br>Group 0: (Blocks 1-127)<br>  Primary superblock at 1, Group descriptors at 2-2<br>  Block bitmap at 3 (+2)<br>  Inode bitmap at 4 (+3)<br>  Inode table at 5-6 (+4)<br>  107 free blocks, 5 free inodes, 2 directories<br>  Free blocks: 21-127<br>  Free inodes: 12-16<br></code></pre></td></tr></table></figure><p><strong>4）挂载文件系统并创建文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建挂载点目录</span><br>amx@amxxxx:~/Desktop/ext2$ <span class="hljs-built_in">mkdir</span> rootdir<br><br><span class="hljs-comment"># 挂载</span><br>amx@amxxxx:~/Desktop/ext2$ sudo mount -t ext2 ext2.img rootdir/<br></code></pre></td></tr></table></figure><ul><li>下面我们来创建一个目录，目录下创建文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/ext2/rootdir/hello$ sudo bash -c <span class="hljs-string">&#x27;echo china &gt; amx.txt&#x27;</span><br>amx@amxxxx:~/Desktop/ext2/rootdir/hello$ <span class="hljs-built_in">cat</span> amx.txt <br>china<br></code></pre></td></tr></table></figure><ul><li>现在看一下他们的inode号</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/ext2/rootdir$ <span class="hljs-built_in">ls</span> -li<br>total 13<br>12 drwxr-xr-x 2 root root  1024 Nov  5 23:36 hello<br>11 drwx------ 2 root root 12288 Nov  5 23:30 lost+found<br><br>amx@amxxxx:~/Desktop/ext2/rootdir/hello$ <span class="hljs-built_in">ls</span> -li<br>total 1<br>13 -rw-r--r-- 1 root root 6 Nov  5 23:42 amx.txt<br></code></pre></td></tr></table></figure><blockquote><p>hello文件夹的inode号为12，amx.txt文件的inode号为13</p></blockquote><h2 id="2-解析文件系统镜像"><a href="#2-解析文件系统镜像" class="headerlink" title="2.解析文件系统镜像"></a>2.解析文件系统镜像</h2><p><strong>1）dump文件系统镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Desktop/ext2$ hexdump -C ext2.img    <br>00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>00000400  10 00 00 00 80 00 00 00  06 00 00 00 6b 00 00 00  |............k...|<br>00000410  05 00 00 00 01 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000420  00 20 00 00 00 20 00 00  10 00 00 00 00 00 00 00  |. ... ..........|<br>00000430  20 b6 47 65 01 00 ff ff  53 ef 00 00 01 00 00 00  | .Ge....S.......|<br>00000440  ff b4 47 65 00 00 00 00  00 00 00 00 01 00 00 00  |..Ge............|<br>00000450  00 00 00 00 0b 00 00 00  80 00 00 00 38 00 00 00  |............8...|<br>00000460  02 00 00 00 03 00 00 00  f3 e7 61 bb a7 3f 40 5b  |..........a..?@[|<br>00000470  97 53 eb b9 c6 6b ff 9f  00 00 00 00 00 00 00 00  |.S...k..........|<br>00000480  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>000004e0  00 00 00 00 00 00 00 00  00 00 00 00 74 e0 0a f1  |............t...|<br>000004f0  b3 3a 44 a6 bc 36 18 4f  88 2b 34 4b 01 00 00 00  |.:D..6.O.+4K....|<br>00000500  0c 00 00 00 00 00 00 00  ff b4 47 65 00 00 00 00  |..........Ge....|<br>00000510  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>00000560  01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000570  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>00000800  03 00 00 00 04 00 00 00  05 00 00 00 69 00 03 00  |............i...|<br>00000810  03 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000820  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>......<br>00001a60  00 00 00 00 7d 9b ef 10  00 00 00 00 00 00 00 00  |....&#125;...........|<br>00001a70  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>00001c00  02 00 00 00 0c 00 01 02  2e 00 00 00 02 00 00 00  |................|<br>00001c10  0c 00 02 02 2e 2e 00 00  0b 00 00 00 14 00 0a 02  |................|<br>00001c20  6c 6f 73 74 2b 66 6f 75  6e 64 00 00 0c 00 00 00  |lost+found......|<br>00001c30  d4 03 05 02 68 65 6c 6c  6f 00 00 00 00 00 00 00  |....hello.......|<br>00001c40  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>......<br>*<br>00020000<br></code></pre></td></tr></table></figure><p>镜像文件中（均为16进制显示） </p><ul><li>00000000 开始的1k大小 保留的引导块 </li><li>块1 00000400 开始的1k大小 保存磁盘的超级块 （dumpe2fs的部分信息从这里获得） </li><li>块2 00000800 开始的1k大小 保存块组描述符 （dumpe2fs的部分信息从这里获得） </li><li>块3 00000c00 开始的1k大小 保存块位图 </li><li>块4 00001000 开始的1k大小 保存 Inode 位图 </li><li>块5 块6 00001400 开始的2k大小 保存 Inode表</li><li>剩下的为数据块</li></ul><blockquote><p>其分别对应了ext2文件系统的布局结构体</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">fs/ext2/ext2.h<br><br>磁盘超级块：<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext2_super_block</span> &#123;</span><br>         __le32  s_inodes_count;         <span class="hljs-comment">/* Inodes count */</span><br>         __le32  s_blocks_count;         <span class="hljs-comment">/* Blocks count */</span><br>         __le32  s_r_blocks_count;       <span class="hljs-comment">/* Reserved blocks count */</span><br>         __le32  s_free_blocks_count;    <span class="hljs-comment">/* Free blocks count */</span><br>         __le32  s_free_inodes_count;    <span class="hljs-comment">/* Free inodes count */</span><br>         __le32  s_first_data_block;     <span class="hljs-comment">/* First Data Block */</span><br>         __le32  s_log_block_size;       <span class="hljs-comment">/* Block size */</span><br>         __le32  s_log_frag_size;        <span class="hljs-comment">/* Fragment size */</span><br>         __le32  s_blocks_per_group;     <span class="hljs-comment">/* # Blocks per group */</span><br>         __le32  s_frags_per_group;      <span class="hljs-comment">/* # Fragments per group */</span><br>         __le32  s_inodes_per_group;     <span class="hljs-comment">/* # Inodes per group */</span><br>  ...<br>&#125;<br><br>磁盘块组描述符：<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext2_group_desc</span></span><br><span class="hljs-class">&#123;</span><br>        __le32  bg_block_bitmap;                <span class="hljs-comment">/* Blocks bitmap block */</span><br>        __le32  bg_inode_bitmap;                <span class="hljs-comment">/* Inodes bitmap block */</span><br>        __le32  bg_inode_table;         <span class="hljs-comment">/* Inodes table block */</span><br>        __le16  bg_free_blocks_count;   <span class="hljs-comment">/* Free blocks count */</span><br>        __le16  bg_free_inodes_count;   <span class="hljs-comment">/* Free inodes count */</span><br>        __le16  bg_used_dirs_count;     <span class="hljs-comment">/* Directories count */</span><br>        __le16  bg_pad;<br>        __le32  bg_reserved[<span class="hljs-number">3</span>];<br>&#125;;<br><br><br>磁盘inode:<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext2_inode</span> &#123;</span><br>         __le16  i_mode;         <span class="hljs-comment">/* File mode */</span><br>         __le16  i_uid;          <span class="hljs-comment">/* Low 16 bits of Owner Uid */</span><br>         __le32  i_size;         <span class="hljs-comment">/* Size in bytes */</span><br>         __le32  i_atime;        <span class="hljs-comment">/* Access time */</span><br>         __le32  i_ctime;        <span class="hljs-comment">/* Creation time */</span><br>         __le32  i_mtime;        <span class="hljs-comment">/* Modification time */</span><br>         __le32  i_dtime;        <span class="hljs-comment">/* Deletion Time */</span><br>         __le16  i_gid;          <span class="hljs-comment">/* Low 16 bits of Group Id */</span><br>         __le16  i_links_count;  <span class="hljs-comment">/* Links count */</span><br>         __le32  i_blocks;       <span class="hljs-comment">/* Blocks count */</span><br>     ...<br>  __le32  i_block[EXT2_N_BLOCKS];<span class="hljs-comment">/* Pointers to blocks */</span><br> ...<br>&#125;;<br><br><br>磁盘目录项：<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext2_dir_entry_2</span> &#123;</span><br>        __le32  inode;                  <span class="hljs-comment">/* Inode number */</span><br>        __le16  rec_len;                <span class="hljs-comment">/* Directory entry length */</span><br>        __u8    name_len;               <span class="hljs-comment">/* Name length */</span><br>        __u8    file_type;<br>        <span class="hljs-type">char</span>    name[];                 <span class="hljs-comment">/* File name, up to EXT2_NAME_LEN */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-路径名查找"><a href="#3-路径名查找" class="headerlink" title="3.路径名查找"></a>3.路径名查找</h2><p>我们知道，使用文件系统给我最直观也是最大的好处是：用户可以通过一个路径名来访问文件，那么一个文件系统究竟如何来找到我们所需要的文件呢？下面我们详细来看ext2文件系统如何查找指定的文件的？</p><p><strong>1）查找根目录</strong></p><p>万事开头难，对于访问一个目录上挂载的文件系统，内核路径名查找会判断并找到挂载的文件系统的根目录，这个过程在文件系统挂载的时候，会从磁盘上读取并在内存构建超级块实例，然后进行的最重要的一步是读取文件系统的根inode: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">fs/ext2/super.c<br>ext2_fill_super<br>-&gt;root = ext2_iget(sb, EXT2_ROOT_INO)   <span class="hljs-comment">//EXT2_ROOT_INO为2，系统定义好的</span><br> -&gt;raw_inode = ext2_get_inode(inode-&gt;i_sb, ino, &amp;bh);  <span class="hljs-comment">//根据inode号查找磁盘inode</span><br>   核心算法如下：<br>     -&gt;block_group = (ino - <span class="hljs-number">1</span>) / EXT2_INODES_PER_GROUP(sb)  <span class="hljs-comment">//获得块组编号  (ino-1)/每个组含有的inode数组</span><br>      gdp = ext2_get_group_desc(sb, block_group, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//获得块组描述符</span><br>      offset = ((ino - <span class="hljs-number">1</span>) % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb); <span class="hljs-comment">//计算出在 块组的  inode表中的inode偏移</span><br>      block = le32_to_cpu(gdp-&gt;bg_inode_table) + (offset &gt;&gt; EXT2_BLOCK_SIZE_BITS(sb)); <span class="hljs-comment">//计算出在文件系统中的块号</span><br>      bh = sb_bread(sb, block))  <span class="hljs-comment">//组合成submit_bh 读取这个块到bh</span><br>      *p = bh;  <span class="hljs-comment">//赋值bh  用于返回</span><br>      offset &amp;= (EXT2_BLOCK_SIZE(sb) - <span class="hljs-number">1</span>);  <span class="hljs-comment">//计算出块中偏移</span><br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> ext2_inode *) (bh-&gt;b_data + offset);  <span class="hljs-comment">//返回inode中位置</span><br></code></pre></td></tr></table></figure><p>简述ext2通过inode号找到并读取磁盘inode核心算法：</p><ol><li>根据inode号计算出所在的块组block_group</li><li>根据inode号计算出块组中的inode表中的字节偏移offset</li><li>根据inode号计算出磁盘inode在文件系统中的块号block</li><li>根据块号block 通过sb_bread读取缓冲区块到内存</li><li>根据inode表中的字节偏移offset 计算出 磁盘inode在块中偏移</li><li>通过读取的缓冲区和磁盘inode在块中偏移 最终返回磁盘inode结构</li></ol><blockquote><p>这里需要解释一下怎么计算块号：block &#x3D; le32_to_cpu(gdp-&gt;bg_inode_table) + (offset &gt;&gt; EXT2_BLOCK_SIZE_BITS(sb));</p><ul><li>一个块的大小是1024（不是一定的），是从superblock读出来的</li><li>1024 &#x3D; 2 ^10，因此如果要看是在第几个块，直接右移10位即可；比如说偏移量offset为1048字节，那就在第1个块中（从0计数）</li></ul><img src="/2023/11/05/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231106225532419.png" alt="image-20231106225532419" style="zoom:67%;"><ul><li>其实我觉得除以1024更容易理解一点</li></ul></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt">☆ 根目录inode号固定: 2<br><br>块组编号:   block_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb)  = (2 - 1) / 16 = 0<br>inode表中的根inode偏移 : offset = ((ino - 1) % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb<br>                              = ( 1 % 16 ) * 128 = 128 = 0x80  (第2个inode  也就是0x480处)<br>文件系统中的根inode所在块号 : block = le32_to_cpu(gdp-&gt;bg_inode_table) + (offset &gt;&gt; EXT2_BLOCK_SIZE_BITS(sb))<br>                                = 5 + (128 &gt;&gt; 10) = 5<br>根inode所在块中偏移：offset &amp;= (EXT2_BLOCK_SIZE(sb) - 1) = 128 = 0x80<br><br>inode中位置 = bh-&gt;b_data + offset = 所在块 + 0x80<br></code></pre></td></tr></table></figure><p>✅ 根inode所在的镜像文件中偏移为：5 * 0x400 + 0x80 &#x3D; 0x1400 + 0x80 &#x3D; 0x1480</p><img src="/2023/11/05/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231106222848259.png" alt="image-20231106222848259" style="zoom:80%;"><ul><li><p>对照ext2文件系统磁盘inode结构，可知i_block为磁盘inode结构的偏移<strong>40 Byte</strong>处，内容即为0x07（ext2通过i_block来查找文件在磁盘中的位置）。</p></li><li><p>于是我们知道，根目录数据块的块号 为0x7（镜像中字节偏移为 0x400 * 7&#x3D; 1c00），这个数据块中保存的是根目录中包含的所有目录和文件的目录项（我们知道这里为”.”、”..”、”dir”、”lost+found”四个目录项）。</p></li></ul><img src="/2023/11/05/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231106223731775.png" alt="image-20231106223731775" style="zoom:80%;"><ul><li>根据目录项ext2_dir_entry_2 结构我们可以查询到文件名为hello的目录项，从而获取hello目录的inode号，为0x0c（和我们之前通ls -lai显示的hello目录inode号12是一致）。</li></ul><p><strong>2）查找hello目录</strong></p><p>和上面查询根inode一样的原理，计算过程如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">dir目录所在块组编号: block_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb)  = (12 - 1) / 16 = 0<br>dir目录所在inode表中的inode偏移 : offset = ((ino - 1) % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb<br>          = ( 11 % 16 ) * 128 = 1408（0x580）<br>文件系统中的dir目录的inode所在块号 : block = le32_to_cpu(gdp-&gt;bg_inode_table) + (offset &gt;&gt; EXT2_BLOCK_SIZE_BITS(sb))<br>       = 5 + (1408 &gt;&gt; 10) = 5 +1 =6<br>dir目录的inode所在块号中偏移：offset &amp;= (EXT2_BLOCK_SIZE(sb) - 1) = 1408（0x580）&amp; (0x400 -1) =   0x180<br>inode中位置 = bh-&gt;b_data + offset = 所在块 +  0x180<br></code></pre></td></tr></table></figure><p>所以：dir目录inode所在的镜像文件中字节偏移为：6 * 0x400 + 0x180 &#x3D; 0x1800 + 0x180 &#x3D; 0x1980</p><img src="/2023/11/05/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231106224058971.png" alt="image-20231106224058971" style="zoom:80%;"><ul><li><p>对照ext2文件系统磁盘inode结构，可知i_block为磁盘inode结构的偏移40B处，内容即为0x15。 </p></li><li><p>于是我们知道，dir目录数据块的块号 为0x63（偏移为 0x400 * 0x15&#x3D; 0x5400），这个数据块中保存的是hello目录中包含的所有目录和文件的目录项（我们知道这里为”.”、”..”、”amx.txt”三个目录项）。</p></li></ul><img src="/2023/11/05/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231106224235097.png" alt="image-20231106224235097" style="zoom:80%;"><ul><li><p>对照目录项ext2_dir_entry_2 结构，查找文件名为amx.txt的inode号，即为0x0d(和我们之前通ls -lai显示的inode号13是一致）。</p></li><li><p>于是我们知道，amx.txt文件的inode号为0x0d（13）。</p></li></ul><p><strong>3）查找amx.txt</strong></p><p>和上面查询根inode一样的原理，计算过程如下： </p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">amx.txt文件inode所在块组 编号: block_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb)  = (13 - 1) / 16 = 0<br>amx.txt文件inode在 inode表中的inode偏移 : offset = ((ino - 1) % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb<br>          = ( 12 % 16 ) * 128 = 1536（0x600）<br>文件系统中的amx.txt文件inode所在块号 : block = le32_to_cpu(gdp-&gt;bg_inode_table) + (offset &gt;&gt; EXT2_BLOCK_SIZE_BITS(sb))<br>       = 5 + (1536 &gt;&gt; 10) = 5 +1 =6<br>amx.txt文件inode所在块号中偏移：offset &amp;= (EXT2_BLOCK_SIZE(sb) - 1) = 1408（0x600）&amp; (0x400 -1) =   0x200<br>    inode中位置 = bh-&gt;b_data + offset = 所在块 +  0x200 <br></code></pre></td></tr></table></figure><p>所以：amx.txt文件inode所在的镜像文件中偏移为：&#x3D; 6 * 0x400 + 0x200 &#x3D; 0x1800 + 0x200 &#x3D; 0x1a00 </p><img src="/2023/11/05/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231106224524268.png" alt="image-20231106224524268" style="zoom:80%;"><ul><li><p>对照ext2文件系统磁盘inode结构，可知i_block为磁盘inode结构的偏移<strong>40 Byte</strong>处，内容即为0x16。</p></li><li><p>于是我们知道，amx.txt文件数据块的块号 为0x16（偏移为0x16 * 0x400 &#x3D; 0x5800）。</p></li></ul><img src="/2023/11/05/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/image-20231106224641224.png" alt="image-20231106224641224" style="zoom:80%;"><ul><li>✅ 和我们写进去的内容一样，都是”china”</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令拾遗-使用blktrace分析io情况</title>
    <link href="/2023/10/30/Linux%E5%91%BD%E4%BB%A4%E6%8B%BE%E9%81%97-%E4%BD%BF%E7%94%A8blktrace%E5%88%86%E6%9E%90io%E6%83%85%E5%86%B5/"/>
    <url>/2023/10/30/Linux%E5%91%BD%E4%BB%A4%E6%8B%BE%E9%81%97-%E4%BD%BF%E7%94%A8blktrace%E5%88%86%E6%9E%90io%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令拾遗-使用blktrace分析io情况"><a href="#Linux命令拾遗-使用blktrace分析io情况" class="headerlink" title="Linux命令拾遗-使用blktrace分析io情况"></a>Linux命令拾遗-使用blktrace分析io情况</h1><blockquote><p>原创：打码日记（微信公众号ID：codelogs），欢迎分享，转载请保留出处。</p><p><a href="https://www.cnblogs.com/codelogs/p/16060775.html">https://www.cnblogs.com/codelogs/p/16060775.html</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一般来说，想检查磁盘I&#x2F;O情况，可以使用iostat、iotop、sar等，但这些命令只能做一个整体的了解，没法具体到某一次io的详细情况，而今天介绍的blktrace就可以深入到Linux I&#x2F;O栈的方方面面，把一切都搞得明明白白的！</p><h2 id="Linux内核I-x2F-O栈"><a href="#Linux内核I-x2F-O栈" class="headerlink" title="Linux内核I&#x2F;O栈"></a>Linux内核I&#x2F;O栈</h2><p>先了解下Linux内核I&#x2F;O栈，一般来说，我们对网络协议栈比较熟悉，比如网络协议分了5层，每一层都是干什么的，但对于I&#x2F;O栈，则了解相对较少，如下：</p><img src="/2023/10/30/Linux%E5%91%BD%E4%BB%A4%E6%8B%BE%E9%81%97-%E4%BD%BF%E7%94%A8blktrace%E5%88%86%E6%9E%90io%E6%83%85%E5%86%B5/2792815-20220326203847680-773190512.png" alt="Linux-storage-stack-diagram_v4.0" style="zoom:80%;"><p>Linux内核I&#x2F;O栈大概分了6层，如下：</p><ul><li>文件系统层<br>提供了open、read、write等文件操作的系统调用给应用程序使用，并且Linux提供了文件系统的统一抽象vfs，使得Linux中可适配各种类型的文件系统，如ext4、btrfs、zfs、fat32、ntfs等，而我们常说的磁盘格式化，实际上就是在安装文件系统，重新写入相关文件系统的初始元数据信息到磁盘。</li><li>卷管理层<br>比如我们常听到的<code>Device Mapper</code>、<code>LVM</code>、<code>soft raid</code>就属于这一层，用于将多个磁盘合为一个，或将一个磁盘拆分为多个。</li><li>块存储层<br>这一层主要实现io调度逻辑，比如将一个大io请求拆分为多个小的io请求，将相邻的io请求合并，实现各种io调度算法等，常见io调度算法有CFQ、NOOP、Deadline、AS。</li><li>存储驱动层<br>每一个硬件都需要驱动程序，硬盘也不例外，如常听到的SCSI、ACHI、NVME等，且如&#x2F;dev&#x2F;sda这样的设备抽象文件，也由这一层实现。</li><li>硬件层<br>硬件层就是具体的硬盘实物了，但我们经常听到ATA、SATA、SCSI、PCIe、SAS等这样的名词，这是不同的硬盘接口规范，就像手机充电线有Type-A、Type-B、Type-C一样。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>软中断笔记</title>
    <link href="/2023/10/30/%E8%BD%AF%E4%B8%AD%E6%96%AD%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/10/30/%E8%BD%AF%E4%B8%AD%E6%96%AD%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="软中断笔记"><a href="#软中断笔记" class="headerlink" title="软中断笔记"></a>软中断笔记</h1><h2 id="1-中断是什么？"><a href="#1-中断是什么？" class="headerlink" title="1.中断是什么？"></a>1.中断是什么？</h2><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/338075214%EF%BC%8C%E4%BD%9C%E8%80%85%EF%BC%9A%E5%B0%8F%E6%9E%97coding">https://zhuanlan.zhihu.com/p/338075214，作者：小林coding</a></p></blockquote><p>先来看看什么是中断？在计算机中，中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。</p><p>这样的解释可能过于学术了，容易云里雾里，我就举个生活中取外卖的例子。</p><p>小林中午搬完砖，肚子饿了，点了份白切鸡外卖，这次我带闪了，没有被某团大数据大熟。虽然平台上会显示配送进度，但是我也不能一直傻傻地盯着呀，时间很宝贵，当然得去干别的事情，等外卖到了配送员会通过「电话」通知我，电话响了，我就会停下手中地事情，去拿外卖。</p><p>这里的打电话，其实就是对应计算机里的中断，没接到电话的时候，我可以做其他的事情，只有接到了电话，也就是发生中断，我才会停下当前的事情，去进行另一个事情，也就是拿外卖。</p><p>从这个例子，我们可以知道，中断是一种异步的事件处理机制，可以提高系统的并发处理能力。</p><p>操作系统收到了中断请求，会打断其他进程的运行，所以<strong>中断请求的响应程序，也就是中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度地影响。</strong></p><p>而且，中断处理程序在响应中断时，可能还会「临时关闭中断」，这意味着，如果当前中断处理程序没有执行完之前，系统中其他的中断请求都无法被响应，也就说中断有可能会丢失，所以中断处理程序要短且快。</p><p>还是回到外卖的例子，小林到了晚上又点起了外卖，这次为了犒劳自己，共点了两份外卖，一份小龙虾和一份奶茶，并且是由不同地配送员来配送，那么问题来了，当第一份外卖送到时，配送员给我打了长长的电话，说了一些杂七杂八的事情，比如给个好评等等，但如果这时另一位配送员也想给我打电话。</p><p>很明显，这时第二位配送员因为我在通话中（相当于关闭了中断响应），自然就无法打通我的电话，他可能尝试了几次后就走掉了（相当于丢失了一次中断）。</p><hr><p>【<strong>来自正点原子笔记</strong>】我们都知道中断处理函数一定要快点执行完毕，越短越好，但是现实往往是残酷的，有些中断处理过程就是比较费时间，我们必须要对其进行处理，缩小中断处理函数的执行时间。比如电容触摸屏通过中断通知 SOC 有触摸事件发生，SOC 响应中断，然后通过 IIC 接口读取触摸坐标值并将其上报给系统。但是我们都知道 IIC 的速度最高也只有400Kbit&#x2F;S，所以在中断中通过 IIC 读取数据就会浪费时间。我们可以将通过 IIC 读取触摸数据的操作暂后执行，中断处理函数仅仅相应中断，然后清除中断标志位即可。这个时候中断处理过程就分为了两部分：</p><ul><li>上半部：<strong>上半部就是中断处理函数</strong>，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。</li><li>下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。</li></ul><p>🎆因此，Linux 内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，那些对时间敏感、执行速度快的操作可以放到中断处理函数中，也就是上半部。剩下的所有工作都可以放到下半部去执行，比如在上半部将数据拷贝到内存中，关于数据的具体处理就可以放到下半部去执行。</p><h2 id="2-下半部机制中的软中断"><a href="#2-下半部机制中的软中断" class="headerlink" title="2.下半部机制中的软中断"></a>2.下半部机制中的软中断</h2><p>由于ISR运行时间不易过长，且不能睡眠，linux将中断中的一部分逻辑推后执行，于是诞生了软中断机制。实际上出现在内核代码中的术语“软中断（softirq）”常常表示可延迟函数的所有种类，即tasklet、softirq、work queue都可以统称为“软中断”，为了不产生混淆，我们使用更加广泛的统称：中断下(底)半部。</p><h3 id="2-1-软中断"><a href="#2-1-软中断" class="headerlink" title="2.1 软中断"></a>2.1 软中断</h3><blockquote><p>内容均来自于正点原子</p></blockquote><p>一开始 Linux 内核提供了“bottom half”机制来实现下半部，简称“BH”。后面引入了软中断和 tasklet 来替代“BH”机制，完全可以使用软中断和 tasklet 来替代 BH，从 2.5 版本的 Linux内核开始 BH 已经被抛弃了。Linux 内核使用结构体 softirq_action 表示软中断， softirq_action结构体定义在文件 include&#x2F;linux&#x2F;interrupt.h 中，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">void</span> (*action)(<span class="hljs-keyword">struct</span> softirq_action *);<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 kernel&#x2F;softirq.c 文件中一共定义了 10 个软中断，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span> <span class="hljs-title">softirq_vec</span>[<span class="hljs-title">NR_SOFTIRQS</span>];</span><br></code></pre></td></tr></table></figure><p>NR_SOFTIRQS 是枚举类型，定义在文件 include&#x2F;linux&#x2F;interrupt.h 中，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>    HI_SOFTIRQ=<span class="hljs-number">0</span>, <span class="hljs-comment">/* 高优先级软中断 */</span><br>TIMER_SOFTIRQ, <span class="hljs-comment">/* 定时器软中断 */</span><br>NET_TX_SOFTIRQ, <span class="hljs-comment">/* 网络数据发送软中断 */</span><br>NET_RX_SOFTIRQ, <span class="hljs-comment">/* 网络数据接收软中断 */</span><br>BLOCK_SOFTIRQ, <br>    BLOCK_IOPOLL_SOFTIRQ, <br>    TASKLET_SOFTIRQ, <span class="hljs-comment">/* tasklet 软中断 */</span><br>    SCHED_SOFTIRQ, <span class="hljs-comment">/* 调度软中断 */</span><br>HRTIMER_SOFTIRQ, <span class="hljs-comment">/* 高精度定时器软中断 */</span><br>RCU_SOFTIRQ, <span class="hljs-comment">/* RCU 软中断 */</span><br>NR_SOFTIRQS<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看出，一共有 10 个软中断，因此 NR_SOFTIRQS 为 10，因此数组 softirq_vec 有 10 个元素。softirq_action 结构体中的 action 成员变量就是软中断的服务函数，数组 softirq_vec 是个全局数组，因此所有的 CPU(对于 SMP 系统而言)都可以访问到，每个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个 CPU 所执行的软中断服务函数确是相同的，都是数组 softirq_vec 中定义的 action 函数。要使用软中断，必须先使用 open_softirq 函数注册对应的软中断处理函数，<strong>open_softirq</strong> 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">open_softirq</span><span class="hljs-params">(<span class="hljs-type">int</span> nr, <span class="hljs-type">void</span> (*action)(<span class="hljs-keyword">struct</span> softirq_action *))</span><br></code></pre></td></tr></table></figure><p>注册好软中断以后需要通过 <strong>raise_softirq</strong> 函数触发，raise_softirq 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">raise_softirq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr)</span><br></code></pre></td></tr></table></figure><p>软中断必须在编译的时候静态注册！Linux 内核使用 softirq_init 函数初始化软中断，softirq_init 函数定义在 kernel&#x2F;softirq.c 文件里面，函数内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __init <span class="hljs-title function_">softirq_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> cpu;<br><br>for_each_possible_cpu(cpu) &#123;<br>per_cpu(tasklet_vec, cpu).tail =<br>&amp;per_cpu(tasklet_vec, cpu).head;<br>per_cpu(tasklet_hi_vec, cpu).tail =<br>&amp;per_cpu(tasklet_hi_vec, cpu).head;<br>&#125;<br><br>open_softirq(TASKLET_SOFTIRQ, tasklet_action);<br>open_softirq(HI_SOFTIRQ, tasklet_hi_action);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>缓冲区的概念和原理</title>
    <link href="/2023/10/25/%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/"/>
    <url>/2023/10/25/%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="缓冲区的概念和原理"><a href="#缓冲区的概念和原理" class="headerlink" title="缓冲区的概念和原理"></a>缓冲区的概念和原理</h1><blockquote><p><strong>声明</strong>：本文内容均转载自下面2篇博客：</p><ul><li><a href="https://blog.csdn.net/weixin_51429254/article/details/127453147">https://blog.csdn.net/weixin_51429254/article/details/127453147</a></li><li><a href="https://codeantenna.com/a/DWEgSdNsKv">https://codeantenna.com/a/DWEgSdNsKv</a></li></ul></blockquote><h2 id="1-用户层缓冲区"><a href="#1-用户层缓冲区" class="headerlink" title="1.用户层缓冲区"></a>1.用户层缓冲区</h2><p>通过对语言的学习，我们知道C语言提供了FILE类，用于描述文件的属性信息，进程所打开的每个文件，都有一个FILE*指针与之对应，指向描述这个文件属性信息的结构体。</p><p>在FILE结构体中，会存储文件描述符fd，也会有指向该文件对应的缓冲区的指针，FILE的定义见下面代码，可见C会为每个打开的文件都申请缓冲区，用于该文件的读写。</p><p><strong>结论：缓冲区就是一段内存空间，每一个被进程打开的文件都有与之对应的缓冲区。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> &#123;</span>    <br>  <span class="hljs-type">int</span> _flags;       <span class="hljs-comment">/* High-order word is _IO_MAGIC; rest is flags. */</span>    <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_file_flags _flags    </span><br>    <br>  <span class="hljs-comment">/* The following pointers correspond to the C++ streambuf protocol. */</span>    <br>  <span class="hljs-comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span>    <br>  <span class="hljs-type">char</span>* _IO_read_ptr;   <span class="hljs-comment">/* Current read pointer */</span>    <br>  <span class="hljs-type">char</span>* _IO_read_end;   <span class="hljs-comment">/* End of get area. */</span>    <br>  <span class="hljs-type">char</span>* _IO_read_base;  <span class="hljs-comment">/* Start of putback+get area. */</span>    <br>  <span class="hljs-type">char</span>* _IO_write_base; <span class="hljs-comment">/* Start of put area. */</span>    <br>  <span class="hljs-type">char</span>* _IO_write_ptr;  <span class="hljs-comment">/* Current put pointer. */</span>    <br>  <span class="hljs-type">char</span>* _IO_write_end;  <span class="hljs-comment">/* End of put area. */</span>    <br>  <span class="hljs-type">char</span>* _IO_buf_base;   <span class="hljs-comment">/* Start of reserve area. */</span>    <br>  <span class="hljs-type">char</span>* _IO_buf_end;    <span class="hljs-comment">/* End of reserve area. */</span>    <br>  <span class="hljs-comment">/* The following fields are used to support backing up and undo. */</span>    <br>  <span class="hljs-type">char</span> *_IO_save_base; <span class="hljs-comment">/* Pointer to start of non-current get area. */</span>    <br>  <span class="hljs-type">char</span> *_IO_backup_base;  <span class="hljs-comment">/* Pointer to first valid character of backup area */</span>    <br>  <span class="hljs-type">char</span> *_IO_save_end; <span class="hljs-comment">/* Pointer to end of non-current get area. */</span>    <br>    <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_marker</span> *_<span class="hljs-title">markers</span>;</span>    <br>    <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">chain</span>;</span>    <br>    <br>  <span class="hljs-type">int</span> _fileno;    <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0    </span><br>  <span class="hljs-type">int</span> _blksize;    <br><span class="hljs-meta">#<span class="hljs-keyword">else</span>    </span><br>  <span class="hljs-type">int</span> _flags2;    <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>    </span><br>  _IO_off_t _old_offset; <span class="hljs-comment">/* This used to be _offset but it&#x27;s too small.  */</span>    <br>    <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HAVE_COLUMN <span class="hljs-comment">/* temporary */</span>    </span><br>  <span class="hljs-comment">/* 1+column number of pbase(); 0 is unknown. */</span>    <br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> _cur_column;    <br>  <span class="hljs-type">signed</span> <span class="hljs-type">char</span> _vtable_offset;    <br>  <span class="hljs-type">char</span> _shortbuf[<span class="hljs-number">1</span>];    <br>    <br>  <span class="hljs-comment">/*  char* _save_gptr;  char* _save_egptr; */</span>    <br>    <br>  _IO_lock_t *_lock;    <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _IO_USE_OLD_IO_FILE    </span><br>&#125;;    <br></code></pre></td></tr></table></figure><p>我们可以据此推断，当调用C&#x2F;C++的IO函数向外部设备（磁盘文件）输出数据时，数据会被先写入目标磁盘文件的缓冲区，当缓冲区的数据积累到了一定的量时，再调用系统接口write，将缓冲区的数据写操作系统的内核缓冲区，在合适的时间，内核缓冲区的数据就会被刷新到外部设备，具体流程参考下图。这样相比于每次调用C&#x2F;C++的IO函数都直接使用系统接口write，效率会有所提高。</p><p>从外部设备读取数据时，C&#x2F;C++标准库提供的缓冲区的工作原理与向外部设备写数据时类似。</p><img src="/2023/10/25/%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/5ce11a1ad0dc469ba4b6faa9468718a4.png" alt="img" style="zoom: 33%;"><h2 id="2-缓冲区的简单模拟实现"><a href="#2-缓冲区的简单模拟实现" class="headerlink" title="2.缓冲区的简单模拟实现"></a>2.缓冲区的简单模拟实现</h2><p>只需要在自定义的struct myFILE中定义一段缓冲区，在写文件时先将内容写入到缓冲区中，在缓冲区满、文件关闭或用户强制刷新缓冲区时，调用系统write函数刷新缓冲区，即可模拟实现简单的缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM 10</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myFile</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> fd;       <span class="hljs-comment">//文件描述符</span><br>    <span class="hljs-type">char</span> buffer[NUM]; <span class="hljs-comment">//缓冲区 </span><br>    <span class="hljs-type">int</span> end;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myFile</span> <span class="hljs-title">MyFILE</span>;</span><br><br>MyFILE* <span class="hljs-title function_">fopen_</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* mode)</span><br>&#123;<br>    assert(path);<br>    assert(mode);<br><br>    MyFILE* ret = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(mode, <span class="hljs-string">&quot;w&quot;</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">//只写、清空、没有就创建文件</span><br>        fd = open(path, O_WRONLY|O_CREAT|O_TRUNC, <span class="hljs-number">0666</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(mode, <span class="hljs-string">&quot;r&quot;</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        fd = open(path, O_RDONLY);  <span class="hljs-comment">//只写打开</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(mode, <span class="hljs-string">&quot;a&quot;</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        fd = open(path, O_WRONLY|O_CREAT|O_APPEND, <span class="hljs-number">0666</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(mode, <span class="hljs-string">&quot;w+&quot;</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        fd = open(path, O_RDWR|O_CREAT|O_TRUNC, <span class="hljs-number">0666</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(mode, <span class="hljs-string">&quot;r+&quot;</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        fd = open(path, O_RDWR);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(mode, <span class="hljs-string">&quot;a+&quot;</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        fd = open(path, O_RDWR|O_CREAT|O_APPEND, <span class="hljs-number">0666</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mode error!\n&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">if</span>(fd &gt;= <span class="hljs-number">0</span>)                                                                                                      <br>    &#123;<br>        ret = (MyFILE*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(MyFILE));<br>        <span class="hljs-built_in">memset</span>(ret, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(MyFILE));<br>        ret-&gt;fd = fd;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">//缓冲区刷新函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">fflush_</span><span class="hljs-params">(MyFILE* pf)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> n = <span class="hljs-built_in">strlen</span>(pf-&gt;buffer);<br>    <span class="hljs-comment">//fprintf(stdout, &quot;%s\n&quot;, pf-&gt;buffer);</span><br>    write(pf-&gt;fd, pf-&gt;buffer, n);<br>    <span class="hljs-built_in">memset</span>(pf-&gt;buffer, <span class="hljs-number">0</span>, NUM);<br>    pf-&gt;end = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//文件关闭函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">close_</span><span class="hljs-params">(MyFILE* pf)</span><br>&#123;<br>    fflush_(pf);<br>    close(pf-&gt;fd);<br>    <span class="hljs-built_in">free</span>(pf);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fputs_</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, MyFILE* pf)</span><br>&#123;<br>    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>)<span class="hljs-built_in">strlen</span>(s);   <span class="hljs-comment">//要写入的字符数</span><br>    <span class="hljs-keyword">while</span>(pf-&gt;end + len &gt;= NUM)<br>    &#123;<br>        <span class="hljs-type">int</span> n = NUM - pf-&gt;end - <span class="hljs-number">1</span>;   <span class="hljs-comment">//实际可以读取的字符数</span><br>        <span class="hljs-built_in">strncpy</span>(pf-&gt;buffer + pf-&gt;end, s, n);  <span class="hljs-comment">//字符数拷贝到缓冲区</span><br>        <span class="hljs-comment">//fprintf(stdout, &quot;%s\n&quot;, pf-&gt;buffer);</span><br>        fflush_(pf);   <span class="hljs-comment">//缓冲区满，强制清理</span><br>        sleep(<span class="hljs-number">1</span>);<br>        len -= n;   <span class="hljs-comment">//还没有拷贝的字符数</span><br>        s += n;<br>    &#125;<br><br><br>    <span class="hljs-built_in">strcpy</span>(pf-&gt;buffer, s);<br>    pf-&gt;end = len;<br><br>    <span class="hljs-keyword">if</span>(pf-&gt;end != <span class="hljs-number">0</span> &amp;&amp; (pf-&gt;fd == <span class="hljs-number">1</span> || pf-&gt;fd == <span class="hljs-number">2</span>))<br>    &#123;<br>        <span class="hljs-comment">//标准输出和标准错误(显示屏)采用行刷新策略</span><br>        <span class="hljs-keyword">if</span>(s[<span class="hljs-built_in">strlen</span>(s) - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        &#123;<br>            fflush_(pf);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    MyFILE* pf = fopen_(<span class="hljs-string">&quot;log.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    dup2(pf-&gt;fd, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">//int fd = open(&quot;log2.txt&quot;, O_RDONLY);</span><br>    <span class="hljs-comment">//printf(&quot;%d\n&quot;, fd);</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s1 = <span class="hljs-string">&quot;hello world, hello linux, hello everyone\n&quot;</span>;<br>    fputs_(s1, pf);<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s2 = <span class="hljs-string">&quot;zhangHHHHHHHHHH\n&quot;</span>;<br>    fputs_(s2, pf);<br><br>    close_(pf);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-缓冲区的刷新策略"><a href="#3-缓冲区的刷新策略" class="headerlink" title="3.缓冲区的刷新策略"></a>3.缓冲区的刷新策略</h2><p>缓冲区有三种类型对应三种刷新缓冲区的方式：</p><ol><li><strong>全缓冲</strong><br>当填满标准I&#x2F;O缓存后才进行实际I&#x2F;O操作，如将数据从用户层缓冲区拷贝到内核缓冲区。全缓冲的典型代表是对磁盘文件的读写</li><li><strong>行缓冲</strong><br>当输入和输出中遇到换行符时才执行实际I&#x2F;O操作，典型代表是标准输入stdin和标准输出stdout</li><li><strong>无缓冲</strong><br>不对数据进行缓冲，直接进行I&#x2F;O，如标准错误stderr就是无缓冲刷新</li></ol><p><strong>缓冲区何时会被刷呢&amp;刷新方法：</strong></p><ol><li>调用exit()进程结束时会刷新缓冲区，return会自动调用exit()，注意_exit()不会刷新缓冲区</li><li>当<strong>缓冲区满了</strong>也会被刷新出来</li><li>可通过fflush强制将缓冲流中的数据复制到内核缓冲区中</li><li>流被关闭时也会被刷出来，如调用fclose函数</li><li>行缓冲遇见<code>&#39;\n&#39;</code>会被刷新出来</li></ol><h2 id="4-内核缓冲区"><a href="#4-内核缓冲区" class="headerlink" title="4.内核缓冲区"></a>4.内核缓冲区</h2><p>内核层缓冲区为<code>buffer</code>和<code>cache</code>，它们位于内核空间，被所有进程可见。buffer和cache是内存的不同的体现，它们搭建了CPU和磁盘快速交互的桥梁</p><ul><li>buffer存储暂未写入到磁盘的数据，积攒到一定量后写入磁盘，可以降低和磁盘IO的频率</li><li>cache实现数据预读的功能：可以暂时存储来自磁盘的数据，提高这部分数据重用性，使得OS无需频繁访问磁盘</li></ul><p><strong>设置内核缓冲区的好处：</strong>内核缓冲区数据不写回磁盘也能被其它进程读取，在这点的作用上和磁盘存储文件无异，直接读取内核缓冲区的数据，带来了读写的高效性</p><h2 id="5-零拷贝"><a href="#5-零拷贝" class="headerlink" title="5.零拷贝"></a>5.零拷贝</h2><blockquote><p>以下内容来自：<a href="https://xiaolincoding.com/os/8_network_system/zero_copy.html">小林coding</a>，侵权联系删除</p></blockquote><h3 id="5-1-为什么要有DMA技术"><a href="#5-1-为什么要有DMA技术" class="headerlink" title="5.1 为什么要有DMA技术"></a>5.1 为什么要有DMA技术</h3><p>在没有 DMA 技术前，I&#x2F;O 的过程是这样的：</p><ul><li>CPU 发出对应的指令给磁盘控制器，然后返回；</li><li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li><li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li></ul><p>为了方便你理解，我画了一副图：</p><img src="/2023/10/25/%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/I_O 中断.png" alt="img" style="zoom: 40%;"><p>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。</p><p>简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。</p><p>计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是<strong>直接内存访问（Direct Memory Access）</strong> 技术。</p><p>什么是 DMA 技术？简单理解就是，<strong>在进行 I&#x2F;O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p><p>那使用 DMA 控制器进行数据传输的过程究竟是什么样的呢？下面我们来具体看看。</p><img src="/2023/10/25/%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/DRM I_O 过程.png" alt="img" style="zoom:40%;"><p>具体过程：</p><ul><li>用户进程调用 read 方法，向操作系统发出 I&#x2F;O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li><li>操作系统收到请求后，进一步将 I&#x2F;O 请求发送 DMA，然后让 CPU 执行其他任务；</li><li>DMA 进一步将 I&#x2F;O 请求发送给磁盘；</li><li>磁盘收到 DMA 的 I&#x2F;O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li><li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li><li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li><li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li></ul><p>可以看到， <strong>CPU 不再参与「将数据从磁盘控制器缓冲区搬运到内核空间」的工作，这部分工作全程由 DMA 完成</strong>。但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。</p><p>早期 DMA 只存在在主板上，如今由于 I&#x2F;O 设备越来越多，数据传输的需求也不尽相同，所以每个 I&#x2F;O 设备里面都有自己的 DMA 控制器。</p><h3 id="4-2-传统的文件传输有多糟糕？"><a href="#4-2-传统的文件传输有多糟糕？" class="headerlink" title="4.2 传统的文件传输有多糟糕？"></a>4.2 传统的文件传输有多糟糕？</h3><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I&#x2F;O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I&#x2F;O 接口从磁盘读取或写入。</p><p>代码通常如下，一般会需要两个系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">read(file, tmp_buf, len);<br>write(socket, tmp_buf, len);<br></code></pre></td></tr></table></figure><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p><img src="/2023/10/25/%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/传统文件传输.png" alt="img" style="zoom:50%;"><p>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p><p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p><ul><li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li><li><em>第二次拷贝</em>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li><li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li><li><em>第四次拷贝</em>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li></ul><p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p><p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p><p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p><h3 id="4-3-如何优化文件传输的性能？"><a href="#4-3-如何优化文件传输的性能？" class="headerlink" title="4.3 如何优化文件传输的性能？"></a>4.3 如何优化文件传输的性能？</h3><blockquote><p>先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？</p></blockquote><p>读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。</p><p>而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。</p><p>所以，<strong>要想减少上下文切换到次数，就要减少系统调用的次数</strong>。</p><blockquote><p>再来看看，如何减少「数据拷贝」的次数？</p></blockquote><p>在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。</p><p>因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此<strong>用户的缓冲区是没有必要存在的</strong>。</p><h3 id="4-4-如何实现零拷贝？"><a href="#4-4-如何实现零拷贝？" class="headerlink" title="4.4 如何实现零拷贝？"></a>4.4 如何实现零拷贝？</h3><ul><li>mmap + write</li><li>sendfile</li></ul><p>下面就谈一谈，它们是如何减少「上下文切换」和「数据拷贝」的次数。</p><h4 id="4-4-1-mmap-write"><a href="#4-4-1-mmap-write" class="headerlink" title="4.4.1 mmap + write"></a>4.4.1 mmap + write</h4><p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">buf = mmap(file, len);<br>write(sockfd, buf, len);<br></code></pre></td></tr></table></figure><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><img src="/2023/10/25/%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/mmap %2B write 零拷贝.png" alt="img" style="zoom: 50%;"><p>具体过程如下：</p><ul><li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li><li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li><li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li></ul><p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。</p><p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p><h4 id="4-4-2-sendfile"><a href="#4-4-2-sendfile" class="headerlink" title="4.4.2  sendfile"></a>4.4.2  sendfile</h4><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span> *offset, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure><p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p><p>首先，它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p><p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p><img src="/2023/10/25/%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/senfile-3次拷贝.png" alt="img" style="zoom:50%;"><p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p><p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">$ ethtool -k eth0 | grep scatter-gather<br>scatter-gather: on<br></code></pre></td></tr></table></figure><p>于是，从 Linux 内核 <code>2.4</code> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul><p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p><img src="/2023/10/25/%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/senfile-零拷贝.png" alt="img" style="zoom: 50%;"><p>这就是所谓的<strong>零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong>。</p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p><p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内核常用的bit操作</title>
    <link href="/2023/10/16/%E5%86%85%E6%A0%B8%E5%B8%B8%E7%94%A8%E7%9A%84bit%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/10/16/%E5%86%85%E6%A0%B8%E5%B8%B8%E7%94%A8%E7%9A%84bit%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="内核常用的bit操作"><a href="#内核常用的bit操作" class="headerlink" title="内核常用的bit操作"></a>内核常用的bit操作</h1><h3 id="set-bit-x2F-clear-bit"><a href="#set-bit-x2F-clear-bit" class="headerlink" title="set_bit&#x2F;clear_bit"></a>set_bit&#x2F;clear_bit</h3><p>set_bit(nr,addr)将addr的第nr位置1</p><p>clear_bit(nr,addr)</p><p>test_and_set_bit(nr,addr)将addr的第nr位置1，并返回原始addr第nr位的值</p><p>test_and_clear_bit(nr,addr)</p><h3 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lock_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span><br>&#123;<br>might_sleep();<br><span class="hljs-keyword">if</span> (!trylock_page(page))<br>__lock_page(page);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trylock_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span><br>&#123;<br>page = compound_head(page);<br>    <span class="hljs-comment">// 检查是否可以锁定这个page.如果没有其他进程用这个page，则直接设置flag来锁定这个page，否则调用__lock_page</span><br><span class="hljs-comment">// 来等待这个页面被释放</span><br><span class="hljs-keyword">return</span> (likely(!test_and_set_bit_lock(PG_locked, &amp;page-&gt;flags)));<br>&#125;<br><br><span class="hljs-type">void</span> __lock_page(<span class="hljs-keyword">struct</span> page *__page)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> compound_head(__page);<br><span class="hljs-type">wait_queue_head_t</span> *q = page_waitqueue(page);<br>wait_on_page_bit_common(q, page, PG_locked, TASK_UNINTERRUPTIBLE,<br>EXCLUSIVE);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>bio实现对磁盘读写，用bio_add_page与submit_bio的方式</title>
    <link href="/2023/10/16/bio%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%EF%BC%8C%E7%94%A8bio-add-page%E4%B8%8Esubmit-bio%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/10/16/bio%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%EF%BC%8C%E7%94%A8bio-add-page%E4%B8%8Esubmit-bio%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="bio实现对磁盘读写，用bio-add-page与submit-bio的方式"><a href="#bio实现对磁盘读写，用bio-add-page与submit-bio的方式" class="headerlink" title="bio实现对磁盘读写，用bio_add_page与submit_bio的方式"></a>bio实现对磁盘读写，用bio_add_page与submit_bio的方式</h1><p>在Linux内核中，可以使用<code>struct bio</code>数据结构和相应的函数来实现对磁盘的读写操作。下面是一个使用<code>bio_add_page()</code>和<code>submit_bio()</code>函数进行磁盘读写的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><br><br><span class="hljs-comment">// 读操作的回调函数，可在此处进行处理</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">read_complete</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bio *bio, <span class="hljs-type">int</span> err)</span><br>&#123;<br>    <span class="hljs-comment">// 处理读取完成后的逻辑</span><br>&#125;<br><br><span class="hljs-comment">// 读写数据函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">disk_read_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> block_device *bdev, <span class="hljs-type">sector_t</span> start_sector, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sectors, <span class="hljs-type">int</span> is_write)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> *<span class="hljs-title">bio</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">q</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gendisk</span> *<span class="hljs-title">disk</span>;</span><br><br>    disk = bdev-&gt;bd_disk;<br>    q = disk-&gt;<span class="hljs-built_in">queue</span>;<br><br>    bio = bio_alloc(GFP_NOIO, BIO_MAX_PAGES);<br>    <span class="hljs-keyword">if</span> (!bio)<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br><br>    bio-&gt;bi_iter.bi_sector = start_sector;<br>    bio-&gt;bi_bdev = bdev;<br>    bio-&gt;bi_end_io = read_complete;<br><br>    <span class="hljs-keyword">while</span> (sectors &gt; <span class="hljs-number">0</span>) &#123;<br>        page = alloc_page(GFP_NOIO);<br>        <span class="hljs-keyword">if</span> (!page) &#123;<br>            bio_put(bio);<br>            <span class="hljs-keyword">return</span> -ENOMEM;<br>        &#125;<br><br>        <span class="hljs-comment">// 将页添加到 BIO 中</span><br>        bio_add_page(bio, page, PAGE_SIZE, <span class="hljs-number">0</span>);<br><br>        sectors--;<br>        start_sector++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (is_write)<br>        bio_set_op_attrs(bio, REQ_OP_WRITE, REQ_SYNC);<br>    <span class="hljs-keyword">else</span><br>         bio_set_op_attrs(bio, REQ_OP_READ, REQ_SYNC | REQ_META);<br><br>    <span class="hljs-comment">// 提交 BIO 进行读操作</span><br>    submit_bio(READ_SYNC, bio);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文件系统do_writepages流程分析</title>
    <link href="/2023/10/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fdo-writepages%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2023/10/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fdo-writepages%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统do-writepages流程分析"><a href="#文件系统do-writepages流程分析" class="headerlink" title="文件系统do_writepages流程分析"></a>文件系统do_writepages流程分析</h1><h2 id="入口函数do-writepages"><a href="#入口函数do-writepages" class="headerlink" title="入口函数do_writepages"></a>入口函数do_writepages</h2><img src="/2023/10/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fdo-writepages%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20231015200520926.png" alt="image-20231015200520926" style="zoom:67%;"><p>可以看到会先判断mapping对应的文件系统是否有writepages函数，</p><ul><li>如果有则调用各自文件系统的writepages函数</li><li>如果没有则调用公共的接口generic_writepages</li></ul><h3 id="公共写页接口generic-writepages"><a href="#公共写页接口generic-writepages" class="headerlink" title="公共写页接口generic_writepages"></a>公共写页接口generic_writepages</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">generic_writepages</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> address_space *mapping, <span class="hljs-keyword">struct</span> writeback_control *wbc)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_plug</span> <span class="hljs-title">plug</span>;</span><br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-comment">/* deal with chardevs and other special file */</span><br><span class="hljs-keyword">if</span> (!mapping-&gt;a_ops-&gt;writepage)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>blk_start_plug(&amp;plug);<br>ret = write_cache_pages(mapping, wbc, __writepage, mapping);<br>blk_finish_plug(&amp;plug);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不同文件系统的写页接口"><a href="#不同文件系统的写页接口" class="headerlink" title="不同文件系统的写页接口"></a>不同文件系统的写页接口</h3><h4 id="ext4文件系统"><a href="#ext4文件系统" class="headerlink" title="ext4文件系统"></a>ext4文件系统</h4><h4 id="f2fs文件系统"><a href="#f2fs文件系统" class="headerlink" title="f2fs文件系统"></a>f2fs文件系统</h4><blockquote><p>参考：<a href="https://blog.csdn.net/u011649400/article/details/94589060">https://blog.csdn.net/u011649400/article/details/94589060</a></p></blockquote><img src="/2023/10/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fdo-writepages%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20231015214705090.png" alt="image-20231015214705090" style="zoom:90%;"><p>f2fs文件系统区分了node，data，metadata不同的接口</p><img src="/2023/10/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fdo-writepages%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20231015200929261.png" alt="image-20231015200929261" style="zoom: 80%;"><p>以写数据页为例，writepages对应的接口为f2fs_write_data_pages</p><img src="/2023/10/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fdo-writepages%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20231015200852579.png" alt="image-20231015200852579" style="zoom:50%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_write_data_pages</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> address_space *mapping,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> writeback_control *wbc)</span><br>&#123;<br>    <span class="hljs-comment">// 通过mapping-&gt;host拿到inode</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> =</span> mapping-&gt;host;<br><br><span class="hljs-keyword">return</span> __f2fs_write_data_pages(mapping, wbc,<br>F2FS_I(inode)-&gt;cp_task == current ?<br>FS_CP_DATA_IO : FS_DATA_IO);<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __f2fs_write_data_pages(<span class="hljs-keyword">struct</span> address_space *mapping,<br><span class="hljs-keyword">struct</span> writeback_control *wbc,<br><span class="hljs-keyword">enum</span> iostat_type io_type)<br>&#123;<br>ret = f2fs_write_cache_pages(mapping, wbc, io_type); <span class="hljs-comment">// 取出需要回写的page，然后写入</span><br>f2fs_remove_dirty_inode(inode); <span class="hljs-comment">// 写入后将inode从dirty标志清除，即不需要再回写</span><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>f2fs_write_cache_pages函数</strong></p><p>这个函数的主要作用是从inode对应的mapping(radix tree的root)中，取出所有需要回写的page，然后通过一个循环，逐个写入到磁盘。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_write_cache_pages</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> address_space *mapping,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> writeback_control *wbc,</span><br><span class="hljs-params"><span class="hljs-keyword">enum</span> iostat_type io_type)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pagevec</span> <span class="hljs-title">pvec</span>;</span><br><br>pagevec_init(&amp;pvec); <span class="hljs-comment">// 这是一个用于装载page的数组，数组大小是15个page</span><br><br>retry:<br>done_index = index;<br><br><span class="hljs-keyword">while</span> (!done &amp;&amp; !retry &amp;&amp; (index &lt;= end)) &#123;<br><span class="hljs-comment">// 从mapping中取出tag类型的15个page，装载到pvec中</span><br>nr_pages = pagevec_lookup_range_tag(&amp;pvec, mapping, &amp;index, end, tag); <br><br><span class="hljs-comment">// 循环将pvec中的page取出，回写到磁盘</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nr_pages; i++) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> pvec.pages[i];<br>ret = f2fs_write_single_data_page(page, &amp;submitted, &amp;bio, &amp;last_block, wbc, io_type, <span class="hljs-number">0</span>);<br>&#125;<br>pagevec_release(&amp;pvec); <span class="hljs-comment">// 释放掉pvec</span><br>cond_resched();<br>&#125;<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>f2fs_write_single_data_page</strong>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_write_single_data_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">int</span> *submitted,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> bio **bio,</span><br><span class="hljs-params"><span class="hljs-type">sector_t</span> *last_block,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> writeback_control *wbc,</span><br><span class="hljs-params"><span class="hljs-keyword">enum</span> iostat_type io_type,</span><br><span class="hljs-params"><span class="hljs-type">int</span> compr_blocks)</span><br>&#123;<br>    <span class="hljs-comment">// 这个数据结构在整个写流程非常重要，记录了写入的信息</span><br><span class="hljs-comment">// 关键变量是 fio-&gt;old_blkaddr 以及 fio-&gt;new_blkaddr记录旧地址和新地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_io_info</span> <span class="hljs-title">fio</span> =</span> &#123;<br>.sbi = sbi,<br>.ino = inode-&gt;i_ino,<br>.type = DATA,<br>.op = REQ_OP_WRITE,<br>.op_flags = wbc_to_write_flags(wbc),<br>.old_blkaddr = NULL_ADDR,<br>.page = page,<br>.encrypted_page = <span class="hljs-literal">NULL</span>,<br>.submitted = <span class="hljs-literal">false</span>,<br>.compr_blocks = compr_blocks,<br>.need_lock = LOCK_RETRY,<br>.io_type = io_type,<br>.io_wbc = wbc,<br>.bio = bio,<br>.last_block = last_block,<br>&#125;;<br>write:<br><span class="hljs-keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123; <span class="hljs-comment">// 如果是目录文件，直接写入不需要修改</span><br>err = f2fs_do_write_data_page(&amp;fio);<br><span class="hljs-keyword">goto</span> done;<br>&#125;<br><br>err = -EAGAIN;<br><span class="hljs-keyword">if</span> (f2fs_has_inline_data(inode)) &#123; <span class="hljs-comment">// 内联文件使用内联的写入方式</span><br>err = f2fs_write_inline_data(inode, page);<br><span class="hljs-keyword">if</span> (!err)<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-keyword">if</span> (err == -EAGAIN) &#123; <span class="hljs-comment">// 普通文件则使用普通的方式</span><br>err = f2fs_do_write_data_page(&amp;fio);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>f2fs_do_write_data_page</strong>函数</p><p>这个函数的作用是根据系统的状态选择就地更新数据(inplace update)还是异地更新数据(outplace update)。一般情况下，系统只会在磁盘空间比较满的时候选择就地更新策略，避免触发过多的gc影响性能。因此，这里主要介绍异地更新的写流程:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_do_write_data_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_io_info *fio)</span> <span class="hljs-comment">// 前面提到fio是写流程最重要的数据结构</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> fio-&gt;page;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> =</span> page-&gt;mapping-&gt;host;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dnode_of_data</span> <span class="hljs-title">dn</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">extent_info</span> <span class="hljs-title">ei</span> =</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">bool</span> ipu_force = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br><br>set_new_dnode(&amp;dn, inode, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化dnode</span><br>err = f2fs_get_dnode_of_data(&amp;dn, page-&gt;index, LOOKUP_NODE); <span class="hljs-comment">// 根据文件偏移page-&gt;index获取物理地址</span><br><br>fio-&gt;old_blkaddr = dn.data_blkaddr; <span class="hljs-comment">// 将旧的物理地址赋值给fio-&gt;old_blkaddr</span><br><br><span class="hljs-keyword">if</span> (fio-&gt;old_blkaddr == NULL_ADDR) &#123; <span class="hljs-comment">// 前面提及到f2fs_file_write_iter已经将物理地址设置为NEW_ADDR或者具体的block号，因此这里表示在写入磁盘之前，用户又将这部分数据删除了，所以没必要写入了</span><br>ClearPageUptodate(page);<br><span class="hljs-keyword">goto</span> out_writepage;<br>&#125;<br>got_it:<br><span class="hljs-keyword">if</span> (ipu_force || (is_valid_blkaddr(fio-&gt;old_blkaddr) &amp;&amp;<br>need_inplace_update(fio))) &#123; <span class="hljs-comment">// 判断是否需要就地更新</span><br>err = encrypt_one_page(fio);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> out_writepage;<br><br>set_page_writeback(page);<br>ClearPageError(page);<br>f2fs_put_dnode(&amp;dn);<br><span class="hljs-keyword">if</span> (fio-&gt;need_lock == LOCK_REQ)<br>f2fs_unlock_op(fio-&gt;sbi);<br>err = f2fs_inplace_write_data(fio); <span class="hljs-comment">// 使用就地更新的方式写入</span><br>trace_f2fs_do_write_data_page(fio-&gt;page, IPU);<br>set_inode_flag(inode, FI_UPDATE_WRITE);<br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br>err = encrypt_one_page(fio); <span class="hljs-comment">// 如果开启系统加密，会将这个fio-&gt;page先加密</span><br><br>set_page_writeback(page);<br>ClearPageError(page);<br><br>f2fs_outplace_write_data(&amp;dn, fio); <span class="hljs-comment">// 执行异地更新函数</span><br><br>set_inode_flag(inode, FI_APPEND_WRITE);<br><span class="hljs-keyword">if</span> (page-&gt;index == <span class="hljs-number">0</span>)<br>set_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);<br>out_writepage:<br>f2fs_put_dnode(&amp;dn);<br>out:<br><span class="hljs-keyword">if</span> (fio-&gt;need_lock == LOCK_REQ)<br>f2fs_unlock_op(fio-&gt;sbi);<br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>f2fs_outplace_write_data</strong>函数</p><p>这个函数主要用作异地更新，所谓异地更新即不在原先的物理地址更新数据，因此包含了如下四个步骤:</p><ol><li>分配一个新的物理地址</li><li>将数据写入新的物理地址</li><li>将旧的物理地址无效掉，然后等GC回收</li><li>更新逻辑地址和物理地址的映射关系</li></ol><p>本函数即完成以上四个步骤:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_outplace_write_data</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dnode_of_data *dn,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> f2fs_io_info *fio)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_sb_info</span> *<span class="hljs-title">sbi</span> =</span> fio-&gt;sbi;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_summary</span> <span class="hljs-title">sum</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_info</span> <span class="hljs-title">ni</span>;</span><br><br>f2fs_get_node_info(sbi, dn-&gt;nid, &amp;ni);<br>set_summary(&amp;sum, dn-&gt;nid, dn-&gt;ofs_in_node, ni.version);<br><br>do_write_page(&amp;sum, fio); <span class="hljs-comment">// 这里完成第1,2,3步骤</span><br>f2fs_update_data_blkaddr(dn, fio-&gt;new_blkaddr); <span class="hljs-comment">// 这里完成第四个步骤，重新建立映射</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面多次提及到struct dnode_of_data dn的作用是根据文件inode，找到f2fs_inode或者direct_node，然后再通过文件偏移得到物理地址，因此f2fs_update_data_blkaddr也是通过dnode_of_data将新的物理地址更新到f2fs_inode或者direct_node对应的位置中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_update_data_blkaddr</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dnode_of_data *dn, <span class="hljs-type">block_t</span> blkaddr)</span><br>&#123;<br>dn-&gt;data_blkaddr = blkaddr; <span class="hljs-comment">// 获得新的物理地址</span><br>f2fs_set_data_blkaddr(dn); <span class="hljs-comment">// 更新地址到f2fs_inode或者direct_node</span><br>f2fs_update_extent_cache(dn); <span class="hljs-comment">// 更新cache</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_set_data_blkaddr</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dnode_of_data *dn)</span><br>&#123;<br>f2fs_wait_on_page_writeback(dn-&gt;node_page, NODE, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 因为要更新node，所以要保证当前的node是最新状态</span><br>__set_data_blkaddr(dn);<br><span class="hljs-keyword">if</span> (set_page_dirty(dn-&gt;node_page)) <span class="hljs-comment">// 设置dirty，因为更新后的地址要回写到磁盘记录</span><br>dn-&gt;node_changed = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __set_data_blkaddr(<span class="hljs-keyword">struct</span> dnode_of_data *dn)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_node</span> *<span class="hljs-title">rn</span> =</span> F2FS_NODE(dn-&gt;node_page); <span class="hljs-comment">// 根据node page转换到对应的f2fs_node</span><br>__le32 *addr_array;<br><span class="hljs-type">int</span> base = <span class="hljs-number">0</span>;<br><br>addr_array = blkaddr_in_node(rn); <span class="hljs-comment">// 这个用于获得f2fs_inode-&gt;i_addr地址或者direct_node-&gt;addr地址</span><br>addr_array[base + dn-&gt;ofs_in_node] = cpu_to_le32(dn-&gt;data_blkaddr); <span class="hljs-comment">// 根据偏移赋值更新</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> __le32 *<span class="hljs-title function_">blkaddr_in_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_node *node)</span><br>&#123;<br><span class="hljs-comment">// RAW_IS_INODE判断当前node是属于f2fs_inode还是f2fs_node，然后返回物理地址数组指针</span><br><span class="hljs-keyword">return</span> RAW_IS_INODE(node) ? node-&gt;i.i_addr : node-&gt;dn.addr;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>do_write_page</strong>函数</p><p>上一节提及到异地更新的1,2,3步骤都是在这里完成，分别是<code>f2fs_allocate_data_block</code>函数完成新物理地址的分配，以及旧物理地址的回收; <code>f2fs_submit_page_write</code>函数完成最后一步，将数据提交到磁盘。下面进行分析:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">do_write_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_summary *sum, <span class="hljs-keyword">struct</span> f2fs_io_info *fio)</span><br>&#123;<br><span class="hljs-type">int</span> type = __get_segment_type(fio); <span class="hljs-comment">// 获取数据类型，这个类型指HOT/WARM/COLD X NODE/DATA的六种类型</span><br><br>f2fs_allocate_data_block(fio-&gt;sbi, fio-&gt;page, fio-&gt;old_blkaddr,<br>&amp;fio-&gt;new_blkaddr, sum, type, fio, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 完成异地更新的1,2步</span><br><br>f2fs_submit_page_write(fio); <span class="hljs-comment">//完成异地更新的第3步</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>f2fs_allocate_data_block</code>函数首先会根据type获得CURSEG。然后在CURSEG分配一个新的物理块，然后将旧的物理块无效掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_allocate_data_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-keyword">struct</span> page *page,</span><br><span class="hljs-params"><span class="hljs-type">block_t</span> old_blkaddr, <span class="hljs-type">block_t</span> *new_blkaddr,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> f2fs_summary *sum, <span class="hljs-type">int</span> type,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> f2fs_io_info *fio, <span class="hljs-type">bool</span> add_list)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_info</span> *<span class="hljs-title">sit_i</span> =</span> SIT_I(sbi);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg</span> =</span> CURSEG_I(sbi, type);<br><br>*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg); <span class="hljs-comment">// 获取新的物理地址</span><br><br>__add_sum_entry(sbi, type, sum); <span class="hljs-comment">// 将当前summary更新到CURSEG中</span><br><br>__refresh_next_blkoff(sbi, curseg); <span class="hljs-comment">// 更新下一次可以用的物理地址</span><br><br><span class="hljs-comment">// 下面更新主要是更新SIT区域的segment信息</span><br><br><span class="hljs-comment">// 根据new_blkaddr找到对应的sit_entry，然后更新状态为valid(值为1)，表示被用户使用，不可被其他人所使用</span><br>update_sit_entry(sbi, *new_blkaddr, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 根据old_blkaddr找到对应的sit_entry，然后更新状态为invalid(值为-1)，表示被覆盖了，等待GC回收后重新投入使用</span><br><span class="hljs-keyword">if</span> (GET_SEGNO(sbi, old_blkaddr) != NULL_SEGNO)<br>update_sit_entry(sbi, old_blkaddr, <span class="hljs-number">-1</span>);<br><br><span class="hljs-comment">// 如果当前segment没有空间进行下一次分配了，就分配一个新的segment给CURSEG</span><br><span class="hljs-keyword">if</span> (!__has_curseg_space(sbi, type))<br>sit_i-&gt;s_ops-&gt;allocate_segment(sbi, type, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 将segment设置为脏，等CP写回磁盘</span><br>locate_dirty_segment(sbi, GET_SEGNO(sbi, old_blkaddr));<br>locate_dirty_segment(sbi, GET_SEGNO(sbi, *new_blkaddr));<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>f2fs_submit_page_write</code>完成最后的提交到磁盘的任务，具体步骤是先创建一个bio，然后将page加入到bio中，如果bio满了就提交到磁盘。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_submit_page_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_io_info *fio)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_sb_info</span> *<span class="hljs-title">sbi</span> =</span> fio-&gt;sbi;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">page_type</span> <span class="hljs-title">btype</span> =</span> PAGE_TYPE_OF_BIO(fio-&gt;type);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_bio_info</span> *<span class="hljs-title">io</span> =</span> sbi-&gt;write_io[btype] + fio-&gt;temp; <span class="hljs-comment">// 这个是F2FS用于临时存放bio的变量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">bio_page</span>;</span><br><br>down_write(&amp;io-&gt;io_rwsem);<br>next:<br><span class="hljs-comment">// 第一步根据是否有加密，将bio_page设置为对应的page</span><br><span class="hljs-keyword">if</span> (fio-&gt;encrypted_page)<br>bio_page = fio-&gt;encrypted_page;<br><span class="hljs-keyword">else</span><br>bio_page = fio-&gt;page;<br><br>fio-&gt;submitted = <span class="hljs-literal">true</span>;<br><br>alloc_new:<br><span class="hljs-comment">// 如果bio是null，就创建一个新的bio</span><br><span class="hljs-keyword">if</span> (io-&gt;bio == <span class="hljs-literal">NULL</span>) &#123;<br>io-&gt;bio = __bio_alloc(sbi, fio-&gt;new_blkaddr, fio-&gt;io_wbc,<br>BIO_MAX_PAGES, <span class="hljs-literal">false</span>,<br>fio-&gt;type, fio-&gt;temp); <span class="hljs-comment">// BIO_MAX_PAGES一般等于256</span><br>io-&gt;fio = *fio;<br>&#125;<br><br><span class="hljs-comment">// 将page加入到bio中，如果  &lt; PAGE_SIZE 表示bio已经满了，因此就先将这个bio提交，然后重新分配一个新的bio</span><br><span class="hljs-keyword">if</span> (bio_add_page(io-&gt;bio, bio_page, PAGE_SIZE, <span class="hljs-number">0</span>) &lt; PAGE_SIZE) &#123;<br>__submit_merged_bio(io); <span class="hljs-comment">// 提交bio，最终会执行submit_bio函数</span><br><span class="hljs-keyword">goto</span> alloc_new;<br>&#125;<br>out:<br>up_write(&amp;io-&gt;io_rwsem);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，在这个函数，当bio还没有填满page的时候是不会被提交到磁盘的，这是因为F2FS通过增大bio的size提高了写性能。因此，在用户fsync或者系统writeback的时候，为了保证这些page都可以刷写到磁盘，会如f2fs_write_cache_pages函数所介绍一样，通过f2fs_submit_merged_write_cond函数或者其他函数强行提交这个page未满的bio。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文件系统sync</title>
    <link href="/2023/10/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fsync/"/>
    <url>/2023/10/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fsync/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统sync"><a href="#文件系统sync" class="headerlink" title="文件系统sync"></a>文件系统sync</h1><h2 id="1-sync系统调用"><a href="#1-sync系统调用" class="headerlink" title="1.sync系统调用"></a>1.sync系统调用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE0(sync)<br>&#123;<br>ksys_sync();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ksys_sync</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> nowait = <span class="hljs-number">0</span>, wait = <span class="hljs-number">1</span>;<br><br>wakeup_flusher_threads(WB_REASON_SYNC);<br>iterate_supers(sync_inodes_one_sb, <span class="hljs-literal">NULL</span>);<br>iterate_supers(sync_fs_one_sb, &amp;nowait);<br>iterate_supers(sync_fs_one_sb, &amp;wait);<br>iterate_bdevs(fdatawrite_one_bdev, <span class="hljs-literal">NULL</span>);<br>iterate_bdevs(fdatawait_one_bdev, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (unlikely(laptop_mode))<br>laptop_sync_completion();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-1-唤醒刷新队列线程"><a href="#1-1-唤醒刷新队列线程" class="headerlink" title="1.1 唤醒刷新队列线程"></a>1.1 唤醒刷新队列线程</h3><h3 id="1-2-同步系统重所有文件系统下面的文件"><a href="#1-2-同步系统重所有文件系统下面的文件" class="headerlink" title="1.2 同步系统重所有文件系统下面的文件"></a>1.2 同步系统重所有文件系统下面的文件</h3><h4 id="1-2-1-iterate-supers遍历所有文件系统的超级块"><a href="#1-2-1-iterate-supers遍历所有文件系统的超级块" class="headerlink" title="1.2.1 iterate_supers遍历所有文件系统的超级块"></a>1.2.1 iterate_supers遍历所有文件系统的超级块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">iterate_supers</span><span class="hljs-params">(<span class="hljs-type">void</span> (*f)(<span class="hljs-keyword">struct</span> super_block *, <span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span>, *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;<br><br>list_for_each_entry(sb, &amp;super_blocks, s_list) &#123;<br><span class="hljs-keyword">if</span> (hlist_unhashed(&amp;sb-&gt;s_instances))<br><span class="hljs-keyword">continue</span>;<br>sb-&gt;s_count++;<br><span class="hljs-keyword">if</span> (sb-&gt;s_root &amp;&amp; (sb-&gt;s_flags &amp; SB_BORN))<br>f(sb, arg);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>list_for_each_entry遍历s_list，并依次调用传进来的函数指针（sync_inodes_one_sb，sync_fs_one_sb等等）</p><ul><li>s_list是super_block中的成员变量，所有文件系统的超级块添加到全局链表s_lists中</li></ul><img src="/2023/10/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fsync/1.png" alt="在这里插入图片描述" style="zoom:75%;"><h4 id="1-2-2-sync-inodes-one-sb"><a href="#1-2-2-sync-inodes-one-sb" class="headerlink" title="1.2.2 sync_inodes_one_sb"></a>1.2.2 sync_inodes_one_sb</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sync_inodes_one_sb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">void</span> *arg)</span><br>&#123;<br><span class="hljs-keyword">if</span> (!sb_rdonly(sb))<br>sync_inodes_sb(sb);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sync_inodes_sb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">backing_dev_info</span> *<span class="hljs-title">bdi</span> =</span> sb-&gt;s_bdi;<br>DEFINE_WB_COMPLETION(done, bdi);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wb_writeback_work</span> <span class="hljs-title">work</span> =</span> &#123;<br>.sb= sb,<br>.sync_mode= WB_SYNC_ALL,<br>.nr_pages= LONG_MAX,<br>.range_cyclic= <span class="hljs-number">0</span>,<br>.done= &amp;done,<br>.reason= WB_REASON_SYNC,<br>.for_sync= <span class="hljs-number">1</span>,<br>&#125;;<br><br><br>bdi_split_work_to_wbs(bdi, &amp;work, <span class="hljs-literal">false</span>);<br>wb_wait_for_completion(&amp;done);<br><br>wait_sb_inodes(sb);<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">bdi_split_work_to_wbs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> backing_dev_info *bdi,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> wb_writeback_work *base_work,</span><br><span class="hljs-params">  <span class="hljs-type">bool</span> skip_if_busy)</span><br>&#123;<br>might_sleep();<br><br><span class="hljs-keyword">if</span> (!skip_if_busy || !writeback_in_progress(&amp;bdi-&gt;wb)) &#123;<br>base_work-&gt;auto_free = <span class="hljs-number">0</span>;<br>wb_queue_work(&amp;bdi-&gt;wb, base_work);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>创建一个work，插入到bdi的回写队列<strong>work_list</strong>中，等待dwork的wb_workfn线程将其刷写到磁盘</p><h4 id="1-2-3"><a href="#1-2-3" class="headerlink" title="1.2.3"></a>1.2.3</h4><h4 id="fdatawrite-one-bdev"><a href="#fdatawrite-one-bdev" class="headerlink" title="fdatawrite_one_bdev"></a>fdatawrite_one_bdev</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">fdatawrite_one_bdev</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> block_device *bdev, <span class="hljs-type">void</span> *arg)</span><br>&#123;<br>filemap_fdatawrite(bdev-&gt;bd_inode-&gt;i_mapping);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">filemap_fdatawrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> address_space *mapping)</span><br>&#123;<br><span class="hljs-keyword">return</span> __filemap_fdatawrite(mapping, WB_SYNC_ALL);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> __filemap_fdatawrite(<span class="hljs-keyword">struct</span> address_space *mapping,<br><span class="hljs-type">int</span> sync_mode)<br>&#123;<br><span class="hljs-keyword">return</span> __filemap_fdatawrite_range(mapping, <span class="hljs-number">0</span>, LLONG_MAX, sync_mode);<br>&#125;<br><br><span class="hljs-type">int</span> __filemap_fdatawrite_range(<span class="hljs-keyword">struct</span> address_space *mapping, <span class="hljs-type">loff_t</span> start,<br><span class="hljs-type">loff_t</span> end, <span class="hljs-type">int</span> sync_mode)<br>&#123;<br><span class="hljs-type">int</span> ret;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">writeback_control</span> <span class="hljs-title">wbc</span> =</span> &#123;<br>.sync_mode = sync_mode,<br>.nr_to_write = LONG_MAX,<br>.range_start = start,<br>.range_end = end,<br>&#125;;<br><br>wbc_attach_fdatawrite_inode(&amp;wbc, mapping-&gt;host);<br>ret = do_writepages(mapping, &amp;wbc);<br>wbc_detach_inode(&amp;wbc);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终还是调用到了do_writepages接口【参考：<a href="https://anmuxixixi.github.io/2023/10/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fdo-writepages%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">文件系统do_writepages流程分析</a>】</p><h2 id="2-知识补充"><a href="#2-知识补充" class="headerlink" title="2.知识补充"></a>2.知识补充</h2><h3 id="2-1-bdi脏页回写涉及的数据结构简介"><a href="#2-1-bdi脏页回写涉及的数据结构简介" class="headerlink" title="2.1 bdi脏页回写涉及的数据结构简介"></a>2.1 bdi脏页回写涉及的数据结构简介</h3><blockquote><p>转载自：</p><ul><li><a href="https://blog.csdn.net/hu1610552336/article/details/115315770">https://blog.csdn.net/hu1610552336/article/details/115315770</a></li><li><a href="https://zhuanlan.zhihu.com/p/614053726">https://zhuanlan.zhihu.com/p/614053726</a></li></ul></blockquote><h4 id="2-1-1-backing-dev-info"><a href="#2-1-1-backing-dev-info" class="headerlink" title="2.1.1 backing_dev_info"></a>2.1.1 backing_dev_info</h4><p>每个块设备对应一个该结构体struct block_device-&gt;bd_bdi，用于管理脏页信息，回写任务等。</p><p>🎆<strong>每个backing_dev_info都挂在bdi_list链表下面</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">backing_dev_info</span> &#123;</span><br><span class="hljs-comment">// 管理所有的backing_dev_info的链表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">bdi_list</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ra_pages;<span class="hljs-comment">/* max readahead in PAGE_SIZE units */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> io_pages;<span class="hljs-comment">/* max allowed IO size */</span><br>congested_fn *congested_fn; <span class="hljs-comment">/* Function pointer if device is md/dm */</span><br><span class="hljs-type">void</span> *congested_data;<span class="hljs-comment">/* Pointer to aux data for congested func */</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kref</span> <span class="hljs-title">refcnt</span>;</span><span class="hljs-comment">/* Reference counter for the structure */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> capabilities; <span class="hljs-comment">/* Device capabilities */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> min_ratio;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_ratio, max_prop_frac;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Sum of avg_write_bw of wbs with dirty inodes.  &gt; 0 if there are</span><br><span class="hljs-comment"> * any dirty wbs, which is depended upon by bdi_has_dirty().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">atomic_long_t</span> tot_write_bandwidth;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bdi_writeback</span> <span class="hljs-title">wb</span>;</span>  <span class="hljs-comment">/* the root writeback info for this bdi */</span><br><span class="hljs-comment">// 管理bdi_writeback成员</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">wb_list</span>;</span> <span class="hljs-comment">/* list of all wbs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_root</span> <span class="hljs-title">cgwb_tree</span>;</span> <span class="hljs-comment">/* radix tree of active cgroup wbs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">cgwb_congested_tree</span>;</span> <span class="hljs-comment">/* their congested states */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">cgwb_release_mutex</span>;</span>  <span class="hljs-comment">/* protect shutdown of wb structs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bdi_writeback_congested</span> *<span class="hljs-title">wb_congested</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">wait_queue_head_t</span> wb_waitq;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">owner</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">laptop_mode_wb_timer</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_FS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">debug_dir</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">debug_stats</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>每一个块设备在驱动初始化时会分配一个块设备专属的运行队列struct request_queue，<strong>request_queue有一个成员struct backing_dev_info</strong> ，这就是传说中的bdi数据结构，是脏页回写母体吧。这里需要说明一下，<strong>每个块设备都有一个唯一的struct backing_dev_info结构</strong>。</p><p>struct backing_dev_info的成员struct bdi_writeback在实际脏页回写代码中出现频率较高，它的成员都挺关键的，这里先只介绍struct delayed_work dwork，这与脏页回写进程有关。每个块设备的脏页回写就是靠struct delayed_work dwork插入到bdi脏页回写队列，然后脏页回写进程再从这个队列取出dwork，顺藤摸瓜找到块设备的struct backing_dev_info，然后才能进行实际的脏页回写。</p><h4 id="2-1-2-wb-writeback-work"><a href="#2-1-2-wb-writeback-work" class="headerlink" title="2.1.2 wb_writeback_work"></a>2.1.2 wb_writeback_work</h4><p>用于回写任务描述，一次回写请求就创建一个wb_writeback_work</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Passed into wb_writeback(), essentially a subset of writeback_control</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wb_writeback_work</span> &#123;</span><br><span class="hljs-comment">// 本次回写的页数限制</span><br><span class="hljs-type">long</span> nr_pages;<br><span class="hljs-comment">// 回写的文件系统的超级块</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span>;</span><br><span class="hljs-comment">// 回写的模式</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">writeback_sync_modes</span> <span class="hljs-title">sync_mode</span>;</span><br><span class="hljs-comment">// tag-and-write 机制标记</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tagged_writepages:<span class="hljs-number">1</span>;<br><span class="hljs-comment">// 定期回写标记</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> for_kupdate:<span class="hljs-number">1</span>;<br><span class="hljs-comment">// 继续上次循环回写标记</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> range_cyclic:<span class="hljs-number">1</span>;<br><span class="hljs-comment">// 阈值回写标记</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> for_background:<span class="hljs-number">1</span>;<br><span class="hljs-comment">// sync 系统调用标记</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> for_sync:<span class="hljs-number">1</span>;<span class="hljs-comment">/* sync(2) WB_SYNC_ALL writeback */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> auto_free:<span class="hljs-number">1</span>;<span class="hljs-comment">/* free on completion */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">wb_reason</span> <span class="hljs-title">reason</span>;</span><span class="hljs-comment">/* why was writeback initiated? */</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><span class="hljs-comment">/* pending work list */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wb_completion</span> *<span class="hljs-title">done</span>;</span><span class="hljs-comment">/* set if the caller waits */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>后续通过 <code>include/linux/writeback.h</code> 中的 <code>writeback_control</code> 结构体封装，传递给底层的 <code>writepages</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * A control structure which tells the writeback code what to do.  These are</span><br><span class="hljs-comment"> * always on the stack, and hence need no locking.  They are always initialised</span><br><span class="hljs-comment"> * in a manner such that unspecified fields are set to zero.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">writeback_control</span> &#123;</span><br><span class="hljs-type">long</span> nr_to_write;<span class="hljs-comment">/* Write this many pages, and decrement</span><br><span class="hljs-comment">   this for each page written */</span><br><span class="hljs-type">long</span> pages_skipped;<span class="hljs-comment">/* Pages which were not written */</span><br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For a_ops-&gt;writepages(): if start or end are non-zero then this is</span><br><span class="hljs-comment"> * a hint that the filesystem need only write out the pages inside that</span><br><span class="hljs-comment"> * byterange.  The byte at `end&#x27; is included in the writeout request.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">loff_t</span> range_start;<br><span class="hljs-type">loff_t</span> range_end;<br> <br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">writeback_sync_modes</span> <span class="hljs-title">sync_mode</span>;</span><br> <br><span class="hljs-type">unsigned</span> for_kupdate:<span class="hljs-number">1</span>;<span class="hljs-comment">/* A kupdate writeback */</span><br><span class="hljs-type">unsigned</span> for_background:<span class="hljs-number">1</span>;<span class="hljs-comment">/* A background writeback */</span><br><span class="hljs-type">unsigned</span> tagged_writepages:<span class="hljs-number">1</span>;<span class="hljs-comment">/* tag-and-write to avoid livelock */</span><br><span class="hljs-type">unsigned</span> for_reclaim:<span class="hljs-number">1</span>;<span class="hljs-comment">/* Invoked from the page allocator */</span><br><span class="hljs-type">unsigned</span> range_cyclic:<span class="hljs-number">1</span>;<span class="hljs-comment">/* range_start is cyclic */</span><br><span class="hljs-type">unsigned</span> for_sync:<span class="hljs-number">1</span>;<span class="hljs-comment">/* sync(2) WB_SYNC_ALL writeback */</span><br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When writeback IOs are bounced through async layers, only the</span><br><span class="hljs-comment"> * initial synchronous phase should be accounted towards inode</span><br><span class="hljs-comment"> * cgroup ownership arbitration to avoid confusion.  Later stages</span><br><span class="hljs-comment"> * can set the following flag to disable the accounting.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> no_cgroup_owner:<span class="hljs-number">1</span>;<br> <br><span class="hljs-type">unsigned</span> punt_to_cgroup:<span class="hljs-number">1</span>;<span class="hljs-comment">/* cgrp punting, see __REQ_CGROUP_PUNT */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bdi_writeback</span> *<span class="hljs-title">wb</span>;</span><span class="hljs-comment">/* wb this writeback is issued under */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span>;</span><span class="hljs-comment">/* inode being written out */</span><br> <br><span class="hljs-comment">/* foreign inode detection, see wbc_detach_inode() */</span><br><span class="hljs-type">int</span> wb_id;<span class="hljs-comment">/* current wb id */</span><br><span class="hljs-type">int</span> wb_lcand_id;<span class="hljs-comment">/* last foreign candidate wb id */</span><br><span class="hljs-type">int</span> wb_tcand_id;<span class="hljs-comment">/* this foreign candidate wb id */</span><br><span class="hljs-type">size_t</span> wb_bytes;<span class="hljs-comment">/* bytes written by current wb */</span><br><span class="hljs-type">size_t</span> wb_lcand_bytes;<span class="hljs-comment">/* bytes written by last candidate */</span><br><span class="hljs-type">size_t</span> wb_tcand_bytes;<span class="hljs-comment">/* bytes written by this candidate */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-1-3-bdi-writeback"><a href="#2-1-3-bdi-writeback" class="headerlink" title="2.1.3 bdi_writeback"></a>2.1.3 bdi_writeback</h4><p>主要用于记录本块设备上需要回写的脏页，同时设置回写work。每次有个回写任务就创建一个wb_writeback_work，管理在work_list链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bdi_writeback</span> &#123;</span><br>...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">b_dirty</span>;</span>   <span class="hljs-comment">/* dirty inodes */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">b_io</span>;</span>      <span class="hljs-comment">/* parked for writeback */</span><br>...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">delayed_work</span> <span class="hljs-title">dwork</span>;</span>  <span class="hljs-comment">/* work item used for writeback */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">work_list</span>;</span><br>...<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>b_dirty：用来存放文件系统中所有的脏页</p></li><li><p>b_io：用来存放准备写回到存储设备的<code>inode</code></p></li><li><p>dwork：负责把脏页写回到存储设备。 对应的函数是<code>wb_workfn</code></p></li><li><p>work_list：每一个回写任务为一个work, 会被链接到这个链表上来</p></li></ul><h4 id="2-1-4-各结构体的关系"><a href="#2-1-4-各结构体的关系" class="headerlink" title="2.1.4 各结构体的关系"></a>2.1.4 各结构体的关系</h4><img src="/2023/10/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fsync/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N3ZWVOZWls,size_16,color_FFFFFF,t_70.jpeg" alt="img"><img src="/2023/10/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fsync/2.png" alt="在这里插入图片描述" style="zoom:75%;"><ul><li><p><strong>一个块设备</strong>对应唯一的一个request_queue，一个request_queue又对应了一个backing_dev_info</p><ul><li><strong>所有块设备</strong>的backing_dev_info通过全局链表bdi_list进行管理</li></ul></li><li><p>bdi回写队列work_list，每一个回写任务为<strong>wb_writeback_work</strong>（通常说的一个work），通过链表<strong>work_list</strong>管理</p></li><li><p>bdi_writeback对应了本块设备的回写信息，它有一个成员变量为dwork，将要回写的脏页添加到脏页链表work_list中</p><ul><li>脏页回写线程会从脏页回写队列work_list中取出dwork，然后调用其脏页回写函数wb_workfn进行脏页回写</li></ul></li><li><p>可参阅：<a href="https://blog.csdn.net/bin_linux96/article/details/121612699">https://blog.csdn.net/bin_linux96/article/details/121612699</a></p></li></ul><h3 id="2-2-bdi回写机制"><a href="#2-2-bdi回写机制" class="headerlink" title="2.2 bdi回写机制"></a>2.2 bdi回写机制</h3><p>bdi_writeback中的成员变量dwork在初始化函数<strong>wb_init</strong>时会初始化一个定时器和到时处理函数<strong>wb_workfn</strong>【也就是说每隔一段时间就会做一次bdi脏页回写】</p><p>wb_workfn中会执行wb_do_writeback回写脏页，最终会调用文件系统的接口<strong>do_writepages</strong></p><blockquote><p>图片源自：<a href="https://blog.csdn.net/bin_linux96/article/details/121612699">https://blog.csdn.net/bin_linux96/article/details/121612699</a></p></blockquote><img src="/2023/10/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fsync/a41f4a8da8c6b63a196491db581da635.png" alt="a41f4a8da8c6b63a196491db581da635.png" style="zoom:67%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>USB接口与协议</title>
    <link href="/2023/10/09/USB%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/10/09/USB%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="USB接口与协议"><a href="#USB接口与协议" class="headerlink" title="USB接口与协议"></a>USB接口与协议</h1><h2 id="1-USB传输协议"><a href="#1-USB传输协议" class="headerlink" title="1.USB传输协议"></a>1.USB传输协议</h2><blockquote><p>转载自：<a href="https://post.smzdm.com/p/aqmdp2q2/">https://post.smzdm.com/p/aqmdp2q2/</a></p></blockquote><img src="/2023/10/09/USB%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/648dd0a361dac9878.png_e1080.jpg" alt="一文带你看懂所有USB接口类型，Micro-USB和USB-C傻傻分不清？" style="zoom:80%;"><p>USB 3.0系列经历过两次重命名，记着Gen后面数字越大，版本越新就可以了。但同时你也要提防别人用USB 3.2来忽悠你：</p><p>把USB 3.0说成USB 3.2 Gen1，第一反应好像是3.2 Gen1要牛一点，其实就是一种东西不同叫法。</p><p>按大类来说，目前USB的传输协议分为USB 2.0、USB 3.2、USB4三大类。</p><ul><li>USB 1.0速率太慢，早已被淘汰</li><li>USB 2.0处于被淘汰的边缘，需注意的是，不是所有USB 2.0的传输速度都是480Mbps，USB 2.0又分为低速、全速和高速版：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">低速版1.5Mbps（即1.5MB/8=192KB/s）<br>全速版12Mbps（即12MB/8=1.5MB/s）<br>高速版480Mbps（即480MB/8=60MB/s<br></code></pre></td></tr></table></figure><ul><li>类似，USB 3.0也拥有三个版本，分别是3.2 Gen1、3.2 Gen2×1、3.2 Gen2×2：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">USB3.2 Gen1 5Gbps（即5GB/8=640MB/s）<br>USB3.2 Gen2×1 10Gbps（即10GB/8=1280MB/s）<br>USB3.2 Gen2×2 20Gbps（即20GB/8=2560MB/s）<br></code></pre></td></tr></table></figure><p>这不禁让人想到高通骁龙8 Gen1、8+ Gen1、8 Gen2这些拗口的命名。</p><p>USB4相当于USB3.2+雷电3的组合，也就是说你的设备上有USB4接口，理论上就能外接雷电3的设备。好消息是，最新的USB4仅支持Type-C，且命名非常人性化，通俗易懂，直接采用传输速率大小的方式命名，这才是真正意义上做到了统一：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">USB4 20Gbps（即20GB/8=2560MB/s）<br>USB4 40Gbps（即40GB/8=5120MB/s）<br></code></pre></td></tr></table></figure><h2 id="2-雷电协议"><a href="#2-雷电协议" class="headerlink" title="2.雷电协议"></a>2.雷电协议</h2><blockquote><p>推荐视频：<a href="https://www.bilibili.com/video/BV12R4y1C7Ec">https://www.bilibili.com/video/BV12R4y1C7Ec</a></p></blockquote><p>我们常说的雷电接口，本质上也是一种传输协议，全程英文名叫做Thunderbolt。</p><p>Thunderbolt技术融合PCI Express和DisplayPort两种通信协议：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">PCI Express用于数据传输，可以非常方便的进行任何类型设备扩展。<br><br>DisplayPort用于显示，能同步传输1080p乃至超高清视频和最多八声道音频，并且两条通道在传输时都有自己单独的通道，不会产生任何干扰。<br></code></pre></td></tr></table></figure><p>早期的雷电接口外观和原有Mini DisplayPort接口相同，Mini DP接口的显示器以及Mini DP至HDMI&#x2F;DVI&#x2F;VGA等接口的转接头都可在雷电接口上使用，这种雷电接口在早期的Mac上使用。</p><p>而雷电3采用了通用度更高的Type-C物理接口，所以更广为人知。但因为支持雷电3接口的设备价格都非常昂贵，所以雷电3并没有得到普及。直到英特尔宣布向USB开放雷电协议，于是USB4的出现带动了雷电3的普及。</p><p>雷电4则是相较于雷电3更强的接口协议，雷电4协议并没有开放，这是英特尔留的底牌。雷电4是目前功能最全的协议，无论是传输速度、视频拓展还是充电都是顶级的接口协议（如下图）。</p><img src="/2023/10/09/USB%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/648dd113403376764.png_e1080.jpg" alt="一文带你看懂所有USB接口类型，Micro-USB和USB-C傻傻分不清？" style="zoom:80%;"><h2 id="3-USB接口"><a href="#3-USB接口" class="headerlink" title="3.USB接口"></a>3.USB接口</h2><blockquote><p>转载自：<a href="https://www.sohu.com/a/513786088_121117077">https://www.sohu.com/a/513786088_121117077</a></p></blockquote><p><strong>1、USB Type-A</strong></p><p>USB Type-A这种接口是比较常用的接口，比如电脑、鼠标、键盘、U盘等等，其外部接口均采用这种接口。目前，这种接口已经由USB 2.0发展到了USB 3.0，传输速率是原来的10倍。<strong>USB 3.0与USB 2.0最大的差别就是3.0的接口部分为蓝色，而2.0的接口部分为黑色。</strong></p><img src="/2023/10/09/USB%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/4d2597090d6c45a39b10b818c5486666.jpeg" alt="img" style="zoom: 33%;"><p><strong>2、USB Type-B</strong></p><p>平时，这种类型的接口并不是很常见，因为它主要用于<strong>大型设备</strong>和<strong>专业领域</strong>。比如打印机、移动硬盘、扫描仪、显示器、大型的连接器、游戏硬件接口；专业领域的有单片机的调试工具Jlink、室内外的电缆布线等。</p><img src="/2023/10/09/USB%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/0dfdab3218944e388dbac45d4e25251d.jpeg" alt="img" style="zoom:33%;"><p><strong>3、USB Type-C</strong></p><p>Type-C的接口是一种全新的USB接口与形式，在国产的Android手机中较为常用。这种接口是USB-IF于2014年8月份发布。真正解决了其他类型USB接口有50%几率插不准的问题，可以实现不分正反面使用，用户可以随意插。除此之外这种接口支持最新的USB 3.1以及100W的供电功率。</p><img src="/2023/10/09/USB%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/b3af0d5c5a004fffb9aea237b3af9d4b.jpeg" alt="img" style="zoom:33%;"><p><strong>4、mini USB</strong></p><p>mini USB在市场的存活时间较短，可以分为A型、B型、AB型等。早期的读卡器、数码相机、移动硬盘、MP3、MP4等电子产品会采用这种接口。现在，已经很少能看到它的存在了。</p><img src="/2023/10/09/USB%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/ff76bd96b1d64dc189f6ea37686de78d.jpeg" alt="img" style="zoom:33%;"><p><strong>5、micro USB</strong></p><p>在USB Type-C没有大量普及之前，这种接口的USB基本上是国产手机的标配，是其充电和数据传输接口。这种接口由USB-IF(Implementers Forum)于2007年制定，内部为5针接口。</p><img src="/2023/10/09/USB%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/u=834000812,3609546457&fm=253&fmt=auto&app=138&f=JPEG.jpeg" alt="img" style="zoom:67%;"><p><strong>6、Lightning</strong></p><p>严格意义这种接口不属于USB中一种。这种接口是<strong>2012</strong>年苹果公司在发布<strong>iPhone 5</strong>的时候推出的。这种接口与USB Type-C类似没有正反的区分，使用起来非常的方便。这接口的传输速度仅仅与<strong>USB 2.0</strong>一样约为<strong>25MB&#x2F;s~35MB&#x2F;s</strong>。可能由于保护苹果供应商的原因，苹果公司迟迟不进行硬件升级。</p><img src="/2023/10/09/USB%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/f032b92647454be5adfbb858a324d5c9.jpeg" alt="img" style="zoom: 33%;">]]></content>
    
    
    <categories>
      
      <category>USB学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统CURSEG备忘</title>
    <link href="/2023/10/08/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FCURSEG%E5%A4%87%E5%BF%98/"/>
    <url>/2023/10/08/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FCURSEG%E5%A4%87%E5%BF%98/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统CURSEG备忘"><a href="#f2fs文件系统CURSEG备忘" class="headerlink" title="f2fs文件系统CURSEG备忘"></a>f2fs文件系统CURSEG备忘</h1><blockquote><p>内容均来自于作者<a href="https://blog.csdn.net/u011649400">HuberyPan</a></p><p>🎮图标的地方仔细阅读一下！</p></blockquote><h2 id="1-f2fs-summary的作用"><a href="#1-f2fs-summary的作用" class="headerlink" title="1.f2fs_summary的作用"></a>1.f2fs_summary的作用</h2><p>有一些场合，需要通过data的物理地址找到保存这个地址的node的信息。例如GC的时候，F2FS会找到一个segment进行GC，将数据块迁移到新的segment中。此时系统要根据segment里面的block的物理地址，反过来找到node的信息，然后将新的数据块物理地址重新更新的node的对应位置。</p><p>因此SSA的<strong>主要</strong>作用是<strong>提供系统通过数据块物理地址找到所属的node的信息的能力</strong>。我们可以直接分析<code>f2fs_summary</code>的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_summary</span> &#123;</span><br>__le32 nid;<span class="hljs-comment">/* parent node id */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__u8 reserved[<span class="hljs-number">3</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u8 version;<span class="hljs-comment">/* node version number */</span><br>__le16 ofs_in_node;<span class="hljs-comment">/* block index in parent node */</span><br>&#125; __packed;<br>&#125;;<br>&#125; __packed;<br></code></pre></td></tr></table></figure><p>系统中每一个<strong>数据块</strong>的物理地址，都对应了一个f2fs_summary，系统可以通过物理地址找到对应的f2fs_summary。f2fs_summary的nid变量表示当前的数据块所属的node的nid。而ofs_in_node则表示当前的数据块位于这个node的第几个block，即**f2fs_inode-&gt;i_addr[ofs_in_node]**或者direct_node-&gt;addr[ofs_in_node]。</p><h2 id="2-Checkpoint在元数据区域的物理结构"><a href="#2-Checkpoint在元数据区域的物理结构" class="headerlink" title="2.Checkpoint在元数据区域的物理结构"></a>2.Checkpoint在元数据区域的物理结构</h2><img src="/2023/10/08/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FCURSEG%E5%A4%87%E5%BF%98/1.png" alt="在这里插入图片描述" style="zoom:80%;"><p>根据上述的结构图，Checkpoint区域由几个部分构成，分别是checkpoint元数据区域(f2fs_checkpoint)、orphan node区域、active segments区域。同时active segments区域在不同的情况下，会有不同的形式，目的是减少IO的写入。接下来分别讨论Checkpoint不同的部分。</p><h3 id="2-1-Checkpoint元数据区域"><a href="#2-1-Checkpoint元数据区域" class="headerlink" title="2.1 Checkpoint元数据区域"></a>2.1 Checkpoint元数据区域</h3><p>F2FS使用数据结构f2fs_checkpoint表示Checkpoint结构，它保存在磁盘中f2fs_super_block之后区域中，数据结构如下。需要特别注意的是<strong>cur_node_segno</strong>、<strong>cur_node_blkoff</strong>、<strong>cur_data_segno</strong>、<strong>cur_data_blkoff</strong>这几个变量。F2FS分为了6个log区域，分别对应<strong>hot node&#x2F;data、warm node&#x2F;data、cold node&#x2F;data</strong>。F2FS必须定时执行Checkpoint去记录当前系统的log分配到哪个位置，否则在系统宕机的时候，会出现数据丢失等一致性问题，因此cur_xxx_segno以及cur_xxx_blkoff记录了上次Checkpoint时，系统正在使用的log的segment number，以及分配到这个segment的哪个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_checkpoint</span> &#123;</span><br>__le64 checkpoint_ver;<span class="hljs-comment">/* CP版本，用于比较新旧版本进行恢复 */</span><br>__le64 user_block_count;<span class="hljs-comment">/* # of user blocks */</span><br>__le64 valid_block_count;<span class="hljs-comment">/* # of valid blocks in main area */</span><br>__le32 rsvd_segment_count;<span class="hljs-comment">/* # of reserved segments for gc */</span><br>__le32 overprov_segment_count;<span class="hljs-comment">/* # of overprovision segments */</span><br>__le32 free_segment_count;<span class="hljs-comment">/* # of free segments in main area */</span><br><br><span class="hljs-comment">/* information of current node segments */</span><br>__le32 cur_node_segno[MAX_ACTIVE_NODE_LOGS];<br>__le16 cur_node_blkoff[MAX_ACTIVE_NODE_LOGS];<br><span class="hljs-comment">/* information of current data segments */</span><br>__le32 cur_data_segno[MAX_ACTIVE_DATA_LOGS];<br>__le16 cur_data_blkoff[MAX_ACTIVE_DATA_LOGS];<br>__le32 ckpt_flags;<span class="hljs-comment">/* Flags : umount and journal_present */</span><br>__le32 cp_pack_total_block_count;<span class="hljs-comment">/* total # of one cp pack */</span><br>__le32 cp_pack_start_sum;<span class="hljs-comment">/* start block number of data summary */</span><br>__le32 valid_node_count;<span class="hljs-comment">/* Total number of valid nodes */</span><br>__le32 valid_inode_count;<span class="hljs-comment">/* Total number of valid inodes */</span><br>__le32 next_free_nid;<span class="hljs-comment">/* Next free node number */</span><br>__le32 sit_ver_bitmap_bytesize;<span class="hljs-comment">/* Default value 64 */</span><br>__le32 nat_ver_bitmap_bytesize; <span class="hljs-comment">/* Default value 256 */</span><br>__le32 checksum_offset;<span class="hljs-comment">/* checksum offset inside cp block */</span><br>__le64 elapsed_time;<span class="hljs-comment">/* mounted time */</span><br><span class="hljs-comment">/* allocation type of current segment */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> alloc_type[MAX_ACTIVE_LOGS];<br><br><span class="hljs-comment">/* SIT and NAT version bitmap */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sit_nat_version_bitmap[<span class="hljs-number">1</span>];<br>&#125; __packed;<br></code></pre></td></tr></table></figure><h3 id="2-2-Active-Segments区域"><a href="#2-2-Active-Segments区域" class="headerlink" title="2.2 Active Segments区域"></a>2.2 Active Segments区域</h3><h4 id="2-2-1-Active-Segments的定义"><a href="#2-2-1-Active-Segments的定义" class="headerlink" title="2.2.1 Active Segments的定义"></a>2.2.1 Active Segments的定义</h4><p>**Active Segments，又称current segment(CURSEG)**，即当前正在用于进行数据分配的log对应的segment，如用户需要写入8KB数据，那么就会从active segments分配两个block提供给用户写入到磁盘中。F2FS为了提高数据分配的效率，根据数据的特性，一共定义了6个active segment，这6个active segments对应了(how, warm, cold) X (node, data)的数据。</p><h4 id="2-2-2-Active-Segment与恢复相关的数据结构"><a href="#2-2-2-Active-Segment与恢复相关的数据结构" class="headerlink" title="2.2.2 Active Segment与恢复相关的数据结构"></a>2.2.2 Active Segment与恢复相关的数据结构</h4><p>CP的主要任务是维护数据一致性，因此CP的active segment区域的主要任务是维护Active Segment的分配状态，使系统宕机时候可以恢复正常。维护active segment需要维护三种信息，分别是f2fs_checkpoint的信息，以及该segment对应的journal和summary的信息。</p><ul><li>f2fs_checkpoint中Active Segment信息：从上面给出的f2fs_checkpoint定义，cur_node_segno[MAX_ACTIVE_NODE_LOGS]和cur_data_segno[MAX_ACTIVE_DATA_LOGS]表示node和data当前的Active Segment的编号(segment number, segno)，系统可以通过这个编号找到对应的segment。MAX_ACTIVE_NODE_LOGS以及MAX_ACTIVE_NODE_LOGS分别表示data和node有多少种类型，F2FS默认情况下都等于3，即HOT、WARM、COLD类型数据。cur_node_blkoff[MAX_ACTIVE_NODE_LOGS]以及cur_data_blkoff[MAX_ACTIVE_DATA_LOGS]则分别表示当前active segment分配到哪一个block(一个segment包含了512个block)。</li><li>Segment对应的Journal信息：Journal在两处地方都有出现，分别是CP区域以及SSA区域。🎮<strong>CP区域的journal主要用来保存active segment的修改信息，而SSA区域的则是持久化保存的所有的segment的journal信息。</strong>如系统分配出一个block给用户，那么就要将这个block所在的segment的bitmap中标记为已分配，防止其他写请求使用。分两个区域存放journal是为了减轻频繁更新导致的系统性能下降。例如，当系统写压力很大的时候，bitmap就会频繁被更新，如果这个时候频繁将bitmap写入SIT，就会加重写压力。因此CP区域的Journal的作用就是维护这些经常修改的数据，等待CP被触发的时候才回写到闪存设备，从而减少写压力，提高闪存寿命。</li><li>Segment对应的Summary信息：summary同样在CP区域和SSA区域有出现，它表示的是逻辑地址和物理地址的映射关系，这个映射关系会使用到GC流程中。summary与segment是一对一的关系，一个summary保存了一个segment所有的block的物理地址和逻辑地址的映射关系。summary保存在CP区域中同样是出于减少IO的写入。</li></ul><h3 id="2-3-Checkpoint内存管理结构"><a href="#2-3-Checkpoint内存管理结构" class="headerlink" title="2.3 Checkpoint内存管理结构"></a>2.3 Checkpoint内存管理结构</h3><p>Checkpoint的内存管理结构是struct f2fs_checkpoint本身，因为Checkpoint一般只在F2FS启动的时候被读取数据，用于数据恢复，而在运行过程中大部分情况都是被写，用于记录恢复信息。因此，Checkpoint不需要过于复杂的内存管理结构，因此使用struct f2fs_checkpoint本身即可以满足需求。</p><p>另一方面，🎮<strong>active segments，即F2FS的log，主要用于系统free block的分配</strong>，因此需要特定的管理结构struct curseg_info进行管理，它的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">curseg_mutex</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_summary_block</span> *<span class="hljs-title">sum_blk</span>;</span><span class="hljs-comment">/* 每一个segment对应一个summary block */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span> <span class="hljs-title">journal_rwsem</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_journal</span> *<span class="hljs-title">journal</span>;</span><span class="hljs-comment">/*每一个segment对应一个 info */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> alloc_type;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> segno;<span class="hljs-comment">/* 当前segno */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> next_blkoff;<span class="hljs-comment">/* 记录当前segment用于分配的下一个给block号 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> zone;<span class="hljs-comment">/* current zone number */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> next_segno;<span class="hljs-comment">/* 当前segno用完以后，下个即将用来分配的segno */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>从结构分析可以直到，curseg_info记录当前的segment的分配信息，当系统出现宕机的时候，可以从CP记录的curseg_info恢复当上一次CP点的状态。</p><p>🎮 <strong>每一种类型的active segment就对应一个struct curseg_info结构</strong>。在F2FS中，使用一个数组来表示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_sm_info</span> &#123;</span><br>...<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg_array</span>;</span> <span class="hljs-comment">// 默认是分配6个curseg_info，分别对应不同类型</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>struct f2fs_sm_info</code>是SIT的管理结构，它也管理了CP最终的active segment的信息，是一个跨区域的管理结构。</p><h2 id="3-元数据区SSA区域"><a href="#3-元数据区SSA区域" class="headerlink" title="3.元数据区SSA区域"></a>3.元数据区SSA区域</h2><img src="/2023/10/08/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FCURSEG%E5%A4%87%E5%BF%98/2.png" alt="在这里插入图片描述" style="zoom:80%;"><h3 id="3-1-SSA物理存放区域结构"><a href="#3-1-SSA物理存放区域结构" class="headerlink" title="3.1 SSA物理存放区域结构"></a>3.1 SSA物理存放区域结构</h3><p>SSA的基本存放单元是<code>struct f2fs_summary_block</code>，它结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_summary_block</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_summary</span> <span class="hljs-title">entries</span>[<span class="hljs-title">ENTRIES_IN_SUM</span>];</span> <span class="hljs-comment">// ENTRIES_IN_SUM = 512</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_journal</span> <span class="hljs-title">journal</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">summary_footer</span> <span class="hljs-title">footer</span>;</span><br>&#125; __packed;<br></code></pre></td></tr></table></figure><p>与summary直接相关的是<code>struct f2fs_summary</code>以及<code>struct summary_footer</code>。<code>ENTRIES_IN_SUM</code>的值512，因此每一个entry对应一个block，记录了从物理地址到逻辑地址的映射关系，entry的结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_summary</span> &#123;</span><br>__le32 nid;<span class="hljs-comment">/* parent node id */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__u8 reserved[<span class="hljs-number">3</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u8 version;<span class="hljs-comment">/* node version number */</span><br>__le16 ofs_in_node;<span class="hljs-comment">/* block index in parent node */</span><br>&#125; __packed;<br>&#125;;<br>&#125; __packed;<br></code></pre></td></tr></table></figure><p>用了一个union结构进行表示，但是核心信息是nid、version以及ofs_in_node。数据的索引是通过node来进行，文件访问某一个页的数据时，需要首先根据页的索引，找到对应的nid以及offset(两者构成逻辑地址)，从而根据nid得到node page，再根据offset得到了该页的物理地址，然后从磁盘中读取出来。f2fs_summary则是记录物理地址到逻辑地址的映射，即根据物理地址找到对应的nid以及offset。例如，现在需要根据物理地址为624的block，找到对应的nid以及offset。那么物理地址为624，可以得到该地址位于第二个segment，然后属于第二个segment的第113个block(block的编址从0开始)。因此根据属于第二个segment的信息，找到第二个struct f2fs_summary_block，然后根据偏移量为113的信息，找到对应的struct f2fs_summary结构，从而得到nid以及ofs_in_node。</p><p>struct summary_footer结构记录了校验信息，以及这个summary对应的segment是<strong>属于保存data数据的segment还是node数据的segment</strong>。</p><h3 id="3-2-SSA内存管理结构"><a href="#3-2-SSA内存管理结构" class="headerlink" title="3.2 SSA内存管理结构"></a>3.2 SSA内存管理结构</h3><p>SSA在内存没有单独的管理结构，summary以及journal在内存中主要存在于<code>CURSEG</code>中，可以从Checkpoint结构这一章节（第2节）找到相关的描述。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux内核链表</title>
    <link href="/2023/10/07/linux%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/10/07/linux%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="linux内核链表"><a href="#linux内核链表" class="headerlink" title="linux内核链表"></a>linux内核链表</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/to_be_better_wen/article/details/127720433">https://blog.csdn.net/to_be_better_wen/article/details/127720433</a></p></blockquote><h2 id="一、Linux内核链表简介"><a href="#一、Linux内核链表简介" class="headerlink" title="一、Linux内核链表简介"></a>一、Linux内核链表简介</h2><p>Linux内核中需要经常用到双链表，该链表只有指针域，没有数据域。在很多的数据结构中都会嵌入struct list_head结构体变量，它可以使结构体加入到一个双向链表中。链表的初始化，增加，删除等操作的接口在linux-x.x.x&#x2F;include&#x2F;linux&#x2F;list.h里面，内核链表在内核中使用的是如此广泛，所以需要深刻的理解。</p><h2 id="二、Linux内核链表使用介绍"><a href="#二、Linux内核链表使用介绍" class="headerlink" title="二、Linux内核链表使用介绍"></a>二、Linux内核链表使用介绍</h2><p><strong>1.基本数据结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">next</span>, *<span class="hljs-title">prev</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>从结构体成员看，内核链表是一个双向链表，没有数据域，next指向下一个链表元素，prev指向上一个链表元素。</p><p><strong>2. 链表的初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_HEAD(name) \</span><br><span class="hljs-meta">struct list_head name = LIST_HEAD_INIT(name)</span><br></code></pre></td></tr></table></figure><p>链表声明和初始化的通常用LIST_HEAD(name)处理。LIST_HEAD定义了一个变量struct list变量name，并且name的next和prev指针都指向name的地址。如下图所示：</p><img src="/2023/10/07/linux%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/c8f72d6a3d554bc79ecb1d4076cd45ed.png" alt="img" style="zoom: 80%;"><p><strong>3.链表元素添加</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __list_add(<span class="hljs-keyword">struct</span> list_head *new,<br>      <span class="hljs-keyword">struct</span> list_head *prev,<br>      <span class="hljs-keyword">struct</span> list_head *next)<br>&#123;<br>next-&gt;prev = new;<br>new-&gt;next = next;<br>new-&gt;prev = prev;<br>prev-&gt;next = new;<br>&#125;<br> <br># 向头部添加 (在链表头指针和链表第一个元素之间插入元素)<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">list_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_head *new, <span class="hljs-keyword">struct</span> list_head *head)</span><br>&#123;<br>__list_add(new, head, head-&gt;next);<br>&#125;<br> <br># 向尾部添加 (在链表最后一个元素和链表头指针之间插入元素)<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">list_add_tail</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_head *new, <span class="hljs-keyword">struct</span> list_head *head)</span><br>&#123;<br>__list_add(new, head-&gt;prev, head);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/10/07/linux%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/7acf68571d31469891f10361299dcf96.png" alt="img" style="zoom:67%;"><p>list_add函数向__list_add函数传入的prev和next参数分别是head和head-&gt;next，所以list_add函数是在链表头指针和链表第一个元素之间插入new元素。</p><p>list_add_tail函数向__list_add函数传入的prev和next指针分别是head-&gt;prev和head，head-&gt;prev就是指向链表的最后一个元素，所以list_add_tail是在链表最后一个元素和链表头指针之间插入元素。</p><p><strong>4.链表元素删除</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __list_del(<span class="hljs-keyword">struct</span> list_head * prev, <span class="hljs-keyword">struct</span> list_head * next)<br>&#123;<br>next-&gt;prev = prev;<br>prev-&gt;next = next;<br>&#125;<br> <br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __list_del_entry(<span class="hljs-keyword">struct</span> list_head *entry)<br>&#123;<br>__list_del(entry-&gt;prev, entry-&gt;next);<br>&#125;<br> <br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">list_del</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_head *entry)</span><br>&#123;<br>__list_del(entry-&gt;prev, entry-&gt;next);<br>entry-&gt;next = LIST_POISON1;<br>entry-&gt;prev = LIST_POISON2;<br>&#125;<br></code></pre></td></tr></table></figure><p> _list_del函数的作用是删除prev和next指针指向的元素之间的元素，如下图所示</p><img src="/2023/10/07/linux%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/0f24f204a2034c5cae94e9bb7e796635.png" alt="img" style="zoom:67%;"><p> __list_del_entry函数向__list_del函数传入的的prev和next参数分别指向是要删除元素的前一个元素和后一个元素。</p><p>list_del函数和__list_del_entry函数的区别是将删除元素的前向指针和后向指针都指向一个非法值，如元素从链表中删除后仍然反问，则会产生内存页错误。</p><p><strong>5.链表的遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each-iterate over a list</span><br><span class="hljs-comment"> * @pos:the &amp;struct list_head to use as a loop cursor.</span><br><span class="hljs-comment"> * @head:the head for your list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each(pos, head) \</span><br><span class="hljs-meta">for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span><br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each_prev-iterate over a list backwards</span><br><span class="hljs-comment"> * @pos:the &amp;struct list_head to use as a loop cursor.</span><br><span class="hljs-comment"> * @head:the head for your list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_prev(pos, head) \</span><br><span class="hljs-meta">for (pos = (head)-&gt;prev; pos != (head); pos = pos-&gt;prev)</span><br> <br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each_safe - iterate over a list safe against removal of list entry</span><br><span class="hljs-comment"> * @pos:the &amp;struct list_head to use as a loop cursor.</span><br><span class="hljs-comment"> * @n:another &amp;struct list_head to use as temporary storage</span><br><span class="hljs-comment"> * @head:the head for your list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_safe(pos, n, head) \</span><br><span class="hljs-meta">for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \</span><br><span class="hljs-meta">pos = n, n = pos-&gt;next)</span><br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each_prev_safe - iterate over a list backwards safe against removal of list entry</span><br><span class="hljs-comment"> * @pos:the &amp;struct list_head to use as a loop cursor.</span><br><span class="hljs-comment"> * @n:another &amp;struct list_head to use as temporary storage</span><br><span class="hljs-comment"> * @head:the head for your list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_prev_safe(pos, n, head) \</span><br><span class="hljs-meta">for (pos = (head)-&gt;prev, n = pos-&gt;prev; \</span><br><span class="hljs-meta">     pos != (head); \</span><br><span class="hljs-meta">     pos = n, n = pos-&gt;prev)</span><br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each_entry-iterate over list of given type</span><br><span class="hljs-comment"> * @pos:the type * to use as a loop cursor.</span><br><span class="hljs-comment"> * @head:the head for your list.</span><br><span class="hljs-comment"> * @member:the name of the list_struct within the struct.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_entry(pos, head, member)\</span><br><span class="hljs-meta">for (pos = list_first_entry(head, typeof(*pos), member);\</span><br><span class="hljs-meta">     &amp;pos-&gt;member != (head);\</span><br><span class="hljs-meta">     pos = list_next_entry(pos, member))</span><br></code></pre></td></tr></table></figure><p>list_for_each函数是按照从前往后的顺序遍历链表，通过不断指向元素的next元素，直到元素的指针和链表头指针地址相同，则表示链表遍历完成。</p><p>list_for_each_prev函数则是从链表的尾部元素向前遍历。</p><p>list_for_each_safe函数引入了指针n，用于存储pos的下一个元素的地址。引入指针n可以方便在遍历链表的时候删除pos指向的元素，而不影响遍历。list_for_each无法做到这一点。</p><p>list_for_each_prev_safe函数和list_for_each_safe函数的区别是从后往前遍历。</p><p>list_for_each_entry函数是list_for_each和list_entry的结合，有pos，head，member三个参数，pos是一个中间变量，指向当前访问的链表元素，head指链表头，member指pos指向的结构体中链表成员变量的名称，示意图如下：</p><img src="/2023/10/07/linux%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/b54ea1e8ca784b2bbdbaef085bc90c01.png" alt="img" style="zoom:80%;"><p><strong>6.查找链表元素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_entry - get the struct for this entry</span><br><span class="hljs-comment"> * @ptr:the &amp;struct list_head pointer.</span><br><span class="hljs-comment"> * @type:the type of the struct this is embedded in.</span><br><span class="hljs-comment"> * @member:the name of the list_struct within the struct.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_entry(ptr, type, member) \</span><br><span class="hljs-meta">container_of(ptr, type, member)</span><br></code></pre></td></tr></table></figure><p>list_entry宏有三个参数ptr，type，member。ptr是指数据结构中struct list_head变量成员的地址，type是指数据结构的类型，member是指数据结构中struct list_head的变量名。list_entry宏的结果是ptr指向的type类型的数据结构的变量地址。</p><img src="/2023/10/07/linux%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/dd2eeb6f00484fa7a5eb243274df053a.png" alt="img" style="zoom: 80%;"><p><strong>代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">tasks</span>;</span><br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果要获取某个struct task_struct类型的变量的地址，ptr指向该变量的tasks指针变量的地址，则可以这么写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">addr</span> =</span> list_entry(ptr, <span class="hljs-keyword">struct</span> task_struct, tasks);<br></code></pre></td></tr></table></figure><p>举例：list_for_each和list_entry配合使用</p><p>list_for_each函数用于获取数据结构中struct list_head成员的地址，list_entry则是通过struct list_head成员的地址获取到数据结构的地址。</p><p><strong>代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">list_for_each(pos, &amp;<span class="hljs-built_in">list</span>)<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">addr</span> =</span> list_entry(pos, <span class="hljs-keyword">struct</span> task_struct, tasks);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><strong>代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/list.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/rculist.h&gt;</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu_info</span></span><br><span class="hljs-class">&#123;</span><br>   <span class="hljs-type">char</span>* name;<br>   <span class="hljs-type">int</span> age;<br>   <span class="hljs-type">void</span> (*print)(<span class="hljs-keyword">struct</span> stu_info *stu);<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br>&#125;;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">print_info</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stu_info *stu)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;name = %s, age = %d\n&quot;</span>, stu-&gt;name, stu-&gt;age);<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu_info</span> <span class="hljs-title">students</span>[8] =</span> &#123;<br>&#123;<span class="hljs-string">&quot;Zhao&quot;</span>, <span class="hljs-number">20</span>, print_info&#125;,<br>&#123;<span class="hljs-string">&quot;Qian&quot;</span>, <span class="hljs-number">21</span>, print_info&#125;,<br>&#123;<span class="hljs-string">&quot;Sun&quot;</span>, <span class="hljs-number">22</span>, print_info&#125;,<br>&#123;<span class="hljs-string">&quot;Li&quot;</span>, <span class="hljs-number">23</span>, print_info&#125;,<br>&#125;;<br> <br>LIST_HEAD(stu);<br> <br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">student_list_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">pos</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu_info</span> *<span class="hljs-title">s</span>;</span><br> <br>list_add(&amp;students[<span class="hljs-number">0</span>].<span class="hljs-built_in">list</span>, &amp;stu);<br>list_add(&amp;students[<span class="hljs-number">1</span>].<span class="hljs-built_in">list</span>, &amp;stu);<br>list_add(&amp;students[<span class="hljs-number">2</span>].<span class="hljs-built_in">list</span>, &amp;stu);<br>list_add(&amp;students[<span class="hljs-number">3</span>].<span class="hljs-built_in">list</span>, &amp;stu);<br> <br>list_for_each(pos, &amp;stu)<br>&#123;<br>s = list_entry(pos, <span class="hljs-keyword">struct</span> stu_info, <span class="hljs-built_in">list</span>);<br>s-&gt;print(s);<br>&#125;<br><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">student_list_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>   printk(<span class="hljs-string">&quot;student_list_exit\n&quot;</span>);<br> <br>   <span class="hljs-keyword">return</span>;<br>&#125;<br> <br>module_init(student_list_init);<br>module_exit(student_list_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;Dual BSD/GPL&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">[<span class="hljs-number">19764.110000</span>] name = Li, age = <span class="hljs-number">23</span><br>[<span class="hljs-number">19764.120000</span>] name = Sun, age = <span class="hljs-number">22</span><br>[<span class="hljs-number">19764.120000</span>] name = Qian, age = <span class="hljs-number">21</span><br>[<span class="hljs-number">19764.130000</span>] name = Zhao, age = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h2 id="四-常用的2个链表遍历函数"><a href="#四-常用的2个链表遍历函数" class="headerlink" title="四.常用的2个链表遍历函数"></a>四.常用的2个链表遍历函数</h2><h3 id="4-1-list-for-each-entry"><a href="#4-1-list-for-each-entry" class="headerlink" title="4.1 list_for_each_entry"></a>4.1 list_for_each_entry</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each_entry    - iterate over list of given type</span><br><span class="hljs-comment"> * @pos:    the type * to use as a loop cursor.</span><br><span class="hljs-comment"> * @head:    the head for your list.</span><br><span class="hljs-comment"> * @member:    the name of the list_struct within the struct.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_entry(pos, head, member)                \</span><br><span class="hljs-meta">    for (pos = list_entry((head)-&gt;next, typeof(*pos), member);    \</span><br><span class="hljs-meta">         &amp;pos-&gt;member != (head);     \</span><br><span class="hljs-meta">         pos = list_entry(pos-&gt;member.next, typeof(*pos), member))</span><br></code></pre></td></tr></table></figure><p>这个宏的作用就是根据list_head对链表进行遍历。</p><ul><li>pos ：表示每一次遍历是返回的结构体变量的首地址</li><li>head : 表示要遍历的链表的头部</li><li>member ：表示该链表在结构体中的成员名称</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/list.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">next</span>, *<span class="hljs-title">prev</span>;</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usrList</span> &#123;</span> <br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-type">int</span> data; <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span> <br>&#125; USR_LIST_TYPE; <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> <br>&#123; <br>    USR_LIST_TYPE msg, *pmsg; <br>    LIST_HEAD(msg_head);<br>    <span class="hljs-type">int</span> *ptr = &amp;msg.data;<br>    <span class="hljs-type">int</span> i; <span class="hljs-comment">/* insert the 10 msgs */</span> <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <br>        pmsg = (USR_LIST_TYPE *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(USR_LIST_TYPE)); <br>        pmsg-&gt;index = i + <span class="hljs-number">1</span>; <br>        pmsg-&gt;data = (i + <span class="hljs-number">1</span>)*<span class="hljs-number">10</span>; <br>        list_add_tail(&amp;pmsg-&gt;<span class="hljs-built_in">list</span>, &amp;msg_head); <br>    &#125; <br><br>    <span class="hljs-comment">/* 根据list 遍历 整个链表，并打印信息 */</span> <br>    list_for_each_entry(pmsg, &amp;msg_head, <span class="hljs-built_in">list</span>)<br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;msg index:%d data:%d\n&quot;</span>, pmsg-&gt;index, pmsg-&gt;data); <br>    &#125; <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-list-for-each-entry-safe"><a href="#4-2-list-for-each-entry-safe" class="headerlink" title="4.2 list_for_each_entry_safe"></a>4.2 list_for_each_entry_safe</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* list_for_each_entry_safe - iterate over list of given type safe against removal of list entry</span><br><span class="hljs-comment">* @pos:     the type * to use as a loop cursor.</span><br><span class="hljs-comment">* @n:          another type * to use as temporary storage</span><br><span class="hljs-comment">* @head:     the head for your list.</span><br><span class="hljs-comment">* @member:     the name of the list_struct within the struct.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_entry_safe(pos, n, head, member)               \</span><br><span class="hljs-meta">     for (pos = list_entry((head)-&gt;next, typeof(*pos), member),     \</span><br><span class="hljs-meta">          n = list_entry(pos-&gt;member.next, typeof(*pos), member);     \</span><br><span class="hljs-meta">          &amp;pos-&gt;member != (head);                         \</span><br><span class="hljs-meta">          pos = n, n = list_entry(n-&gt;member.next, typeof(*n), member))</span><br></code></pre></td></tr></table></figure><p>这段代码是一个宏定义，用于遍历一个链表中所有的元素，并且在遍历过程中可以安全地删除元素。具体来说，这个宏定义的功能是：</p><ol><li>遍历链表中所有的元素，从头节点开始，直到尾节点结束。</li><li>对于每个元素，使用给定的结构体成员变量名找到它所属的结构体对象，并且将该对象的指针赋值给给定的变量名。</li><li>在遍历过程中，可以安全地删除当前元素，因为它在删除前会先保存下一个元素的指针，保证不会影响遍历的正确性。</li></ol><p>下面是这个宏定义的详细解释：</p><ul><li>pos：用于保存当前遍历到的元素的指针。</li><li>tmp：用于保存下一个元素的指针，以便在删除当前元素后继续遍历。</li><li>head：链表的头节点。</li><li>member：链表节点所在的结构体成员变量名。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何判断f2fs文件系统是否使用多设备</title>
    <link href="/2023/10/04/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADf2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%AE%BE%E5%A4%87/"/>
    <url>/2023/10/04/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADf2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="如何判断f2fs文件系统是否使用多设备"><a href="#如何判断f2fs文件系统是否使用多设备" class="headerlink" title="如何判断f2fs文件系统是否使用多设备"></a>如何判断f2fs文件系统是否使用多设备</h1><p>在f2fs文件系统中使用函数<strong>f2fs_is_multi_device</strong>进行判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">f2fs_is_multi_device</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-keyword">return</span> sbi-&gt;s_ndevs &gt; <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/10/04/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADf2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%AE%BE%E5%A4%87/image-20231004234402946.png" alt="image-20231004234402946" style="zoom:50%;"><p>其赋值的地方为<strong>f2fs_scan_devices</strong>函数。</p><hr><p>在文件系统进行挂载的时候，会调用fill_super这样的函数，对于f2fs文件系统而言，其会调用到f2fs_scan_devices函数</p><img src="/2023/10/04/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADf2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%AE%BE%E5%A4%87/image-20231004233549137.png" alt="image-20231004233549137" style="zoom: 67%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RDEV(i)(raw_super-&gt;devs[i])</span><br></code></pre></td></tr></table></figure><p>就是对应f2fs_super_block中的dev字段，其位于0xca0：</p><img src="/2023/10/04/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADf2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%AE%BE%E5%A4%87/image-20231004234151705.png" alt="image-20231004234151705" style="zoom:80%;"><p>如果都是0【具体多少位需要看f2fs_device结构体大小】，我这里全是0，说明是单设备</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【转载】C语言0长度数组(可变数组/柔性数组)详解</title>
    <link href="/2023/10/04/C%E8%AF%AD%E8%A8%800%E9%95%BF%E5%BA%A6%E6%95%B0%E7%BB%84-%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84-%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84-%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/10/04/C%E8%AF%AD%E8%A8%800%E9%95%BF%E5%BA%A6%E6%95%B0%E7%BB%84-%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84-%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84-%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://www.modb.pro/db/463637">https://www.modb.pro/db/463637</a></p></blockquote><h1 id="【转载】C语言0长度数组-可变数组-x2F-柔性数组-详解"><a href="#【转载】C语言0长度数组-可变数组-x2F-柔性数组-详解" class="headerlink" title="【转载】C语言0长度数组(可变数组&#x2F;柔性数组)详解"></a>【转载】C语言0长度数组(可变数组&#x2F;柔性数组)详解</h1><h2 id="零长度数组概念"><a href="#零长度数组概念" class="headerlink" title="零长度数组概念"></a>零长度数组概念</h2><p>众所周知, GNU&#x2F;GCC 在标准的 C&#x2F;C++ 基础上做了有实用性的扩展, 零长度数组（Arrays of Length Zero） 就是其中一个知名的扩展.</p><p>多数情况下, 其应用在变长数组中, 其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Packet</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> state;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">char</span> cData[<span class="hljs-number">0</span>]; <span class="hljs-comment">//这里的0长结构体就为变长结构体提供了非常好的支持</span><br>    <span class="hljs-comment">// char cData[];  也是一样的</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>首先对 0长度数组【或者空长度数组】, 也叫柔性数组 做一个解释 ：</p><ul><li>用途 : 长度为0的数组的主要用途是为了满足需要变长度的结构体</li><li>用法 : 在一个结构体的最后, 申明一个长度为0的数组, 就可以使得这个结构体是可变长的. 对于编译器来说, 此时长度为0的数组并不占用空间, 因为数组名本身不占空间, 它只是一个偏移量, 数组名这个符号本身代表了一个不可修改的地址常量</li></ul><p>(注意 : 数组名永远都不会是指针!), 但对于这个数组的大小, 我们可以进行动态分配</p><p>注意 ：如果结构体是通过calloc、malloc或 者new等动态分配方式生成，在不需要时要释放相应的空间。</p><ul><li><p>优点 ：比起在结构体中声明一个指针变量、再进行动态分 配的办法，这种方法效率要高。因为在访问数组内容时，不需要间接访问，避免了两次访存。</p></li><li><p>缺点 ：在结构体中，数组为0的数组必须在最后声明，使 用上有一定限制。</p></li></ul><p>对于编译器而言, 数组名仅仅是一个符号, 它不会占用任何空间, 它在结构体中, 只是代表了一个偏移量, 代表一个不可修改的地址常量!</p><h2 id="0长度数组的用途"><a href="#0长度数组的用途" class="headerlink" title="0长度数组的用途"></a>0长度数组的用途</h2><p>我们设想这样一个场景, 我们在网络通信过程中使用的数据缓冲区, 缓冲区包括一个len字段和data字段, 分别标识数据的长度和传输的数据, 我们常见的有几种设计思路：</p><ul><li>定长数据缓冲区, 设置一个足够大小 MAX_LENGTH 的数据缓冲区</li><li>设置一个指向实际数据的指针, 每次使用时, 按照数据的长度动态的开辟数据缓冲区的空间</li></ul><p>我们从实际场景中应用的设计来考虑他们的优劣. 主要考虑的有, 缓冲区空间的开辟, 释放和访问。</p><h3 id="定长包-开辟空间-释放-访问"><a href="#定长包-开辟空间-释放-访问" class="headerlink" title="定长包(开辟空间, 释放, 访问)"></a>定长包(开辟空间, 释放, 访问)</h3><p>比如我要发送 1024 字节的数据, 如果用定长包, 假设定长包的长度 MAX_LENGTH 为 2048, 就会浪费 1024 个字节的空间, 也会造成不必要的流量浪费：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  定长缓冲区</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">max_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span>     len;<br>    <span class="hljs-type">char</span>    data[MAX_LENGTH];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>数据结构大小：考虑对齐, 那么数据结构的大小 &gt;&#x3D; sizeof(int) + sizeof(char) * MAX_LENGTH</li></ul><p>由于考虑到数据的溢出, 变长数据包中的 data 数组长度一般会设置得足够长足以容纳最大的数据, 因此 max_buffer 中的 data 数组很多情况下都没有填满数据, 因此造成了浪费</p><ul><li>数据包的构造：假如我们要发送 CURR_LENGTH &#x3D; 1024 个字节, 我们如何构造这个数据包呢；一般来说, 我们会返回一个指向缓冲区数据结构 max_buffer 的指针：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">///  开辟</span><br><span class="hljs-keyword">if</span> ((mbuffer = (<span class="hljs-keyword">struct</span> max_buffer *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> max_buffer))) != <span class="hljs-literal">NULL</span>)<br>&#123;<br>    mbuffer-&gt;len = CURR_LENGTH;<br>    <span class="hljs-built_in">memcpy</span>(mbuffer-&gt;data, <span class="hljs-string">&quot;Hello World&quot;</span>, CURR_LENGTH);<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %s\n&quot;</span>, mbuffer-&gt;len, mbuffer-&gt;data);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>访问：这段内存要分两部分使用；前部分 4 个字节 p-&gt;len, 作为包头(就是多出来的那部分)，这个包头是用来描述紧接着包头后面的数据部分的长度，这里是 1024, 所以前四个字节赋值为 1024 (既然我们要构造不定长数据包，那么这个包到底有多长呢，因此，我们就必须通过一个变量来表明这个数据包的长度，这就是len的作用)；而紧接其后的内存是真正的数据部分, 通过 p-&gt;data, 最后, 进行一个 memcpy() 内存拷贝, 把要发送的数据填入到这段内存当中</li><li>释放：那么当使用完毕释放数据的空间的时候, 直接释放就可以</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// 销毁</span><br><span class="hljs-built_in">free</span>(mbuffer);<br>mbuffer = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>使用定长数组, 作为数据缓冲区, 为了避免造成缓冲区溢出, 数组的大小一般设为足够的空间 MAX_LENGTH, 而实际使用过程中, 达到 MAX_LENGTH 长度的数据很少, 那么多数情况下, 缓冲区的大部分空间都是浪费掉的</li><li>但是使用过程很简单, 数据空间的开辟和释放简单, 无需程序员考虑额外的操作</li></ul><h3 id="指针数据包-开辟空间-释放-访问"><a href="#指针数据包-开辟空间-释放-访问" class="headerlink" title="指针数据包(开辟空间, 释放, 访问)"></a>指针数据包(开辟空间, 释放, 访问)</h3><p>如果你将上面的长度为 MAX_LENGTH 的定长数组换为指针, 每次使用时动态的开辟 CURR_LENGTH 大小的空间, 那么就避免造成 MAX_LENGTH - CURR_LENGTH 空间的浪费, 只浪费了一个指针域的空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span>     len;<br>    <span class="hljs-type">char</span>    *data;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>数据结构大小：考虑对齐, 那么数据结构的大小 &gt;&#x3D; sizeof(int) + sizeof(char *)</li><li>空间分配：但是也造成了使用在分配内存时，需采用两步</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// =====================</span><br> <span class="hljs-comment">// 指针数组  占用-开辟-销毁</span><br> <span class="hljs-comment">// =====================</span><br> <span class="hljs-comment">///  占用</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the length of struct test3:%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> point_buffer));<br> <span class="hljs-comment">///  开辟</span><br> <span class="hljs-keyword">if</span> ((pbuffer = (<span class="hljs-keyword">struct</span> point_buffer *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> point_buffer))) != <span class="hljs-literal">NULL</span>)<br> &#123;<br>     pbuffer-&gt;len = CURR_LENGTH;<br>     <span class="hljs-keyword">if</span> ((pbuffer-&gt;data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * CURR_LENGTH)) != <span class="hljs-literal">NULL</span>)<br>     &#123;<br>         <span class="hljs-built_in">memcpy</span>(pbuffer-&gt;data, <span class="hljs-string">&quot;Hello World&quot;</span>, CURR_LENGTH);<br><br><br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %s\n&quot;</span>, pbuffer-&gt;len, pbuffer-&gt;data);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>首先, 需为结构体分配一块内存空间；其次再为结构体中的成员变量分配内存空间。</p><p>这样两次分配的内存是不连续的, 需要分别对其进行管理. 当使用长度为的数组时, 则是采用一次分配的原则, 一次性将所需的内存全部分配给它。</p><ul><li>释放：相反, 释放时也是一样的：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// 销毁</span><br><span class="hljs-built_in">free</span>(pbuffer-&gt;data);<br><span class="hljs-built_in">free</span>(pbuffer);<br>pbuffer = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><ul><li><p>小结：</p></li><li><ul><li>使用指针结果作为缓冲区, 只多使用了一个指针大小的空间, 无需使用 MAX_LENGTH 长度的数组, 不会造成空间的大量浪费</li><li>但那是开辟空间时, 需要额外开辟数据域的空间, 施放时候也需要显示释放数据域的空间, 但是实际使用过程中, 往往在函数中开辟空间, 然后返回给使用者指向 struct point_buffer 的指针, 这时候我们并不能假定使用者了解我们开辟的细节, 并按照约定的操作释放空间, 因此使用起来多有不便, 甚至造成内存泄漏。</li></ul></li></ul><h3 id="变长数据缓冲区-开辟空间-释放-访问"><a href="#变长数据缓冲区-开辟空间-释放-访问" class="headerlink" title="变长数据缓冲区(开辟空间, 释放, 访问)"></a>变长数据缓冲区(开辟空间, 释放, 访问)</h3><p>定长数组使用方便, 但是却浪费空间, 指针形式只多使用了一个指针的空间, 不会造成大量空间分浪费, 但是使用起来需要多次分配, 多次释放, 那么有没有一种实现方式能够既不浪费空间, 又使用方便的呢?</p><p>GNU C 的0长度数组, 也叫变长数组, 柔性数组就是这样一个扩展. 对于0长数组的这个特点，很容易构造出变成结构体，如缓冲区，数据包等等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  0长度数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zero_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span>     len;<br>    <span class="hljs-type">char</span>    data[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>数据结构大小：这样的变长数组常用于网络通信中构造不定长数据包, 不会浪费空间浪费网络流量, 因为char data[0]; 只是个数组名, 是不占用存储空间的：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> zero_buffer) = <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><ul><li>开辟空间：那么我们使用的时候, 只需要开辟一次空间即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">///  开辟</span><br><span class="hljs-keyword">if</span> ((zbuffer = (<span class="hljs-keyword">struct</span> zero_buffer *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> zero_buffer) + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * CURR_LENGTH)) != <span class="hljs-literal">NULL</span>)<br>&#123;<br>    zbuffer-&gt;len = CURR_LENGTH;<br>    <span class="hljs-built_in">memcpy</span>(zbuffer-&gt;data, <span class="hljs-string">&quot;Hello World&quot;</span>, CURR_LENGTH);<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %s\n&quot;</span>, zbuffer-&gt;len, zbuffer-&gt;data);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>释放空间：释放空间也是一样的, 一次释放即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">///  销毁</span><br><span class="hljs-built_in">free</span>(zbuffer);<br>zbuffer = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><ul><li>总结：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// zero_length_array.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LENGTH      1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CURR_LENGTH      512</span><br><br><span class="hljs-comment">//  0长度数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zero_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span>     len;<br>    <span class="hljs-type">char</span>    data[<span class="hljs-number">0</span>];<br>&#125;__attribute((packed));<br><br><br><span class="hljs-comment">//  定长数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">max_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span>     len;<br>    <span class="hljs-type">char</span>    data[MAX_LENGTH];<br>&#125;__attribute((packed));<br><br><br><span class="hljs-comment">//  指针数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span>     len;<br>    <span class="hljs-type">char</span>    *data;<br>&#125;__attribute((packed));<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zero_buffer</span>  *<span class="hljs-title">zbuffer</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">max_buffer</span>   *<span class="hljs-title">mbuffer</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point_buffer</span> *<span class="hljs-title">pbuffer</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><br>    <span class="hljs-comment">// =====================</span><br>    <span class="hljs-comment">// 0长度数组  占用-开辟-销毁</span><br>    <span class="hljs-comment">// =====================</span><br>    <span class="hljs-comment">///  占用</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the length of struct test1:%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> zero_buffer));<br>    <span class="hljs-comment">///  开辟</span><br>    <span class="hljs-keyword">if</span> ((zbuffer = (<span class="hljs-keyword">struct</span> zero_buffer *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> zero_buffer) + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * CURR_LENGTH)) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        zbuffer-&gt;len = CURR_LENGTH;<br>        <span class="hljs-built_in">memcpy</span>(zbuffer-&gt;data, <span class="hljs-string">&quot;Hello World&quot;</span>, CURR_LENGTH);<br><br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %s\n&quot;</span>, zbuffer-&gt;len, zbuffer-&gt;data);<br>    &#125;<br>    <span class="hljs-comment">///  销毁</span><br>    <span class="hljs-built_in">free</span>(zbuffer);<br>    zbuffer = <span class="hljs-literal">NULL</span>;<br><br><br>    <span class="hljs-comment">// =====================</span><br>    <span class="hljs-comment">// 定长数组  占用-开辟-销毁</span><br>    <span class="hljs-comment">// =====================</span><br>    <span class="hljs-comment">///  占用</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the length of struct test2:%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> max_buffer));<br>    <span class="hljs-comment">///  开辟</span><br>    <span class="hljs-keyword">if</span> ((mbuffer = (<span class="hljs-keyword">struct</span> max_buffer *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> max_buffer))) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        mbuffer-&gt;len = CURR_LENGTH;<br>        <span class="hljs-built_in">memcpy</span>(mbuffer-&gt;data, <span class="hljs-string">&quot;Hello World&quot;</span>, CURR_LENGTH);<br><br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %s\n&quot;</span>, mbuffer-&gt;len, mbuffer-&gt;data);<br>    &#125;<br>    <span class="hljs-comment">/// 销毁</span><br>    <span class="hljs-built_in">free</span>(mbuffer);<br>    mbuffer = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// =====================</span><br>    <span class="hljs-comment">// 指针数组  占用-开辟-销毁</span><br>    <span class="hljs-comment">// =====================</span><br>    <span class="hljs-comment">///  占用</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the length of struct test3:%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> point_buffer));<br>    <span class="hljs-comment">///  开辟</span><br>    <span class="hljs-keyword">if</span> ((pbuffer = (<span class="hljs-keyword">struct</span> point_buffer *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> point_buffer))) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        pbuffer-&gt;len = CURR_LENGTH;<br>        <span class="hljs-keyword">if</span> ((pbuffer-&gt;data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * CURR_LENGTH)) != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">memcpy</span>(pbuffer-&gt;data, <span class="hljs-string">&quot;Hello World&quot;</span>, CURR_LENGTH);<br><br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %s\n&quot;</span>, pbuffer-&gt;len, pbuffer-&gt;data);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/// 销毁</span><br>    <span class="hljs-built_in">free</span>(pbuffer-&gt;data);<br>    <span class="hljs-built_in">free</span>(pbuffer);<br>    pbuffer = <span class="hljs-literal">NULL</span>;<br><br><br>    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs中nat与sit位图管理</title>
    <link href="/2023/10/04/f2fs%E4%B8%ADnat%E4%B8%8Esit%E4%BD%8D%E5%9B%BE%E7%AE%A1%E7%90%86/"/>
    <url>/2023/10/04/f2fs%E4%B8%ADnat%E4%B8%8Esit%E4%BD%8D%E5%9B%BE%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs中nat与sit位图管理"><a href="#f2fs中nat与sit位图管理" class="headerlink" title="f2fs中nat与sit位图管理"></a>f2fs中nat与sit位图管理</h1><blockquote><p>部分参考：<a href="https://blog.csdn.net/wenj12/article/details/115414147">https://blog.csdn.net/wenj12/article/details/115414147</a></p></blockquote><h2 id="关于NAT和SIT的有效位图"><a href="#关于NAT和SIT的有效位图" class="headerlink" title="关于NAT和SIT的有效位图"></a>关于NAT和SIT的有效位图</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nm_info</span> &#123;</span> <span class="hljs-comment">//node manager 信息</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-type">char</span> *nat_bitmap;<span class="hljs-comment">/* NAT bitmap pointer */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_info</span> &#123;</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-type">char</span> *sit_bitmap;<span class="hljs-comment">/* SIT bitmap pointer */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在<strong>sbi-&gt;f2fs_nm_info-&gt;nat_bitmap</strong>中是NAT的位图，<strong>sbi-&gt;sit_info-&gt;sit_bitmap</strong>为SIT的位图。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_checkpoint</span> &#123;</span><br>__le64 checkpoint_ver;<span class="hljs-comment">/* checkpoint block version number */</span><br>__le64 user_block_count;<span class="hljs-comment">/* # of user blocks */</span><br>__le64 valid_block_count;<span class="hljs-comment">/* # of valid blocks in main area */</span><br>__le32 rsvd_segment_count;<span class="hljs-comment">/* # of reserved segments for gc */</span><br>__le32 overprov_segment_count;<span class="hljs-comment">/* # of overprovision segments */</span><br>__le32 free_segment_count;<span class="hljs-comment">/* # of free segments in main area */</span><br><br><span class="hljs-comment">/* information of current node segments */</span><br>__le32 cur_node_segno[MAX_ACTIVE_NODE_LOGS];<br>__le16 cur_node_blkoff[MAX_ACTIVE_NODE_LOGS];<br><span class="hljs-comment">/* information of current data segments */</span><br>__le32 cur_data_segno[MAX_ACTIVE_DATA_LOGS];<br>__le16 cur_data_blkoff[MAX_ACTIVE_DATA_LOGS];<br>__le32 ckpt_flags;<span class="hljs-comment">/* Flags : umount and journal_present */</span><br>__le32 cp_pack_total_block_count;<span class="hljs-comment">/* total # of one cp pack */</span><br>__le32 cp_pack_start_sum;<span class="hljs-comment">/* start block number of data summary */</span><br>__le32 valid_node_count;<span class="hljs-comment">/* Total number of valid nodes */</span><br>__le32 valid_inode_count;<span class="hljs-comment">/* Total number of valid inodes */</span><br>__le32 next_free_nid;<span class="hljs-comment">/* Next free node number */</span><br>__le32 sit_ver_bitmap_bytesize;<span class="hljs-comment">/* Default value 64 */</span><br>__le32 nat_ver_bitmap_bytesize; <span class="hljs-comment">/* Default value 256 */</span><br>__le32 checksum_offset;<span class="hljs-comment">/* checksum校验和 offset inside cp block */</span><br>__le64 elapsed_time;<span class="hljs-comment">/* mounted time */</span><br><span class="hljs-comment">/* allocation type of current segment */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> alloc_type[MAX_ACTIVE_LOGS];<br><br><span class="hljs-comment">/* SIT and NAT version bitmap */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sit_nat_version_bitmap[];  <span class="hljs-comment">// 可变数组/柔性数组</span><br>&#125; __packed;<br></code></pre></td></tr></table></figure><p>位图在磁盘上是存储在f2fs_checkpoint里的sit_nat_version_bitmap：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//确定ckpt的sit_nat_version_bitmap中，nat和sit位图的位置</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *__bitmap_ptr(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">int</span> flag)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_checkpoint</span> *<span class="hljs-title">ckpt</span> =</span> F2FS_CKPT(sbi);<br><span class="hljs-type">int</span> offset = (flag == NAT_BITMAP) ?<br>le32_to_cpu(ckpt-&gt;sit_ver_bitmap_bytesize) : <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> &amp;ckpt-&gt;sit_nat_version_bitmap + offset;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上述函数可以看出，sit和NAT位图在sit_nat_version_bitmap中是紧挨着，其中sit在前部分，nat在后部分。</p><h2 id="位图大小与cp-payload"><a href="#位图大小与cp-payload" class="headerlink" title="位图大小与cp_payload"></a>位图大小与cp_payload</h2><h3 id="位图大小"><a href="#位图大小" class="headerlink" title="位图大小"></a>位图大小</h3><p>从f2fs_checkpoint结构体定义可以找到位图的大小，sit_ver_bitmap_bytesize位于0x20009c，nat_ver_bitmap_bytesize位于0x2000a0；</p><img src="/2023/10/04/f2fs%E4%B8%ADnat%E4%B8%8Esit%E4%BD%8D%E5%9B%BE%E7%AE%A1%E7%90%86/image-20231004224145996.png" alt="image-20231004224145996" style="zoom: 50%;"><p>✅<strong>这2个数值在我们格式化磁盘mkfs.f2fs的时候就已经确定了。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// external\f2fs-tools\mkfs\f2fs_format.c</span><br><br>set_cp(sit_ver_bitmap_bytesize, ((get_sb(segment_count_sit) / <span class="hljs-number">2</span>) &lt;&lt; get_sb(log_blocks_per_seg)) / <span class="hljs-number">8</span>);<br><br>set_cp(nat_ver_bitmap_bytesize, ((get_sb(segment_count_nat) / <span class="hljs-number">2</span>) &lt;&lt; get_sb(log_blocks_per_seg)) / <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>sit的计算过程如下【nat的计算同理】：</p><ul><li><p>获取f2fs_super_block中的segment_count_sit值（看看sit总共占了几个segment），然后除以2【因为sit区域是主备的】</p></li><li><p>获取f2fs_super_block中的log_blocks_per_seg值（查看一个segment有几个block，当然这里取了底为2的对数）</p></li><li><p>我们通过 <strong>&lt;&lt;</strong> 位运算就可以算出一个sit区域总共有多少个block</p></li><li><p>计算出来的值除以8，因为f2fs_checkpoint结构体变量sit_nat_version_bitmap为<strong>unsigned char</strong>类型（就是8位）</p></li></ul><blockquote><p>这里可能有点小小忘记sit和nat的<a href="https://anmuxixixi.github.io/2023/07/23/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FJournal%E6%9C%BA%E5%88%B6/">主备机制</a>了：</p><img src="/2023/10/04/f2fs%E4%B8%ADnat%E4%B8%8Esit%E4%BD%8D%E5%9B%BE%E7%AE%A1%E7%90%86/e70cb7105d434b019d36cf0992dd232f.jpeg" alt="img" style="zoom: 67%;"></blockquote><h3 id="cp-payload"><a href="#cp-payload" class="headerlink" title="cp_payload"></a>cp_payload</h3><p>首先解释一下cp_payload这个字段，由于在f2fs的cp pack中的第一个块本来应该放置f2fs_checkpoint这个数据结构的，但是我们发现这个数据结构的大小不够一个block，也就是还有剩余的空间，所以当sit&#x2F;nat version bitmap比较大的时候，那么这两个bitmap是需要额外的空间来保存的，所以cp_payload记录的就是这个额外的空间的块的数量。</p><img src="/2023/10/04/f2fs%E4%B8%ADnat%E4%B8%8Esit%E4%BD%8D%E5%9B%BE%E7%AE%A1%E7%90%86/image-20231004225233756.png" alt="image-20231004225233756" style="zoom:80%;"><blockquote><p>图片源自知乎LZT：<a href="https://zhuanlan.zhihu.com/p/639115192">https://zhuanlan.zhihu.com/p/639115192</a></p></blockquote><h3 id="位图管理与主备机制"><a href="#位图管理与主备机制" class="headerlink" title="位图管理与主备机制"></a>位图管理与主备机制</h3><p>当我们需要通过nid获取node的地址时，可能会走到这一步：【详见-&gt;sit和nat的<a href="https://anmuxixixi.github.io/2023/07/23/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FJournal%E6%9C%BA%E5%88%B6/">主备机制</a>】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pgoff_t</span> <span class="hljs-title function_">current_nat_addr</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">nid_t</span> start)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nm_info</span> *<span class="hljs-title">nm_i</span> =</span> NM_I(sbi);<br><span class="hljs-type">pgoff_t</span> block_off;<br><span class="hljs-type">pgoff_t</span> block_addr;<br><br>    <span class="hljs-comment">// 计算偏移量</span><br>block_off = NAT_BLOCK_OFFSET(start);<br><br>    <span class="hljs-comment">// 计算在主区中的偏移量</span><br>block_addr = (<span class="hljs-type">pgoff_t</span>)(nm_i-&gt;nat_blkaddr +<br>(block_off &lt;&lt; <span class="hljs-number">1</span>) -<br>(block_off &amp; (sbi-&gt;blocks_per_seg - <span class="hljs-number">1</span>)));<br><br>    <span class="hljs-comment">// nat_bitmap指明是在主区还是备区</span><br>    <span class="hljs-comment">// 如果在备区，还要加上blocks_per_seg</span><br><span class="hljs-keyword">if</span> (f2fs_test_bit(block_off, nm_i-&gt;nat_bitmap))<br>block_addr += sbi-&gt;blocks_per_seg;<br><br><span class="hljs-keyword">return</span> block_addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到通过f2fs_test_bit来判断nid对应的node block是在nat的主区还是备区中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//addr是char(8bit)类型数组的位图，nr为偏移量，得到nr处的位图状况</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_test_bit</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr, <span class="hljs-type">char</span> *addr)</span><br>&#123;<br><span class="hljs-type">int</span> mask;<br><br>addr += (nr &gt;&gt; <span class="hljs-number">3</span>);<span class="hljs-comment">//找到nr属于哪个字节</span><br>mask = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">7</span> - (nr &amp; <span class="hljs-number">0x07</span>));<span class="hljs-comment">//nr &amp; 0x07就是nr%8，7-他=从后面数的第几位，然后将1左移这些位就得到了nr处mask</span><br><span class="hljs-keyword">return</span> mask &amp; *addr;<span class="hljs-comment">//拿着mask与该字节处做与，就得到了该位的状况</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当我们在f2fs_checkpoint区域中的<strong>sit_nat_version_bitmap</strong>发现该位为1，说明当前还在checkpoint区域还<strong>没有下刷</strong>，所以<strong>需要取备区中</strong>的。当进行checkpoint操作的时候，会下刷到nat区域，同时位图中对应的位为被清理。那么，下次再次访问nid对应的node block地址时，在page cache找不到，在cp区域的nat journal找不到，最终回去nat区域找，而cp区域位图已经清理过了，所以在主区就可以了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>checkpoint版本号如何变换</title>
    <link href="/2023/10/02/checkpoint%E7%89%88%E6%9C%AC%E5%8F%B7%E5%A6%82%E4%BD%95%E5%8F%98%E6%8D%A2/"/>
    <url>/2023/10/02/checkpoint%E7%89%88%E6%9C%AC%E5%8F%B7%E5%A6%82%E4%BD%95%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="checkpoint版本号如何变换"><a href="#checkpoint版本号如何变换" class="headerlink" title="checkpoint版本号如何变换"></a>checkpoint版本号如何变换</h1><p>f2fs文件系统的版本如何变化起始还是一个挺有意思的问题，自己每次格式化文件系统后，发现checkpoint每次都不一样，感觉就很像一个随机数，那么在进行一次cp后，版本号如何变化呢，现在就一起研究一下。</p><h2 id="1-初始化checkpoint-version"><a href="#1-初始化checkpoint-version" class="headerlink" title="1.初始化checkpoint version"></a>1.初始化checkpoint version</h2><p>我们初始化磁盘的文件系统时常常用到mkfs命令，格式化f2fs文件系统时会用到f2fs-tools中的mkfs.f2fs，其对应的源码文件在Android中也包含了，路径：</p><p><strong>external\f2fs-tools\mkfs</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_write_check_point_pack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 1. cp page 1 of checkpoint pack 1 */</span><br>srand((c.fake_seed) ? <span class="hljs-number">0</span> : time(<span class="hljs-literal">NULL</span>));<br>cp-&gt;checkpoint_ver = cpu_to_le64(rand() | <span class="hljs-number">0x1</span>);<br>    <br>    <span class="hljs-comment">/* cp page 1 of check point pack 2</span><br><span class="hljs-comment"> * Initialize other checkpoint pack with version zero</span><br><span class="hljs-comment">     */</span><br>cp-&gt;checkpoint_ver = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>cp pack1的checkpoint version是随机数</li><li>cp pack2的checkpoint version是0</li></ul><h2 id="2-一次checkpoint后，版本号的变化"><a href="#2-一次checkpoint后，版本号的变化" class="headerlink" title="2.一次checkpoint后，版本号的变化"></a>2.一次checkpoint后，版本号的变化</h2><p>源码：Linux 5.10.8</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_write_checkpoint</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-keyword">struct</span> cp_control *cpc)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_checkpoint</span> *<span class="hljs-title">ckpt</span> =</span> F2FS_CKPT(sbi);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ckpt_ver;<br>    <br>    ckpt_ver = cur_cp_version(ckpt);<br>ckpt-&gt;checkpoint_ver = cpu_to_le64(++ckpt_ver);  <span class="hljs-comment">// 将ckpy_version++</span><br><br>    err = do_checkpoint(sbi, cpc);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_checkpoint</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-keyword">struct</span> cp_control *cpc)</span><br>&#123;<br>    start_blk = __start_cp_next_addr(sbi);  <span class="hljs-comment">// start_blk表示的是备份cp pack的起始地址</span><br> <br>    f2fs_update_meta_page(sbi, ckpt, start_blk++);  <span class="hljs-comment">// 往cp pack的cp page1中去写【注意这里只是写入到page cache中，还没有落盘】</span><br>    <br>    <span class="hljs-comment">/* barrier and flush checkpoint cp pack 2 page if it can */</span><br>commit_checkpoint(sbi, ckpt, start_blk);<br>f2fs_wait_on_all_pages(sbi, F2FS_WB_CP_DATA);<br>    <br>    __set_cp_next_pack(sbi);  <span class="hljs-comment">// 当前cp pack刷盘好了，将备份cp转正</span><br>&#125;<br><br><span class="hljs-comment">// -------------------------------------------------------------------------</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">block_t</span> __start_cp_next_addr(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)<br>&#123;<br><span class="hljs-type">block_t</span> start_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)-&gt;cp_blkaddr);<br><br><span class="hljs-keyword">if</span> (sbi-&gt;cur_cp_pack == <span class="hljs-number">1</span>)<br>start_addr += sbi-&gt;blocks_per_seg;<br><span class="hljs-keyword">return</span> start_addr;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __set_cp_next_pack(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)<br>&#123;<br>sbi-&gt;cur_cp_pack = (sbi-&gt;cur_cp_pack == <span class="hljs-number">1</span>) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>✅<strong>一句话总结</strong>：进行一次checkpoint，其版本号+1</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="f2fs-update-meta-page函数"><a href="#f2fs-update-meta-page函数" class="headerlink" title="f2fs_update_meta_page函数"></a>f2fs_update_meta_page函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_update_meta_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">void</span> *src, <span class="hljs-type">block_t</span> blk_addr)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> f2fs_grab_meta_page(sbi, blk_addr);<br><br><span class="hljs-built_in">memcpy</span>(page_address(page), src, PAGE_SIZE);<br>set_page_dirty(page);<br>f2fs_put_page(page, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将src拷贝到page对应的位置，然后设置该页为脏页，接着将这个页写入到page cache中</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统的write checkpoint流程分析</title>
    <link href="/2023/10/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84write-checkpoint%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2023/10/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84write-checkpoint%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统的write-checkpoint流程分析"><a href="#f2fs文件系统的write-checkpoint流程分析" class="headerlink" title="f2fs文件系统的write checkpoint流程分析"></a>f2fs文件系统的write checkpoint流程分析</h1><p>f2fs文件系统在2个地方都有这部分的代码，一个是原生Linux代码，一个是f2fs-tools工具中的代码。2份代码逻辑是一样的，只是代码编写方式不同，我推荐先f2fs-tools中的代码，这部分逻辑代码更加易懂，没有涉及打到缓存页的操作。</p><h2 id="1-f2fs-tools中的write-checkpoint"><a href="#1-f2fs-tools中的write-checkpoint" class="headerlink" title="1.f2fs-tools中的write checkpoint"></a>1.f2fs-tools中的write checkpoint</h2><p>这部分源码来自于Android 12源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// external\f2fs-tools\fsck\mount.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">write_checkpoints</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-comment">/* copy valid checkpoint to its mirror position */</span><br>duplicate_checkpoint(sbi);<br><br><span class="hljs-comment">/* repair checkpoint at CP #0 position */</span><br>sbi-&gt;cur_cp = <span class="hljs-number">1</span>;<br>write_checkpoint(sbi);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>duplicate_checkpoint：将cp pack1和cp pack2中的内容进行备份，保持一致</li><li>sbi-&gt;cur_cp&#x3D;1：既然2份cp pack已经一致，往哪一个写都行，那么直接定义当前要写的cp pack为cp pack1</li><li>write_checkpoin：向cp pack1写checkpoint</li></ul><h3 id="1-1-备份cp-pack"><a href="#1-1-备份cp-pack" class="headerlink" title="1.1 备份cp pack"></a>1.1 备份cp pack</h3><p>这里首先了解一下啊Checkpoint的布局【主备机制】：</p><img src="/2023/10/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84write-checkpoint%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/5-1696222445978-1.png" alt="5" style="zoom:80%;"><ul><li>checkpoint区域由2个cp pack组成，分别为cp pack1和cp pack2，每一个cp pack的大小都是1个segment</li><li>每一个cp pack头尾都有一个cp page页（对应f2fs_checkpoint结构体），一般2个cp page被称为cp page1、cp page2或cp header page、cp footer page。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">duplicate_checkpoint</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_super_block</span> *<span class="hljs-title">sb</span> =</span> F2FS_RAW_SUPER(sbi);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> dst, src;<br><span class="hljs-type">void</span> *buf;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seg_size = <span class="hljs-number">1</span> &lt;&lt; get_sb(log_blocks_per_seg);<br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-keyword">if</span> (sbi-&gt;cp_backuped)<br><span class="hljs-keyword">return</span>;<br><br>buf = <span class="hljs-built_in">malloc</span>(F2FS_BLKSIZE * seg_size);<br><br>    <span class="hljs-comment">// src: 当前被使用的cp pack</span><br>    <span class="hljs-comment">// dst: 将当前使用的cp pack拷贝备份到另外一个cp pcak</span><br><span class="hljs-keyword">if</span> (sbi-&gt;cur_cp == <span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">// 如果当前使用的是第一个cp pack</span><br>src = get_sb(cp_blkaddr);<br>dst = src + seg_size;<br>&#125; <span class="hljs-keyword">else</span> &#123;                       <span class="hljs-comment">// 如果当前使用的是第二个cp pack</span><br>dst = get_sb(cp_blkaddr);<br>src = dst + seg_size;<br>&#125;<br><br>ret = dev_read(buf, src &lt;&lt; F2FS_BLKSIZE_BITS, seg_size &lt;&lt; F2FS_BLKSIZE_BITS);<br><br>ret = dev_write(buf, dst &lt;&lt; F2FS_BLKSIZE_BITS,seg_size &lt;&lt; F2FS_BLKSIZE_BITS);<br><br><span class="hljs-built_in">free</span>(buf);<br><br>ret = f2fs_fsync_device();<br>ASSERT(ret &gt;= <span class="hljs-number">0</span>);<br><br>sbi-&gt;cp_backuped = <span class="hljs-number">1</span>;<br><br>MSG(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Info: Duplicate valid checkpoint to mirror position %llu -&gt; %llu\n&quot;</span>, src, dst);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-写checkpoint"><a href="#1-2-写checkpoint" class="headerlink" title="1.2 写checkpoint"></a>1.2 写checkpoint</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">write_checkpoint</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_checkpoint</span> *<span class="hljs-title">cp</span> =</span> F2FS_CKPT(sbi);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_super_block</span> *<span class="hljs-title">sb</span> =</span> F2FS_RAW_SUPER(sbi);<br><span class="hljs-type">block_t</span> orphan_blks = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> cp_blk_no;<br>u32 flags = CP_UMOUNT_FLAG;<br><span class="hljs-type">int</span> i, ret;<br><span class="hljs-type">u_int32_t</span> crc = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (is_set_ckpt_flags(cp, CP_ORPHAN_PRESENT_FLAG)) &#123;<br>orphan_blks = __start_sum_addr(sbi) - <span class="hljs-number">1</span>;<br>flags |= CP_ORPHAN_PRESENT_FLAG;<br>&#125;<br><br><br>    set_cp(checksum_offset, CP_CHKSUM_OFFSET);  <span class="hljs-comment">// #define CP_CHKSUM_OFFSET4092</span><br><br>set_cp(cp_pack_total_block_count, <span class="hljs-number">8</span> + orphan_blks + get_sb(cp_payload));<br><br>flags = update_nat_bits_flags(sb, cp, flags);<br>set_cp(ckpt_flags, flags);<br><br>crc = f2fs_checkpoint_chksum(cp); <span class="hljs-comment">// 计算checkpoint的crc值</span><br>*((__le32 *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)cp + get_cp(checksum_offset))) = cpu_to_le32(crc);  <span class="hljs-comment">// cp偏移4092字节的位置，修改crc值</span><br><br>    <span class="hljs-comment">// 获取到的cp pack的起始地址</span><br>cp_blk_no = get_sb(cp_blkaddr);<br><span class="hljs-keyword">if</span> (sbi-&gt;cur_cp == <span class="hljs-number">2</span>)<br>cp_blk_no += <span class="hljs-number">1</span> &lt;&lt; get_sb(log_blocks_per_seg);<br><br><span class="hljs-comment">// 写cp pack1的cp page1，因为cp page1为1个block，写完后直接++</span><br>ret = dev_write_block(cp, cp_blk_no++);<br><br><span class="hljs-comment">/* skip payload */</span><br>cp_blk_no += get_sb(cp_payload);<br><span class="hljs-comment">/* skip orphan blocks */</span><br>cp_blk_no += orphan_blks;<br><br><span class="hljs-comment">/* update summary blocks having nullified journal entries */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NO_CHECK_TYPE; i++) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg</span> =</span> CURSEG_I(sbi, i);<br>u64 ssa_blk;<br><br>ret = dev_write_block(curseg-&gt;sum_blk, cp_blk_no++);<br>ASSERT(ret &gt;= <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">if</span> (!(get_sb(feature) &amp; cpu_to_le32(F2FS_FEATURE_RO))) &#123;<br><span class="hljs-comment">/* update original SSA too */</span><br>ssa_blk = GET_SUM_BLKADDR(sbi, curseg-&gt;segno);<br>ret = dev_write_block(curseg-&gt;sum_blk, ssa_blk);<br>ASSERT(ret &gt;= <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* Write nat bits */</span><br><span class="hljs-keyword">if</span> (flags &amp; CP_NAT_BITS_FLAG)<br>write_nat_bits(sbi, sb, cp, sbi-&gt;cur_cp);<br><br><span class="hljs-comment">/* in case of sudden power off */</span><br>ret = f2fs_fsync_device();<br><br><span class="hljs-comment">// 写cp pack的cp page2，其实这里没必要cp_blk_no了</span><br>ret = dev_write_block(cp, cp_blk_no++);<br>    <br>ret = f2fs_fsync_device();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个流程起手就是在填充下面这张图中每个区域：</p><img src="/2023/10/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84write-checkpoint%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/5-1696222445978-1.png" alt="5" style="zoom:80%;"><p>值得注意的是写2个cp page页，cp page1和cp page2：</p><img src="/2023/10/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84write-checkpoint%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20231002131029196.png" alt="image-20231002131029196" style="zoom:67%;"><img src="/2023/10/02/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84write-checkpoint%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20231002131016847.png" alt="image-20231002131016847" style="zoom: 67%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dev_write_block</span><span class="hljs-params">(<span class="hljs-type">void</span> *buf, __u64 blk_addr)</span><br>&#123;<br>    <span class="hljs-comment">// #define F2FS_BLKSIZE 4096 我们知道一个页对应4096字节，也即f2fs中一个block大小为4096字节</span><br><span class="hljs-keyword">return</span> dev_write(buf, blk_addr &lt;&lt; F2FS_BLKSIZE_BITS, F2FS_BLKSIZE);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Linux源码中的write-checkpoint"><a href="#2-Linux源码中的write-checkpoint" class="headerlink" title="2.Linux源码中的write checkpoint"></a>2.Linux源码中的write checkpoint</h2><p>这部分源码来自于Linux 5.10.8源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_write_checkpoint</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-keyword">struct</span> cp_control *cpc)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_checkpoint</span> *<span class="hljs-title">ckpt</span> =</span> F2FS_CKPT(sbi);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ckpt_ver;<br><span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br><br>err = block_operations(sbi);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> out;<br><br>f2fs_flush_merged_writes(sbi);<br><br>ckpt_ver = cur_cp_version(ckpt);<br>ckpt-&gt;checkpoint_ver = cpu_to_le64(++ckpt_ver);<br><br>err = f2fs_flush_nat_entries(sbi, cpc);<br><br>f2fs_flush_sit_entries(sbi, cpc);<br><br>f2fs_save_inmem_curseg(sbi);<br><br>err = do_checkpoint(sbi, cpc);<br><br>f2fs_restore_inmem_curseg(sbi);<br>stop:<br>unblock_operations(sbi);<br>stat_inc_cp_count(sbi-&gt;stat_info);<br><br>f2fs_update_time(sbi, CP_TIME);<br>trace_f2fs_write_checkpoint(sbi-&gt;sb, cpc-&gt;reason, <span class="hljs-string">&quot;finish checkpoint&quot;</span>);<br>out:<br><span class="hljs-keyword">if</span> (cpc-&gt;reason != CP_RESIZE)<br>mutex_unlock(&amp;sbi-&gt;cp_mutex);<br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-NAT脏数据回写"><a href="#2-1-NAT脏数据回写" class="headerlink" title="2.1 NAT脏数据回写"></a>2.1 NAT脏数据回写</h3><blockquote><p>部分参考自：<a href="https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Data-Recovery/Checkpoint%E6%B5%81%E7%A8%8B.md">https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Data-Recovery/Checkpoint%E6%B5%81%E7%A8%8B.md</a></p></blockquote><p><code>f2fs_flush_nat_entries</code> 和 <code>f2fs_flush_sit_entries</code> 的作用是将暂存在ram的nat entry合sit entry都回写到Journal或磁盘当中:</p><h4 id="2-1-1-f2fs-flush-nat-entries函数"><a href="#2-1-1-f2fs-flush-nat-entries函数" class="headerlink" title="2.1.1 f2fs_flush_nat_entries函数"></a>2.1.1 f2fs_flush_nat_entries函数</h4><p>✅修改node的信息会对对应的<code>nat_entry</code>进行修改，同时<code>nat_entry</code>会被设置为脏，加入到<code>nm_i-&gt;nat_set_root</code>的radix tree中。Checkpoint会对脏的<code>nat_entry</code>进行回写，完成元数据的更新。</p><p>首先声明了一个list变量<code>LIST_HEAD(sets)</code>，然后通过一个while循环，将<code>nat_entry_set</code>按一个set为单位，对脏的<code>nat_entry</code>进行提取，每次提取SETVEC_SIZE个，然后保存到<code>setvec[SETVEC_SIZE]</code>中，然后对<code>setvec</code>中的每一个<code>nat_entry_set</code>，按照一定条件加入到<code>LIST_HEAD(sets)</code>的链表中。最后针对<code>LIST_HEAD(sets)</code>的<code>nat_entry_set</code>，执行<code>__flush_nat_entry_set</code>函数，对脏数据进行回写。<code>__flush_nat_entry_set</code>有两种回写方法，第一种是写入到curseg的journal中，第二种是直接找到对应的nat block，回写到磁盘中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_flush_nat_entries</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-keyword">struct</span> cp_control *cpc)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nm_info</span> *<span class="hljs-title">nm_i</span> =</span> NM_I(sbi);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg</span> =</span> CURSEG_I(sbi, CURSEG_HOT_DATA);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_journal</span> *<span class="hljs-title">journal</span> =</span> curseg-&gt;journal;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nat_entry_set</span> *<span class="hljs-title">setvec</span>[<span class="hljs-title">SETVEC_SIZE</span>];</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nat_entry_set</span> *<span class="hljs-title">set</span>, *<span class="hljs-title">tmp</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> found;<br><span class="hljs-type">nid_t</span> set_idx = <span class="hljs-number">0</span>;<br>LIST_HEAD(sets);<br><br><span class="hljs-keyword">if</span> (!nm_i-&gt;dirty_nat_cnt)<br><span class="hljs-keyword">return</span>;<br><br>down_write(&amp;nm_i-&gt;nat_tree_lock);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * __gang_lookup_nat_set 这个函数就是从radix tree读取set_idx开始，</span><br><span class="hljs-comment"> * 连续读取SETVEC_SIZE这么多个nat_entry_set，保存在setvec中</span><br><span class="hljs-comment"> * 然后按照一定条件，通过__adjust_nat_entry_set函数加入到LIST_HEAD(sets)链表中</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">while</span> ((found = __gang_lookup_nat_set(nm_i,<br>set_idx, SETVEC_SIZE, setvec))) &#123;<br><span class="hljs-type">unsigned</span> idx;<br>set_idx = setvec[found - <span class="hljs-number">1</span>]-&gt;<span class="hljs-built_in">set</span> + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (idx = <span class="hljs-number">0</span>; idx &lt; found; idx++)<br>__adjust_nat_entry_set(setvec[idx], &amp;sets,<br>MAX_NAT_JENTRIES(journal));<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * flush dirty nats in nat entry set</span><br><span class="hljs-comment"> * 遍历这个list所有的nat_entry_set，然后写入到curseg-&gt;journal中</span><br><span class="hljs-comment"> * */</span><br>list_for_each_entry_safe(<span class="hljs-built_in">set</span>, tmp, &amp;sets, set_list)<br>__flush_nat_entry_set(sbi, <span class="hljs-built_in">set</span>, cpc);<br><br>up_write(&amp;nm_i-&gt;nat_tree_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>__flush_nat_entry_set</code>有两种回写的方式，第一种是写入到curseg的journal中，第二种是回写到nat block中。</p><p>第一种写入方式通常是由于curseg有足够的journal的情况下的写入，首先遍历<code>nat_entry_set</code>中的所有<code>nat_entry</code>，然后根据nid找到curseg-&gt;journal中对应的nat_entry的位置，跟着将被遍历的<code>nat_entry</code>的值赋予给curseg-&gt;journal的<code>nat_entry</code>，通过<code>raw_nat_from_node_info</code>完成curseg的nat_entry的更新。</p><p>第二种写入方式在curseg没有足够的journal的时候触发，首先根据nid找到NAT区域的对应的<code>f2fs_nat_block</code>，然后通过<code>get_next_nat_page</code>读取出来，然后通过<code>raw_nat_from_node_info</code>进行更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __flush_nat_entry_set(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi,<br><span class="hljs-keyword">struct</span> nat_entry_set *<span class="hljs-built_in">set</span>, <span class="hljs-keyword">struct</span> cp_control *cpc)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg</span> =</span> CURSEG_I(sbi, CURSEG_HOT_DATA);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_journal</span> *<span class="hljs-title">journal</span> =</span> curseg-&gt;journal;<br><span class="hljs-type">nid_t</span> start_nid = <span class="hljs-built_in">set</span>-&gt;<span class="hljs-built_in">set</span> * NAT_ENTRY_PER_BLOCK; <span class="hljs-comment">// 根据set number找到对应f2fs_nat_block</span><br><span class="hljs-type">bool</span> to_journal = <span class="hljs-literal">true</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nat_block</span> *<span class="hljs-title">nat_blk</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nat_entry</span> *<span class="hljs-title">ne</span>, *<span class="hljs-title">cur</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * there are two steps to flush nat entries:</span><br><span class="hljs-comment"> * #1, flush nat entries to journal in current hot data summary block.</span><br><span class="hljs-comment"> * #2, flush nat entries to nat page.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (enabled_nat_bits(sbi, cpc) ||<br>!__has_cursum_space(journal, <span class="hljs-built_in">set</span>-&gt;entry_cnt, NAT_JOURNAL)) <span class="hljs-comment">//当curseg的journal空间不够了，就刷写到磁盘中</span><br>to_journal = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">if</span> (to_journal) &#123;<br>down_write(&amp;curseg-&gt;journal_rwsem);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>page = get_next_nat_page(sbi, start_nid); <span class="hljs-comment">/* 根据nid找到管理这个nid的f2fs_nat_block */</span><br>nat_blk = page_address(page);<br>f2fs_bug_on(sbi, !nat_blk);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * flush dirty nats in nat entry set</span><br><span class="hljs-comment"> * 遍历所有脏的nat_entry</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * nat_entry只存在于内存当中，具体在磁盘保存的是f2fs_entry_block</span><br><span class="hljs-comment"> * */</span><br>list_for_each_entry_safe(ne, cur, &amp;<span class="hljs-built_in">set</span>-&gt;entry_list, <span class="hljs-built_in">list</span>) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nat_entry</span> *<span class="hljs-title">raw_ne</span>;</span><br><span class="hljs-type">nid_t</span> nid = nat_get_nid(ne);<br><span class="hljs-type">int</span> offset;<br><br>f2fs_bug_on(sbi, nat_get_blkaddr(ne) == NEW_ADDR);<br><br><span class="hljs-keyword">if</span> (to_journal) &#123;<br><span class="hljs-comment">// 搜索当前的journal中nid所在的位置</span><br>offset = f2fs_lookup_journal_in_cursum(journal,<br>NAT_JOURNAL, nid, <span class="hljs-number">1</span>);<br>f2fs_bug_on(sbi, offset &lt; <span class="hljs-number">0</span>);<br>raw_ne = &amp;nat_in_journal(journal, offset); <span class="hljs-comment">// 从journal中取出f2fs_nat_entry的信息</span><br>nid_in_journal(journal, offset) = cpu_to_le32(nid); <span class="hljs-comment">// 更新journal的nid</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>raw_ne = &amp;nat_blk-&gt;entries[nid - start_nid]; <span class="hljs-comment">/* 拿到nid对应的nat_entry地址，下面开始填数据 */</span><br>&#125;<br>raw_nat_from_node_info(raw_ne, &amp;ne-&gt;ni); <span class="hljs-comment">// 将node info的信息更新到journal中后者磁盘中</span><br>nat_reset_flag(ne); <span class="hljs-comment">// 清除需要CP的标志</span><br>__clear_nat_cache_dirty(NM_I(sbi), <span class="hljs-built_in">set</span>, ne); <span class="hljs-comment">// 从dirty list清除处理后的entry</span><br><span class="hljs-keyword">if</span> (nat_get_blkaddr(ne) == NULL_ADDR) &#123; <span class="hljs-comment">// 如果对应nid已经是被无效化了，则释放</span><br>add_free_nid(sbi, nid, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>spin_lock(&amp;NM_I(sbi)-&gt;nid_list_lock);<br>update_free_nid_bitmap(sbi, nid, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 更新可用的nat的bitmap</span><br>spin_unlock(&amp;NM_I(sbi)-&gt;nid_list_lock);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (to_journal) &#123;<br>up_write(&amp;curseg-&gt;journal_rwsem);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>__update_nat_bits(sbi, start_nid, page);<br>f2fs_put_page(page, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/* Allow dirty nats by node block allocation in write_begin */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set</span>-&gt;entry_cnt) &#123;<br>radix_tree_delete(&amp;NM_I(sbi)-&gt;nat_set_root, <span class="hljs-built_in">set</span>-&gt;<span class="hljs-built_in">set</span>);<br>kmem_cache_free(nat_entry_set_slab, <span class="hljs-built_in">set</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓checkpoint=disable如何传递到f2fs文件系统</title>
    <link href="/2023/09/19/%E5%AE%89%E5%8D%93checkpoint-disable%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%88%B0f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/09/19/%E5%AE%89%E5%8D%93checkpoint-disable%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%88%B0f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓checkpoint-x3D-disable如何传递到f2fs文件系统"><a href="#安卓checkpoint-x3D-disable如何传递到f2fs文件系统" class="headerlink" title="安卓checkpoint&#x3D;disable如何传递到f2fs文件系统"></a>安卓checkpoint&#x3D;disable如何传递到f2fs文件系统</h1><h2 id="1-解析挂载参数并处理"><a href="#1-解析挂载参数并处理" class="headerlink" title="1.解析挂载参数并处理"></a>1.解析挂载参数并处理</h2><p>当我们挂载f2fs文件系统的时候，会调用到<strong>f2fs_mount</strong>，后面的调用栈依次为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">f2fs_mount<br>    -&gt; mount_bdev<br>    -&gt; f2fs_fill_super <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_fill_super</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">void</span> *data, <span class="hljs-type">int</span> silent)</span><br>&#123;<br>    default_options(sbi);<br>options = kstrdup((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)data, GFP_KERNEL);<br>err = parse_options(sb, options, <span class="hljs-literal">false</span>);  <span class="hljs-comment">// 解析挂载参数</span><br>    <br>    <span class="hljs-comment">// ...</span><br>    <br>reset_checkpoint:<br><br><span class="hljs-keyword">if</span> (test_opt(sbi, DISABLE_CHECKPOINT)) &#123;<br>err = f2fs_disable_checkpoint(sbi);   <span class="hljs-comment">// 处理disable参数#</span><br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> sync_free_meta;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_set_ckpt_flags(sbi, CP_DISABLED_FLAG)) &#123;<br>f2fs_enable_checkpoint(sbi);<br>&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-1-解析挂载参数"><a href="#1-1-解析挂载参数" class="headerlink" title="1.1 解析挂载参数"></a>1.1 解析挂载参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">match_table_t</span> f2fs_tokens = &#123;<br><span class="hljs-comment">// ...</span><br>&#123;Opt_checkpoint_disable, <span class="hljs-string">&quot;checkpoint=disable&quot;</span>&#125;,<br>&#123;Opt_checkpoint_disable_cap, <span class="hljs-string">&quot;checkpoint=disable:%u&quot;</span>&#125;,<br>&#123;Opt_checkpoint_disable_cap_perc, <span class="hljs-string">&quot;checkpoint=disable:%u%%&quot;</span>&#125;,<br><span class="hljs-comment">// ...</span><br>&#123;Opt_err, <span class="hljs-literal">NULL</span>&#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parse_options</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">char</span> *options, <span class="hljs-type">bool</span> is_remount)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> ((p = strsep(&amp;options, <span class="hljs-string">&quot;,&quot;</span>)) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-type">int</span> token;<br><span class="hljs-keyword">if</span> (!*p)<br><span class="hljs-keyword">continue</span>;<br><br>args[<span class="hljs-number">0</span>].to = args[<span class="hljs-number">0</span>].from = <span class="hljs-literal">NULL</span>;<br>token = match_token(p, f2fs_tokens, args);<br><br><span class="hljs-keyword">switch</span> (token) &#123;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">case</span> Opt_checkpoint_disable:<br>                set_opt(sbi, DISABLE_CHECKPOINT);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，从用户态传递下来的参数最终就干了一件事：<strong>set_opt(sbi, DISABLE_CHECKPOINT)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> F2FS_OPTION(sbi)((sbi)-&gt;mount_opt)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clear_opt(sbi, option)(F2FS_OPTION(sbi).opt &amp;= ~F2FS_MOUNT_##option)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_opt(sbi, option)(F2FS_OPTION(sbi).opt |= F2FS_MOUNT_##option)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> test_opt(sbi, option)(F2FS_OPTION(sbi).opt &amp; F2FS_MOUNT_##option)</span><br></code></pre></td></tr></table></figure><p>✅一句话总结：checkpoint&#x3D;disable的最终影响为sbi的mount_opt字段会多一个选项：<strong>F2FS_MOUNT_DISABLE_CHECKPOINT</strong></p><h3 id="1-2-处理DISABLE-CHECKPOINT"><a href="#1-2-处理DISABLE-CHECKPOINT" class="headerlink" title="1.2 处理DISABLE_CHECKPOINT"></a>1.2 处理DISABLE_CHECKPOINT</h3><p>在f2fs_fill_super里面设置了该DISABLE_CHECKPOINT，那么这里就会走进去判断</p><img src="/2023/09/19/%E5%AE%89%E5%8D%93checkpoint-disable%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%88%B0f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20231006233308177.png" alt="image-20231006233308177" style="zoom:67%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_disable_checkpoint</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> s_flags = sbi-&gt;sb-&gt;s_flags;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cp_control</span> <span class="hljs-title">cpc</span>;</span><br><span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ret;<br><span class="hljs-type">block_t</span> unusable;<br><br>    <span class="hljs-comment">// 注意: checkpoint=disable是不允许运行在只读的f2fs文件系统中</span><br><span class="hljs-keyword">if</span> (s_flags &amp; SB_RDONLY) &#123;<br>f2fs_err(sbi, <span class="hljs-string">&quot;checkpoint=disable on readonly fs&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br>sbi-&gt;sb-&gt;s_flags |= SB_ACTIVE;<br><br>ret = sync_filesystem(sbi-&gt;sb);  <span class="hljs-comment">// 这里会sync一次，也就是进行了一次checkpoint</span><br><br>unusable = f2fs_get_unusable_blocks(sbi);<br><br>down_write(&amp;sbi-&gt;gc_lock);<br>cpc.reason = CP_PAUSE;   <span class="hljs-comment">// 设置cpc的原因为CP_PAUSE</span><br>set_sbi_flag(sbi, SBI_CP_DISABLED);<br>err = f2fs_write_checkpoint(sbi, &amp;cpc);<br><br>spin_lock(&amp;sbi-&gt;stat_lock);<br>sbi-&gt;unusable_block_count = unusable;<br>spin_unlock(&amp;sbi-&gt;stat_lock);<br><br>out_unlock:<br>up_write(&amp;sbi-&gt;gc_lock);<br>restore_flag:<br>sbi-&gt;sb-&gt;s_flags = s_flags;<span class="hljs-comment">/* Restore SB_RDONLY status */</span><br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置完了<code>cpc.reason = CP_PAUSE</code>，并且设置sbi的标志为<code>SBI_CP_DISABLED</code>，紧接着会调用一次checkpoint</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_write_checkpoint</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-keyword">struct</span> cp_control *cpc)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED))) &#123;<br><span class="hljs-keyword">if</span> (cpc-&gt;reason != CP_PAUSE)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>f2fs_warn(sbi, <span class="hljs-string">&quot;Start checkpoint disabled!&quot;</span>);<br>&#125;<br>    <br>    <span class="hljs-comment">// 下面就是一次正常的cp操作了</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-以后的checkpoint影响是啥"><a href="#1-3-以后的checkpoint影响是啥" class="headerlink" title="1.3 以后的checkpoint影响是啥"></a>1.3 以后的checkpoint影响是啥</h3><p>当挂载完成时完成了一次checkpoint后，下次当用户态调用sync或者周期进行cp的时候，最终又会调用到<strong>f2fs_write_checkpoint</strong></p><p>根据上面发现，因为是sync过来的cp，或者周期性的cp，那么cpc-&gt;reason肯定是没有设置CP_PAUSE的，那么走到if分支里面就会return 0，后面正常的cp流程就不会走。</p><img src="/2023/09/19/%E5%AE%89%E5%8D%93checkpoint-disable%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%88%B0f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20231006235204172.png" alt="image-20231006235204172" style="zoom: 67%;"><p>✅一句话总结：设置了checkpoint&#x3D;disable后，除了挂载时候能够完成一次正常的cp，后面的每一次cp都会失效</p><h2 id="2-用户携带了checkpoint-x3D-enable重新挂载"><a href="#2-用户携带了checkpoint-x3D-enable重新挂载" class="headerlink" title="2.用户携带了checkpoint&#x3D;enable重新挂载"></a>2.用户携带了checkpoint&#x3D;enable重新挂载</h2><p>例如在Android中，launcher启动完成后会回调cp_commitChanges，此时会携带<strong>checkpoint&#x3D;enable</strong>重新挂载一次</p><img src="/2023/09/19/%E5%AE%89%E5%8D%93checkpoint-disable%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%88%B0f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20231006235540325.png" alt="image-20231006235540325" style="zoom: 60%;"><p>注意这里有MS_REMOUNT标志，会重新挂载f2fs文件系统</p><p>在内核态调用do_remount函数，调用栈为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">do_remount<br>    -&gt; f2fs_remount<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_remount</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">int</span> *flags, <span class="hljs-type">char</span> *data)</span><br>&#123;<br>    <span class="hljs-type">bool</span> disable_checkpoint = test_opt(sbi, DISABLE_CHECKPOINT);  <span class="hljs-comment">// 1.1节中设置了DISABLE_CHECKPOINT，所以disable_checkpoint=true</span><br>    <span class="hljs-type">bool</span> checkpoint_changed;<br>    <br>err = parse_options(sb, data, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// 见2.1 解析重挂载参数</span><br><br>    <span class="hljs-comment">// 见2.2 清除的后续操作</span><br>checkpoint_changed = disable_checkpoint != test_opt(sbi, DISABLE_CHECKPOINT);<br>    <br>    <span class="hljs-keyword">if</span> (checkpoint_changed) &#123;<br><span class="hljs-keyword">if</span> (test_opt(sbi, DISABLE_CHECKPOINT)) &#123;<br>err = f2fs_disable_checkpoint(sbi);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> restore_gc;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>f2fs_enable_checkpoint(sbi);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-解析重挂载参数"><a href="#2-1-解析重挂载参数" class="headerlink" title="2.1 解析重挂载参数"></a>2.1 解析重挂载参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">match_table_t</span> f2fs_tokens = &#123;<br><span class="hljs-comment">// ...</span><br>&#123;Opt_checkpoint_enable, <span class="hljs-string">&quot;checkpoint=enable&quot;</span>&#125;,<br><span class="hljs-comment">// ...</span><br>&#123;Opt_err, <span class="hljs-literal">NULL</span>&#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parse_options</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">char</span> *options, <span class="hljs-type">bool</span> is_remount)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> ((p = strsep(&amp;options, <span class="hljs-string">&quot;,&quot;</span>)) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-type">int</span> token;<br><span class="hljs-keyword">if</span> (!*p)<br><span class="hljs-keyword">continue</span>;<br><br>args[<span class="hljs-number">0</span>].to = args[<span class="hljs-number">0</span>].from = <span class="hljs-literal">NULL</span>;<br>token = match_token(p, f2fs_tokens, args);<br><br><span class="hljs-keyword">switch</span> (token) &#123;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">case</span> Opt_checkpoint_enable:<br>                clear_opt(sbi, DISABLE_CHECKPOINT);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，从用户态传递下来的参数最终就干了一件事：<strong>clear_opt(sbi, DISABLE_CHECKPOINT);</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> F2FS_OPTION(sbi)((sbi)-&gt;mount_opt)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clear_opt(sbi, option)(F2FS_OPTION(sbi).opt &amp;= ~F2FS_MOUNT_##option)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_opt(sbi, option)(F2FS_OPTION(sbi).opt |= F2FS_MOUNT_##option)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> test_opt(sbi, option)(F2FS_OPTION(sbi).opt &amp; F2FS_MOUNT_##option)</span><br></code></pre></td></tr></table></figure><p>✅一句话总结：checkpoint&#x3D;enable的最终影响为sbi的mount_opt字段会清除选项：<strong>F2FS_MOUNT_DISABLE_CHECKPOINT</strong></p><h3 id="2-2-清除的后续操作"><a href="#2-2-清除的后续操作" class="headerlink" title="2.2 清除的后续操作"></a>2.2 清除的后续操作</h3><p>可以发现，checkpoint_changed变量应该为true，因为初始化时<strong>disale_checkpoint&#x3D;true</strong>(上面有分析)，此时已经被清除了DISABLE_CHECKPOINT，所以两边不等</p><img src="/2023/09/19/%E5%AE%89%E5%8D%93checkpoint-disable%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%88%B0f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20231007000550469.png" alt="image-20231007000550469" style="zoom:80%;"><p>对应在f2fs_remount中checkpoint_changed为true，就会走<strong>f2fs_enable_checkpoint</strong></p><img src="/2023/09/19/%E5%AE%89%E5%8D%93checkpoint-disable%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%88%B0f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20231007000858315.png" alt="image-20231007000858315" style="zoom:67%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_enable_checkpoint</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br>clear_sbi_flag(sbi, SBI_CP_DISABLED);<br>set_sbi_flag(sbi, SBI_IS_DIRTY);<br>f2fs_sync_fs(sbi-&gt;sb, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>clear_sbi_flag：清除1.2节中设置的SBI_CP_DISABLED，这样f2fs_write_checkpoint的第一个if分支就不会被return 0拦截了</li><li>set_sbi_flag：设置SBI_IS_DIRTY</li><li>f2fs_sync_fs：调用sync，最终会走到cp流程里面【那么disbale-&gt;enable这段时间的所有数据都会刷盘】</li></ul><img src="/2023/09/19/%E5%AE%89%E5%8D%93checkpoint-disable%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%88%B0f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20231007001522443.png" alt="image-20231007001522443" style="zoom:80%;"><h2 id="备忘1：f2fs的checkpoint时机"><a href="#备忘1：f2fs的checkpoint时机" class="headerlink" title="备忘1：f2fs的checkpoint时机"></a>备忘1：f2fs的checkpoint时机</h2><p>CP是一个开销很大的操作，因此合理选取CP时机，能够很好地提高性能。CP的触发时机有:</p><blockquote><p>前台GC(FG_GC)<br>FASTBOOT<br>UMOUNT<br>DISCARD<br>RECOVERY<br>TRIM<br><strong>周期进行</strong></p></blockquote><p>因此F2FS有几个宏表示CP的触发原因：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span>CP_UMOUNT0x00000001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>CP_FASTBOOT0x00000002</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>CP_SYNC0x00000004</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>CP_RECOVERY0x00000008</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>CP_DISCARD0x00000010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CP_TRIMMED0x00000020</span><br></code></pre></td></tr></table></figure><p>✅CP执行周期查看：<strong>cat &#x2F;dev&#x2F;sys&#x2F;fs&#x2F;by-name&#x2F;userdata&#x2F;cp_interval</strong></p><h2 id="备忘2：什么情况下数据需要写回磁盘"><a href="#备忘2：什么情况下数据需要写回磁盘" class="headerlink" title="备忘2：什么情况下数据需要写回磁盘"></a>备忘2：什么情况下数据需要写回磁盘</h2><blockquote><p><a href="https://blog.csdn.net/guoyong10721073/article/details/8718288">https://blog.csdn.net/guoyong10721073/article/details/8718288</a></p></blockquote><p>在内存中积累起来的脏页最终必须被写回磁盘。在以下3种情况发生时，脏页被写回磁盘：</p><p>1）<strong>当空闲内存低于一个特定的阈值时</strong>，内核必须将脏页写回磁盘以便释放内存，因为只有干净内存才可以被回收。当内存干净后，内核就可以从缓存清理数据，然后收缩缓存，最终释放出更多的内存。</p><p>2）当脏页在内存中<strong>驻留的时间</strong>超过了一个给定的<strong>阈值</strong>时，内核必须将超时的脏页写回磁盘，以确保脏页不会无限期地驻留在内存中。</p><p>3）当用户进程调用<strong>sync</strong>和<strong>fsync</strong>系统调用时，内核会按要求执行写回操作。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【转载】龙蜥白皮书精选：基于 SM4 算法的文件加密（fscrypt）实践</title>
    <link href="/2023/09/19/%E9%BE%99%E8%9C%A5%E7%99%BD%E7%9A%AE%E4%B9%A6%E7%B2%BE%E9%80%89%EF%BC%9A%E5%9F%BA%E4%BA%8E-SM4-%E7%AE%97%E6%B3%95%E7%9A%84%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%EF%BC%88fscrypt%EF%BC%89%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/09/19/%E9%BE%99%E8%9C%A5%E7%99%BD%E7%9A%AE%E4%B9%A6%E7%B2%BE%E9%80%89%EF%BC%9A%E5%9F%BA%E4%BA%8E-SM4-%E7%AE%97%E6%B3%95%E7%9A%84%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%EF%BC%88fscrypt%EF%BC%89%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="【转载】龙蜥白皮书精选：基于-SM4-算法的文件加密（fscrypt）实践"><a href="#【转载】龙蜥白皮书精选：基于-SM4-算法的文件加密（fscrypt）实践" class="headerlink" title="【转载】龙蜥白皮书精选：基于 SM4 算法的文件加密（fscrypt）实践"></a>【转载】龙蜥白皮书精选：基于 SM4 算法的文件加密（fscrypt）实践</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/weixin_60347558/article/details/129886294?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_60347558/article/details/129886294?spm=1001.2014.3001.5506</a></p></blockquote><h2 id="1-fscrypt-简介"><a href="#1-fscrypt-简介" class="headerlink" title="1.fscrypt 简介"></a>1.fscrypt 简介</h2><p>内核中的 fscrypt 是一个库，文件系统可以使用它以支持文件和目录的透明加密。</p><p>与 dm-crypt 不同，fscrypt 在文件系统级别而不是块设备级别运行。这允许它使用不同的密钥加密不同的文件，并在同一文件系统上拥有未加密的文件。这对于多用户系统非常有用，在该系统中，每个用户的静态数据都需要与其他用户进行加密隔离。除了文件名，fscrypt 不加密文件系统的元数据。</p><p>与作为栈式文件系统的 eCryptfs 不同，fscrypt 是直接集成到支持的文件系统中，目前支持 fscrypt 的文件系统是 ext4、F2FS 和 UBIFS。fscrypt 允许读取和写入加密文件，而无需在页面缓存中同时缓存解密和加密页面，从而将使用的内存几乎减半并使其与未加密文件保持一致。同样，需要一半的 dentry 和 inode。eCryptfs 还将加密文件名限制为 143 字节，从而导致应用程序兼容性问题；fscrypt 允许完整的 255 个字节 (NAME_MAX)长度的文件名。最后，与 eCryptfs 不同，fscrypt API 可以由非特权用户使用，而无需依赖其它任何组件。</p><p>fscrypt 不支持就地加密文件。相反，它支持将空目录标记为已加密。然后，在用户空间提供密钥后，在该目录树中创建的所有常规文件、目录和符号链接都将被透明地加密。</p><h2 id="2-支持的加密模式和用法"><a href="#2-支持的加密模式和用法" class="headerlink" title="2.支持的加密模式和用法"></a>2.支持的加密模式和用法</h2><p>fscrypt 允许为文件内容指定一种加密模式，为文件名指定一种加密模式。不同的目录树允许使用不同的加密方式。目前支持以下几种加密方式对：</p><ul><li>AES-256-XTS 算法用于加密内容，AES-256-CTS-CBC 算法用于加密文件名</li><li>AES-128-CBC 算法用于加密内容，AES-128-CTS-CBC 算法用于加密文件名</li><li>Adiantum 算法同时用于加密文件内容和文件名</li><li>AES-256-XTS 算法用于加密内容，AES-256-HCTR2 算法用于加密文件名（仅限 v2 策略）</li><li>SM4-XTS 算法用于加密内容，SM4-CTS-CBC 算法用于加密文件名（仅限 v2 策略）</li></ul><p>AES-128-CBC 仅为具有不支持 XTS 模式的加速器的低功耗嵌入式设备使用。要使用 AES-128-CBC，必须启用 CONFIG_CRYPTO_ESSIV 和 CONFIG_CRYPTO_SHA256（或其他 SHA-256 实现）以便使用 ESSIV。</p><p>Adiantum 是一种基于流密码的模式，即使在没有专用加密指令的 CPU 上也很快。与 XTS 不同，它也是真正的宽块模式。要使用 Adiantum，必须启用 CONFIG_CRYPTO_ADIANTUM。此外，应启用 ChaCha 和 NHPoly1305 的快速实现，例如 ARM 架构上的 CONFIG_CRYPTO_CHACHA20_NEON 和 CONFIG_CRYPTO_NHPOLY1305_NEON。</p><p>AES-256-HCTR2 是另一种真正的宽块加密模式，旨在用于具有专用加密指令的 CPU。AES-256-HCTR2 具有明文中的位翻转会更改整个密文的属性。由于初始化向量在目录中重复使用，因此此属性使其成为<strong>文件名加密的理想选择</strong>。要使用 AES-256-HCTR2，必须启用 CONFIG_CRYPTO_HCTR2。此外，应启用 XCTR 和 POLYVAL 的快速实现，例如 用于 ARM64 的 CRYPTO_POLYVAL_ARM64_CE 和 CRYPTO_AES_ARM64_CE_BLK。</p><p><strong>最后是 SM4 算法，目前仅在 fscrypt v2 策略中启用。</strong></p><h2 id="3-使用-SM4-算法加密文件"><a href="#3-使用-SM4-算法加密文件" class="headerlink" title="3.使用 SM4 算法加密文件"></a>3.使用 SM4 算法加密文件</h2><blockquote><p>🟢 <strong>准备工作</strong></p></blockquote><p>fscrypt 依赖内核配置 CONFIG_FS_ENCRYPTION&#x3D;y，这里操作系统选择使用 ANCK 5.10 内核的 Anolis OS，其次，需要支持 fscrypt 特性的文件系统，这里以 ext4 为例，当然，F2FS 或者 UBIFS 也可以。</p><p>用户空间是通过 fscrypt API 跟内核完成交互的，对于用户来说，一般是通过 fscryptctl 或者 fscrypt 工具来下达加密策略。</p><p>本节内容以 fscryptctl（<a href="https://github.com/google/fscryptctl%EF%BC%89">https://github.com/google/fscryptctl）</a> 工具为例来演示，目前这是一个第三方工具，需要手工安装，按如下常规流程安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/google/fscryptctl.git<br><span class="hljs-built_in">cd</span> fscryptctl<br>make<br>make install<br></code></pre></td></tr></table></figure><p>其次，选择一块未用到的磁盘格式化为支持 fscrypt 的文件系统 ext4，并挂载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.ext4 -O encrypt /dev/vda3<br>mount /dev/vda3 /mnt<br></code></pre></td></tr></table></figure><blockquote><p>🟢 <strong>透明加密文件</strong></p></blockquote><p>fscrypt 所用的加解密钥是关联在超级块上的，运行时是跟挂载点相关联的，添加删除密钥都是针对挂载点的操作，以下对密钥操作的命令都会带上挂载点。</p><p>按如下命令所示设置加密策略：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成密钥文件，实际环境中应用使用更复杂的密钥</span><br>&gt; <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234567812345678&#x27;</span> &gt; /tmp/keyfile<br> <br><span class="hljs-comment"># 添加该密钥到文件系统，返回密钥ID，之后对密钥的操作都使用这个ID来索引</span><br>&gt; fscryptctl add_key /mnt &lt; /tmp/keyfile<br>23086a13ed81fd75ca5fe9b8f2ff25c7<br> <br><span class="hljs-comment"># 查看密钥状态（不是必需）</span><br>&gt; fscryptctl key_status 23086a13ed81fd75ca5fe9b8f2ff25c7 /mnt<br>Present (user_count=1, added_by_self)<br> <br><span class="hljs-comment"># 创建加密目录 endir，并设置加密策略</span><br><span class="hljs-comment"># 使用之前添加的密钥和 SM4 算法来加密该目录中的文件和子目录</span><br>&gt; <span class="hljs-built_in">mkdir</span> /mnt/endir<br>&gt; fscryptctl set_policy --contents=SM4-XTS \<br>        --filenames=SM4-CTS 23086a13ed81fd75ca5fe9b8f2ff25c7 /mnt/endir<br> <br><span class="hljs-comment"># 查看策略是否生效（不是必需）</span><br>&gt; fscryptctl get_policy /mnt/endir<br>Encryption policy <span class="hljs-keyword">for</span> /mnt/endir:<br>    Policy version: 2<br>    Master key identifier: 23086a13ed81fd75ca5fe9b8f2ff25c7<br>    Contents encryption mode: SM4-XTS<br>    Filenames encryption mode: SM4-CTS<br>    Flags: PAD_32<br></code></pre></td></tr></table></figure><p>此时，endir 已经是支持透明加解密的一个目录，可以像正常目录一样创建删除文件，在该目录下进行一些常规的文件操作，可以看到与普通目录没有区别：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; <span class="hljs-built_in">mkdir</span> /mnt/endir/foo<br>&gt; <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello&#x27;</span> &gt; /mnt/endir/foo/hello<br> <br>&gt; <span class="hljs-built_in">cp</span> -v /usr/include/curl/* endir<br>&gt; tree /mnt/endir<br>/mnt/endir<br>├── curl.h<br>├── easy.h<br>├── foo<br>│   └── hello<br>└── websockets.h<br></code></pre></td></tr></table></figure><blockquote><p>🟢 <strong>锁定加密目录</strong></p></blockquote><p>之所以能像普通目录一样操作，是因为密钥已经被添加到了文件系统中。接下来删除密钥后，就能看到目录被锁定，里面的所有路径和内容都是加密状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移除密钥</span><br>&gt; fscryptctl remove_key 23086a13ed81fd75ca5fe9b8f2ff25c7 /mnt<br> <br>&gt; fscryptctl key_status 23086a13ed81fd75ca5fe9b8f2ff25c7 /mnt<br>Absent<br> <br><span class="hljs-comment"># 处于加密状态的目录树</span><br>&gt; tree /mnt/endir<br>/mnt/endir<br>├── 1H2e0BbS4MGZKAKEu6NVXniaYMWIrWDwbyzX6EVEWEN8tfWcWNgDyw<br>├── LvYw6Jl0a1jImKKOFPjtpG3hEDxjjuM6YIYqcMeXaWdzKUdaX0YCNQ<br>├── QBBz8_qGE4MJY6YVzfqVUkr6YeCSqtoQmbvG04BsR0lAr2oLwO0b2g<br>│   └── wOYdFlMRACjeBa-eSo3LuO4sE55q1YuFv-S_lVU-n498jdMjAt06JA<br>└── zoiobWxVG2DLjg8uMXfsVP11159zqQUjozJ8gmt1zyjayJlZ4awOhA<br> <br><span class="hljs-comment"># 目录被锁定，无法进行常规文件操作，即便拔盘，也不能得到明文内容</span><br>&gt; <span class="hljs-built_in">cat</span> /mnt/endir/1H2e0BbS4MGZKAKEu6NVXniaYMWIrWDwbyzX6EVEWEN8tfWcWNgDyw<br><span class="hljs-built_in">cat</span>: /mnt/endir/1H2e0BbS4MGZKAKEu6NVXniaYMWIrWDwbyzX6EVEWEN8tfWcWNgDyw: Required key not available<br>&gt; <span class="hljs-built_in">mkdir</span> /mnt/endir/hello<br><span class="hljs-built_in">mkdir</span>: cannot create directory ‘/mnt/endir/hello’: Required key not available<br></code></pre></td></tr></table></figure><blockquote><p>🟢 <strong>再次解锁加密目录</strong></p></blockquote><p>要解锁目录也很简单，重新添加密钥即可，文件系统会搜索到正确的密钥并解锁相应目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; fscryptctl add_key /mnt &lt; /tmp/keyfile<br>23086a13ed81fd75ca5fe9b8f2ff25c7<br> <br><span class="hljs-comment"># 添加密钥后文件内容可正常访问</span><br>&gt; <span class="hljs-built_in">cat</span> /mnt/endir/foo/hello<br>hello<br></code></pre></td></tr></table></figure><h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4.后记"></a>4.后记</h2><p>fscryptctl 是一个相对原生的工具，更接近内核，可以看到，该工具命令比较复杂，使用中需要记住很长一串密钥 ID，用户体验并不好。</p><p>实际环境中，一般会使用 fscrypt 工具来完成加密策略操作，该工具由 Google 开发，用 Go 语言写成，通过在用户层面维护了一些元数据来简化用户操作，命令更易于理解，也更接近用户。</p><p>商密软件栈 SIG 主页：</p><p><a href="https://openanolis.cn/sig/crypto">https://openanolis.cn/sig/crypto</a></p><p>附：商用密码技术最佳实践白皮书</p><p><a href="https://openanolis.cn/shangmi">https://openanolis.cn/shangmi</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>android::base对应的WriteStringToFile和ReadFileToString</title>
    <link href="/2023/09/19/android-base%E5%AF%B9%E5%BA%94%E7%9A%84WriteStringToFile%E5%92%8CReadFileToString/"/>
    <url>/2023/09/19/android-base%E5%AF%B9%E5%BA%94%E7%9A%84WriteStringToFile%E5%92%8CReadFileToString/</url>
    
    <content type="html"><![CDATA[<h1 id="android-base对应的WriteStringToFile和ReadFileToString"><a href="#android-base对应的WriteStringToFile和ReadFileToString" class="headerlink" title="android::base对应的WriteStringToFile和ReadFileToString"></a>android::base对应的WriteStringToFile和ReadFileToString</h1><h2 id="1-android-base对应命名空间的路径"><a href="#1-android-base对应命名空间的路径" class="headerlink" title="1.android::base对应命名空间的路径"></a>1.android::base对应命名空间的路径</h2><p>android::base对应的命名空间位于：<strong>system\libbase\file.cpp</strong></p><img src="/2023/09/19/android-base%E5%AF%B9%E5%BA%94%E7%9A%84WriteStringToFile%E5%92%8CReadFileToString/image-20230919225124870.png" alt="image-20230919225124870" style="zoom:67%;"><p>里面的函数有：</p><ul><li>ReadFdToString</li><li>WriteStringToFd</li><li>CleanUpAfterFailedWrite</li><li>WriteStringToFile</li><li>ReadFully</li><li>ReadFullyAtOffset</li><li>WriteFully</li><li>RemoveFileIfExists</li><li>GetExecutablePath</li><li>GetExecutableDirectory</li><li>Basename</li><li>Dirname</li></ul><h2 id="2-ReadFileToString函数"><a href="#2-ReadFileToString函数" class="headerlink" title="2.ReadFileToString函数"></a>2.ReadFileToString函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ReadFileToString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path, std::string* content, <span class="hljs-type">bool</span> follow_symlinks)</span> </span>&#123;<br>  content-&gt;<span class="hljs-built_in">clear</span>();<br><br>  <span class="hljs-type">int</span> flags = O_RDONLY | O_CLOEXEC | O_BINARY | (follow_symlinks ? <span class="hljs-number">0</span> : O_NOFOLLOW);<br>  android::<span class="hljs-function">base::unique_fd <span class="hljs-title">fd</span><span class="hljs-params">(TEMP_FAILURE_RETRY(open(path.c_str(), flags)))</span></span>;<br>  <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReadFdToString</span>(fd, content);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ReadFdToString</span><span class="hljs-params">(borrowed_fd fd, std::string* content)</span> </span>&#123;<br>  content-&gt;<span class="hljs-built_in">clear</span>();<br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> sb;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fstat</span>(fd.<span class="hljs-built_in">get</span>(), &amp;sb) != <span class="hljs-number">-1</span> &amp;&amp; sb.st_size &gt; <span class="hljs-number">0</span>) &#123;<br>    content-&gt;<span class="hljs-built_in">reserve</span>(sb.st_size);<br>  &#125;<br><br>  <span class="hljs-type">char</span> buf[BUFSIZ] __attribute__((__uninitialized__));<br>  <span class="hljs-type">ssize_t</span> n;<br>  <span class="hljs-keyword">while</span> ((n = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">read</span>(fd.<span class="hljs-built_in">get</span>(), &amp;buf[<span class="hljs-number">0</span>], <span class="hljs-built_in">sizeof</span>(buf)))) &gt; <span class="hljs-number">0</span>) &#123;<br>    content-&gt;<span class="hljs-built_in">append</span>(buf, n);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (n == <span class="hljs-number">0</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-WriteStringToFile函数"><a href="#3-WriteStringToFile函数" class="headerlink" title="3.WriteStringToFile函数"></a>3.WriteStringToFile函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">WriteStringToFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; content, <span class="hljs-type">const</span> std::string&amp; path,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">bool</span> follow_symlinks)</span> </span>&#123;<br>  <span class="hljs-type">int</span> flags = O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC | O_BINARY |<br>              (follow_symlinks ? <span class="hljs-number">0</span> : O_NOFOLLOW);<br>  android::<span class="hljs-function">base::unique_fd <span class="hljs-title">fd</span><span class="hljs-params">(TEMP_FAILURE_RETRY(open(path.c_str(), flags, <span class="hljs-number">0666</span>)))</span></span>;<br>  <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">WriteStringToFd</span>(content, fd) || <span class="hljs-built_in">CleanUpAfterFailedWrite</span>(path);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">WriteStringToFd</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; content, borrowed_fd fd)</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = content.<span class="hljs-built_in">data</span>();<br>  <span class="hljs-type">size_t</span> left = content.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">while</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">ssize_t</span> n = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">write</span>(fd.<span class="hljs-built_in">get</span>(), p, left));<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    p += n;<br>    left -= n;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现其携带了<strong>O_CREAT</strong>参数，也就是说打开文件的时候如果不存在会去主动创建。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>结构体位域</title>
    <link href="/2023/09/11/%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%8D%E5%9F%9F/"/>
    <url>/2023/09/11/%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%8D%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="结构体位域"><a href="#结构体位域" class="headerlink" title="结构体位域"></a>结构体位域</h1><blockquote><p>转载自：<a href="https://www.cnblogs.com/bigrabbit/archive/2012/09/20/2695543.html">https://www.cnblogs.com/bigrabbit/archive/2012/09/20/2695543.html</a></p></blockquote><p>有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p><h2 id="位域的定义"><a href="#位域的定义" class="headerlink" title="位域的定义"></a>位域的定义</h2><p>位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 位域结构名 </span><br><span class="hljs-class">&#123;</span><br>位域列表<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中位域列表的形式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">类型说明符 位域名：位域长度<br></code></pre></td></tr></table></figure><p>位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bs</span></span><br><span class="hljs-class">&#123;</span><br>　　<span class="hljs-type">int</span> a:<span class="hljs-number">8</span>;<br>　　<span class="hljs-type">int</span> b:<span class="hljs-number">2</span>;<br>　　<span class="hljs-type">int</span> c:<span class="hljs-number">6</span>;<br>&#125;data; <br></code></pre></td></tr></table></figure><p>说明data为bs变量，共占两个字节。其中位域a占8位，位域b占2位，位域c占6位。对于位域的定义尚有以下几点说明：</p><ol><li><strong>一个位域必须存储在同一个字节中，不能跨两个字节</strong>。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bs</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> a:<span class="hljs-number">4</span><br>    <span class="hljs-type">unsigned</span> b:<span class="hljs-number">5</span> <span class="hljs-comment">/*从下一单元开始存放*/</span><br>    <span class="hljs-type">unsigned</span> c:<span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>由于位域不允许跨两个字节，因此<strong>位域的长度不能大于一个字节的长度</strong>。</p></li><li><p><strong>位域可以无位域名</strong>，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">k</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> a:<span class="hljs-number">1</span><br>    <span class="hljs-type">int</span> :<span class="hljs-number">2</span> <span class="hljs-comment">/*无位域名，该2位不能使用*/</span><br>    <span class="hljs-type">int</span> b:<span class="hljs-number">3</span><br>    <span class="hljs-type">int</span> c:<span class="hljs-number">2</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="位域的使用"><a href="#位域的使用" class="headerlink" title="位域的使用"></a>位域的使用</h2><p>下面例子是参加一个公司（白领科技-青岛）的笔试遇到的，当时做错了，为了怕忘了，赶紧写下来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> a:<span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> b:<span class="hljs-number">3</span>;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;0134324324afsadfsdlfjlsdjfl&quot;</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> <span class="hljs-title">d</span>;</span><br>    <span class="hljs-built_in">memcpy</span>(&amp;d, str, <span class="hljs-keyword">sizeof</span>(A));<br>    <span class="hljs-built_in">cout</span> &lt;&lt; d.a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; d.b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在32位x86机器上输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-16<br>1<br></code></pre></td></tr></table></figure><p>解析：在默认情况下，为了方便对结构体内元素的访问和管理，当结构体内的元素长度都小于处理器的位数的时候，便以结构体里面最长的元素为对其单位，即结构体的长度一定是最长的数据元素的整数倍；如果有结构体内存长度大于处理器位数的元素，那么就以处理器的位数为对齐单元。由于是32位处理器，而且结构体中a和b元素类型均为int（也是4个字节），所以结构体的A占用内存为4个字节。</p><p>上例程序中定义了位域结构A，两个个位域为a（占用5位），b（占用3位），所以a和b总共占用了结构A一个字节（低位的一个字节）。</p><p>当程序运行到14行时，d内存分配情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">高位 <span class="hljs-number">00110100</span> <span class="hljs-number">00110011</span>   <span class="hljs-number">00110001</span>    <span class="hljs-number">00110000</span> 低位  [ASCII]<br>      <span class="hljs-string">&#x27;4&#x27;</span>       <span class="hljs-string">&#x27;3&#x27;</span>       <span class="hljs-string">&#x27;1&#x27;</span>          <span class="hljs-string">&#x27;0&#x27;</span>  <br>其中d.a和d.b占用d低位一个字节（<span class="hljs-number">00110000</span>）,d.a : <span class="hljs-number">10000</span>, d.b : <span class="hljs-number">001</span><br></code></pre></td></tr></table></figure><blockquote><p>🔴 关于符号扩展见：<a href="http://blog.chinaunix.net/uid-13746440-id-4244281.html">http://blog.chinaunix.net/uid-13746440-id-4244281.html</a> </p><p><strong>扩展的原则是：</strong></p><p><strong>1.有符号的数据类型，在向高精度扩展时，总是带符号扩展</strong></p><p><strong>2.无符号的数据类型，在向高精度扩展时，总是无符号扩展</strong></p></blockquote><p>d.a内存中二进制表示为10000，由于d.a为有符号的整型变量，输出时要对符号位进行扩展，所以结果为-16（二进制11111111111111111111111111110000）</p><p>d.b内存中二进制表示为001，由于d.b为有符号的整型变量，输出时要对符号位进行扩展，所以结果为1（二进制为00000000000000000000000000000001）</p><blockquote><p>计算机内部使用补码表示数字：</p><ul><li>正数的补码&#x3D;原码</li><li>负数的补码&#x3D;符号位不动 + （所有位取反后末位+1）</li></ul></blockquote><h2 id="位域的对齐"><a href="#位域的对齐" class="headerlink" title="位域的对齐"></a>位域的对齐</h2><p>如果结构体中含有位域(bit-field)，那么VC中准则是：</p><ol><li><p>如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；</p></li><li><p>如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</p></li><li><p>如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式（不同位域字段存放在不同的位域类型字节中），Dev-C++和GCC都采取压缩方式；</p></li></ol><p>系统会先为结构体成员按照对齐方式分配空间和填塞（padding）,然后对变量进行位域操作。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>std::lock_guard引起的思考</title>
    <link href="/2023/09/06/std-lock-guard%E5%BC%95%E8%B5%B7%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2023/09/06/std-lock-guard%E5%BC%95%E8%B5%B7%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1 id="std-lock-guard引起的思考"><a href="#std-lock-guard引起的思考" class="headerlink" title="std::lock_guard引起的思考"></a>std::lock_guard引起的思考</h1><blockquote><p>转载自：<a href="https://www.jianshu.com/p/681f553fa4ab">https://www.jianshu.com/p/681f553fa4ab</a></p></blockquote><h2 id="std-lock-guard-简介"><a href="#std-lock-guard-简介" class="headerlink" title="std::lock_guard 简介"></a>std::lock_guard 简介</h2><p>这个类是一个互斥量的包装类，用来<strong>提供自动为互斥量上锁和解锁</strong>的功能，简化了多线程编程，用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex kMutex;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 构造时自动加锁</span><br>  std::<span class="hljs-built_in">lock_guard</span>&lt;std::mutex&gt; (kMutex);<br>  <br>  <span class="hljs-comment">// 离开局部作用域，析构函数自动完成解锁功能</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用法非常简单，只需在保证线程安全的函数开始处加上一行代码即可，其他的都在这个类的构造函数和析构函数中自动完成。</p><p>如何自动完成？其实 Just so so …</p><h2 id="实现-my-lock-guard"><a href="#实现-my-lock-guard" class="headerlink" title="实现 my_lock_guard"></a>实现 my_lock_guard</h2><p>这是自己实现的一个 <code>lock_guard</code>，就是在<strong>构造和析构中完成加锁和解锁</strong>的操作，之所以会自动完成，是因为<strong>离开函数作用域会导致局部变量析构函数被调用</strong>，而我们又是手动构造了 <code>lock_guard</code>，因此这两个函数都是自动被调用的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> myspace &#123;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">my_lock_guard</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// 在 std::mutex 的定义中，下面两个函数被删除了</span><br>        <span class="hljs-comment">// mutex(const mutex&amp;) = delete;</span><br>        <span class="hljs-comment">// mutex&amp; operator=(const mutex&amp;) = delete;</span><br>        <span class="hljs-comment">// 因此这里必须传递引用</span><br>        <span class="hljs-built_in">my_lock_guard</span>(T&amp; mutex) :<span class="hljs-built_in">mutex_</span>(mutex)&#123;<br>            <span class="hljs-comment">// 构造加锁</span><br>            mutex_.<span class="hljs-built_in">lock</span>();<br>        &#125;<br><br>        ~<span class="hljs-built_in">my_lock_guard</span>() &#123;<br>            <span class="hljs-comment">// 析构解锁</span><br>            mutex_.<span class="hljs-built_in">unlock</span>();<br>        &#125;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">// 不可赋值，不可拷贝</span><br>        <span class="hljs-built_in">my_lock_guard</span>(my_lock_guard <span class="hljs-type">const</span>&amp;);<br>        my_lock_guard&amp; <span class="hljs-keyword">operator</span>=(my_lock_guard <span class="hljs-type">const</span>&amp;);<br>    <span class="hljs-keyword">private</span>:<br>        T&amp; mutex_;<br>    &#125;;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>要注意的是这个类官方定义是<strong>不可以赋值和拷贝</strong>，因此需要私有化 <code>operator =</code> 和 <code>copy</code> 这两个函数。</p><h2 id="什么是-std-mutex-？"><a href="#什么是-std-mutex-？" class="headerlink" title="什么是 std::mutex ？"></a>什么是 std::mutex ？</h2><p>如果你细心可以发现，不管是 <code>std::lock_guard</code>，还是<code>my_lock_guard</code>，都使用了一个 <code>std::mutex</code> 作为构造函数的参数，这是因为我们的 <code>lock_guard</code> 只是一个包装类，而实际的加锁和解锁的操作都还是 <code>std::mutex</code> 完成的，那什么是 <code>std::mutex</code> 呢？</p><p><code>std::mutex</code> 其实是一个<strong>用于保护共享数据不会同时被多个线程访问的类</strong>，它叫做<strong>互斥量</strong>，你可以把它看作一把锁，它的基本使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex kMutex;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//加锁</span><br>  kMutex.<span class="hljs-built_in">lock</span>();<br>  <span class="hljs-comment">//kMutex.try_lock();</span><br><br>  <span class="hljs-comment">//do something that is thread safe...</span><br>  <br>  <span class="hljs-comment">// 离开作用域解锁</span><br>  kMutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>前面都提到了<strong>锁</strong>这个概念，那么什么是锁，有啥用处？</p><h2 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h2><p><strong>锁是用来保护共享资源（变量或者代码）不被并发访问的一种方法</strong>，它只是方法，实际的实现就是 <code>std::mutex</code> 等等的类了。</p><p>可以简单的理解为：</p><ol><li>当前线程访问一个变量之前，将这个变量放到盒子里锁住，并且当前线程拿着钥匙。这样一来，如果有其他的线程也要访问这个变量，则必须等待当前线程将盒子解锁之后才能访问，之后其他线程在访问这个变量之前也将会再次锁住这个变量。</li><li>当前线程执行完后，就将该盒子解锁，这样其他的线程就可以拿到盒子的钥匙，并再次加锁访问这个变量了。</li></ol><p>这样就<strong>保证了同一时刻只有一个线程可以访问共享资源</strong>，解决了简单的线程安全问题。</p><p>什么，你还没有遇到过线程安全问题？下面开始我的表演…</p><h2 id="一个简单的线程安全的例子"><a href="#一个简单的线程安全的例子" class="headerlink" title="一个简单的线程安全的例子"></a>一个简单的线程安全的例子</h2><p>这个例子中，<strong>主线程开启了 2 个子线程</strong>，每个子线程都修改<strong>共享的全局变量</strong> <code>kData</code>，如果没有增加必要的锁机制，那么每个子线程打印出的 <code>kData</code> 就可能会出错。</p><p>这里使用了 3 种不同的加锁方法来解决：</p><ol><li>使用 <code>std::lock_guard</code></li><li>使用 <code>std::mutex</code> 实现原生的加锁</li><li>使用自己的 <code>myspace::my_lock_guard</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-comment">// 两个子线程共享的全局变量</span><br><span class="hljs-type">int</span> kData = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// std::mutex 提供了一种防止共享数据被多个线程并发访问的简单同步方法</span><br><span class="hljs-comment">// 调用线程可以通过 lock 和 try_lock 来获取互斥量，使用 unlock() 释放互斥量</span><br>std::mutex kMutex;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1.创建一个互斥量的包装类，用来自动管理互斥量的获取和释放</span><br>    <span class="hljs-comment">// std::lock_guard&lt;std::mutex&gt; lock(kMutex);</span><br>    <br>    <span class="hljs-comment">// 2.原生加锁</span><br>    <span class="hljs-comment">// kMutex.lock();</span><br><br>    <span class="hljs-comment">// 3.自己实现的 std::mutex 的包装类</span><br>    <span class="hljs-function">myspace::my_lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(kMutex)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-comment">// 打印当前线程的 id : kData</span><br>        std::cout &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() <br>                  &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; kData++ &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 原生解锁  </span><br>    <span class="hljs-comment">//kMutex.unlock();</span><br>    <br>    <span class="hljs-comment">// 离开局部作用域，局部锁解锁，释放互斥量</span><br>    <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 打印当前函数名</span><br>    std::cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; kData &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 开启两个线程</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(increment)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(increment)</span></span>;<br><br>    <span class="hljs-comment">// 主线程等待这两个线程完成操作之后再退出</span><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-comment">// 防止立刻退出</span><br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++独立大括号</title>
    <link href="/2023/09/06/C-%E7%8B%AC%E7%AB%8B%E5%A4%A7%E6%8B%AC%E5%8F%B7/"/>
    <url>/2023/09/06/C-%E7%8B%AC%E7%AB%8B%E5%A4%A7%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="C-独立大括号"><a href="#C-独立大括号" class="headerlink" title="C++独立大括号"></a>C++独立大括号</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/qq_41861406/article/details/124664297">https://blog.csdn.net/qq_41861406/article/details/124664297</a></p></blockquote><p>c++ 语言中。{}一般是在函数、类之下使用，但是在阅读代码过程中发现一种奇怪的现象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// Some unrelated code</span><br>        <br>&#123;<br><span class="hljs-comment">// Some other code</span><br><span class="hljs-comment">// ... </span><br>&#125;<br><br>     <span class="hljs-comment">// Somce unrelated code</span><br> <span class="hljs-comment">// ...</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>在代码中有一个多余的大括号，但是不知道是做什么用的，因为他不和前面或后面的任何代码有关。</p><p><strong>解释</strong></p><p>这个多余的大括号提供了一个新的作用域。 加入这个多余大括号的原因有两个：</p><ol><li>可以更干净的声明新变量</li><li>可以更快的释放资源<ul><li>因为C++有析构器，当离开作用域的时候，多余的大括号可以使资源(files, mutexes, whatever)自动释放。这使代码变得更干净。这就意味着程序可以占用一些共享资源更短的时间。拥有自动储存的变量在离开作用域后会自动销毁，多余的大括号可以使它比没有时更早的被销毁。</li></ul></li><li>限制变量的作用域</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++并发多线程基础</title>
    <link href="/2023/09/03/C-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/09/03/C-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="C-并发多线程基础"><a href="#C-并发多线程基础" class="headerlink" title="C++并发多线程基础"></a>C++并发多线程基础</h1><blockquote><p>原文：<a href="https://blog.csdn.net/weixin_42636062/category_11292803.html">https://blog.csdn.net/weixin_42636062/category_11292803.html</a></p></blockquote><h2 id="1-线程启动、结束、创建线程多发、join，detach"><a href="#1-线程启动、结束、创建线程多发、join，detach" class="headerlink" title="1.线程启动、结束、创建线程多发、join，detach"></a>1.线程启动、结束、创建线程多发、join，detach</h2><h3 id="1-1-范例演示线程运行的开始和结束"><a href="#1-1-范例演示线程运行的开始和结束" class="headerlink" title="1.1 范例演示线程运行的开始和结束"></a>1.1 范例演示线程运行的开始和结束</h3><p>1）程序运行起来，生成一个进程，该进程所属的主线程开始自动运行</p><p>2）主线程从main（）开始执行，那么我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，就代表着我们这个线程运行完毕</p><p>3）整个进程是否完毕的标志是 主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了。此时，如果其他子线程还没有执行完毕，那么这些子线程也会被操作系统强行终止。</p><p> 所以，一般情况下，我们将得到一个结论，如果大家想保持线程（自己用代码创建的）运行状态的话，那么大家要让主线程一直保持运行，不要让主线程运行完毕（这条规律也有例外，后续会解释这种例外（就是1.3 detach），大家目前先这样理解和记忆）</p><img src="/2023/09/03/C-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/3da72dfb46be496a8d9def6a8ce10af8.png" alt="在这里插入图片描述" style="zoom:80%;"><p><strong>创建一个线程：</strong></p><p>1）包含一个头文件 <code>#include &lt;thread&gt;</code></p><p>2）初始函数要写</p><p>3） main中开始写代码</p><p>注意：有两个线程在跑，相当于两个程序的执行有两条线在同时走，所以，可以同时运行两个事情，即使一条线被堵住了，另外一条线还是可以运行，这就是多线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-comment">//自己创建的线程也要从一个函数（初始函数）开始运行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程开始执行了1&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;我的线程开始执行了2&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;我的线程开始执行了3&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程执行完毕了&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//a)包含一个头文件 #include &lt;thread&gt;</span><br><br><span class="hljs-comment">//b)初始函数要写 例如上面的void myprint()；</span><br><br><span class="hljs-comment">//c) main中开始写代码</span><br><span class="hljs-function">thread <span class="hljs-title">mytobj</span><span class="hljs-params">(myprint)</span></span>;  <span class="hljs-comment">//（1）创建了线程，线程执行起点（入口）myprint（）； （2）myprint开始执行</span><br>    <br>    <span class="hljs-comment">//阻塞主线程并等待myprint子线程执行完</span><br>mytobj.<span class="hljs-built_in">join</span>(); <span class="hljs-comment">//主线程阻塞到这里，等待myprint()执行完，当子线程执行完毕，这个join（）就执行完毕，主线程就继续往下执行</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;主线程收尾，最终主线程正常退出&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//大家必须明确一点：有两个线程在跑，相当于两个程序的执行有两条线在同时走，所以，可以同时运行两个事情，即使一条线被堵住了，另外一条线还是可以运行，这就是多线程</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/09/03/C-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/0780dced36d94719bfad44ba7d758b91.png" alt="在这里插入图片描述" style="zoom:80%;"><h4 id="1-1-1-therad"><a href="#1-1-1-therad" class="headerlink" title="1.1.1 therad"></a>1.1.1 therad</h4><p>概念：thread是个标准库里的类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">thread <span class="hljs-title">mytobj</span><span class="hljs-params">(myprint)</span></span>;<span class="hljs-comment">//（1）创建了线程，线程执行起点（入口）myprint（）； （2）myprint开始执行</span><br></code></pre></td></tr></table></figure><h4 id="1-1-2-join"><a href="#1-1-2-join" class="headerlink" title="1.1.2 join"></a>1.1.2 join</h4><p>概念：join（）：加入&#x2F;汇合，说白了就是阻塞，阻塞主线程，让主线程等待子线程执行完毕然后子线程和主线程汇合，然后主线程再往下走。</p><p>注意：如果主线程执行完毕，但子程序没执行完毕，这种程序员是不合格的，程序也是不稳定的。</p><p> 一个书写良好的程序，应该是主线程等待子线程执行完毕后，自己才能最终退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//阻塞主线程并等待myprint子线程执行完</span><br>mytobj.<span class="hljs-built_in">join</span>();  <span class="hljs-comment">//主线程阻塞到这里，等待myprint()执行完，当子线程执行完毕，这个join（）就执行完毕，主线程就继续往下执行</span><br></code></pre></td></tr></table></figure><h4 id="1-1-3-detach"><a href="#1-1-3-detach" class="headerlink" title="1.1.3 detach"></a>1.1.3 detach</h4><p>1）概念：传统多线程程序主线程要等待子线程执行完毕，然后自己再最后退出。</p><p>2）detach：分离，也就是主线程不和子线程汇合了，你主线程执行你的，我子线程执行我的，你主线程也不必等我子线程运行完毕，你可以先执行结束，这并不影响我子线程的执行。</p><blockquote><p>（下面为什么的解释说明：但是老师还是推荐实际项目不要这样，让子线程执行完毕再说，权当概念记）</p></blockquote><p>3）为什么引入detach：我们创建了很多子线程，让主线程逐个等待子线程结束，这种编程方法不好，所以引入detach（）；一旦detach（）之后，与这个主线程关联的thread对象就会失去与这个主线程的关联，此时这个子线程就会驻留在后台运行（主线程跟子线程失去联系）；这个子线程就相当于被c++运行时库接管，当这个子线程执行完毕后，由运行时库负责清理该线程相关的资源（守护线程）。</p><p>4）注意：一旦调用了detach（）。就不能再使用join（）</p><p>例子里面 detach（）使线程myprint失去我们自己的控制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-comment">//自己创建的线程也要从一个函数（初始函数）开始运行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程开始执行了1&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;我的线程开始执行了2&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;我的线程开始执行了3&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程执行完毕了&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-function">thread <span class="hljs-title">mytobj</span><span class="hljs-params">(myprint)</span></span>;  <span class="hljs-comment">//（1）创建了线程，线程执行起点（入口）myprint（）； （2）myprint开始执行</span><br>    mytobj.<span class="hljs-built_in">detach</span>();  <span class="hljs-comment">//一旦调用了detach（）。就不能再使用join（）</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;主线程收尾，最终主线程正常退出1&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;主线程收尾，最终主线程正常退出2&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;主线程收尾，最终主线程正常退出3&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;主线程收尾，最终主线程正常退出4&quot;</span> &lt;&lt; endl;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/09/03/C-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNjA2Mg==,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述" style="zoom:80%;"><img src="/2023/09/03/C-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/42db6f4ca3b14d01aa167cfda19d482a.png" alt="在这里插入图片描述" style="zoom:80%;"><p>如果主线程的最后一步运行完了，就退出了，其他子线程就输出不来了</p><h4 id="1-1-4-joinable"><a href="#1-1-4-joinable" class="headerlink" title="1.1.4 joinable"></a>1.1.4 joinable</h4><p>概念：判断是否可以成功使用join（）或者detach（）。返回true（可以使用join（）或者detach（））或者false（不可以使用）</p><p><strong>即，使用了join（）就不可以再detach（），使用了detach（）就不可以再join（）；</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-comment">//自己创建的线程也要从一个函数（初始函数）开始运行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程开始执行了&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程执行完毕了&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-function">thread <span class="hljs-title">mytobj</span><span class="hljs-params">(myprint)</span></span>;  <span class="hljs-comment">//（1）创建了线程，线程执行起点（入口）myprint（）； （2）myprint开始执行</span><br><span class="hljs-keyword">if</span>(mytobj.<span class="hljs-built_in">joinable</span>())&#123;      <span class="hljs-comment">//这里输出1.joinable() == true</span><br>cout&lt;&lt;<span class="hljs-string">&quot;1.joinable() == true&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;1.joinable() == false&quot;</span>&lt;&lt;endl;<br>&#125;<br>    mytobj.<span class="hljs-built_in">detach</span>();  <span class="hljs-comment">//一旦调用了detach（）。就不能再使用join（）</span><br>    <span class="hljs-keyword">if</span>(mytobj.<span class="hljs-built_in">joinable</span>())&#123;   <span class="hljs-comment">//这里输出2.joinable() == false</span><br>cout&lt;&lt;<span class="hljs-string">&quot;2.joinable() == true&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;2.joinable() == false&quot;</span>&lt;&lt;endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;主线程收尾，最终主线程正常退出&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-其他创建线程的方法"><a href="#1-2-其他创建线程的方法" class="headerlink" title="1.2 其他创建线程的方法"></a>1.2 其他创建线程的方法</h3><h4 id="1-2-1-用类，以及一个问题范例"><a href="#1-2-1-用类，以及一个问题范例" class="headerlink" title="1.2.1 用类，以及一个问题范例"></a>1.2.1 用类，以及一个问题范例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TA</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-comment">//不能带参数，重载了()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程开始执行了&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程执行完毕了&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//2.1 用类对象（可调用对象），以及一个问题范例</span><br>TA ta;<br><span class="hljs-function">thread <span class="hljs-title">mytobj3</span><span class="hljs-params">(ta)</span></span>; <span class="hljs-comment">//ta可调用对象</span><br>mytobj3.<span class="hljs-built_in">join</span>();    <span class="hljs-comment">//等子线程执行结束</span><br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;主线程收尾，最终主线程正常退出&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/09/03/C-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/ca2a0f32f53c4949814faba1537ec0fb.png" alt="在这里插入图片描述" style="zoom:80%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TA</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> &amp;m_i;<br><span class="hljs-built_in">TA</span>(<span class="hljs-type">int</span> &amp;i) :<span class="hljs-built_in">m_i</span>(i) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;TA()构造函数被执行&quot;</span>&lt;&lt;endl;<br>    &#125;;<br>    <span class="hljs-built_in">TA</span>(<span class="hljs-type">const</span> TA &amp; ta) :<span class="hljs-built_in">m_i</span>(ta.m_i) &#123;  <span class="hljs-comment">//因为是复制的，所以调用了拷贝构造</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;TA()拷贝构造函数被执行&quot;</span>&lt;&lt;endl;<br>    &#125;;<br>    ~<span class="hljs-built_in">TA</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;TA()析构函数被执行&quot;</span>&lt;&lt;endl;<br>    &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-comment">//不能带参数，重载了()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程开始执行了&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;m_i的值为&quot;</span> &lt;&lt;m_i&lt;&lt; endl;<br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程执行完毕了&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//2.1 用类对象（可调用对象），以及一个问题范例</span><br><span class="hljs-type">int</span> myi = <span class="hljs-number">0</span>;<br><span class="hljs-function">TA <span class="hljs-title">ta</span><span class="hljs-params">(myi)</span></span>;<br><span class="hljs-function">thread <span class="hljs-title">mytobj3</span><span class="hljs-params">(ta)</span></span>; <span class="hljs-comment">//ta可调用对象</span><br>mytobj3.<span class="hljs-built_in">detach</span>();    <br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;主线程收尾，最终主线程正常退出&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/09/03/C-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNjA2Mg==,size_16,color_FFFFFF,t_70#pic_center-1693751275417-11.png" alt="在这里插入图片描述" style="zoom:80%;"><img src="/2023/09/03/C-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/a9bcaa852dd64183ba5b0764f2ade151.png" alt="在这里插入图片描述" style="zoom:80%;"><p>分析：</p><p>1）myi为局部变量，引用过去如果主线程运行完，那myi就被销毁了</p><p>2）为什么会有拷贝构造？因为这个对象实际上是被复制到线程中去的</p><p>3）为什么析构两次？例子1里那个第一次是复制的那个ta的析构，第二次是ta的析构，例子2里那个是ta的析构</p><blockquote><p>分析：</p><p>1）myi为局部变量，引用过去如果主线程运行完，那myi就被销毁了</p><p>2）为什么会有拷贝构造？因为这个对象实际上是被复制到线程中去的</p><p>3）为什么析构两次？例子1里那个第一次是复制的那个ta的析构，第二次是ta的析构，例子2里那个是ta的析构</p></blockquote><p>可以用join（）看看正常的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TA</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> &amp;m_i;<br><span class="hljs-built_in">TA</span>(<span class="hljs-type">int</span> &amp;i) :<span class="hljs-built_in">m_i</span>(i) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;TA()构造函数被执行&quot;</span>&lt;&lt;endl;<br>    &#125;;<br>    <span class="hljs-built_in">TA</span>(<span class="hljs-type">const</span> TA &amp; ta) :<span class="hljs-built_in">m_i</span>(ta.m_i) &#123;  <span class="hljs-comment">//因为是复制的，所以调用了拷贝构造</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;TA()拷贝构造函数被执行&quot;</span>&lt;&lt;endl;<br>    &#125;;<br>    ~<span class="hljs-built_in">TA</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;TA()析构函数被执行&quot;</span>&lt;&lt;endl;<br>    &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-comment">//不能带参数，重载了()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程开始执行了&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;m_i的值为&quot;</span> &lt;&lt;m_i&lt;&lt; endl;<br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程执行完毕了&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//2.1 用类对象（可调用对象），以及一个问题范例</span><br><span class="hljs-type">int</span> myi = <span class="hljs-number">0</span>;<br><span class="hljs-function">TA <span class="hljs-title">ta</span><span class="hljs-params">(myi)</span></span>;<br><span class="hljs-function">thread <span class="hljs-title">mytobj3</span><span class="hljs-params">(ta)</span></span>; <span class="hljs-comment">//ta可调用对象</span><br>mytobj3.<span class="hljs-built_in">join</span>();    <br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;主线程收尾，最终主线程正常退出&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/09/03/C-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNjA2Mg==,size_16,color_FFFFFF,t_70#pic_center-1693751311705-16.png" alt="在这里插入图片描述" style="zoom:80%;"><h4 id="1-2-2-用lambda"><a href="#1-2-2-用lambda" class="headerlink" title="1.2.2 用lambda"></a>1.2.2 用lambda</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">auto</span> mylamthread = [] &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程开始执行了&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;我的线程执行结束了&quot;</span> &lt;&lt; endl;<br>&#125;;<br><br><span class="hljs-function">thread <span class="hljs-title">mytobj4</span><span class="hljs-params">(mylamthread)</span></span>;<br>mytobj4.<span class="hljs-built_in">join</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;主线程收尾，最终主线程正常退出&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/09/03/C-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/3fc19ace7a88487d97337223fdef3ca3.png" alt="在这里插入图片描述" style="zoom:80%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【转载】换个角度理解Android的AIDL原理</title>
    <link href="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/"/>
    <url>/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="【转载】换个角度理解Android的AIDL原理"><a href="#【转载】换个角度理解Android的AIDL原理" class="headerlink" title="【转载】换个角度理解Android的AIDL原理"></a>【转载】换个角度理解Android的AIDL原理</h1><blockquote><p>转载自：<a href="https://www.jianshu.com/p/5de1718454f8">https://www.jianshu.com/p/5de1718454f8</a></p></blockquote><h2 id="本文思路"><a href="#本文思路" class="headerlink" title="本文思路"></a>本文思路</h2><p>本篇文章笔者谈论的是android使用AIDL进行进程间<a href="https://so.csdn.net/so/search?q=%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86&spm=1001.2101.3001.7020">通信原理</a>，但本文不打算一上来就介绍如何使用AIDL，本文会先假设Android没有提供AIDL我们应该如何“用自己的方式”实现IPC,介绍完这一点之后，本文再对比AIDL这种方式实现IPC，并尝试理解AIDL背后代码之间的关系。下文图片是本文“用自己的方式”实现IPC的案例交互图，如下：</p><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/f9d2a6c4d4fdec395eabf302ff80ec47.png" alt="640?wx_fmt=png" style="zoom:80%;"><p>蓝色部分的LibraryServer和Client是本文案例中两个不同的APP,其中LibraryServer能够提供左边绿色部分的“BookCheckService”服务（包含getBookInfo、getBookList），为了能够拥有提供远程服务的能力LibraryServer同时还“招聘”了Binder这种具有远程交互能力的对象，于是LibraryServer通过“BookCheckService”+”Binder”这对组合就拥有提供远程服务的能力了。而Client也是“招聘”了Binder，企图通过Binder来使用远程服务。“黄色部分”又是什么意思呢？其实这只是笔者对Binder机制在底层通信进行的极简的描述，实际上Binder机制在底层通信十分复杂，笔者打算放在其它篇章讨论；“黄色”部分简单地解释了远程服务LibraryServer其实是将它自己的Binder的句柄注册在内核，Client实际上拿到的只是LibraryServer的Binder的句柄，通过内核的Binder映射，再与远程服务交互。</p><h2 id="Demo关键代码分析"><a href="#Demo关键代码分析" class="headerlink" title="Demo关键代码分析"></a>Demo关键代码分析</h2><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/ddc2004c818be797cad61375e7548642.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><p>上文是Client  APP运行后的显示效果，功能很简单，下面对主要代码进行说明：</p><h3 id="Client端代码"><a href="#Client端代码" class="headerlink" title="Client端代码"></a>Client端代码</h3><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/44f549497215f70d3d6df4a727d26453.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/76fd7c1d276d0e83d66b72cd77832c3a.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><p>下面这个函数是请求“查询图书信息”远程服务的实现逻辑</p><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/7d2262f9a5beab91f92f8dd05d10319d.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><p>同样请求“获取图书列表”远程服务的实现逻辑如下：</p><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/383cdc4da40ae23b7072284ac633d4ac.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><h3 id="远程端LibraryServer-代码"><a href="#远程端LibraryServer-代码" class="headerlink" title="远程端LibraryServer 代码"></a>远程端LibraryServer 代码</h3><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/0563a66fd5a4994ee826735ef3d48e30.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/9865ec2e305a8fd7d0d214c09825c8c2.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/288ed2bb1bc64eb503e30949e3b6cbdf.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/6386a9f7d671f670b91e3bbeda91ec1c.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><h2 id="AIDL实现IPC"><a href="#AIDL实现IPC" class="headerlink" title="AIDL实现IPC"></a>AIDL实现IPC</h2><p>上文提到的是使用“自己的方式”实现IPC,下文介绍在这个案例中是如何使用AIDL通信的，关于如何在AndroidStudio创建AIDL文件，这里笔者不再细说，不清楚的朋友可以参考这篇文章：<a href="http://www.jianshu.com/p/d1fac6ccee98%EF%BC%8C%E4%B8%8B%E5%9B%BE%E4%B8%BA%E4%BD%BF%E7%94%A8AIDL%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%A6%82%E4%B8%8B">http://www.jianshu.com/p/d1fac6ccee98，下图为使用AIDL自动生成的代码，如下</a></p><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/1fdf4a758743305dfd5b51ed1910460c.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><blockquote><p>注意：Stub继承了Binder，并且实现了AIDL生成的接口BookCheckService</p></blockquote><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/d6361afa94761d25a7b0a6eab191661c.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><blockquote><p>注意：Proxy是Stub中的类，所以一般我们能看到Stub.Proxy这种表示</p></blockquote><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/dffd09c9418dff635e987bc8bf556676.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><blockquote><p>注意：Proxy中的remote就是Binder中传递出来的Stub对象</p></blockquote><p>上图是笔者使用AIDL自动成的BooKCheckService.java文件，可以用下面的UML来描述各个类之间的联系，如下：</p><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/b42d286e23ae18ecc4bbaaaaeca41db8.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><p>我们先来看以下关键代码：</p><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/93f879f72ec17c9ef57d9e9578687bf8.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><p>再来看看Proxy类中的细节，如下：</p><img src="/2023/08/27/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Android%E7%9A%84AIDL%E5%8E%9F%E7%90%86/1a9c493a79260cbbe28a90ef32d28bb9.jpeg" alt="640?wx_fmt=png" style="zoom:80%;"><p>到此可以看到AIDL实现IPC与上文我们以“以自己的方式”实现IPC本质是一样的，只是AIDL语言会为我们自动生成相关的类，简化我们的编码工作。</p><h2 id="案例源码"><a href="#案例源码" class="headerlink" title="案例源码"></a>案例源码</h2><p><a href="https://github.com/ZhongXiaoHong/AIDLExample">https://github.com/ZhongXiaoHong/AIDLExample</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓context.getSystemService原理解析</title>
    <link href="/2023/08/27/%E5%AE%89%E5%8D%93context-getSystemService%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/08/27/%E5%AE%89%E5%8D%93context-getSystemService%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓context-getSystemService原理解析"><a href="#安卓context-getSystemService原理解析" class="headerlink" title="安卓context.getSystemService原理解析"></a>安卓context.getSystemService原理解析</h1><p>很多的代码里面都会调用context.getSystemService来获取系统服务，例如</p><img src="/2023/08/27/%E5%AE%89%E5%8D%93context-getSystemService%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20230827211203679.png" alt="image-20230827211203679" style="zoom: 50%;"><p>这里会传入StorageManager的Class对象。</p><p><strong>先看这张图，画的比较清晰，看的时候会清晰一点。</strong></p><img src="/2023/08/27/%E5%AE%89%E5%8D%93context-getSystemService%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/c3e563f5c6584600a67a4483876d0395tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="context.getSystemService原理-1 (1).png" style="zoom:80%;"><h2 id="1-SystemServiceRegistry系统服务注册中心"><a href="#1-SystemServiceRegistry系统服务注册中心" class="headerlink" title="1.SystemServiceRegistry系统服务注册中心"></a>1.SystemServiceRegistry系统服务注册中心</h2><p>这个服务注册中心与具体的服务实例无关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks\base\core\java\android\app\SystemServiceRegistry.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemServiceRegistry</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, String&gt; SYSTEM_SERVICE_NAMES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;Class&lt;?&gt;, String&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;String, ServiceFetcher&lt;?&gt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; SYSTEM_SERVICE_CLASS_NAMES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 静态代码块，当JVM加载SystemServiceRegistry的Class对象时，会去调用静态代码块，注册各类服务</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        registerService(Context.STORAGE_SERVICE, StorageManager.class, <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachedServiceFetcher</span>&lt;StorageManager&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> StorageManager <span class="hljs-title function_">createService</span><span class="hljs-params">(ContextImpl ctx)</span> <span class="hljs-keyword">throws</span> ServiceNotFoundException &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StorageManager</span>(ctx, ctx.mMainThread.getHandler().getLooper());<br>                &#125;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-1-registerService注册服务"><a href="#1-1-registerService注册服务" class="headerlink" title="1.1 registerService注册服务"></a>1.1 registerService注册服务</h3><p>注册服务的时候就是往三个HashMap（SYSTEM_SERVICE_NAMES、SYSTEM_SERVICE_FETCHERS、SYSTEM_SERVICE_CLASS_NAMES）中写入对应的kv值，这样外部需要获取的时候就可以通过HashMap获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerService</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String serviceName,</span><br><span class="hljs-params">                                        <span class="hljs-meta">@NonNull</span> Class&lt;T&gt; serviceClass, <span class="hljs-meta">@NonNull</span> ServiceFetcher&lt;T&gt; serviceFetcher)</span> &#123;<br>    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);<br>    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);<br>    SYSTEM_SERVICE_CLASS_NAMES.put(serviceName, serviceClass.getSimpleName());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-创建CachedServiceFetcher"><a href="#1-2-创建CachedServiceFetcher" class="headerlink" title="1.2 创建CachedServiceFetcher"></a>1.2 创建CachedServiceFetcher</h3><p>注意：在静态代码块注册服务的时候有部分创建的是StaticServiceFetcher，有部分是创建CachedServiceFetcher</p><img src="/2023/08/27/%E5%AE%89%E5%8D%93context-getSystemService%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20230827212939821.png" alt="image-20230827212939821" style="zoom: 50%;"><img src="/2023/08/27/%E5%AE%89%E5%8D%93context-getSystemService%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20230827212955723.png" alt="image-20230827212955723" style="zoom: 50%;"><p>两者均继承自<strong>ServicveFetcher</strong></p><img src="/2023/08/27/%E5%AE%89%E5%8D%93context-getSystemService%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/aa7b55dda2e541588b2cbb6d439d4f97tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png" style="zoom: 80%;"><ul><li>CachedServiceFetcher，核心思想是从对应的contextImpl对象的缓存池中获取服务对象，如果不存在则新创建一个</li><li>StaticServiceFetcher 不会针对每个contextImpl做缓存，直接在当前进程中，缓存一个对象。用起来比较简单，也是线程安全的。</li></ul><p><strong>本文暂时只记录CacheServiceFetcher</strong></p><img src="/2023/08/27/%E5%AE%89%E5%8D%93context-getSystemService%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/b6628dc65f484200855da834774853e6tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="context.getSystemService原理-3 (3).png"><p>这里的缓存机制很有意思，也方便以后自己优化代码时可以参考，故进行记录</p><blockquote><ol><li>在ContextImpl中维护了一个数组，其记录了已经被缓存的系统服务【contextImpl只是维护缓存队列，操作缓存队列是在CachedServiceFetcher中】</li><li>当我们调用getService的时候，先去缓存队列中获取；如果缓存中没有则创建后加入缓存队列</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedServiceFetcher</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServiceFetcher</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> mCacheIndex;<br><br>    CachedServiceFetcher() &#123;<br>        <span class="hljs-comment">// 服务对象在缓存中的索引</span><br>        mCacheIndex = sServiceCacheSize++;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> T <span class="hljs-title function_">getService</span><span class="hljs-params">(ContextImpl ctx)</span> &#123;<br>        <span class="hljs-comment">// 获取ContextImpl中你的cache和gates</span><br>        <span class="hljs-comment">// cache存放服务的缓存</span><br>        <span class="hljs-comment">// gate存放初始化后的服务</span><br>        <span class="hljs-keyword">final</span> Object[] cache = ctx.mServiceCache;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] gates = ctx.mServiceInitializationStateArray;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">T</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">doInitialize</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">synchronized</span> (cache) &#123;<br>                <span class="hljs-comment">// 首先尝试从服务缓存中获取，如果找到就直接返回。</span><br>                <span class="hljs-type">T</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> (T) cache[mCacheIndex];<br>                <br>                <span class="hljs-comment">// 查询服务缓存时有两种情况可以直接返回：</span><br>                <span class="hljs-comment">// 1. service != null 表示该类服务已经被创建并保存在服务缓存里，直接返回服务实例即可；</span><br>                <span class="hljs-comment">// 2. service == null &amp;&amp; gets[mCacheIndex] == ContextImpl.STATE_NOT_FOUND</span><br>                <span class="hljs-keyword">if</span> (service != <span class="hljs-literal">null</span>) &#123;<br>                    ret = service;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// exit the for (;;)</span><br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (gates[mCacheIndex] == ContextImpl.STATE_READY<br>                        || gates[mCacheIndex] == ContextImpl.STATE_NOT_FOUND) &#123;<br>                    gates[mCacheIndex] = ContextImpl.STATE_UNINITIALIZED;<br>                &#125;<br><br>                <span class="hljs-comment">// 服务没有初始化</span><br>                <span class="hljs-keyword">if</span> (gates[mCacheIndex] == ContextImpl.STATE_UNINITIALIZED) &#123;<br>                    doInitialize = <span class="hljs-literal">true</span>;<br>                    gates[mCacheIndex] = ContextImpl.STATE_INITIALIZING;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 服务初始化后将服务放入缓存队列中</span><br>            <span class="hljs-keyword">if</span> (doInitialize) &#123;<br>                <span class="hljs-type">T</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-meta">@ServiceInitializationState</span> <span class="hljs-type">int</span> <span class="hljs-variable">newState</span> <span class="hljs-operator">=</span> ContextImpl.STATE_NOT_FOUND;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    service = createService(ctx);<br>                    newState = ContextImpl.STATE_READY;<br>                &#125; <span class="hljs-keyword">catch</span> (ServiceNotFoundException e) &#123;<br>                    onServiceNotFound(e);<br><br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">synchronized</span> (cache) &#123;<br>                        cache[mCacheIndex] = service;<br>                        gates[mCacheIndex] = newState;<br>                        cache.notifyAll();<br>                    &#125;<br>                &#125;<br>                ret = service;<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// exit the for (;;)</span><br>            &#125;<br><br>            <span class="hljs-comment">// 由于可能多个地方调用getService，所以要枷锁</span><br>            <span class="hljs-keyword">synchronized</span> (cache) &#123;<br>                <span class="hljs-comment">// 当前没有服务实例并且已经有线程正在创建服务实例时，等待。</span><br>                <span class="hljs-keyword">while</span> (gates[mCacheIndex] &lt; ContextImpl.STATE_READY) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        interrupted |= Thread.interrupted();<br>                        cache.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        Slog.w(TAG, <span class="hljs-string">&quot;getService() interrupted&quot;</span>);<br>                        interrupted = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (interrupted) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">createService</span><span class="hljs-params">(ContextImpl ctx)</span> <span class="hljs-keyword">throws</span> ServiceNotFoundException;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-注意：SystemServiceRegistry注册的是服务的Manager不是ManagerService"><a href="#1-3-注意：SystemServiceRegistry注册的是服务的Manager不是ManagerService" class="headerlink" title="1.3 注意：SystemServiceRegistry注册的是服务的Manager不是ManagerService"></a>1.3 注意：SystemServiceRegistry注册的是服务的Manager不是ManagerService</h3><h2 id="2-获取各类服务Manager的Class对象"><a href="#2-获取各类服务Manager的Class对象" class="headerlink" title="2.获取各类服务Manager的Class对象"></a>2.获取各类服务Manager的Class对象</h2><p>当我们调用context.getSystemService的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks\base\core\java\android\content\Context.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> &lt;T&gt; T <span class="hljs-title function_">getSystemService</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Class&lt;T&gt; serviceClass)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> getSystemServiceName(serviceClass);<br>    <span class="hljs-keyword">return</span> serviceName != <span class="hljs-literal">null</span> ? (T)getSystemService(serviceName) : <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-先获取SystemServiceName"><a href="#2-1-先获取SystemServiceName" class="headerlink" title="2.1 先获取SystemServiceName"></a>2.1 先获取SystemServiceName</h3><img src="/2023/08/27/%E5%AE%89%E5%8D%93context-getSystemService%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20230827211657141.png" alt="image-20230827211657141" style="zoom:67%;"><blockquote><p>发现是个抽象函数，则调用实现类中对于抽象函数的实现</p></blockquote><img src="/2023/08/27/%E5%AE%89%E5%8D%93context-getSystemService%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20230827211821602.png" alt="image-20230827211821602" style="zoom:50%;"><p>下面就要调用SystemServiceRegistry的getSystemServiceName方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getSystemServiceName</span><span class="hljs-params">(Class&lt;?&gt; serviceClass)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> SYSTEM_SERVICE_NAMES.get(serviceClass);<br>    <span class="hljs-keyword">return</span> serviceName;<br>&#125;<br></code></pre></td></tr></table></figure><p>从第一节中的SystemServiceRegistry中SYSTEM_SERVICE_NAMES中获取StorageManager.class对应的serviceName</p><h3 id="2-2-再去获取系统服务Manager"><a href="#2-2-再去获取系统服务Manager" class="headerlink" title="2.2 再去获取系统服务Manager"></a>2.2 再去获取系统服务Manager</h3><p>如果SystemServiceRegistry保存了serviceName，则再调用getSystemService</p><img src="/2023/08/27/%E5%AE%89%E5%8D%93context-getSystemService%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20230827220638943.png" alt="image-20230827220638943" style="zoom: 67%;"><blockquote><p>发现是个抽象函数，则调用实现类中对于抽象函数的实现</p></blockquote><img src="/2023/08/27/%E5%AE%89%E5%8D%93context-getSystemService%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/image-20230827220752441.png" alt="image-20230827220752441" style="zoom:50%;"><p>下面就要调用SystemServiceRegistry的getSystemServiceName方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getSystemService</span><span class="hljs-params">(ContextImpl ctx, String name)</span> &#123;<br>    <span class="hljs-comment">// 获取SYSTEM_SERVICE_FETCHERS保存的服务</span><br>    <span class="hljs-keyword">final</span> ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);<br>    <span class="hljs-comment">// 如果是CachedServiceFetcher调用其getService方法[在1.2中分析了，获取缓存中服务的Manager]</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> fetcher.getService(ctx);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-一句话总结"><a href="#3-一句话总结" class="headerlink" title="3.一句话总结"></a>3.一句话总结</h2><p>context.getSystemService<strong>获取的是创建的那个Manger对象，而不是MangerService对象</strong>。例如context.getSystemService(StorageManager.class)获取到的是StorageManager对象。<strong>整个过程完全不涉及StorageManagerService，只与虚拟机中的StorageManger的Class对象有关。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>自己实现Android的SystemService</title>
    <link href="/2023/08/27/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0Android%E7%9A%84SystemService/"/>
    <url>/2023/08/27/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0Android%E7%9A%84SystemService/</url>
    
    <content type="html"><![CDATA[<h1 id="自己实现Android的SystemService"><a href="#自己实现Android的SystemService" class="headerlink" title="自己实现Android的SystemService"></a>自己实现Android的SystemService</h1><blockquote><p>转载自：<a href="https://segmentfault.com/a/1190000039997577#item-2">https://segmentfault.com/a/1190000039997577#item-2</a></p></blockquote><p>在android启动过程中会有各式各样的服务，如何编写自己的服务呢？</p><img src="/2023/08/27/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0Android%E7%9A%84SystemService/1460000039997580.png" alt="img" style="zoom:80%;"><h2 id="1-编写AIDL文件"><a href="#1-编写AIDL文件" class="headerlink" title="1.编写AIDL文件"></a>1.编写AIDL文件</h2><p>新建 frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;hardware&#x2F;wuxiaolong&#x2F;IWuXiaolongManager.aidl，内容如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> android.hardware.wuxiaolong;<br><span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IWuXiaolongManager</span> &#123;<br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Context-定义变量"><a href="#2-Context-定义变量" class="headerlink" title="2.Context 定义变量"></a>2.Context 定义变量</h2><p>在 Context 里定义一个代表 wuxiaolong 服务的字符串：frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;content&#x2F;Context.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">WUXIAOLONG_SERVICE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;wuxiaolong&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="3-编写系统服务"><a href="#3-编写系统服务" class="headerlink" title="3.编写系统服务"></a>3.编写系统服务</h2><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wuxiaolong&#x2F;WuXiaolongManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.android.server.wuxiaolong;<br><br><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.hardware.wuxiaolong.IWuXiaolongManager;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WuXiaolongManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IWuXiaolongManager</span>.Stub &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Context mContext;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WuXiaolongManagerService</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        mContext = context;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;WuXiaolong..&quot;</span>;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-注册系统服务"><a href="#4-注册系统服务" class="headerlink" title="4.注册系统服务"></a>4.注册系统服务</h2><p>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.android.server.wuxiaolong.WuXiaolongManagerService;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startOtherServices</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 部分代码省略...</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        android.util.Log.d(<span class="hljs-string">&quot;wxl&quot;</span>,<span class="hljs-string">&quot;SystemServer WuXiaolongManagerService&quot;</span>);<br>        ServiceManager.addService(Context.WUXIAOLONG_SERVICE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">WuXiaolongManagerService</span>(context));<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        reportWtf(<span class="hljs-string">&quot;starting WuXiaolongManagerService&quot;</span>, e);<br>    &#125;<br>    <span class="hljs-comment">// 部分代码省略...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-编写-Manager-类"><a href="#5-编写-Manager-类" class="headerlink" title="5.编写 Manager 类"></a>5.编写 Manager 类</h2><p>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;hardware&#x2F;wuxiaolong&#x2F;WuXiaolongManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> android.hardware.wuxiaolong;<br><br><span class="hljs-keyword">import</span> android.os.IBinder;<br><span class="hljs-keyword">import</span> android.os.ServiceManager;<br><span class="hljs-keyword">import</span> android.hardware.wuxiaolong.IWuXiaolongManager;<br><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.os.RemoteException;<br><span class="hljs-keyword">import</span> android.compat.annotation.UnsupportedAppUsage;<br><span class="hljs-keyword">import</span> android.annotation.Nullable;<br><span class="hljs-keyword">import</span> android.os.ServiceManager.ServiceNotFoundException;<br><span class="hljs-keyword">import</span> android.annotation.SystemService;<br><br><span class="hljs-meta">@SystemService(Context.WUXIAOLONG_SERVICE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WuXiaolongManager</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> WuXiaolongManager sInstance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IWuXiaolongManager mService;<br>    <span class="hljs-keyword">private</span> Context mContext;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@hide</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WuXiaolongManager</span><span class="hljs-params">(IWuXiaolongManager iWuXiaolongManager)</span> &#123;<br>        mService = iWuXiaolongManager;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Gets an instance of the WuXiaolong manager.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> The WuXiaolong manager instance.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@hide</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WuXiaolongManager <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        android.util.Log.d(<span class="hljs-string">&quot;wxl&quot;</span>, <span class="hljs-string">&quot;WuXiaolongManager getInstance&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (WuXiaolongManager.class) &#123;<br>            <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">IBinder</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ServiceManager.getServiceOrThrow(Context.WUXIAOLONG_SERVICE);<br>                    sInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WuXiaolongManager</span>(IWuXiaolongManager.Stub<br>                            .asInterface(ServiceManager.getServiceOrThrow(Context.WUXIAOLONG_SERVICE)));<br>                &#125; <span class="hljs-keyword">catch</span> (ServiceNotFoundException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(e);<br>                &#125;<br><br>            &#125;<br>            <span class="hljs-keyword">return</span> sInstance;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        android.util.Log.d(<span class="hljs-string">&quot;wxl&quot;</span>, <span class="hljs-string">&quot;WuXiaolongManager getName&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> mService.getName();<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-注册-Manager"><a href="#6-注册-Manager" class="headerlink" title="6.注册 Manager"></a>6.注册 Manager</h2><p>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;SystemServiceRegistry.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.hardware.wuxiaolong.WuXiaolongManager;<br><span class="hljs-keyword">static</span> &#123;<br>    registerService(Context.WUXIAOLONG_SERVICE, WuXiaolongManager.class,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachedServiceFetcher</span>&lt;WuXiaolongManager&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> WuXiaolongManager <span class="hljs-title function_">createService</span><span class="hljs-params">(ContextImpl ctx)</span><br>                        <span class="hljs-keyword">throws</span> ServiceNotFoundException &#123;<br>                    android.util.Log.d(<span class="hljs-string">&quot;wxl&quot;</span>,<span class="hljs-string">&quot;SystemServiceRegistry registerService&quot;</span>);<br>                    <span class="hljs-keyword">return</span> WuXiaolongManager.getInstance();<br>                &#125;&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-应用调用"><a href="#7-应用调用" class="headerlink" title="7.应用调用"></a>7.应用调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">WuXiaolongManager</span> <span class="hljs-variable">mWuXiaolongManager</span> <span class="hljs-operator">=</span> (WuXiaolongManager)mContext.getSystemService(Context.WUXIAOLONG_SERVICE);<br>android.util.Log.d(<span class="hljs-string">&quot;wxl&quot;</span>,<span class="hljs-string">&quot;Name=&quot;</span>+ mWuXiaolongManager.getName());<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的Class对象</title>
    <link href="/2023/08/27/Java%E7%9A%84Class%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/08/27/Java%E7%9A%84Class%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Java的Class对象"><a href="#Java的Class对象" class="headerlink" title="Java的Class对象"></a>Java的Class对象</h1><blockquote><p>转载自：<a href="https://www.jianshu.com/p/7ef502580df3">https://www.jianshu.com/p/7ef502580df3</a></p></blockquote><h2 id="0-Java的静态代码段和构造代码段"><a href="#0-Java的静态代码段和构造代码段" class="headerlink" title="0.Java的静态代码段和构造代码段"></a>0.Java的静态代码段和构造代码段</h2><ul><li>静态代码段</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span>&#123;<br>    <span class="hljs-comment">// 静态代码块</span><br>&#125;<br></code></pre></td></tr></table></figure><p>静态代码块是给类初始化的。在类加载的初始化阶段时候就被调用，并且只执行一次</p><ul><li>构造代码段</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    <span class="hljs-comment">//构造代码块</span><br>&#125;<br></code></pre></td></tr></table></figure><p>构造代码块是给对象初始化的。每一次创建对象时执行一次。</p><p><strong>对于一个类而言，按照如下顺序执行：</strong></p><p>1、执行静态代码块<br>2、执行构造代码块<br>3、执行构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HelloWorld</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;this is no param constrcut&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;this is static section&quot;</span>);<br>&#125;<br><br>&#123;<br> System.out.println(<span class="hljs-string">&quot;this is construct section&quot;</span>);<br>&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br><span class="hljs-type">HelloWorld</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloWorld</span>();<br>       System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/08/27/Java%E7%9A%84Class%E5%AF%B9%E8%B1%A1/image-20230827195138399.png" alt="image-20230827195138399" style="zoom: 100%;"><h2 id="1-Class对象"><a href="#1-Class对象" class="headerlink" title="1.Class对象"></a>1.Class对象</h2><p>在Java中有两种对象：Class对象和实例对象，实例对象是类的实例，通常是通过<code>new</code>关键字构建的。Class对象是JVM生成用来保存对象的类的信息的。Java程序执行之前需要经过编译、加载、链接和初始化这几个阶段，编译阶段会将源码文件编译为<code>.class</code>字节码文件，编译器同时会在<code>.class</code>文件中生成Class对象，加载阶段通过JVM内部的类加载机制，将Class对象加载到内存中。在创建实例对象之前，JVM会先检查Class对象是否在内存中存在，如果不存在，则加载Class对象，然后再创建对象实例，如果存在，则直接根据Class对象创建对象实例。JVM中只有一个Class对象，但可以根据Class对象生成多个对象实例。</p><h2 id="2-Class对象的获得"><a href="#2-Class对象的获得" class="headerlink" title="2.Class对象的获得"></a>2.Class对象的获得</h2><h3 id="2-1-类名-class"><a href="#2-1-类名-class" class="headerlink" title="2.1 类名.class"></a>2.1 类名.class</h3><p>当执行类名<code>.class</code>时，JVM会先检查Class对象是否装入内存，如果没有装入内存，则将Class对象装入内存，然后返回Class对象，如果装入内存，则直接返回Class对象。在加载Class对象后，不会对Class对象进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Run static initialization block.&quot;</span>);<br>    &#125;<br>    <br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;Run nonstatic initialization block.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassTest</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Test.class;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果为：空【什么都不打印】</p><h3 id="2-2-Class-forName"><a href="#2-2-Class-forName" class="headerlink" title="2.2 Class.forName()"></a>2.2 Class.forName()</h3><p>当执行<code>Class.forName()</code>时，JVM也会先检查Class对象是否装入内存，如果没有装入内存，则将Class对象装入内存，然后返回Class对象，如果装入内存，则直接返回Class对象。<strong>在加载Class对象后，会对类进行初始化，即执行类的静态代码块</strong>。forName()方法中的参数是类名字符串，类名字符串 &#x3D; 包名 + 类名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.tyan.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Run static initialization block.&quot;</span>);<br>    &#125;<br>    <br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;Run nonstatic initialization block.&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">package</span> com.tyan.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassTest</span> &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.tyan.test.Test&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><img src="/2023/08/27/Java%E7%9A%84Class%E5%AF%B9%E8%B1%A1/image-20230827193927854.png" alt="image-20230827193927854" style="zoom:80%;"><h3 id="2-3-getClass"><a href="#2-3-getClass" class="headerlink" title="2.3 getClass"></a>2.3 getClass</h3><p><code>getClass()</code>方法的方法是在通过的类的实例调用的，即已经创建了类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Run static initialization block.&quot;</span>);<br>    &#125;<br>    <br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;Run nonstatic initialization block.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassTest</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> t.getClass();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><img src="/2023/08/27/Java%E7%9A%84Class%E5%AF%B9%E8%B1%A1/image-20230827194008908.png" alt="image-20230827194008908" style="zoom:80%;"><h2 id="3-Class类的常用方法"><a href="#3-Class类的常用方法" class="headerlink" title="3.Class类的常用方法"></a>3.Class类的常用方法</h2><ul><li>getName()</li></ul><p>一个Class对象描述了一个特定类的属性，Class类中最常用的方法getName以String的形式返回此Class对象所表示的实体（类、接口、数组类、基本类型或void名称。</p><ul><li>newInstance()</li></ul><p>Class还有一个有用的方法可以为类创建一个实例，这个方法叫做newInstance()。例如：<code>x.getClass.newInstance()</code>，创建了一个同<code>x</code>一样类型的新实例。<code>newInstance()</code>方法调用默认构造器（无参数构造器）初始化新建对象。</p><ul><li>getClassLoader()</li></ul><p>返回该类的类加载器。</p><ul><li>getComponentType()</li></ul><p>返回表示数组组件类型的Class。</p><ul><li>getSuperclass()</li></ul><p>返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的Class。</p><ul><li>isArray()</li></ul><p>判定此 Class 对象是否表示一个数组类。</p><h2 id="4-反射"><a href="#4-反射" class="headerlink" title="4.反射"></a>4.反射</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android存储域服务启动</title>
    <link href="/2023/08/24/Android%E5%AD%98%E5%82%A8%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/"/>
    <url>/2023/08/24/Android%E5%AD%98%E5%82%A8%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Android存储域服务启动"><a href="#Android存储域服务启动" class="headerlink" title="Android存储域服务启动"></a>Android存储域服务启动</h1><blockquote><p>部分参考自：<a href="https://blog.csdn.net/geshifei/article/details/131184012">https://blog.csdn.net/geshifei/article/details/131184012</a></p></blockquote><h2 id="1-存储相关Service"><a href="#1-存储相关Service" class="headerlink" title="1.存储相关Service"></a>1.存储相关Service</h2><h3 id="1-1-service介绍"><a href="#1-1-service介绍" class="headerlink" title="1.1 service介绍"></a>1.1 service介绍</h3><p>存储有3个关键service：mount、vold、storaged，通过<code>adb shell &quot;service list&quot;</code>可以看到。</p><table><thead><tr><th>服务名</th><th>代码路径</th></tr></thead><tbody><tr><td>mount service</td><td>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;StorageManagerService.java</td></tr><tr><td>vold service</td><td>system&#x2F;vold 目录</td></tr><tr><td>storaged service</td><td>system&#x2F;core&#x2F;storaged 目录</td></tr></tbody></table><ul><li>mount service负责mount和umount存储设备或存储卷，提供文件系统的访问接口。它的mount、umount请求下发给native层的vold处理。</li><li>vold (Volume Daemon)位于framework和kernel之间，管理存储卷的生命周期、处理mount service的mount和umount请求，以及提供存储卷的管理接口。其主要功能为：<ul><li>监听内核的存储设备uevent事件，并上报给mount service。</li><li>处理mount service下发的mount、umount请求。</li></ul></li><li>storaged是一个deamon进程，提供存储相关的统计数据（磁盘使用信息、应用io信息、存储寿命信息等），并通过向应用程序和系统组件提供 API 接口，使它们能够监控和管理存储资源的使用情况。</li></ul><h3 id="1-2-service之间的关系"><a href="#1-2-service之间的关系" class="headerlink" title="1.2 service之间的关系"></a>1.2 service之间的关系</h3><p>mount、vold、storaged之间的层次关系如下：</p><img src="/2023/08/24/Android%E5%AD%98%E5%82%A8%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/69175f9d8ce84cc58ab121e2a3ba7468.png" alt="img"><p> 图中标号说明：</p><p><strong>①：looper线程监听ACTION_USER_ADDED和ACTION_USER_REMOVED消息。</strong></p><p>StorageManagerService::StorageManagerService –&gt; mContext.registerReceiver(mUserReceiver, userFilter, null, mHandler)注册了BroadcastReceiver ，接收ACTION_USER_ADDED和ACTION_USER_REMOVED类型的 IntentFilter 广播消息， 参数mHandle所代表的线程上执行 BroadcastReceiver。</p><p>在StorageManagerService方法中，mHandler &#x3D; new StorageManagerServiceHandler(hthread.getLooper())，所以Handler 代表的线程是looper线程。</p><p>mount service收到ACTION_USER_ADDED和ACTION_USER_REMOVED后，会做mount或者unmount操作。</p><p><strong>②：mount service设置一个监听器，监听vold状态。</strong></p><p>StorageManagerService::connectVold –&gt; mVold &#x3D; IVold.Stub.asInterface(binder)获取vold service的Binder对象，接着mount service通过mVold.setListener(mListener)设置监听器监听vold状态变化，监听器回调方法在StorageManagerService的匿名内部类中（见private final IVoldListener mListener &#x3D; new IVoldListener.Stub()处的匿名类）。一旦vold状态变化，就会执行监听器回调方法，见⑤。</p><p><strong>③：mount service获取storaged的binder对象，需要的时候执行storaged中的方法。</strong></p><p>StorageManagerService::connectStoraged –&gt; mStoraged &#x3D; IStoraged.Stub.asInterface(binder)获取storaged service的Binder对象。mount service接收到相关事件后，比如unlock user，remove user等，执行storaged中的函数mStoraged.onUserStarted(userId)，mStoraged.onUserStopped(userId)等。</p><p><strong>④：VoldNativeService执行VolumeManager中的方法。</strong></p><p>VoldNativeService通过类似于translate(VolumeManager::Instance()-&gt;XXX执行VolumeManager中的方法。比如VoldNativeService::onUserAdded –&gt; translate(VolumeManager::Instance()-&gt;onUserAdded(userId, userSerial))，执行的是VolumeManager::onUserAdded。</p><p><strong>⑤：VolumeManager上报存储设备事件给mount service。</strong></p><p>用户add或删除，需要mount或者umount掉emulated storage；热插拔存储设备，kernel会上报uevent事件，这些都会引起vold状态变化，此时mount service在②中设置的监听器就监听到这些事件，执行对应的监听器回调方法。</p><p><strong>⑥：NetlinkManager初始化socket，用于接收kernel的uevent事件。</strong></p><p>system&#x2F;vold&#x2F;main.cpp中通过nm &#x3D; NetlinkManager::Instance()实例化了一个NetlinkManager，用于接收kernel的uevent事件。</p><p><strong>⑦：VolumeManager执行系统调用，执行mount等操作。</strong></p><p>VolumeManager通过VolumeManager类执行kernel的系统调用，比如VolumeManager::mountAppFuse –&gt; android::vold::MountAppFuse –&gt; RunCommand –&gt; mount等。</p><h2 id="2-各服务启动"><a href="#2-各服务启动" class="headerlink" title="2.各服务启动"></a>2.各服务启动</h2><h3 id="2-1-mount-service-SMS-启动"><a href="#2-1-mount-service-SMS-启动" class="headerlink" title="2.1 mount service(SMS)启动"></a>2.1 mount service(SMS)启动</h3><p>mount service与其他服务一样，是由SystemServer拉起的：</p><p>SystemServer.run -&gt; startOtherServices</p><img src="/2023/08/24/Android%E5%AD%98%E5%82%A8%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/image-20230824235423489.png" alt="image-20230824235423489" style="zoom:56%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">STORAGE_MANAGER_SERVICE_CLASS</span> <span class="hljs-operator">=</span><br>    <span class="hljs-string">&quot;com.android.server.StorageManagerService$Lifecycle&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">STORAGE_STATS_SERVICE_CLASS</span> <span class="hljs-operator">=</span><br>    <span class="hljs-string">&quot;com.android.server.usage.StorageStatsService$Lifecycle&quot;</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startOtherServices</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> TimingsTraceAndSlog t)</span> &#123;<br>    t.traceBegin(<span class="hljs-string">&quot;startOtherServices&quot;</span>);<br>    <br>    <span class="hljs-type">IStorageManager</span> <span class="hljs-variable">storageManager</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-keyword">if</span> (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;0&quot;</span>.equals(SystemProperties.get(<span class="hljs-string">&quot;system_init.startmountservice&quot;</span>))) &#123;<br>            t.traceBegin(<span class="hljs-string">&quot;StartStorageManagerService&quot;</span>);<br>            mSystemServiceManager.startService(STORAGE_MANAGER_SERVICE_CLASS);<br>            storageManager = IStorageManager.Stub.asInterface(ServiceManager.getService(<span class="hljs-string">&quot;mount&quot;</span>));<br>            t.traceEnd();<br><br>            t.traceBegin(<span class="hljs-string">&quot;StartStorageStatsService&quot;</span>);<br>            mSystemServiceManager.startService(STORAGE_STATS_SERVICE_CLASS);<br>            t.traceEnd();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用SystemServiceManager启动服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SystemService <span class="hljs-title function_">startService</span><span class="hljs-params">(String className)</span> &#123;<br><span class="hljs-comment">// 通过Java反射机制拿到服务的类(loadClassFromLoader会通过Class.forName获取Class)</span><br>    <span class="hljs-comment">// Class.forName要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段</span><br>    <span class="hljs-keyword">final</span> Class&lt;SystemService&gt; serviceClass = loadClassFromLoader(className,<span class="hljs-built_in">this</span>.getClass().getClassLoader());<br>    <span class="hljs-keyword">return</span> startService(serviceClass);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用重载的startService，传入的是Class类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这边的泛型是SystemService</span><br><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SystemService</span>&gt; T <span class="hljs-title function_">startService</span><span class="hljs-params">(Class&lt;T&gt; serviceClass)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> serviceClass.getName();   <span class="hljs-comment">// 通过反射获取类名</span><br>        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, <span class="hljs-string">&quot;StartService &quot;</span> + name);<br><br>        <span class="hljs-keyword">final</span> T service;<br>        Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);  <span class="hljs-comment">// 获取构造器</span><br>        service = constructor.newInstance(mContext);  <span class="hljs-comment">// 创建实例</span><br>        startService(service);   <span class="hljs-comment">// 传入泛型SystemService</span><br>        <span class="hljs-keyword">return</span> service;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次调用重载的startService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startService</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> SystemService service)</span> &#123;<br>    mServices.add(service); <span class="hljs-comment">// mServices存放了所有的服务，用于用户启动时的onUser方法去通知各服务执行相应的多用户操作</span><br>    service.onStart();  <span class="hljs-comment">// 调用服务的onStart方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面继续分析具体service的onStart方法</p><h4 id="2-1-1-StorageManagerService-Lifecycle启动"><a href="#2-1-1-StorageManagerService-Lifecycle启动" class="headerlink" title="2.1.1 StorageManagerService$Lifecycle启动"></a>2.1.1 StorageManagerService$Lifecycle启动</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lifecycle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SystemService</span> &#123;<br>    <span class="hljs-keyword">private</span> StorageManagerService mStorageManagerService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Lifecycle</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br>        mStorageManagerService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StorageManagerService</span>(getContext());<br>        publishBinderService(<span class="hljs-string">&quot;mount&quot;</span>, mStorageManagerService);<br>        mStorageManagerService.start();  <span class="hljs-comment">// 调用StorageManagerService的start方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>创建StorageManagerService实例</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">StorageManagerService</span><span class="hljs-params">(Context context)</span> &#123;<br>    sSelf = <span class="hljs-built_in">this</span>;<br>    mVoldAppDataIsolationEnabled = SystemProperties.getBoolean(<br>        ANDROID_VOLD_APP_DATA_ISOLATION_ENABLED_PROPERTY, <span class="hljs-literal">false</span>);<br>    mContext = context;<br>    mResolver = mContext.getContentResolver();<br>    mCallbacks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callbacks</span>(FgThread.get().getLooper());<br>    mLockPatternUtils = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockPatternUtils</span>(mContext);<br><br>    <span class="hljs-type">HandlerThread</span> <span class="hljs-variable">hthread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerThread</span>(TAG);<br>    hthread.start();<br>    mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StorageManagerServiceHandler</span>(hthread.getLooper());<br><br>    <span class="hljs-comment">// Add OBB Action Handler to StorageManagerService thread.</span><br>    mObbActionHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObbActionHandler</span>(IoThread.get().getLooper());<br><br>    mStorageSessionController = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StorageSessionController</span>(mContext);<br><br>    mInstaller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Installer</span>(mContext);<br>    mInstaller.onStart();<br><br>    <span class="hljs-comment">// Initialize the last-fstrim tracking if necessary</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">dataDir</span> <span class="hljs-operator">=</span> Environment.getDataDirectory();<br>    <span class="hljs-type">File</span> <span class="hljs-variable">systemDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(dataDir, <span class="hljs-string">&quot;system&quot;</span>);<br>    mLastMaintenanceFile = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(systemDir, LAST_FSTRIM_FILE);<br>    <span class="hljs-keyword">if</span> (!mLastMaintenanceFile.exists()) &#123;<br>        <span class="hljs-comment">// Not setting mLastMaintenance here means that we will force an</span><br>        <span class="hljs-comment">// fstrim during reboot following the OTA that installs this code.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(mLastMaintenanceFile)).close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            Slog.e(TAG, <span class="hljs-string">&quot;Unable to create fstrim record &quot;</span> + mLastMaintenanceFile.getPath());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mLastMaintenance = mLastMaintenanceFile.lastModified();<br>    &#125;<br><br>    mSettingsFile = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicFile</span>(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(Environment.getDataSystemDirectory(), <span class="hljs-string">&quot;storage.xml&quot;</span>), <span class="hljs-string">&quot;storage-settings&quot;</span>);<br><br>    <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        readSettingsLocked();<br>    &#125;<br><br>    LocalServices.addService(StorageManagerInternal.class, mStorageManagerInternal);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">IntentFilter</span> <span class="hljs-variable">userFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntentFilter</span>();<br>    userFilter.addAction(Intent.ACTION_USER_ADDED);<br>    userFilter.addAction(Intent.ACTION_USER_REMOVED);<br>    mContext.registerReceiver(mUserReceiver, userFilter, <span class="hljs-literal">null</span>, mHandler);<br><br>    <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        addInternalVolumeLocked();<br>    &#125;<br><br>    <span class="hljs-comment">// Add ourself to the Watchdog monitors if enabled.</span><br>    <span class="hljs-keyword">if</span> (WATCHDOG_ENABLE) &#123;<br>        Watchdog.getInstance().addMonitor(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    mIsAutomotive = context.getPackageManager().hasSystemFeature(<br>        PackageManager.FEATURE_AUTOMOTIVE);<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><ol start="2"><li><strong>StorageManagerService的start方法如下</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    connectStoraged();<br>    connectVold();<br>&#125;<br></code></pre></td></tr></table></figure><p>在SMS中会拿到storaged和vold服务：</p><ul><li><strong>获取storaged服务</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectStoraged</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">IBinder</span> <span class="hljs-variable">binder</span> <span class="hljs-operator">=</span> ServiceManager.getService(<span class="hljs-string">&quot;storaged&quot;</span>);<br>    mStoraged = IStoraged.Stub.asInterface(binder);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>获取vold服务</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectVold</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">IBinder</span> <span class="hljs-variable">binder</span> <span class="hljs-operator">=</span> ServiceManager.getService(<span class="hljs-string">&quot;vold&quot;</span>);<br>    mVold = IVold.Stub.asInterface(binder);<br>    mVold.setListener(mListener);  <span class="hljs-comment">// 监听vold的事件</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-2-StorageStatsService-Lifecycle启动"><a href="#2-1-2-StorageStatsService-Lifecycle启动" class="headerlink" title="2.1.2 StorageStatsService$Lifecycle启动"></a>2.1.2 StorageStatsService$Lifecycle启动</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lifecycle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SystemService</span> &#123;<br>    <span class="hljs-keyword">private</span> StorageStatsService mService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br>        mService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StorageStatsService</span>(getContext());<br>        publishBinderService(Context.STORAGE_STATS_SERVICE, mService);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建StorageStatsService服务实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">StorageStatsService</span><span class="hljs-params">(Context context)</span> &#123;<br>    mContext = Preconditions.checkNotNull(context);<br>    mAppOps = Preconditions.checkNotNull(context.getSystemService(AppOpsManager.class));<br>    mUser = Preconditions.checkNotNull(context.getSystemService(UserManager.class));<br>    mPackage = Preconditions.checkNotNull(context.getPackageManager());<br>    mStorage = Preconditions.checkNotNull(context.getSystemService(StorageManager.class));<br>    mCacheQuotas = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;&gt;();<br><br>    mInstaller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Installer</span>(context);<br>    mInstaller.onStart();<br>    invalidateMounts();<br><br>    mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">H</span>(IoThread.get().getLooper());<br>    mHandler.sendEmptyMessage(H.MSG_LOAD_CACHED_QUOTAS_FROM_FILE);<br><br>    mStorage.registerListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StorageEventListener</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onVolumeStateChanged</span><span class="hljs-params">(VolumeInfo vol, <span class="hljs-type">int</span> oldState, <span class="hljs-type">int</span> newState)</span> &#123;<br>            <span class="hljs-keyword">switch</span> (vol.type) &#123;<br>                <span class="hljs-keyword">case</span> VolumeInfo.TYPE_PUBLIC:<br>                <span class="hljs-keyword">case</span> VolumeInfo.TYPE_PRIVATE:<br>                <span class="hljs-keyword">case</span> VolumeInfo.TYPE_EMULATED:<br>                    <span class="hljs-keyword">if</span> (newState == VolumeInfo.STATE_MOUNTED) &#123;<br>                        invalidateMounts();<br>                    &#125;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    LocalManagerRegistry.addManager(StorageStatsManagerLocal.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalService</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-vold启动"><a href="#2-2-vold启动" class="headerlink" title="2.2 vold启动"></a>2.2 vold启动</h3><h3 id="2-3-storaged启动"><a href="#2-3-storaged启动" class="headerlink" title="2.3 storaged启动"></a>2.3 storaged启动</h3><p>安卓官网对于storaged的描述：<a href="https://source.android.com/docs/core/tests/debug/storaged?hl=zh-cn">https://source.android.com/docs/core/tests/debug/storaged?hl=zh-cn</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统如何解决wandering tree问题</title>
    <link href="/2023/08/22/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3wandering-tree%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/22/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3wandering-tree%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统如何解决wandering-tree问题"><a href="#f2fs文件系统如何解决wandering-tree问题" class="headerlink" title="f2fs文件系统如何解决wandering tree问题"></a>f2fs文件系统如何解决wandering tree问题</h1><h2 id="nand-flash异地更新特性"><a href="#nand-flash异地更新特性" class="headerlink" title="nand flash异地更新特性"></a>nand flash异地更新特性</h2><img src="/2023/08/22/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3wandering-tree%E9%97%AE%E9%A2%98/ulmpx3903i.png" alt="NAND Flash布局示意图" style="zoom:75%;"><ul><li>读写的操作对象是page</li><li>擦除的对象是block</li><li>每个block在写入前需要先擦除（Erase-Before-Write）</li></ul><p>Flash还有一个重要特性：<strong>Flash不支持更新操作</strong>，严格说应该是不支持原址更新。 如果我们已经往某个page中写入了数据，想修改这个page中的内容，只能通过下面的方法：</p><ol><li>先把本page所属block的数据全部读出来，比如先读到内存DRAM</li><li>然后修改对应page的内容</li><li>接下来擦除整个block</li><li>最后把修改后的block数据回写到Flash</li></ol><p>这样的<strong>本地更新</strong>的操作其实会有2个问题：</p><ul><li>对于Flash会加剧磨损，影响寿命</li><li>读出一个整块的擦除块，擦除它，再回写更新的数据，所花时间比单独在其它已经擦除了的擦除块更新数据长100倍。换句话说，对于一个小的更新，在本地更新比异地更新更新时间长100倍。</li></ul><hr><img src="/2023/08/22/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3wandering-tree%E9%97%AE%E9%A2%98/image-20230822214001394.png" alt="image-20230822214001394" style="zoom:67%;"><p>当我们需要更新一个页的时候，在一个新的块上找到空闲页，然后写入，原来的页标志为无效页，等待垃圾回收将其回收。这种页更新不在本地块，而在异地块的特性，称为<strong>异地更新</strong>特性。</p><p><strong>这边会有一个问题，对于上层文件系统而言，我怎么知道异地更新后块的地址是哪里？</strong></p><p>这也就需要记录逻辑页和物理页的映射关系，这部分由Flash Trabslation Layer (FTL)完成。也就是说上层文件系统访问的都是块的逻辑地址，我们在SSD中维护一张FTL表，异地更新之后只需要更新FTL中，逻辑地址对应的物理地址即可。</p><p>例如：当前有一张FTL表，里面对应了块的映射关系，逻辑地址为147的块，真实物理块地址为0x19087</p><table><thead><tr><th>逻辑地址</th><th>物理地址</th></tr></thead><tbody><tr><td>6</td><td>0x42712</td></tr><tr><td>147</td><td>0x19087</td></tr><tr><td>51</td><td>0x22893</td></tr></tbody></table><p>此时我们异地更新了0x19087，改成了0x51209。对于上层文件系统而言其访问的依然是逻辑地址，因此它是不感知的。</p><p>因此<strong>当前Nand Flash对应的文件系统主要有3种形式</strong>：<a href="https://www.jsjkx.com/CN/article/openArticlePDF.jsp?id=738">《一种基于热数据识别技术的UBIFS优化方案》</a></p><img src="/2023/08/22/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3wandering-tree%E9%97%AE%E9%A2%98/image-20230822214933086.png" alt="image-20230822214933086" style="zoom: 67%;"><ol><li>使用<strong>传统磁盘文件系统+设备端FTL</strong>管理Nand Flash中的文件，将Nand Flash设备当做磁盘使用。常见的文件系统有：ext3&#x2F;ext4文件系统</li><li>同样<strong>依靠设备端FTL</strong>来管理Nand Flash，但是这种文件系统<strong>专门针对闪存特性设计</strong>。常见的文件系统有：f2fs文件系统&#x2F;ReconFS文件系统</li><li>可以<strong>直接操作Nand Flash设备的物理地址内容</strong>，不需要设备端FTL支持。常见的有：UBIFS、JFFS2和YAFFS2文件系统</li></ol><h2 id="f2fs解决wandering-tree问题"><a href="#f2fs解决wandering-tree问题" class="headerlink" title="f2fs解决wandering tree问题"></a>f2fs解决wandering tree问题</h2><h3 id="什么是wandering-tree问题"><a href="#什么是wandering-tree问题" class="headerlink" title="什么是wandering  tree问题"></a>什么是wandering  tree问题</h3><p>我们来看论文：<a href="https://www.researchgate.net/publication/289490302_Avoidance_techniques_for_Snowball_effect_of_Wandering_Tree_in_Flash_Memory_based_File_Systems">《Avoidance techniques for Snowball effect of  Wandering Tree in Flash Memory based File Systems》</a></p><img src="/2023/08/22/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3wandering-tree%E9%97%AE%E9%A2%98/image-20230822221751530.png" alt="image-20230822221751530" style="zoom:67%;"><p>一个大文件常常时一个inode表示不了的，常常需要多级node表示，例如这里的inode，有indirect block和double indirect block。假设我们要更新Pointer128指向的数据块393:</p><ul><li>首先要更新Indirect Block中Pointer 128指向的值，因为异地更新的缘故，393数据块对应的页会找到一个新的数据块找到空闲页写入</li><li>更新Double Indirect Block中Pointer 2指向的值，因为异地更新的缘故，Indirect Block中Pointer 128存放的数据块地址值修改了，这个块要异地更新</li><li>….</li><li>依次类推，一直要更新到Inode这个块的值，因为Pointer 12的指向需要修改</li></ul><p>这样就导致了<strong>滚雪球效应</strong>（有些文章也叫做<strong>雪崩效应</strong>），也就是Wandering Tree问题。当一个数据块更新时，由于Nand Flash异地更新特性，会层层递归更新到更节点，像雪崩一样，牵一发动全身。</p><h3 id="如何解决wandering-tree"><a href="#如何解决wandering-tree" class="headerlink" title="如何解决wandering tree"></a>如何解决wandering tree</h3><p>《操作系统导论》的作者戏称在架构设计里面没有什么是加一层中间层解决不了的，哈哈哈哈😯</p><p>在f2fs文件系统中其实也是引用了中间层思想，与FTL有异曲同工之妙。慢慢体会。F2FS在元数据区域引入了NAT(node address table)区域，其指明了nid与真实block address的关系，我们可以查看dump_nat【命令d<strong>ump.f2fs -n 0~-1 xxx</strong> 】来看一下：</p><img src="/2023/08/22/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3wandering-tree%E9%97%AE%E9%A2%98/image-20230719235441702.png" alt="image-20230719235441702" style="zoom:67%;"><p>nid为4的node block（也就是第4个被使用的node block）其对应的物理块地址blkaddr为4612。</p><p>这样对于上面如果在indirect node block和double indirect node block都是存放的是下一级node block的逻辑地址（也就是nid值），这样如果我们更新了393数据块，我们不再需要层层递归的去个更新了，我们只需要更细最后一级直接指向数据块的那个node block，进行异地更新，此时再去NAT中找到对应的nid更新它对应的bldaddr即可，中间层层的逻辑映射关系保持不变。</p><img src="/2023/08/22/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3wandering-tree%E9%97%AE%E9%A2%98/image-20230822224132981.png" alt="image-20230822224132981" style="zoom: 67%;"><h3 id="有了FTL，为什么还要NAT"><a href="#有了FTL，为什么还要NAT" class="headerlink" title="有了FTL，为什么还要NAT"></a>有了FTL，为什么还要NAT</h3><p>下面都是我本人的理解：在文件系统层面针对Nand Flash进行设计，提前规避Wandering Tree问题，这样对于FTL来说压力就说减小很多，因为FTL还要负责垃圾回收，磨损均衡等等。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统目录树结构</title>
    <link href="/2023/08/21/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    <url>/2023/08/21/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E6%A0%91%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统node block相关概念</title>
    <link href="/2023/08/21/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fnode-block%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/08/21/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fnode-block%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统node-block相关概念"><a href="#f2fs文件系统node-block相关概念" class="headerlink" title="f2fs文件系统node block相关概念"></a>f2fs文件系统node block相关概念</h1><h2 id="1-inode、dnode、indnode区别"><a href="#1-inode、dnode、indnode区别" class="headerlink" title="1.inode、dnode、indnode区别"></a>1.inode、dnode、indnode区别</h2><p>我们知道node block的数据结构形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_node</span> &#123;</span><br><span class="hljs-comment">/* can be one of three types: inode, direct, and indirect types */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_inode</span> <span class="hljs-title">i</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">direct_node</span> <span class="hljs-title">dn</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">indirect_node</span> <span class="hljs-title">in</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_footer</span> <span class="hljs-title">footer</span>;</span><br>&#125; __packed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_footer</span> &#123;</span><br>__le32 nid;<span class="hljs-comment">/* node id */</span><br>__le32 ino;<span class="hljs-comment">/* inode number */</span><br>__le32 flag;<span class="hljs-comment">/* include cold/fsync/dentry marks and offset */</span><br>__le64 cp_ver;<span class="hljs-comment">/* checkpoint version */</span><br>__le32 next_blkaddr;<span class="hljs-comment">/* next node page block address */</span><br>&#125; __packed;<br></code></pre></td></tr></table></figure><p>在f2fs文件系统中node block可以分为<code>f2fs_inode、direct_node和indirect_node</code></p><h3 id="1-1-inode"><a href="#1-1-inode" class="headerlink" title="1.1 inode"></a>1.1 inode</h3><p>f2fs_inode即为很多文章里面常说的inode，也是f2fs内核代码里面很多地方的判断形式所代表的数据结构：</p><img src="/2023/08/21/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fnode-block%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20230821225135550.png" alt="image-20230821225135550" style="zoom: 67%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">IS_INODE</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_node</span> *<span class="hljs-title">p</span> =</span> F2FS_NODE(page);  <span class="hljs-comment">// 将node page转换成f2fs_node结构</span><br><span class="hljs-keyword">return</span> RAW_IS_INODE(p);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RAW_IS_INODE(p)((p)-&gt;footer.nid == (p)-&gt;footer.ino)</span><br></code></pre></td></tr></table></figure><p><strong>从这里我们也可以知道f2fs_node尾部有一个node_footer结构，当node_footer中nid和ino相当，则认为当前结构为inode结构</strong></p><h3 id="1-2-dnode"><a href="#1-2-dnode" class="headerlink" title="1.2 dnode"></a>1.2 dnode</h3><p><strong>direct_node</strong>即为很多文章中所说的<strong>dnode block</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">direct_node</span> &#123;</span><br>__le32 addr[DEF_ADDRS_PER_BLOCK];<span class="hljs-comment">/* array of data block address */</span><br>&#125; __packed;<br></code></pre></td></tr></table></figure><p>注意：</p><h3 id="1-3-indnode"><a href="#1-3-indnode" class="headerlink" title="1.3 indnode"></a>1.3 indnode</h3><p>indirect_node即为很多文章中所说的indnode：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">indirect_node</span> &#123;</span><br>__le32 nid[NIDS_PER_BLOCK];<span class="hljs-comment">/* array of data block address */</span><br>&#125; __packed;<br></code></pre></td></tr></table></figure><h2 id="2-node-page相关理解"><a href="#2-node-page相关理解" class="headerlink" title="2.node page相关理解"></a>2.node page相关理解</h2><h3 id="2-1-node-page是什么"><a href="#2-1-node-page是什么" class="headerlink" title="2.1 node page是什么"></a>2.1 node page是什么</h3><p>node block对应的是磁盘上对应的结构，而真实存在于内存中，准确的说应该是缓存Page Cache中的应该是页。</p><p><strong>f2fs_get_node_page</strong>函数会将4K的node block转换成4K的node page。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">f2fs_get_node_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">pgoff_t</span> nid)</span><br>&#123;<br><span class="hljs-keyword">return</span> __get_node_page(sbi, nid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *__<span class="hljs-title">get_node_page</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_sb_info</span> *<span class="hljs-title">sbi</span>, <span class="hljs-title">pgoff_t</span> <span class="hljs-title">nid</span>,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">parent</span>, <span class="hljs-title">int</span> <span class="hljs-title">start</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">int</span> err;<br><br>    <span class="hljs-comment">// 从缓存中获取</span><br>page = f2fs_grab_cache_page(NODE_MAPPING(sbi), nid, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-comment">// 如果缓存中没有找到</span><br>    <span class="hljs-comment">// 则构造bio，然后从磁盘中读取inode对应的block，将block数据放到刚刚创建的page</span><br>    err = read_node_page(page, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-node-page对应的address-space"><a href="#2-2-node-page对应的address-space" class="headerlink" title="2.2 node page对应的address_space"></a>2.2 node page对应的address_space</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> address_space *<span class="hljs-title function_">NODE_MAPPING</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span><br>&#123;<br><span class="hljs-keyword">return</span> sbi-&gt;node_inode-&gt;i_mapping;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现所有的node page都是挂在sbi-&gt;node_inode上。f2fs_sb_info的node_inode上面是（挂载了f2fs文件系统目录的）文件对应的缓存Page Cahe。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统checkpoint机制学习路线</title>
    <link href="/2023/08/16/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2023/08/16/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统checkpoint机制学习路线"><a href="#f2fs文件系统checkpoint机制学习路线" class="headerlink" title="f2fs文件系统checkpoint机制学习路线"></a>f2fs文件系统checkpoint机制学习路线</h1><p><strong>1.先学习Mysql的checkpoint机制</strong></p><ul><li><p>✉️书籍：<strong>《Mysql技术内幕：InnoDB存储引擎》</strong></p></li><li><p><a href="https://xiaolincoding.com/mysql/log/"> MySQL 日志：undo log、redo log、binlog 有什么用？</a></p></li><li><p><a href="https://maimai.cn/article/detail?fid=1750463379&efid=7-na06qVPhj9rdjyPJdmng">恢复数据页</a></p></li><li><p><a href="https://www.cnblogs.com/chenpingzhao/p/5107480.html">【mysql】关于checkpoint机制</a></p></li></ul><blockquote><p><strong>一句话概括</strong>：mysql的checkpoint做的事情：将缓存池中的脏数据刷写到磁盘，更新redo log中的checkpoint信息。</p></blockquote><img src="/2023/08/16/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/image-20230816233304276.png" alt="image-20230816233304276" style="zoom: 67%;"><img src="/2023/08/16/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/image-20230816233339173.png" alt="image-20230816233339173" style="zoom:67%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓SMS与Vold通信机制</title>
    <link href="/2023/08/13/%E5%AE%89%E5%8D%93SMS%E4%B8%8EVold%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/08/13/%E5%AE%89%E5%8D%93SMS%E4%B8%8EVold%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓SMS与Vold通信机制"><a href="#安卓SMS与Vold通信机制" class="headerlink" title="安卓SMS与Vold通信机制"></a>安卓SMS与Vold通信机制</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/geshifei/article/details/130005917?spm=1001.2014.3001.5506">https://blog.csdn.net/geshifei/article/details/130005917?spm=1001.2014.3001.5506</a></p></blockquote><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h2><p><strong>在安卓源码里面，StorageManagerService有很多地方调用了vold的方法。也就是Frameworks(SMS)调用了许多Native(vold)的方法。</strong></p><blockquote><p>以下便是SMS调用Vold的mount方法</p></blockquote><img src="/2023/08/13/%E5%AE%89%E5%8D%93SMS%E4%B8%8EVold%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/image-20230813211308190.png" alt="image-20230813211308190" style="zoom:50%;"><h2 id="2-SMS与Vold通信"><a href="#2-SMS与Vold通信" class="headerlink" title="2.SMS与Vold通信"></a>2.SMS与Vold通信</h2><p>在架构层面，我们选择从上往下看~</p><h3 id="2-1-SMS的mVold变量"><a href="#2-1-SMS的mVold变量" class="headerlink" title="2.1 SMS的mVold变量"></a>2.1 SMS的mVold变量</h3><p>既然在SMS中都是通过mVold变量连接了Vold和SMS，看一下他的初始化过程</p><img src="/2023/08/13/%E5%AE%89%E5%8D%93SMS%E4%B8%8EVold%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/image-20230813211650941.png" alt="image-20230813211650941" style="zoom: 50%;"><p>1968行获取vold service的IBinder对象。一个Service在启动时会创建一个IBinder对象，其他进程可以通过这个IBinder对象与Service通信。因此，getService()方法返回的是服务的IBinder对象，以便客户端可以通过它与服务进行通信。具体来说，客户端可以使用服务的IBinder对象来调用服务提供的接口方法。</p><p>1985行根据IBinder找到aidl定义的mVold（是一个interface），找到mVold后，就可以调用他实现的方法了，比如mVold.mount。总结就是，找到了vold service就能找到具体的函数实现了，所以现在的问题是vold service在哪、是什么？</p><hr><p>可以发现，在SMS启动的时候就调用了connectVold方法</p><img src="/2023/08/13/%E5%AE%89%E5%8D%93SMS%E4%B8%8EVold%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/image-20230813211806529.png" alt="image-20230813211806529" style="zoom:50%;"><h3 id="2-2-vold的aidl接口定义"><a href="#2-2-vold的aidl接口定义" class="headerlink" title="2.2 vold的aidl接口定义"></a>2.2 vold的aidl接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// system\vold\binder\android\os\IVold.aidl</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IVold</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setListener</span><span class="hljs-params">(IVoldListener listener)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">abortFuse</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitor</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUserAdded</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">int</span> userSerial)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUserRemoved</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUserStarted</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUserStopped</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAppIds</span><span class="hljs-params">(in <span class="hljs-meta">@utf8InCpp</span> String[] packageNames, in <span class="hljs-type">int</span>[] appIds)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSandboxIds</span><span class="hljs-params">(in <span class="hljs-type">int</span>[] appIds, in <span class="hljs-meta">@utf8InCpp</span> String[] sandboxIds)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSecureKeyguardStateChanged</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isShowing)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-meta">@utf8InCpp</span> String diskId, <span class="hljs-type">int</span> partitionType, <span class="hljs-type">int</span> ratio)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">forgetPartition</span><span class="hljs-params">(<span class="hljs-meta">@utf8InCpp</span> String partGuid, <span class="hljs-meta">@utf8InCpp</span> String fsUuid)</span>;<br> <span class="hljs-comment">// ...   </span><br>&#125;<br></code></pre></td></tr></table></figure><p> 这是个aidl文件，Android Interface Definition Language,即Android接口定义语言，aidl文件中会定义很多函数，用于多进程间远程调用。</p><p>aidl文件编译后，生成.java文件，并且会生成一个Stub内部类。我们可以在android编译的out目录搜索IVold$Stub.java，如果没有这个文件，可以搜索IVold$Stub.class，反编译class后得到IVold$Stub.java，IVold$Stub.java文件部分内容如下：【我觉得这里应该是IVold.Stub，可能反编译的时候错了，反编译成了IVold$Stub】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IVold$Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Binder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVold</span> &#123;<br>    ……<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TRANSACTION_mount</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mount</span><span class="hljs-params">(String var1, <span class="hljs-type">int</span> var2, <span class="hljs-type">int</span> var3, IVoldMountCallback var4)</span> <span class="hljs-keyword">throws</span> RemoteException;<br> <br>    ……<br> <br>   <span class="hljs-keyword">public</span> IVold$Stub() &#123;<br>      <span class="hljs-built_in">this</span>.attachInterface(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;android.os.IVold&quot;</span>);<br>   &#125;<br> <br>   <span class="hljs-comment">//这里是关键</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IVold <span class="hljs-title function_">asInterface</span><span class="hljs-params">(IBinder obj)</span> &#123;<br>      <span class="hljs-keyword">if</span>(obj == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-type">IInterface</span> <span class="hljs-variable">iin</span> <span class="hljs-operator">=</span> obj.queryLocalInterface(<span class="hljs-string">&quot;android.os.IVold&quot;</span>);<br>         <span class="hljs-keyword">return</span> (IVold)(iin != <span class="hljs-literal">null</span> &amp;&amp; iin <span class="hljs-keyword">instanceof</span> IVold?(IVold)iin:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj));<br>      &#125;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">asBinder</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>   &#125;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>public abstract class IVold$Stub extends Binder implements IVold</code>定义了一个抽象类IVold$Stub，该抽象类继承自Binder类，同时实现了IVold接口。它的定义中包含了抽象方法，这些方法的具体实现需要在该类的子类中完成</li><li>从IVold$Stub可知，Stub是一个内部类。Stub类会根据AIDL文件中定义的接口自动生成，并实现该接口的方法，同时提供一个静态的asInterface()方法和一个默认的构造方法。**在客户端通过bindService()方法绑定服务时，会通过getService()方法获取到一个Binder对象，通过asInterface()方法将其转换为服务端实现的IMyService<u>接口</u>**。在服务端，Binder对象会通过Stub类的onTransact()方法来处理客户端发送的请求。</li></ul><p>举例来说，A绑定了服务端B的service，那么A可以通过下面方法执行B中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> IVold mVold;<br><span class="hljs-comment">//根据binder找到对应的aidl interface</span><br>mVold = IVold.Stub.asInterface(Binder-x)<br><span class="hljs-comment">//执行服务端方法</span><br>mVold.mount()<br></code></pre></td></tr></table></figure><h3 id="2-3-vold-service是什么"><a href="#2-3-vold-service是什么" class="headerlink" title="2.3 vold service是什么"></a>2.3 vold service是什么</h3><img src="/2023/08/13/%E5%AE%89%E5%8D%93SMS%E4%B8%8EVold%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/1ddbc525e73c4e868f14f74b7ef1af4d.png" alt="img" style="zoom: 67%;"><p>可以看到VoldNativeService.h文件中定义了VoldNativeService类。这个类有很多函数定义，我们重点看getServiceName方法。VoldNativeService.getServiceName返回的就是“vold”，所以VoldNativeService类中的函数就是aidl接口中各个函数的具体实现。比如mVold.mount的具体实现就是VoldNativeService::mount（见VoldNativeService.cpp）。</p><h2 id="3-vold进程的启动和vold-service的注册"><a href="#3-vold进程的启动和vold-service的注册" class="headerlink" title="3.vold进程的启动和vold service的注册"></a>3.vold进程的启动和vold service的注册</h2><p>vold的源头在 &#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.rc，系统开机后会执行这个文件，启动vold进程。</p><img src="/2023/08/13/%E5%AE%89%E5%8D%93SMS%E4%B8%8EVold%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/image-20230813212449709.png" alt="image-20230813212449709" style="zoom: 67%;"><p>当启动vold服务的时候，会走到&#x2F;system&#x2F;vold&#x2F;main.cpp中的main函数中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">ATRACE_BEGIN</span>(<span class="hljs-string">&quot;VoldNativeService::start&quot;</span>);<br>    <span class="hljs-keyword">if</span> (android::vold::VoldNativeService::<span class="hljs-built_in">start</span>() != android::OK) &#123;<br>        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Unable to start VoldNativeService&quot;</span>;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">ATRACE_END</span>();<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>VoldNativeService::start()启动VoldNativeService，并将其注册到ServiceManager中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">VoldNativeService::start</span><span class="hljs-params">()</span> </span>&#123;<br>    IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">disableBackgroundScheduling</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">status_t</span> ret = BinderService&lt;VoldNativeService&gt;::<span class="hljs-built_in">publish</span>();<br>    <span class="hljs-keyword">if</span> (ret != android::OK) &#123;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-function">sp&lt;ProcessState&gt; <span class="hljs-title">ps</span><span class="hljs-params">(ProcessState::self())</span></span>;<br>    ps-&gt;<span class="hljs-built_in">startThreadPool</span>();<br>    ps-&gt;<span class="hljs-built_in">giveThreadPoolName</span>();<br>    <span class="hljs-keyword">return</span> android::OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>BinderService&lt;VoldNativeService&gt;::publish()</code>执行具体的注册操作。</p><img src="/2023/08/13/%E5%AE%89%E5%8D%93SMS%E4%B8%8EVold%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/image-20230813212813803.png" alt="image-20230813212813803" style="zoom: 50%;"><p>根据33行typename SERVICE及 VoldNativeService::start()中122行<code>BinderService&lt;VoldNativeService&gt;::publish()</code>，可以知道SERVICE就是VoldNativeService，所以SERVICE::getServiceName()就是VoldNativeService::getServiceName()。通过第二节第3段【vold service是什么】可知getServiceName()将返回字符串“vold”。总结就是，VoldNativeService以“vold”名称注册到ServiceManager中，VoldNativeService类中实现了很多函数，这些函数就是跨进程调用的具体函数，比如mVold.mount。</p><h2 id="4-mVold-mount是什么"><a href="#4-mVold-mount是什么" class="headerlink" title="4.mVold.mount是什么"></a>4.mVold.mount是什么</h2><p>在SMS中通过ServiceManager.getService(“vold”)获取vold service关联的binder，也就是VoldNativeService了。并且通过mVold &#x3D; IVold.Stub.asInterface(binder)获取binder对象关联的aidl接口，所以mVold.mount就是VoldNativeService中mount函数。</p><img src="/2023/08/13/%E5%AE%89%E5%8D%93SMS%E4%B8%8EVold%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/image-20230813213258027.png" alt="image-20230813213258027" style="zoom: 50%;"><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><img src="/2023/08/13/%E5%AE%89%E5%8D%93SMS%E4%B8%8EVold%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/image-20230813214444039.png" alt="image-20230813214444039" style="zoom:80%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓aidl通信</title>
    <link href="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/"/>
    <url>/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓aidl通信"><a href="#安卓aidl通信" class="headerlink" title="安卓aidl通信"></a>安卓aidl通信</h1><h2 id="1-AIDL简述"><a href="#1-AIDL简述" class="headerlink" title="1.AIDL简述"></a>1.AIDL简述</h2><p>AIDL:Android Interface Definition Language,即Android接口定义语言，用于生成Android不同进程间进行进程通信(IPC)的代码，一般情况下一个进程是无法访问另一个进程的内存的。如果某些情况下仍然需要跨进程访问内存数据，这时候Android系统就要将其对象分解成能够识别的原数据，编写这一组操作的代码是一项繁琐的工作，但是AIDL对底层进行了抽象的封装，简化了跨进程操作。</p><p>AIDL IPC机制是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。</p><p>在Android中跨进程操作的方式不止一种，四大组件中ContentProvider天生就是为跨进程操作而存在的，但是ContentProvider所谓的跨进程操作数据，这些数据不一定是存放在内存中的，如通讯录数据时存放在Sqlite数据库中的。AIDL支持的跨进程操作的数据是要存放在内存中的，AIDL底层实际上也是使用的Binder进行的跨进程操作。</p><h2 id="2-AIDL使用"><a href="#2-AIDL使用" class="headerlink" title="2.AIDL使用"></a>2.AIDL使用</h2><h3 id="2-1-服务端代码"><a href="#2-1-服务端代码" class="headerlink" title="2.1 服务端代码"></a>2.1 服务端代码</h3><ol><li>创建User实体类【注意：如果AIDL文件中使用到了实体类对象，需要进行序列化Parcelable】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Parcelable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">User</span><span class="hljs-params">(Parcel in)</span> &#123;<br>        id = in.readInt();<br>        name = in.readString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Creator</span>&lt;User&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> User <span class="hljs-title function_">createFromParcel</span><span class="hljs-params">(Parcel in)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(in);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> User[] newArray(<span class="hljs-type">int</span> size) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>[size];<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">describeContents</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeToParcel</span><span class="hljs-params">(Parcel parcel, <span class="hljs-type">int</span> i)</span> &#123;<br>        parcel.writeInt(id);<br>        parcel.writeString(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>先创建AIDL文件，右击直接生成</li></ol><img src="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/1.png" style="zoom:80%;"><p>定义<code>User.aidl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// User.aidl</span><br><span class="hljs-keyword">package</span> com.amx.aidlservice;<br><br><span class="hljs-comment">// Declare any non-default types here with import statements</span><br><br>parcelable User;<br></code></pre></td></tr></table></figure><p>定义<code>UserManager.aidl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// UserManager.aidl</span><br><span class="hljs-keyword">package</span> com.amx.aidlservice;<br><br><span class="hljs-keyword">import</span> com.amx.aidlservice.User;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserManager</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(in User user)</span>;<br>    List&lt;User&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：需要导包，引入User对象</p></blockquote><ol start="3"><li>创建服务UserService</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br><br>    <span class="hljs-keyword">private</span> UserManagerImpl mUserManager;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserService</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        mUserManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserManagerImpl</span>();<br>        <span class="hljs-keyword">return</span> mUserManager;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserManagerImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UserManager</span>.Stub&#123;<br><br>        List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            users.add(user);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            <span class="hljs-keyword">return</span> users;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在服务中，实现UserManagerImpl，并且将其作为IBinder对象返回给onBind方法</p></blockquote><ol start="4"><li>在清单文件中进行注册</li></ol><img src="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/2.png" style="zoom:80%;"><h3 id="2-2-客户端代码"><a href="#2-2-客户端代码" class="headerlink" title="2.2 客户端代码"></a>2.2 客户端代码</h3><ol><li>将aidl文件和实体类对象原封不动的拷贝过来【包括包】</li></ol><img src="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/3.png" style="zoom:80%;"><ol start="2"><li>调用服务端服务进行进程间通信</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Button mAddUserBtn;<br>    <span class="hljs-keyword">private</span> Button mQueryUserBtn;<br>    <span class="hljs-keyword">private</span> TextView mUserCount;<br>    <span class="hljs-keyword">private</span> UserManager mUserManager;<br>    <span class="hljs-keyword">private</span> UserConnection mUserConnection;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> mIsBind;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        i = <span class="hljs-number">1</span>;<br>        doBindService();<br>        initView();<br>        setListener();<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBindService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>        intent.setAction(<span class="hljs-string">&quot;com.amx.aidlservice.THIRD_PART&quot;</span>);<br>        intent.addCategory(Intent.CATEGORY_DEFAULT);<br>        intent.setPackage(<span class="hljs-string">&quot;com.amx.aidlservice&quot;</span>);<br><br>        mUserConnection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserConnection</span>();<br>        mIsBind = bindService(intent, mUserConnection, BIND_AUTO_CREATE);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServiceConnection</span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceConnected</span><span class="hljs-params">(ComponentName componentName, IBinder iBinder)</span> &#123;<br>            mUserManager = UserManager.Stub.asInterface(iBinder);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceDisconnected</span><span class="hljs-params">(ComponentName componentName)</span> &#123;<br>            mUserManager = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@SuppressLint(&quot;SetTextI18n&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setListener</span><span class="hljs-params">()</span> &#123;<br>        mAddUserBtn.setOnClickListener(view -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                mUserManager.addUser(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(i,<span class="hljs-string">&quot;安慕嘻&quot;</span> + i++ ));<br>                Toast.makeText(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;添加用户&quot;</span> + <span class="hljs-string">&quot;安慕嘻&quot;</span> + (i) ,Toast.LENGTH_SHORT).show();<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        mQueryUserBtn.setOnClickListener(view -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                mUserCount.setText(<span class="hljs-string">&quot;当前用户数量: &quot;</span>+ mUserManager.getUserList().size());;<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initView</span><span class="hljs-params">()</span> &#123;<br>        mAddUserBtn = findViewById(R.id.addUserBtn);<br>        mQueryUserBtn = findViewById(R.id.queryUserBtn);<br>        mUserCount = findViewById(R.id.countTv);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>        <span class="hljs-keyword">if</span>(mIsBind &amp;&amp; mUserConnection != <span class="hljs-literal">null</span>)&#123;<br>            unbindService(mUserConnection);<br>            mIsBind = <span class="hljs-literal">false</span>;<br>            mUserConnection = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>在客户端我们通过bindService拿到系统服务端的IBinder对象（mUserManager），然后就像同进程调用自身方法一样调用它在服务端重写的方法</p></blockquote><img src="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/4.png" style="zoom:80%;"><p>我们添加用户后，查询用户数量后会变多</p><img src="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/5.png" style="zoom:80%;"><h2 id="3-AIDL原理"><a href="#3-AIDL原理" class="headerlink" title="3.AIDL原理"></a>3.AIDL原理</h2><p>首先我们从客户端拿到IBinder对象开始</p><img src="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/6.png" style="zoom: 67%;"><p>我们发现到了AIDL生成的UserManger中</p><img src="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/7.png" style="zoom: 67%;"><p>会生成一个Proxy对象，这个也相当于我们的接口对象mUserManager</p><p>现在我们拿到了mUserManger对象，我们想要在客户端调用它的方法</p><img src="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/8.png" style="zoom: 67%;"><p>那么实际上就是调用了Proxy的addUser方法</p><img src="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/9.png" style="zoom: 67%;"><p>我们发现它通过<code>transact</code>方法去访问了服务端，这个时候我们走到了Binder机制里面，由Binder机制通过<code>onTransac</code>t找到我们的服务端</p><img src="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/10.png" style="zoom: 67%;"><p>而这个this就是我们服务端在Service创建的子类UserManegerImpl，因为UserManegerImpl继承了AIDL生成的UserManeger接口中的Stub【在源码中是一个静态抽象类】</p><img src="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/11.png" style="zoom: 67%;"><p>而Stub中的没有实现this.addUser方法</p><img src="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/12.png" style="zoom: 67%;"><p>而真正实现的是我们自己的子类UserMangerImpl重写后的addUser方法</p><p><strong>到这里我们全部清楚了，在客户端调用的addUser方法，其实就是调用了服务端重写的addUser方法</strong></p><img src="/2023/08/13/%E5%AE%89%E5%8D%93aidl%E9%80%9A%E4%BF%A1/13.png" style="zoom:80%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓tombstone机制</title>
    <link href="/2023/08/10/%E5%AE%89%E5%8D%93tombstone%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/08/10/%E5%AE%89%E5%8D%93tombstone%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓tombstone机制"><a href="#安卓tombstone机制" class="headerlink" title="安卓tombstone机制"></a>安卓tombstone机制</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/weixin_36389889/article/details/128814353">https://blog.csdn.net/weixin_36389889/article/details/128814353</a></p></blockquote><h2 id="1-tombstone定义"><a href="#1-tombstone定义" class="headerlink" title="1.tombstone定义"></a>1.tombstone定义</h2><p>墓碑。当一个动态库（native 程序）开始执行时，系统会注册一些连接到 debuggerd 的 signal handlers，当系统 crash 的时候，会保存一个 tombstone 文件到&#x2F;data&#x2F;tombstones目录下（Logcat中也会有相应的信息），文件的确就像墓碑一样记录了死亡了的进程的基本信息（例如进程的进程号，线程号），死亡的地址（在哪个地址上发生了 Crash），死亡时的现场是什么样的（记录了一系列的堆栈调用信息）等等。 </p><h2 id="2-tombstone日志分析定位"><a href="#2-tombstone日志分析定位" class="headerlink" title="2.tombstone日志分析定位"></a>2.tombstone日志分析定位</h2><p>Tomestone样例（已隐去敏感信息）：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c#">*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***<br>Build fingerprint: <span class="hljs-string">&#x27;xxx&#x27;</span><br>Revision: <span class="hljs-string">&#x27;0&#x27;</span><br>ABI: <span class="hljs-string">&#x27;arm64&#x27;</span><br>Timestamp: <span class="hljs-number">2023</span><span class="hljs-number">-01</span><span class="hljs-number">-29</span> <span class="hljs-number">02</span>:<span class="hljs-number">27</span>:<span class="hljs-number">42.367624270</span>+<span class="hljs-number">0800</span><br>Process uptime: <span class="hljs-number">19</span>s<br>Cmdline: /vendor/bin/android.hardware.automotive.evs@<span class="hljs-number">1.0</span>-ais<br>pid: <span class="hljs-number">504</span>, tid: <span class="hljs-number">504</span>, name: evs@<span class="hljs-number">1.0</span>-ais  &gt;&gt;&gt; /vendor/bin/android.hardware.automotive.evs@<span class="hljs-number">1.0</span>-ais &lt;&lt;&lt;<br>uid: <span class="hljs-number">1000</span><br>signal <span class="hljs-number">11</span> (SIGSEGV), code <span class="hljs-number">1</span> (SEGV_MAPERR), fault addr <span class="hljs-number">0x702f3421d4</span><br>    x0  <span class="hljs-number">00000000f</span>fffffea  x1  <span class="hljs-number">0000000000000080</span>  x2  <span class="hljs-number">0000007f</span>d0ccb200  x3  <span class="hljs-number">0000000000000080</span><br>    x4  <span class="hljs-number">000000000000000</span>c  x5  <span class="hljs-number">00000000f</span>ffffff8  x6  <span class="hljs-number">0000000000000017</span>  x7  <span class="hljs-number">0000000000000438</span><br>    x8  <span class="hljs-number">000000702f</span>33b010  x9  <span class="hljs-number">00000000000071</span>c4  x10 <span class="hljs-number">0000000000000780</span>  x11 <span class="hljs-number">0000000000000002</span><br>    x12 <span class="hljs-number">0000007f</span>d0ccb5e8  x13 <span class="hljs-number">00000070</span>abb2af8c  x14 <span class="hljs-number">0000007f</span>d0ccb548  x15 <span class="hljs-number">0000007f</span>d0ccb438<br>    x16 <span class="hljs-number">00000070</span>ab8642b0  x17 <span class="hljs-number">00000070</span>ab8619d4  x18 <span class="hljs-number">0000007138</span>dec000  x19 <span class="hljs-number">0000007f</span>d0ccb200<br>    x20 <span class="hljs-number">000000702f</span>33b000  x21 <span class="hljs-number">0000007137</span>ecc000  x22 <span class="hljs-number">000000702f</span>340c34  x23 <span class="hljs-number">00000000000001f</span>b<br>    x24 b400007137aa1560  x25 b400007137aa87b0  x26 <span class="hljs-number">0000000000000000</span>  x27 <span class="hljs-number">0000007137</span>ecc000<br>    x28 <span class="hljs-number">0000000000000000</span>  x29 <span class="hljs-number">0000007f</span>d0ccb190<br>    lr  <span class="hljs-number">00000070</span>ab7f8ddc  sp  <span class="hljs-number">0000007f</span>d0cca680  pc  <span class="hljs-number">00000070</span>ab861bf4  pst <span class="hljs-number">0000000060000000</span><br>backtrace:<br>      <span class="hljs-meta">#00 pc 0000000000002bf4  /vendor/lib64/libqdMetaData.so (getMetaDataVa+544) (BuildId: 5f8f611fe24daad279605726e2140611)</span><br>      <span class="hljs-meta">#01 pc 0000000000006dd8  /vendor/lib64/libgrallocutils.so (gralloc::GetCustomDimensions(private_handle_t*, int*, int*)+76) (BuildId: 95f208c6056517672d1fa2c0ce46c9a4)</span><br>      <span class="hljs-meta">#02 pc 000000000000d870  /vendor/lib64/hw/android.hardware.graphics.mapper@4.0-impl-qti-display.so (vendor::qti::hardware::display::mapperextensions::V1_1::implementation::QtiMapperExtensions::getCustomDimensions(void*, std::__1::function&lt;void (vendor::qti::hardware::display::mapperextensions::V1_0::Error, int, int)&gt;)+104) (BuildId: 496c1d7446fe4c37158d156b97488608)</span><br>      <span class="hljs-meta">#03 pc 0000000000017024  /vendor/lib64/vendor.qti.hardware.display.mapperextensions@1.1.so (vendor::qti::hardware::display::mapperextensions::V1_1::BsQtiMapperExtensions::getCustomDimensions(void*, std::__1::function&lt;void (vendor::qti::hardware::display::mapperextensions::V1_0::Error, int, int)&gt;)+152) (BuildId: 86b03cacb633046f5001ffbd4d19c6a6)</span><br>      <span class="hljs-meta">#04 pc 00000000000104ec  /vendor/lib64/egl/eglSubDriverAndroid.so (BuildId: 5b97660bec7ac290203b0cbf9d44710a)</span><br>      <span class="hljs-meta">#05 pc 00000000000122fc  /vendor/lib64/egl/eglSubDriverAndroid.so (BuildId: 5b97660bec7ac290203b0cbf9d44710a)</span><br>      <span class="hljs-meta">#06 pc 0000000000013fb4  /vendor/lib64/egl/eglSubDriverAndroid.so (BuildId: 5b97660bec7ac290203b0cbf9d44710a)</span><br>      <span class="hljs-meta">#07 pc 00000000002bebd0  /vendor/lib64/egl/libGLESv2_adreno.so (BuildId: b5a32c58a407e9d5153c7ed114659e3f)</span><br>      <span class="hljs-meta">#08 pc 00000000001c3fd8  /vendor/lib64/egl/libGLESv2_adreno.so (BuildId: b5a32c58a407e9d5153c7ed114659e3f)</span><br>      <span class="hljs-meta">#09 pc 00000000001c5870  /vendor/lib64/egl/libGLESv2_adreno.so (BuildId: b5a32c58a407e9d5153c7ed114659e3f)</span><br>      <span class="hljs-meta">#10 pc 00000000002077d4  /vendor/lib64/egl/libGLESv2_adreno.so (BuildId: b5a32c58a407e9d5153c7ed114659e3f)</span><br>      <span class="hljs-meta">#11 pc 0000000000011258  /vendor/bin/android.hardware.automotive.evs@1.0-ais (GlWrapper::renderImageToScreen()+80) (BuildId: 22b5c23192874a857be557ff2bacc8e8)</span><br>      <span class="hljs-meta">#12 pc 0000000000022638  /vendor/bin/android.hardware.automotive.evs@1.0-ais (android::hardware::automotive::evs::V1_0::implementation::EvsGlDisplay::returnTargetBufferForDisplay(android::hardware::automotive::evs::V1_0::BufferDesc const&amp;)+204) (BuildId: 22b5c23192874a857be557ff2bacc8e8)</span><br>      <span class="hljs-meta">#13 pc 000000000002d598  /apex/com.android.vndk.v31/lib64/android.hardware.automotive.evs@1.0.so (android::hardware::automotive::evs::V1_0::BnHwEvsDisplay::_hidl_returnTargetBufferForDisplay(android::hidl::base::V1_0::BnHwBase*, android::hardware::Parcel const&amp;, android::hardware::Parcel*, std::__1::function&lt;void (android::hardware::Parcel&amp;)&gt;)+220) (BuildId: e989defcc1a8408c61f50ee43d898657)</span><br>      <span class="hljs-meta">#14 pc 000000000002da30  /apex/com.android.vndk.v31/lib64/android.hardware.automotive.evs@1.0.so (android::hardware::automotive::evs::V1_0::BnHwEvsDisplay::onTransact(unsigned int, android::hardware::Parcel const&amp;, android::hardware::Parcel*, unsigned int, std::__1::function&lt;void (android::hardware::Parcel&amp;)&gt;)+404) (BuildId: e989defcc1a8408c61f50ee43d898657)</span><br>      <span class="hljs-meta">#15 pc 00000000000768a4  /apex/com.android.vndk.v31/lib64/libhidlbase.so (android::hardware::BHwBinder::transact(unsigned int, android::hardware::Parcel const&amp;, android::hardware::Parcel*, unsigned int, std::__1::function&lt;void (android::hardware::Parcel&amp;)&gt;)+92) (BuildId: 1c806a0c7106677e8355f6be1abbdb9b)</span><br>      <span class="hljs-meta">#16 pc 0000000000074eb8  /apex/com.android.vndk.v31/lib64/libhidlbase.so (android::hardware::IPCThreadState::getAndExecuteCommand()+1104) (BuildId: 1c806a0c7106677e8355f6be1abbdb9b)</span><br>      <span class="hljs-meta">#17 pc 0000000000074988  /apex/com.android.vndk.v31/lib64/libhidlbase.so (android::hardware::IPCThreadState::joinThreadPool(bool)+96) (BuildId: 1c806a0c7106677e8355f6be1abbdb9b)</span><br>      <span class="hljs-meta">#18 pc 00000000000121d0  /vendor/bin/android.hardware.automotive.evs@1.0-ais (main+576) (BuildId: 22b5c23192874a857be557ff2bacc8e8)</span><br>      <span class="hljs-meta">#19 pc 00000000000822d4  /apex/com.android.runtime/lib64/bionic/libc.so (__libc_init+96) (BuildId: a01cf07b6a9f32a66547d7774501375f)</span><br>...<br>...<br>...<br></code></pre></td></tr></table></figure><ul><li>发生native crash的时间，有了这个时间可以对照logcat的日志，找到准确的crash位置。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Timestamp: 2023-01-29 02:27:42.367624270+0800<br></code></pre></td></tr></table></figure><ul><li>出错的动态库为：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Cmdline: /vendor/bin/android.hardware.automotive.evs@1.0-ais<br></code></pre></td></tr></table></figure><ul><li>然后，看backtrace，顾名思义，出错栈。从上到下就是调用栈的逆序，可以看到赘述到<a href="mailto:&#101;&#x76;&#x73;&#64;&#49;&#46;&#x30;&#45;&#x61;&#x69;&#x73;">&#101;&#x76;&#x73;&#64;&#49;&#46;&#x30;&#45;&#x61;&#x69;&#x73;</a>这个动态库的GlWrapper::renderImageToScreen()函数：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#11 pc 0000000000011258  /vendor/bin/android.hardware.automotive.evs@1.0-ais (GlWrapper::renderImageToScreen()+80) (BuildId: 22b5c23192874a857be557ff2bacc8e8)</span><br></code></pre></td></tr></table></figure><p>范围很小了吧，但仍不够，我们想定位到具体哪一行，后面+80并不是行数，我们只关注pc后面的地址0000000000011258。那么就开始使用addr2line工具。addr2line工具在linux是就有，所以在真机上把&#x2F;vendor&#x2F;bin&#x2F;<a href="mailto:&#97;&#110;&#x64;&#x72;&#x6f;&#x69;&#100;&#x2e;&#104;&#97;&#x72;&#100;&#119;&#97;&#114;&#101;&#x2e;&#97;&#117;&#x74;&#x6f;&#109;&#111;&#x74;&#x69;&#x76;&#101;&#46;&#x65;&#118;&#x73;&#x40;&#49;&#x2e;&#x30;&#x2d;&#97;&#x69;&#115;">&#97;&#110;&#x64;&#x72;&#x6f;&#x69;&#100;&#x2e;&#104;&#97;&#x72;&#100;&#119;&#97;&#114;&#101;&#x2e;&#97;&#117;&#x74;&#x6f;&#109;&#111;&#x74;&#x69;&#x76;&#101;&#46;&#x65;&#118;&#x73;&#x40;&#49;&#x2e;&#x30;&#x2d;&#97;&#x69;&#115;</a>拉出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb pull /vendor/bin/android.hardware.automotive.evs@1.0-ais<br></code></pre></td></tr></table></figure><p>然后放到linux系统上，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">addr2line 0000000000011258 -e android.hardware.automotive.evs@1.0-ais -f -C -s<br></code></pre></td></tr></table></figure><p>如果出现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">GlWrapper::renderImageToScreen()<br>??:?<br></code></pre></td></tr></table></figure><p>说明编译时符号表被优化掉了，那么重新编译这个动态库，然后再out目录下找生成的带符号表的文件，路径类似：<code>out/target/product/xxx/symbols/vendor/bin</code></p><p>关键就是<strong>symbols</strong>这个文件夹，里面存放的是未被优化符号表的文件。</p><p>在这下面执行同样的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">addr2line 0000000000011258 -e android.hardware.automotive.evs@1.0-ais -f -C -s<br></code></pre></td></tr></table></figure><p>获得：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">GlWrapper::<span class="hljs-built_in">renderImageToScreen</span>()<br>GlWrapper.cpp:<span class="hljs-number">441</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【Android】如何分析 ANR 日志</title>
    <link href="/2023/08/10/%E3%80%90Android%E3%80%91%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-ANR-%E6%97%A5%E5%BF%97/"/>
    <url>/2023/08/10/%E3%80%90Android%E3%80%91%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-ANR-%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="【Android】如何分析-ANR-日志"><a href="#【Android】如何分析-ANR-日志" class="headerlink" title="【Android】如何分析 ANR 日志"></a>【Android】如何分析 ANR 日志</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/yang553566463/article/details/125335624">https://blog.csdn.net/yang553566463/article/details/125335624</a></p></blockquote><h2 id="导致ANR的原因"><a href="#导致ANR的原因" class="headerlink" title="导致ANR的原因"></a>导致ANR的原因</h2><p><strong>应用层导致的ANR（耗时操作）</strong>、</p><ul><li>主线程耗时长</li><li>主线程方法执行了死循环</li><li>主线程等待子线程释放锁时间过长</li><li>应用内存紧张，当一个应用长期处于内存紧张状态，会导致频繁内存交换，进而导致应用的一些操作超时</li></ul><p><strong>系统层导致的ANR</strong></p><ul><li>CPU被抢占：一般来说，前台在玩游戏，可能会导致你的后台广播被抢占CPU</li><li>系统服务无法及时响应：比如获取系统联系人等，系统的服务都是Binder机制，服务能力也是有限的，有可能系统服务长时间不响应导致ANR</li><li>其他应用占用的大量内存</li></ul><h2 id="导出并查看ANR日志"><a href="#导出并查看ANR日志" class="headerlink" title="导出并查看ANR日志"></a>导出并查看ANR日志</h2><p><strong>方法一</strong></p><p>当系统出现 ANR 时，设备会自动将 ANR 日志输出到 <code>/data/anr/</code> 目录下，如下所示：</p><img src="/2023/08/10/%E3%80%90Android%E3%80%91%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-ANR-%E6%97%A5%E5%BF%97/8eedb9c9d48a49a4ac5adf3c6c2b495e.png" alt="在这里插入图片描述" style="zoom:80%;"><p>对于这些文件，我们直接双击在 <a href="https://so.csdn.net/so/search?q=Android&spm=1001.2101.3001.7020">Android</a> Studio 上打开即可。</p><p><strong>方法二</strong></p><p>执行命令：</p><blockquote><p>adb bugreport D:\mybug\bugrep.zip</p></blockquote><p>可以导出设备所有 bug 日志，执行命令后，在指定文件夹内得到一个 zip 文件，将文件解压后打开，文件目录如下所示：</p><img src="/2023/08/10/%E3%80%90Android%E3%80%91%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-ANR-%E6%97%A5%E5%BF%97/5a6ef7aa45dd499d85e6e3ba29389908.png" alt="在这里插入图片描述" style="zoom:80%;"><p>其中，设备的 anr 日志会保存在该路径下：<code>D:\mybug\bugrep\FS\data\anr</code>，如图：</p><img src="/2023/08/10/%E3%80%90Android%E3%80%91%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-ANR-%E6%97%A5%E5%BF%97/14f45c0d8a754cc782f1cb203121b7d3.png" alt="在这里插入图片描述" style="zoom:80%;"><p>另外，该文件 <code>D:\mybug\bugrep\bugreport-device.200216.002-2022-06-16-15-30-10.txt</code> 内也有有 anr 日志的打印，我们可以通过以下关键词搜索该文件的一些异常信息，如：</p><blockquote><p>“main” prio&#x3D;：搜索 anr 相关信息【应用层导致的ANR一般是主线程耗时长】</p><p>beginning of crash：搜索 crash 相关信息</p><p>CPU usage from：搜索 cpu 使用信息</p></blockquote><h2 id="如何分析ANR日志"><a href="#如何分析ANR日志" class="headerlink" title="如何分析ANR日志"></a>如何分析ANR日志</h2><p>一个 ANR 日志，会包含当前设备中所有进程的使用情况，每个进程开头都会</p><p>以 <code>----- pid 16808 at date -----</code> 来开头，</p><p>以 <code>----- end 16808 -----</code> 来结尾，</p><p>如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">----- pid 16808 at 2022-06-16 16:56:04 -----<br>Cmd line: com.example.demoproject<br>...<br>...<br>...<br>----- end 16808 -----<br></code></pre></td></tr></table></figure><p>另外，每个进程日志中都会有一些进程<strong>内存相关</strong>的信息，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">----- pid 16808 at 2022-06-16 16:56:04 -----<br>Cmd line: com.example.demoproject<br>...<br>...<br>Total number of allocations 59378 // 进程创建到现在一共创建了多少对象<br>Total bytes allocated 8815KB // 进程创建到现在一共申请了多少内存<br>Total bytes freed 6847KB // 进程创建到现在一共释放了多少内存<br>Free memory 23MB // 空闲内存（可用内存）<br>Free memory until GC 23MB // GC前的空闲内存<br>Free memory until OOME 190MB // OOM之前的可用内存，当这个值很小的时候，已经处于内存紧张状态，应用可能占用了过多的内存<br>Total memory 25MB // 当前总内存（已用+可用）<br>Max memory 192MB // 进程最多能申请的内存 <br>...<br>----- end 16808 -----<br></code></pre></td></tr></table></figure><p>另外，每个进程日志中都会有进程堆栈信息，堆栈信息非常重要，它展示了发生 ANR 的进程当前的<strong>所有线程</strong>状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs bash">----- pid 16808 at 2022-06-16 16:56:04 -----<br>... <br><span class="hljs-built_in">suspend</span> all histogram:  Sum: 114us 99% C.I. 2us-27us Avg: 12.666us Max: 27us<br>DALVIK THREADS (14):<br><span class="hljs-string">&quot;Signal Catcher&quot;</span> daemon prio=5 tid=7 Runnable<br>  | group=<span class="hljs-string">&quot;system&quot;</span> sCount=0 dsCount=0 flags=0 obj=0x182c0298 self=0x7914b9c000<br>  | sysTid=16819 <span class="hljs-built_in">nice</span>=0 cgrp=default <span class="hljs-built_in">sched</span>=0/0 handle=0x791a98fd50<br>  | state=R schedstat=( 28572293 3522448 11 ) utm=1 stm=1 core=0 HZ=100<br>  | stack=0x791a899000-0x791a89b000 stackSize=991KB<br>  | held mutexes= <span class="hljs-string">&quot;mutator lock&quot;</span>(shared held)<br>  native: <span class="hljs-comment">#00 pc 00000000004108e8  /apex/com.android.runtime/lib64/libart.so (art::DumpNativeStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, int, BacktraceMap*, char const*, art::ArtMethod*, void*, bool)+140)</span><br>  native: <span class="hljs-comment">#01 pc 00000000004f8040  /apex/com.android.runtime/lib64/libart.so (art::Thread::DumpStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, bool, BacktraceMap*, bool) const+512)</span><br>  native: <span class="hljs-comment">#02 pc 000000000051297c  /apex/com.android.runtime/lib64/libart.so (art::DumpCheckpoint::Run(art::Thread*)+828)</span><br>  native: <span class="hljs-comment">#03 pc 000000000050b7a0  /apex/com.android.runtime/lib64/libart.so (art::ThreadList::RunCheckpoint(art::Closure*, art::Closure*)+456)</span><br>  native: <span class="hljs-comment">#04 pc 000000000050ac84  /apex/com.android.runtime/lib64/libart.so (art::ThreadList::Dump(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, bool)+1964)</span><br>  native: <span class="hljs-comment">#05 pc 000000000050a364  /apex/com.android.runtime/lib64/libart.so (art::ThreadList::DumpForSigQuit(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;)+844)</span><br>  native: <span class="hljs-comment">#06 pc 00000000004c5778  /apex/com.android.runtime/lib64/libart.so (art::Runtime::DumpForSigQuit(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;)+200)</span><br>  native: <span class="hljs-comment">#07 pc 00000000004d9bb0  /apex/com.android.runtime/lib64/libart.so (art::SignalCatcher::HandleSigQuit()+1352)</span><br>  native: <span class="hljs-comment">#08 pc 00000000004d8c5c  /apex/com.android.runtime/lib64/libart.so (art::SignalCatcher::Run(void*)+252)</span><br>  native: <span class="hljs-comment">#09 pc 00000000000e68a0  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start(void*)+36)</span><br>  native: <span class="hljs-comment">#10 pc 0000000000084b6c  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+64)</span><br>  (no managed stack frames)<br><br><span class="hljs-string">&quot;main&quot;</span> prio=5 tid=1 Blocked<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=1 dsCount=0 flags=1 obj=0x72e0ee78 self=0x79aafbcc00<br>  | sysTid=16808 <span class="hljs-built_in">nice</span>=-10 cgrp=default <span class="hljs-built_in">sched</span>=0/0 handle=0x79ac524ed0<br>  | state=S schedstat=( 1140726262 41301458 368 ) utm=94 stm=20 core=0 HZ=100<br>  | stack=0x7fe35ed000-0x7fe35ef000 stackSize=8192KB<br>  | held mutexes=<br>  at com.example.demoproject.view.MainActivity.doSomething(MainActivity.kt:51)<br>  - waiting to lock &lt;0x02250ad8&gt; (a com.example.demoproject.view.MainActivity) held by thread 18<br>  at com.example.demoproject.view.MainActivity.click2(MainActivity.kt:36)<br>  at java.lang.reflect.Method.invoke(Native method)<br>  at androidx.appcompat.app.AppCompatViewInflater<span class="hljs-variable">$DeclaredOnClickListener</span>.onClick(AppCompatViewInflater.java:441)<br>  at android.view.View.performClick(View.java:7259)<br>  at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1194)<br>  at android.view.View.performClickInternal(View.java:7236)<br>  at android.view.View.access<span class="hljs-variable">$3600</span>(View.java:801)<br>  at android.view.View<span class="hljs-variable">$PerformClick</span>.run(View.java:27896)<br>  at android.os.Handler.handleCallback(Handler.java:883)<br>  at android.os.Handler.dispatchMessage(Handler.java:100)<br>  at android.os.Looper.loop(Looper.java:214)<br>  at android.app.ActivityThread.main(ActivityThread.java:7397)<br>  at java.lang.reflect.Method.invoke(Native method)<br>  at com.android.internal.os.RuntimeInit<span class="hljs-variable">$MethodAndArgsCaller</span>.run(RuntimeInit.java:492)<br>  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:935)   <br>      <br><span class="hljs-string">&quot;Jit thread pool worker thread 0&quot;</span> daemon prio=5 tid=2 Native<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=1 dsCount=0 flags=1 obj=0x182c0220 self=0x7919600000<br>  | sysTid=16814 <span class="hljs-built_in">nice</span>=0 cgrp=default <span class="hljs-built_in">sched</span>=0/0 handle=0x791aa94d40<br>  | state=S schedstat=( 44810570 11604064 76 ) utm=4 stm=0 core=0 HZ=100<br>  | stack=0x791a996000-0x791a998000 stackSize=1023KB<br>  | held mutexes=<br>  kernel: (couldn<span class="hljs-string">&#x27;t read /proc/self/task/16814/stack)</span><br><span class="hljs-string">  native: #00 pc 000000000008033c  /apex/com.android.runtime/lib64/bionic/libc.so (syscall+28)</span><br><span class="hljs-string">  native: #01 pc 000000000014b1f4  /apex/com.android.runtime/lib64/libart.so (art::ConditionVariable::WaitHoldingLocks(art::Thread*)+148)</span><br><span class="hljs-string">  native: #02 pc 00000000005143dc  /apex/com.android.runtime/lib64/libart.so (art::ThreadPool::GetTask(art::Thread*)+256)</span><br><span class="hljs-string">  native: #03 pc 0000000000513768  /apex/com.android.runtime/lib64/libart.so (art::ThreadPoolWorker::Run()+144)</span><br><span class="hljs-string">  native: #04 pc 0000000000513228  /apex/com.android.runtime/lib64/libart.so (art::ThreadPoolWorker::Callback(void*)+148)</span><br><span class="hljs-string">  native: #05 pc 00000000000e68a0  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start(void*)+36)</span><br><span class="hljs-string">  native: #06 pc 0000000000084b6c  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+64)</span><br><span class="hljs-string">  (no managed stack frames)</span><br><span class="hljs-string">...</span><br><span class="hljs-string">----- end 16808 -----</span><br></code></pre></td></tr></table></figure><p>如上截图中，有三个线程，一个是 Signal Catcher 线程，一个是 main 线程，一个是 Jit thread pool worker thread 0，他们的线程状态分别是 Runnable 、 blocked 和 native 状态。</p><p>而在 Java 中，线程状态有6种，如下所示：</p><ul><li>NEW - 创建状态</li><li>RUNNABLE - 就绪或运行状态</li><li>BLOCKED - 阻塞状态</li><li>WATING - 等待状态</li><li>TIMED_WAITING - 定时等待状态</li><li>TERMINATED - 终止状态</li></ul><p>那么，上述日志中的 <code>native</code> 状态是什么呢？</p><p>其实该状态是 <code>cpp</code> 代码中定义的线程状态，他跟 <code>java</code> 定义的线程状态关系如下：</p><img src="/2023/08/10/%E3%80%90Android%E3%80%91%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-ANR-%E6%97%A5%E5%BF%97/21420c32c57e447bad14cb690bbf254c.png" alt="在这里插入图片描述" style="zoom: 67%;"><img src="/2023/08/10/%E3%80%90Android%E3%80%91%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-ANR-%E6%97%A5%E5%BF%97/image-20230810214928410.png" alt="image-20230810214928410" style="zoom: 67%;"><p>由上可知，native 状态对应的 java 线程状态是 runnable 状态。</p><p>堆栈信息是我们分析ANR的第一个重要的信息，一般来说：</p><ul><li>主线程处于 BLOCK &#x2F; WAITING &#x2F; TIMEWAITING 状态，基本上是函数阻塞导致的 anr</li><li>若主线程无异常，则应该排查 CPU 负载和内存环境等其他因素</li></ul><p>另外，在 anr 日志中，还有一些常见参数，他们的含义如下：</p><ul><li>group：线程所处的线程组</li><li>sCount：线程被正常挂起的次数</li><li>dsCount：线程因调试而挂起次数</li><li>nice：线程的调度优先级</li><li>utm：线程在用户态中调度时间值</li><li>stm：线程在内核态中的调度时间值</li><li>core：最后执行这个线程的CPU核序号</li></ul><h2 id="ANR案例分析"><a href="#ANR案例分析" class="headerlink" title="ANR案例分析"></a>ANR案例分析</h2><h3 id="案例一-、Slepping-anr"><a href="#案例一-、Slepping-anr" class="headerlink" title="案例一 、Slepping anr"></a>案例一 、Slepping anr</h3><p>MainActivity 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : AppCompatActivity() &#123;<br>    <br>    override fun <span class="hljs-title function_">onCreate</span><span class="hljs-params">(savedInstanceState: Bundle?)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 点击睡眠 10s</span><br><span class="hljs-comment">     */</span><br>    fun <span class="hljs-title function_">clickToSleep</span><span class="hljs-params">(view: View)</span> &#123;<br>        Thread.sleep(<span class="hljs-number">10_000</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当点击按钮睡眠 10s 后，我们左滑或者点击返回键退出 MainActivity（由于主线程正在睡眠，所以此时是无法退出成功的），等待一段时间，系统将会弹出 ANR 弹窗。</p><p>我们导出 ANR 日志并打开：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;main&quot;</span> prio=5 tid=1 Sleeping<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=1 dsCount=0 flags=1 obj=0x72e0ee78 self=0x79aafbcc00<br>  | sysTid=16356 <span class="hljs-built_in">nice</span>=-10 cgrp=default <span class="hljs-built_in">sched</span>=0/0 handle=0x79ac524ed0<br>  | state=S schedstat=( 1075827038 33414740 291 ) utm=93 stm=14 core=2 HZ=100<br>  | stack=0x7fe35ed000-0x7fe35ef000 stackSize=8192KB<br>  | held mutexes=<br>  at java.lang.Thread.<span class="hljs-built_in">sleep</span>(Native method)<br>  - sleeping on &lt;0x04fbafa5&gt; (a java.lang.Object)<br>  at java.lang.Thread.<span class="hljs-built_in">sleep</span>(Thread.java:440)<br>  - locked &lt;0x04fbafa5&gt; (a java.lang.Object)<br>  at java.lang.Thread.<span class="hljs-built_in">sleep</span>(Thread.java:356)<br>  at com.example.demoproject.view.MainActivity.clickToSleep(MainActivity.kt:57)<br>  at java.lang.reflect.Method.invoke(Native method)<br>  at androidx.appcompat.app.AppCompatViewInflater<span class="hljs-variable">$DeclaredOnClickListener</span>.onClick(AppCompatViewInflater.java:441)<br>  at android.view.View.performClick(View.java:7259)<br>  at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1194)<br>  at android.view.View.performClickInternal(View.java:7236)<br>  at android.view.View.access<span class="hljs-variable">$3600</span>(View.java:801)<br>  at android.view.View<span class="hljs-variable">$PerformClick</span>.run(View.java:27896)<br>  at android.os.Handler.handleCallback(Handler.java:883)<br>  at android.os.Handler.dispatchMessage(Handler.java:100)<br>  at android.os.Looper.loop(Looper.java:214)<br>  at android.app.ActivityThread.main(ActivityThread.java:7397)<br>  at java.lang.reflect.Method.invoke(Native method)<br>  at com.android.internal.os.RuntimeInit<span class="hljs-variable">$MethodAndArgsCaller</span>.run(RuntimeInit.java:492)<br>  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:935)<br></code></pre></td></tr></table></figure><p>从堆栈信息中也很容易发现，在执行到 <code>MainActivity.clickToSleep</code> 方法时，线程进行了睡眠，最终导致 anr。</p><h3 id="案例二、Blocked-anr"><a href="#案例二、Blocked-anr" class="headerlink" title="案例二、Blocked anr"></a>案例二、Blocked anr</h3><p>MainActivity 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : AppCompatActivity() &#123;<br><br>    override fun <span class="hljs-title function_">onCreate</span><span class="hljs-params">(savedInstanceState: Bundle?)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 点击按钮1 - 创建一个子线程并持有当前 Activity 对象锁然后开始睡眠 10s</span><br><span class="hljs-comment">     */</span><br>    fun <span class="hljs-title function_">click1</span><span class="hljs-params">(view: View)</span> &#123;<br>        testBlockThread()<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 点击按钮2 - 在主线程中尝试获取 Activity 对象锁并打印 log</span><br><span class="hljs-comment">     */</span><br>    fun <span class="hljs-title function_">click2</span><span class="hljs-params">(view: View)</span> &#123;<br>        doSomething()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> fun <span class="hljs-title function_">testBlockThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">val</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread &#123;<br>            <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>                Log.i(<span class="hljs-string">&quot;testLog&quot;</span>, <span class="hljs-string">&quot;开始睡眠 10s.. 当前线程名称=$&#123;Thread.currentThread().name&#125; 线程id=$&#123;Thread.currentThread().id&#125;&quot;</span>)<br>                Thread.sleep(<span class="hljs-number">10_000</span>)<br>            &#125;<br>        &#125;<br>        thread.name = <span class="hljs-string">&quot;MyTestBlockThread&quot;</span><br>        thread.start()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> fun <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>            Log.i(<span class="hljs-string">&quot;testLog&quot;</span>, <span class="hljs-string">&quot;doSomething.. 当前线程名称=$&#123;Thread.currentThread().name&#125; 线程id=$&#123;Thread.currentThread().id&#125;&quot;</span>)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当首先点击按钮1时，会创建一个子线程 MyTestBlockThread 并持有当前 Activity 对象锁然后开始睡眠 10s，然后继续点击按钮2，此时主线程将会尝试获取 Activity 对象锁并执行，由于锁正在被子线程 MyTestBlockThread 持有，因此，主线程将会一直被 block 直到子线程释放锁。</p><p>在主线程被 block 期间，我们左滑或者点击返回键退出 MainActivity（由于主线程正在被 block，所以此时是无法退出成功的），等待一段时间，系统将会弹出 ANR 弹窗。</p><p>下面我们导出 ANR 日志并打开：</p><img src="/2023/08/10/%E3%80%90Android%E3%80%91%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-ANR-%E6%97%A5%E5%BF%97/1f89d376cdb446b7a1241b74794f7f22.png" alt="在这里插入图片描述" style="zoom:80%;"><p>可以发现，这里有一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">- waiting to lock &lt;0x02250ad8&gt; (a com.example.demoproject.view.MainActivity) held by thread 18<br></code></pre></td></tr></table></figure><p>其含义就是，主线程正在被 block， 其正在等待 线程18 释放锁，最终因此导致出现了 ANR。</p><p>那么，这个 线程18 是谁呢？我们继续看 anr 日志：</p><img src="/2023/08/10/%E3%80%90Android%E3%80%91%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-ANR-%E6%97%A5%E5%BF%97/2b81b3c4963e4167b5d6305e3bdfa5d2.png" alt="在这里插入图片描述" style="zoom:80%;"><p>在这里，发现这一行日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;MyTestBlockThread&quot;</span> prio=5 tid=18 Sleeping<br></code></pre></td></tr></table></figure><p>其含义就是：线程 <code>MyTestBlockThread</code> 正在 <code>Sleeping</code>，它的 <code>prio=5 tid=18</code>。</p><h3 id="案例三、耗时或死循环方法"><a href="#案例三、耗时或死循环方法" class="headerlink" title="案例三、耗时或死循环方法"></a>案例三、耗时或死循环方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : AppCompatActivity() &#123;<br><br>    override fun <span class="hljs-title function_">onCreate</span><span class="hljs-params">(savedInstanceState: Bundle?)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>    &#125;<br>    <br>    fun <span class="hljs-title function_">click</span><span class="hljs-params">(view: View)</span> &#123;<br>        doSomething()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> fun <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            Log.i(<span class="hljs-string">&quot;testLog&quot;</span>, <span class="hljs-string">&quot;doSomething.. 当前线程名称=$&#123;Thread.currentThread().name&#125; 线程id=$&#123;Thread.currentThread().id&#125;&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们点击按钮时，会在主线程通过一个死循环不断打印 log，因此 doSomething() 方法我们可以认为是一个耗时方法，点击按钮后，我们左滑或者点击返回键退出 MainActivity（由于主线程正在忙碌中，所以此时是无法退出成功的），等待一段时间，系统将会弹出 ANR 弹窗。</p><p>下面我们导出 ANR 日志并打开：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">----- pid 13231 at 2022-06-17 14:23:41 -----<br>Cmd line: com.example.demoproject<br>...<br><span class="hljs-string">&quot;main&quot;</span> prio=5 tid=1 Runnable<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=0 dsCount=0 flags=0 obj=0x72b20e78 self=0x77fe5a6c00<br>  | sysTid=13231 <span class="hljs-built_in">nice</span>=-10 cgrp=default <span class="hljs-built_in">sched</span>=0/0 handle=0x77ffb0eed0<br>  | state=R schedstat=( 31694533124 58819622 723 ) utm=1310 stm=1859 core=5 HZ=100<br>  | stack=0x7fdc2b7000-0x7fdc2b9000 stackSize=8192KB<br>  | held mutexes= <span class="hljs-string">&quot;mutator lock&quot;</span>(shared held)<br>  native: <span class="hljs-comment">#00 pc 00000000004108e8  /apex/com.android.runtime/lib64/libart.so (art::DumpNativeStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, int, BacktraceMap*, char const*, art::ArtMethod*, void*, bool)+140)</span><br>  native: <span class="hljs-comment">#01 pc 00000000004f8040  /apex/com.android.runtime/lib64/libart.so (art::Thread::DumpStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, bool, BacktraceMap*, bool) const+512)</span><br>  native: <span class="hljs-comment">#02 pc 000000000051297c  /apex/com.android.runtime/lib64/libart.so (art::DumpCheckpoint::Run(art::Thread*)+828)</span><br>  native: <span class="hljs-comment">#03 pc 00000000004f8d4c  /apex/com.android.runtime/lib64/libart.so (art::Thread::RunCheckpointFunction()+176)</span><br>  native: <span class="hljs-comment">#04 pc 00000000003713fc  /apex/com.android.runtime/lib64/libart.so (art::(anonymous namespace)::CheckJNI::ReleaseStringCharsInternal(char const*, _JNIEnv*, _jstring*, void const*, bool, bool)+1356)</span><br>  native: <span class="hljs-comment">#05 pc 00000000001507cc  /system/lib64/libandroid_runtime.so (android::android_util_Log_println_native(_JNIEnv*, _jobject*, int, int, _jstring*, _jstring*)+232)</span><br>  at android.util.Log.println_native(Native method)<br>  at android.util.Log.i(Log.java:176)<br>  at com.example.demoproject.view.MainActivity.doSomething(MainActivity.kt:52)<br>  at com.example.demoproject.view.MainActivity.click2(MainActivity.kt:36)<br>  at java.lang.reflect.Method.invoke(Native method)<br>  at androidx.appcompat.app.AppCompatViewInflater<span class="hljs-variable">$DeclaredOnClickListener</span>.onClick(AppCompatViewInflater.java:441)<br>  at android.view.View.performClick(View.java:7259)<br>  at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1194)<br>  at android.view.View.performClickInternal(View.java:7236)<br>  at android.view.View.access<span class="hljs-variable">$3600</span>(View.java:801)<br>  at android.view.View<span class="hljs-variable">$PerformClick</span>.run(View.java:27896)<br>  at android.os.Handler.handleCallback(Handler.java:883)<br>  at android.os.Handler.dispatchMessage(Handler.java:100)<br>  at android.os.Looper.loop(Looper.java:214)<br>  at android.app.ActivityThread.main(ActivityThread.java:7397)<br>  at java.lang.reflect.Method.invoke(Native method)<br>  at com.android.internal.os.RuntimeInit<span class="hljs-variable">$MethodAndArgsCaller</span>.run(RuntimeInit.java:492)<br>  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:935)<br>...<br>----- end 16808 -----<br></code></pre></td></tr></table></figure><p>发现主线程正处于 <code>Runnable</code> 状态，并不是处于空闲状态，堆栈信息中有一行关键日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">at com.example.demoproject.view.MainActivity.doSomething(MainActivity.kt:52)<br></code></pre></td></tr></table></figure><h3 id="案例四、正常情况"><a href="#案例四、正常情况" class="headerlink" title="案例四、正常情况"></a>案例四、正常情况</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;main&quot;</span> prio=<span class="hljs-number">5</span> tid=<span class="hljs-number">1</span> Native<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=<span class="hljs-number">1</span> dsCount=<span class="hljs-number">0</span> flags=<span class="hljs-number">1</span> obj=<span class="hljs-number">0x72e0ee78</span> self=<span class="hljs-number">0x79aafbcc00</span><br>  | sysTid=<span class="hljs-number">1496</span> nice=-<span class="hljs-number">2</span> cgrp=<span class="hljs-keyword">default</span> sched=<span class="hljs-number">0</span>/<span class="hljs-number">0</span> handle=<span class="hljs-number">0x79ac524ed0</span><br>  | state=S schedstat=( <span class="hljs-number">50585681414</span> <span class="hljs-number">30364690662</span> <span class="hljs-number">64096</span> ) utm=<span class="hljs-number">3092</span> stm=<span class="hljs-number">1966</span> core=<span class="hljs-number">2</span> HZ=<span class="hljs-number">100</span><br>  | stack=<span class="hljs-number">0x7fe35ed000</span>-<span class="hljs-number">0x7fe35ef000</span> stackSize=8192KB<br>  | held mutexes=<br>  kernel: (couldn<span class="hljs-string">&#x27;t read /proc/self/task/1496/stack)</span><br><span class="hljs-string">  native: #00 pc 00000000000d0f58  /apex/com.android.runtime/lib64/bionic/libc.so (__epoll_pwait+8)</span><br><span class="hljs-string">  native: #01 pc 00000000000180bc  /system/lib64/libutils.so (android::Looper::pollInner(int)+144)</span><br><span class="hljs-string">  native: #02 pc 0000000000017f8c  /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+56)</span><br><span class="hljs-string">  native: #03 pc 000000000013b8f4  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, long, int)+44)</span><br><span class="hljs-string">  at android.os.MessageQueue.nativePollOnce(Native method)</span><br><span class="hljs-string">  at android.os.MessageQueue.next(MessageQueue.java:336)</span><br><span class="hljs-string">  at android.os.Looper.loop(Looper.java:174)</span><br><span class="hljs-string">  at com.android.server.SystemServer.run(SystemServer.java:546)</span><br><span class="hljs-string">  at com.android.server.SystemServer.main(SystemServer.java:354)</span><br><span class="hljs-string">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="hljs-string">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)</span><br><span class="hljs-string">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:913)</span><br></code></pre></td></tr></table></figure><p>上述主线程堆栈就是一个很正常的空闲堆栈，表明主线程正在等待新的消息。如果ANR日志里主线程是这样一个状态，那可能有两个原因导致 anr：</p><ul><li>该 anr 是 cpu 资源抢占或内存紧张等其他因素引起</li><li>这份 anr 日志抓取的时候，主线程已经恢复正常</li></ul><h3 id="案例五、CPU被其他应用抢占"><a href="#案例五、CPU被其他应用抢占" class="headerlink" title="案例五、CPU被其他应用抢占"></a>案例五、CPU被其他应用抢占</h3><p>当 anr 日志中找不到有效的信息，这种情况我们就得看 cpu 信息了，</p><p>这个日志一般在 <code>bugreport.txt</code> 文件中可以查看，具体怎么导出 <code>bugreport.txt</code> 文件可见本文的《导出并查看 ANR 日志》那里的步骤</p><p>取出 cpu 信息日志如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">-------------------------------------------------------------------------------<br>DUMP OF SERVICE CRITICAL cpuinfo:<br>Load: <span class="hljs-number">5.28</span> / <span class="hljs-number">5.71</span> / <span class="hljs-number">5.58</span><br>CPU usage from 275243ms to 190078ms <span class="hljs-title function_">ago</span> <span class="hljs-params">(<span class="hljs-number">2022</span>-<span class="hljs-number">06</span>-<span class="hljs-number">16</span> <span class="hljs-number">15</span>:<span class="hljs-number">25</span>:<span class="hljs-number">36.158</span> to <span class="hljs-number">2022</span>-<span class="hljs-number">06</span>-<span class="hljs-number">16</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">01.323</span>)</span>:<br>  <span class="hljs-number">51</span>% <span class="hljs-number">695</span>/audioserver: <span class="hljs-number">35</span>% user + <span class="hljs-number">15</span>% kernel / faults: <span class="hljs-number">3071</span> minor<br>  <span class="hljs-number">17</span>% <span class="hljs-number">1496</span>/system_server: <span class="hljs-number">9</span>% user + <span class="hljs-number">8</span>% kernel / faults: <span class="hljs-number">43598</span> minor<br>  <span class="hljs-number">14</span>% <span class="hljs-number">2077</span>/VosRXThread: <span class="hljs-number">0</span>% user + <span class="hljs-number">14</span>% kernel<br>  <span class="hljs-number">3.1</span>% <span class="hljs-number">666</span>/android.hardware.sensors@<span class="hljs-number">1.0</span>-service: <span class="hljs-number">0.8</span>% user + <span class="hljs-number">2.3</span>% kernel / faults: <span class="hljs-number">170</span> minor<br>  <span class="hljs-number">3.1</span>% <span class="hljs-number">642</span>/android.hardware.audio@<span class="hljs-number">2.0</span>-service: <span class="hljs-number">0.2</span>% user + <span class="hljs-number">2.8</span>% kernel / faults: <span class="hljs-number">2</span> minor<br>  ...................................省略 N 行...........................................<br><span class="hljs-number">21</span>% TOTAL: <span class="hljs-number">6.4</span>% user + <span class="hljs-number">10</span>% kernel + <span class="hljs-number">0.1</span>% iowait + <span class="hljs-number">2.4</span>% irq + <span class="hljs-number">1.4</span>% softirq<br>--------- <span class="hljs-number">0.</span>007s was the duration of dumpsys cpuinfo, ending at: <span class="hljs-number">2022</span>-<span class="hljs-number">06</span>-<span class="hljs-number">16</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">11</span><br>-------------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><p>这个日志怎么分析呢？它的这个部分的含义如下：</p><blockquote><p>1、Load: 5.28 &#x2F; 5.71 &#x2F; 5.58 &#x2F;&#x2F; 代表了设备在 1、5、15 分钟内 正在使用和等待使用CPU 的活动进程的平均数<br>2、CPU usage from 275243ms to 190078ms ago (2022-06-16 15:25:36.158 to 2022-06-16 15:27:01.323) &#x2F;&#x2F; 表明负载信息抓取是在 275243ms ~ 190078ms之间的，且时间点是从 2022-06-16 15:25:36.158 开始<br>3、中间打印百分比的部分 &#x2F;&#x2F; 各个进程占用的CPU的详细情况<br>4、最后一行 &#x2F;&#x2F; 各个进程合计占用的CPU信息。</p></blockquote><p>还有一些名词和含义如下：</p><blockquote><p>1、user: 用户态<br>2、kernel: 内核态<br>3、faults: 内存缺页，minor —— 轻微的，major —— 重度，需要从磁盘拿数据<br>4、iowait: IO 等待占比，如果占比很高，意味着有很大可能是io耗时导致ANR<br>5、irq: 硬中断，<br>6、softirq: 软中断</p></blockquote><p>注意以下两点：</p><ul><li>如果 iowait 占比很高，意味着有很大可能是 io 耗时导致的 ANR，具体进一步查看有没有进程 faults major 比较多</li><li>单进程 CPU 的负载并不是以100%为上限，而是有几个核就有百分之几百，如 4 核，那么上限为400%</li></ul><p>了解了如何看 cpu 日志后，我们再回到具体的日志中查看，</p><p>发现如上排在第一位的进程 audioserver 即为系统中占用 cpu 最高的进程，达到 51%，这属于正常的 cpu 占用范围，因此，此日志中并没有发现导致 anr 的有效日志。</p><p>如果发现排在第一位的进程占用了极高的 cpu 资源，那么就极有可能是这个进程导致的 anr 。</p><h3 id="案例六、系统服务超时"><a href="#案例六、系统服务超时" class="headerlink" title="案例六、系统服务超时"></a>案例六、系统服务超时</h3><p>如果系统服务超时，日志中一般会包含 <code>BinderProxy.transactNative</code> 关键字，如下：</p><img src="/2023/08/10/%E3%80%90Android%E3%80%91%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-ANR-%E6%97%A5%E5%BF%97/7e8b011e4d1b43fe89b4acf97070fcad.png" alt="在这里插入图片描述" style="zoom:80%;"><p>从堆栈可以看出 getActiveNetworkInfo 方法发生了 ANR。我们知道，系统的服务都是 Binder 机制，Binder 一共有16个线程，服务能力也是有限的，所以有可能系统服务长时间不响应导致ANR。</p><p>如果其他应用占用了 Binder 线程，那么当前应用只能等待，可进一步搜索 blockUntilThreadAvailable 关键字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">at android.os.Binder.blockUntilThreadAvailable(Native method)<br></code></pre></td></tr></table></figure><p>如果有发现某个线程的堆栈包含此字样，可进一步看其堆栈确定其调用了什么系统服务。</p><p>此类 ANR 属于系统环境的问题，如果某类型机器上频繁发生此问题，应用层可以考虑规避策略。</p><h3 id="案例七、内存紧张"><a href="#案例七、内存紧张" class="headerlink" title="案例七、内存紧张"></a>案例七、内存紧张</h3><p>如果日志中 CPU 和堆栈都正常，仍旧发生了 ANR，那么可以进一步考虑是否是内存紧张导致的 anr。</p><p>在 <code>bugreport.txt</code> 文件中，我们还可以通过如下关键字 <code>am_meminfo</code> 搜索日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">06-16 02:14:42.014  1000  1496  1575 I am_meminfo: [1163550720,172752896,7536640,272494592,512559104]<br></code></pre></td></tr></table></figure><p>数组中的五个值分别指的是</p><ul><li>Cached</li><li>Free</li><li>Zram</li><li>Kernel</li><li>Native</li></ul><p>其中 Cached + Free 代表当前整个手机的 可用内存，如果值很小，那就意味着处于内存紧张状态。</p><p>一般低内存的判定阈值为：4G 内存手机以下阀值：350MB，以上阀值则为：450MB</p><p>另外，如果通过关键字 am_meminfo 搜索不出任何日志，那么我们可以通过 onTrimMemory 搜索，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">10-31 22:37:33.458 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher0<br></code></pre></td></tr></table></figure><p>它也可以作为内存紧张的一个参考判断，可见，这里的 <code>level 为 80</code> ，我们看看 Android 中是怎么定义这个 level 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程接近后台 LRU 列表的末尾，如果没有很快找到更多内存，进程将被杀死</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TRIM_MEMORY_COMPLETE</span> <span class="hljs-operator">=</span> <span class="hljs-number">80</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程在后台 LRU 列表的中间；释放内存可以帮助系统保持列表中稍后运行的其他进程，以获得更好的整体性能</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TRIM_MEMORY_MODERATE</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程已进入 LRU 列表。这是一个清理资源的好机会，如果用户返回应用程序，这些资源可以高效快速地重新构建</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TRIM_MEMORY_BACKGROUND</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程已显示用户界面，现在不再显示。此时应释放 UI 的大量分配，以便更好地管理内存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TRIM_MEMORY_UI_HIDDEN</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该进程不是可消耗的后台进程，但设备运行的内存极低，即将无法保持任何后台进程运行。您正在运行的进程应尽可能多地释放非关键资源，以允许该内存在其他地方使用。在此之后将发生的下一件事是调用 onLowMemory() 以报告在后台根本无法保留任何内容，这种情况可能会开始显着影响用户</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TRIM_MEMORY_RUNNING_CRITICAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程不是可消耗的后台进程，但设备内存不足。您正在运行的进程应该释放不需要的资源，以允许在其他地方使用该内存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TRIM_MEMORY_RUNNING_LOW</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 进程不是可消耗的后台进程，但设备运行的内存适中。您正在运行的进程可能希望释放一些不需要的资源以供其他地方使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TRIM_MEMORY_RUNNING_MODERATE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓Watchdog机制以及问题分析</title>
    <link href="/2023/08/10/%E5%AE%89%E5%8D%93Watchdog%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <url>/2023/08/10/%E5%AE%89%E5%8D%93Watchdog%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓Watchdog机制以及问题分析"><a href="#安卓Watchdog机制以及问题分析" class="headerlink" title="安卓Watchdog机制以及问题分析"></a>安卓Watchdog机制以及问题分析</h1><p><strong>转载链接：<a href="http://duanqz.github.io/2015-10-12-Watchdog-Analysis#section-1">http://duanqz.github.io/2015-10-12-Watchdog-Analysis#section-1</a></strong></p><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h2><p><code>Watchdog</code>的中文的“看门狗”，有保护的意思。最早引入Watchdog是在单片机系统中，由于单片机的工作环境容易受到外界磁场的干扰，导致程序“跑飞”，造成整个系统无法正常工作，因此，引入了一个“看门狗”，对单片机的运行状态进行实时监测，针对运行故障做一些保护处理，譬如让系统重启。这种Watchdog属于硬件层面，必须有硬件电路的支持。</p><p>Linux也引入了Watchdog，在Linux内核下，当Watchdog启动后，便设定了一个定时器，如果在超时时间内没有对&#x2F;dev&#x2F;Watchdog进行写操作，则会导致系统重启。通过定时器实现的Watchdog属于软件层面。</p><p>Android设计了一个软件层面Watchdog，用于保护一些重要的系统服务，当出现故障时，通常会让Android系统重启。由于这种机制的存在，就经常会出现一些system_server进程被Watchdog杀掉而发生手机重启的问题。</p><p>本文期望回答以下问题：</p><blockquote><ol><li>Watchdog是怎么工作的？这涉及到Watchdog的工作机制。</li><li>遇到Watchdog的问题该怎么办？这涉及到分析Watchdog问题的惯用方法。</li></ol></blockquote><h2 id="2-Watchdog机制"><a href="#2-Watchdog机制" class="headerlink" title="2.Watchdog机制"></a>2.Watchdog机制</h2><p>我们以<a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/Watchdog.java">frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;Watchdog.java</a>为蓝本，分析Watchdog的实现逻辑。为了描述方便，ActivityManagerService， PackageManagerService， WindowManagerService会分别简称为AMS, PKMS, WMS。</p><h3 id="2-1-Watchdog的初始化"><a href="#2-1-Watchdog的初始化" class="headerlink" title="2.1 Watchdog的初始化"></a>2.1 Watchdog的初始化</h3><p>Android的Watchdog是一个单例线程，在System Server时就会初始化Watchdog。Watchdog在初始化时，会构建很多<strong>HandlerChecker</strong>，大致可以分为两类：</p><ul><li><strong>Monitor Checker</strong>，用于检查是Monitor对象可能发生的死锁, AMS, PKMS, WMS等核心的系统服务都是Monitor对象。</li><li><strong>Looper Checker</strong>，用于检查线程的消息队列是否长时间处于工作状态。Watchdog自身的消息队列，Ui, Io, Display这些全局的消息队列都是被检查的对象。此外，一些重要的线程的消息队列，也会加入到<strong>Looper Checker</strong>中，譬如AMS, PKMS，这些是在对应的对象初始化时加入的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">Watchdog</span><span class="hljs-params">()</span> &#123;<br>    ....<br>    mMonitorChecker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(FgThread.getHandler(),<br>                <span class="hljs-string">&quot;foreground thread&quot;</span>, DEFAULT_TIMEOUT);<br>    mHandlerCheckers.add(mMonitorChecker);<br>    mHandlerCheckers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper()),<br>                <span class="hljs-string">&quot;main thread&quot;</span>, DEFAULT_TIMEOUT));<br>    mHandlerCheckers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(UiThread.getHandler(),<br>                <span class="hljs-string">&quot;ui thread&quot;</span>, DEFAULT_TIMEOUT));<br>    mHandlerCheckers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(IoThread.getHandler(),<br>                <span class="hljs-string">&quot;i/o thread&quot;</span>, DEFAULT_TIMEOUT));<br>    mHandlerCheckers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(DisplayThread.getHandler(),<br>                <span class="hljs-string">&quot;display thread&quot;</span>, DEFAULT_TIMEOUT));<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>两类<strong>HandlerChecker</strong>的侧重点不同，<strong>Monitor Checker</strong>预警我们不能长时间持有核心系统服务的对象锁，否则会阻塞很多函数的运行; <strong>Looper Checker</strong>预警我们不能长时间的霸占消息队列，否则其他消息将得不到处理。这两类都会导致系统卡住(System Not Responding)。</p><h3 id="2-2-添加Watchdog检测对象"><a href="#2-2-添加Watchdog检测对象" class="headerlink" title="2.2 添加Watchdog检测对象"></a>2.2 添加Watchdog检测对象</h3><p>Watchdog初始化以后，就可以作为system_server进程中的一个单独的线程运行了。但这个时候，还不能触发Watchdog的运行，因为AMS, PKMS等系统服务还没有加入到Watchdog的监测集。 所谓监测集，就是需要Watchdog关注的对象，Android中有成千上万的消息队列在同时运行，然而，Watchdog毕竟是系统层面的东西，它只会关注一些核心的系统服务。</p><p>Watchdog提供两个方法，分别用于添加<strong>Monitor Checker</strong>对象和<strong>Looper Checker</strong>对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMonitor</span><span class="hljs-params">(Monitor monitor)</span> &#123;<br>    <span class="hljs-comment">// 将monitor对象添加到Monitor Checker中，</span><br>    <span class="hljs-comment">// 在Watchdog初始化时，可以看到Monitor Checker本身也是一个HandlerChecker对象</span><br>    mMonitors.add(monitor);<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addThread</span><span class="hljs-params">(Handler thread, <span class="hljs-type">long</span> timeoutMillis)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (isAlive()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Threads can&#x27;t be added once the Watchdog is running&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> thread.getLooper().getThread().getName();<br>        <span class="hljs-comment">// 为Handler构建一个HandlerChecker对象，其实就是**Looper Checker**</span><br>        mHandlerCheckers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(thread, name, timeoutMillis));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>被Watchdog监测的对象，都需要将自己添加到Watchdog的监测集中。以下是AMS的类定义和构造器的代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ActivityManagerNative</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watchdog</span>.Monitor, BatteryStatsImpl.BatteryCallback &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ActivityManagerService</span><span class="hljs-params">(Context systemContext)</span> &#123;<br>        ...<br>        Watchdog.getInstance().addMonitor(<span class="hljs-built_in">this</span>);<br>        Watchdog.getInstance().addThread(mHandler);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AMS实现了Watchdog.Monitor接口，这个接口只有一个方法，就是monitor()，它的作用后文会再解释。这里可以看到在AMS的构造器中，将自己添加到Monitor Checker对象中，然后将自己的handler添加到Looper Checker对象中。 其他重要的系统服务添加到Watchdog的代码逻辑都与AMS差不多。</p><p>整个Android系统中，被monitor的对象并不多，十个手指头就能数出来Watchdog.Monitor的实现类的个数。</p><h3 id="2-3-Watchdog的监测机制"><a href="#2-3-Watchdog的监测机制" class="headerlink" title="2.3 Watchdog的监测机制"></a>2.3 Watchdog的监测机制</h3><p>Watchdog本身是一个线程，它的run()方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">waitedHalf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            ...<br>            <span class="hljs-comment">// 1. 调度所有的HandlerChecker</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;mHandlerCheckers.size(); i++) &#123;<br>                <span class="hljs-type">HandlerChecker</span> <span class="hljs-variable">hc</span> <span class="hljs-operator">=</span> mHandlerCheckers.get(i);<br>                hc.scheduleCheckLocked();<br>            &#125;<br>            ...<br>            <span class="hljs-comment">// 2. 开始定期检查</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-keyword">while</span> (timeout &gt; <span class="hljs-number">0</span>) &#123;<br>                ...<br>                <span class="hljs-keyword">try</span> &#123;<br>                    wait(timeout);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Log.wtf(TAG, e);<br>                &#125;<br>                ...<br>                timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);<br>            &#125;<br> <br>            <span class="hljs-comment">// 3. 检查HandlerChecker的完成状态</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">waitState</span> <span class="hljs-operator">=</span> evaluateCheckerCompletionLocked();<br>            <span class="hljs-keyword">if</span> (waitState == COMPLETED) &#123;<br>                ...<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitState == WAITING) &#123;<br>                ...<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitState == WAITED_HALF) &#123;<br>                ...<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br> <br>            <span class="hljs-comment">// 4. 存在超时的HandlerChecker</span><br>            blockedCheckers = getBlockedCheckersLocked();<br>            subject = describeCheckersLocked(blockedCheckers);<br>            allowRestart = mAllowRestart;<br>        &#125;<br>        ...<br>        <span class="hljs-comment">// 5. 保存日志，判断是否需要杀掉系统进程</span><br>        Slog.w(TAG, <span class="hljs-string">&quot;*** GOODBYE!&quot;</span>);<br>        Process.killProcess(Process.myPid());<br>        System.exit(<span class="hljs-number">10</span>);<br>    &#125; <span class="hljs-comment">// end of while (true)</span><br> <br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码片段主要的运行逻辑如下：</p><ol><li>Watchdog运行后，便开始无限循环，依次调用每一个HandlerChecker的scheduleCheckLocked()方法</li><li>调度完HandlerChecker之后，便开始定期检查是否超时，每一次检查的间隔时间由<strong>CHECK_INTERVAL</strong>常量设定，为30秒</li><li>每一次检查都会调用evaluateCheckerCompletionLocked()方法来评估一下HandlerChecker的完成状态：<ul><li>COMPLETED表示已经完成</li><li>WAITING和WAITED_HALF表示还在等待，但未超时</li><li>OVERDUE表示已经超时。默认情况下，timeout是1分钟，但监测对象可以通过传参自行设定，譬如PKMS的<strong>Handler Checker</strong>的超时是10分钟</li></ul></li><li>如果超时时间到了，还有HandlerChecker处于未完成的状态(OVERDUE)，则通过getBlockedCheckersLocked()方法，获取阻塞的HandlerChecker，生成一些描述信息</li><li>保存日志，包括一些运行时的堆栈信息，这些日志是我们解决Watchdog问题的重要依据。如果判断需要杀掉system_server进程，则给当前进程(system_server)发送signal 9</li></ol><p>只要Watchdog没有发现超时的任务，HandlerChecker就会被不停的调度，那HandlerChecker具体做一些什么检查呢？ 直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChecker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleCheckLocked</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Looper Checker中是不包含monitor对象的，判断消息队列是否处于空闲</span><br>        <span class="hljs-keyword">if</span> (mMonitors.size() == <span class="hljs-number">0</span> &amp;&amp; mHandler.getLooper().isIdling()) &#123;<br>            mCompleted = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ...<br>        <span class="hljs-comment">// 将Monitor Checker的对象置于消息队列之前，优先运行</span><br>        mHandler.postAtFrontOfQueue(<span class="hljs-built_in">this</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 依次调用Monitor对象的monitor()方法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; size ; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Watchdog.<span class="hljs-built_in">this</span>) &#123;<br>                mCurrentMonitor = mMonitors.get(i);<br>            &#125;<br>            mCurrentMonitor.monitor();<br>        &#125;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对于<strong>Looper Checker</strong>而言，会判断线程的消息队列是否处于空闲状态。 如果被监测的消息队列一直闲不下来，则说明可能已经阻塞等待了很长时间</li><li>对于<strong>Monitor Checker</strong>而言，会调用实现类的monitor方法，譬如上文中提到的AMS.monitor()方法， 方法实现一般很简单，就是获取当前类的对象锁，如果当前对象锁已经被持有，则monitor()会一直处于wait状态，直到超时，这种情况下，很可能是线程发生了死锁</li></ul><p><strong>至此，我们已经分析了Watchdog的工作机制，回答了我们提出的第一个问题：</strong></p><p><strong>Watchdog定时检查一些重要的系统服务，举报长时间阻塞的事件，甚至杀掉system_server进程，让Android系统重启。</strong></p><h2 id="3-问题分析方法"><a href="#3-问题分析方法" class="headerlink" title="3.问题分析方法"></a>3.问题分析方法</h2><h3 id="3-1-日志获取"><a href="#3-1-日志获取" class="headerlink" title="3.1 日志获取"></a>3.1 日志获取</h3><p>Andriod的日志门类繁多，而且，为了调试的需要，设备厂商和应用开发者都会在AOSP的基础上增加很多日志。 面对如此庞大复杂的日志系统，通常只有对应领域的专家才能看懂其透露的细节信息，就像去医院就诊，医生一看检查报告就知道患者身体出了什么问题，而外行对这些诊断信息往往是束手无策的。</p><p>解决Watchdog相关的问题，对日志的要求比较高，有些问题与当时的系统环境相关，仅仅凭借单一的日志并不能定位问题。 以下罗列出获取Android日志的一些重要手段，部分场景下，Watchdog相关的问题甚至需要以下所有的日志：</p><ul><li><strong>logcat</strong> 通过<code>adb logcat</code>命令输出Android的一些当前运行日志，可以通过logcat的 <strong>-b</strong> 参数指定要输出的日志缓冲区，缓冲区对应着logcat的一种日志类型。 高版本的logcat可以使用 <strong>-b all</strong> 获取到所有缓冲区的日志<ul><li>event 通过android.util.EventLog工具类打印的日志，一些重要的系统事件会使用此类日志</li><li>main 通过android.util.Log工具类打印的日志，应用程序，尤其是基于SDK的应用程序，会使用此类日志</li><li>system 通过android.util.Slog工具类打印的日志，系统相关的日志一般都是使用此类日志，譬如SystemServer</li><li>radio 通过android.util.Rlog工具类打印的日志，通信模块相关的日志一般都是使用此类日志，譬如RIL</li></ul></li><li><strong>dumpsys</strong> 通过<code>adb dumpsys</code>命令输出一些重要的系统服务信息，譬如内存、电源、磁盘等， 工作原理可以查阅<a href="http://duanqz.github.io/2015-07-19-Intro-to-dumpsys">dumpsys介绍</a>一文</li><li><strong>traces</strong> 该文件记录了一个时间段的函数调用栈信息，通常在应用发生ANR(Application Not Responding)时，会触发打印各进程的函数调用栈。 站在Linux的角度，其实就是向进程发送SIGNAL_QUIT(3)请求，譬如，我们可以通过<code>adb shell kill -3 &lt;pid&gt;</code>命令，打印指定进程的的trace。 SIGNAL_QUIT(3)表面意思有一点误导，它其实并不会导致进程退出。输出一般在 <em>&#x2F;data&#x2F;anr&#x2F;traces.txt</em> 文件中，当然，这是可以灵活配置的， Android提供的系统属性dalvik.vm.stack-trace-file可以用来配置生成traces文件的位置。</li><li><strong>binder</strong> 通过Binder跨进程调用的日志，可以通过<code>adb shell cat</code>命令从 &#x2F;proc&#x2F;binder 下取出对应的日志<ul><li>failed_transaction_log</li><li>transaction_log</li><li>transactions</li><li>stats</li></ul></li><li><strong>dropbox</strong> 为了记录历史的logcat日志，Android引入了Dropbox，将历史日志持久化到磁盘中(<strong>&#x2F;data&#x2F;system&#x2F;dropbox</strong>)。 logcat的缓冲区大小毕竟是有限的，所以需要循环利用，这样历史的日志信息就会被冲掉。在一些自动化测试的场景下，譬如Monkey需要长时间的运行， 就需要把历史的日志全都保存下来。</li><li><strong>tombstone</strong> tombstone错误一般由Dalvik错误、native层的代码问题导致的。当系统发生tombstone时，内核会上报一个严重的警告信号， 上层收到后，把当前的调用栈信息持久化到磁盘中(<strong>&#x2F;data&#x2F;tombstone</strong>)</li><li><strong>bugreport</strong> 通过<code>adb bugreport</code>命令输出，日志内容多到爆，logcat, traces, dmesg, dumpsys, binder的日志都包含在其中。 由于输出bugreport的时间很长，当系统发生错误时，我们再执行bugreport往往就来不及了(此时，系统可能都已经重启了)，所以，要动用bugreport就需要结合一些其他机制， 譬如在杀掉system_server进程之前，先让bugreport运行完</li></ul><h3 id="3-2-问题定位"><a href="#3-2-问题定位" class="headerlink" title="3.2 问题定位"></a>3.2 问题定位</h3><p>Watchdog出现的日志很明显，logcat中的event, system中都会有体现，要定位问题，可以从检索日志中的watchdog关键字开始。</p><p>发生Watchdog检测超时这么重要的系统事件，Android会打印一个EventLog：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">watchdog: Blocked <span class="hljs-keyword">in</span> handler XXX    <span class="hljs-comment"># 表示HandlerChecker超时了</span><br>watchdog: Blocked <span class="hljs-keyword">in</span> monitor XXX    <span class="hljs-comment"># 表示MonitorChecker超时了</span><br></code></pre></td></tr></table></figure><p>Watchdog是运行在system_server进程中，会打印一些System类型的日志。在手机处于非调试状态时，伴随Watchdog出现的往往是system_server进程被杀，从而系统重启。 当Watchdog要主动杀掉system_server进程时，以下关键字就会出现在SystemLog中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: XXX<br>Watchdog: XXX<br>Watchdog: <span class="hljs-string">&quot;*** GOODBYE!</span><br></code></pre></td></tr></table></figure><p>当我们在日志中检索到上述两类关键信息时，说明“Watchdog显灵”了，从另一个角度来理解，就是“System Not Responding”了。 接下来，我们需要进一步定位在watchdog出现之前，system_server进程在干什么，处于一个什么状态。 这与排除”Application Not Responding“问题差不多，我们需要进程的traces信息、当前系统的CPU运行信息、IO信息。</p><p>找到Watchddog出现之前的traces.txt文件，这个时间差最好不要太大，因为Watchdog默认的超时时间是1分钟，太久以前的traces并不能说明问题。 诱导Watchdong出现的直接原因其实就是system_server中某个线程被阻塞了，这个信息在event和system的log中清晰可见。 我们以一个systemLog为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked <span class="hljs-keyword">in</span> monitor com.android.server.wm.WindowManagerService on foreground thread (android.fg)<br></code></pre></td></tr></table></figure><p>Watchdog告诉我们<strong>Monitor Checker</strong>超时了，具体在哪呢？ 名为<strong>android.fg</strong>的线程在WindowManagerService的monitor()方法被阻塞了。这里隐含了两层意思：</p><ol><li>WindowManagerService实现了Watchdog.Monitor这个接口，并将自己作为<strong>Monitor Checker</strong>的对象加入到了Watchdog的监测集中</li><li>monitor()方法是运行在<strong>android.fg</strong>线程中的。Android将<strong>android.fg</strong>设计为一个全局共享的线程，意味着它的消息队列可以被其他线程共享， Watchdog的<strong>Monitor Checker</strong>就是使用的<strong>android.fg</strong>线程的消息队列。因此，出现<strong>Monitor Checker</strong>的超时，肯定是<strong>android.fg</strong>线程阻塞在monitor()方法上。</li></ol><p>我们打开system_server进程的traces，检索 <strong>android.fg</strong> 可以快速定位到该线程的函数调用栈：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;android.fg&quot;</span> prio=5 tid=25 Blocked<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=1 dsCount=0 obj=0x12eef900 self=0x7f7a8b1000<br>  | sysTid=973 <span class="hljs-built_in">nice</span>=0 cgrp=default <span class="hljs-built_in">sched</span>=0/0 handle=0x7f644e9000<br>  | state=S schedstat=( 3181688530 2206454929 8991 ) utm=251 stm=67 core=1 HZ=100<br>  | stack=0x7f643e7000-0x7f643e9000 stackSize=1036KB<br>  | held mutexes=<br>  at com.android.server.wm.WindowManagerService.monitor(WindowManagerService.java:13125)<br>  - waiting to lock &lt;0x126dccb8&gt; (a java.util.HashMap) held by thread 91<br>  at com.android.server.Watchdog<span class="hljs-variable">$HandlerChecker</span>.run(Watchdog.java:204)<br>  at android.os.Handler.handleCallback(Handler.java:815)<br>  at android.os.Handler.dispatchMessage(Handler.java:104)<br>  at android.os.Looper.loop(Looper.java:194)<br>  at android.os.HandlerThread.run(HandlerThread.java:61)<br>  at com.android.server.ServiceThread.run(ServiceThread.java:46)<br></code></pre></td></tr></table></figure><p><strong>android.fg</strong>线程调用栈告诉我们几个关键的信息：</p><ul><li>这个线程当前的状态是<strong>Blocked</strong>，阻塞</li><li>由Watchdog发起调用monitor()，这是一个Watchdog检查，阻塞已经超时</li><li>**waiting to lock &lt;0x126dccb8&gt;**： 阻塞的原因是monitor()方法中在等锁&lt;0x126dccb8&gt;</li><li><strong>held by thread 91</strong>： 这个锁被编号为91的线程持有，需要进一步观察91号线程的状态。</li></ul><blockquote><p>题外话：每一个进程都会对自己所辖的线程编号，从1开始。1号线程通常就是我们所说的主线程。 线程在Linux系统中还有一个全局的编号，由sysTid表示。我们在logcat等日志中看到的一般是线程的全局编号。 譬如，本例中android.fg线程在system_server进程中的编号是25，系统全局编号是973。</p></blockquote><p>可以在traces.txt文件中检索 tid&#x3D;91 来快速找到91号线程的函数调用栈信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;Binder_C&quot;</span> prio=5 tid=91 Native<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=1 dsCount=0 obj=0x12e540a0 self=0x7f63289000<br>  | sysTid=1736 <span class="hljs-built_in">nice</span>=0 cgrp=default <span class="hljs-built_in">sched</span>=0/0 handle=0x7f6127c000<br>  | state=S schedstat=( 96931835222 49673449591 260122 ) utm=7046 stm=2647 core=2 HZ=100<br>  | stack=0x7f5ffbc000-0x7f5ffbe000 stackSize=1008KB<br>  | held mutexes=<br>  at libcore.io.Posix.writeBytes(Native method)<br>  at libcore.io.Posix.write(Posix.java:258)<br>  at libcore.io.BlockGuardOs.write(BlockGuardOs.java:313)<br>  at libcore.io.IoBridge.write(IoBridge.java:537)<br>  at java.io.FileOutputStream.write(FileOutputStream.java:186)<br>  at com.android.internal.util.FastPrintWriter.flushBytesLocked(FastPrintWriter.java:334)<br>  at com.android.internal.util.FastPrintWriter.flushLocked(FastPrintWriter.java:355)<br>  at com.android.internal.util.FastPrintWriter.appendLocked(FastPrintWriter.java:303)<br>  at com.android.internal.util.FastPrintWriter.<span class="hljs-built_in">print</span>(FastPrintWriter.java:466)<br>  - locked &lt;@addr=0x134c4910&gt; (a com.android.internal.util.FastPrintWriter<span class="hljs-variable">$DummyWriter</span>)<br>  at com.android.server.wm.WindowState.dump(WindowState.java:1510)<br>  at com.android.server.wm.WindowManagerService.dumpWindowsNoHeaderLocked(WindowManagerService.java:12279)<br>  at com.android.server.wm.WindowManagerService.dumpWindowsLocked(WindowManagerService.java:12266)<br>  at com.android.server.wm.WindowManagerService.dump(WindowManagerService.java:12654)<br>  - locked &lt;0x126dccb8&gt; (a java.util.HashMap)<br>  at android.os.Binder.dump(Binder.java:324)<br>  at android.os.Binder.onTransact(Binder.java:290)<br></code></pre></td></tr></table></figure><p>91号线程的名字是<strong>Binder_C</strong>，它的函数调用栈告诉我们几个关键信息：</p><ul><li>Native，表示线程处于运行状态(RUNNING)，并且正在执行JNI方法</li><li>在WindowManagerService.dump()方法申请了锁&lt;0x126dccb8&gt;，这个锁正是<strong>android.fg</strong>线程所等待的</li><li>FileOutputStream.write()表示<strong>Binder_C</strong>线程在执行IO写操作，正式因为这个写操作一直在阻塞，导致线程持有的锁不能释放</li></ul><blockquote><p>题外话：关于Binder线程。当Android进程启动时，就会创建一个线程池，专门处理Binder事务。线程池中会根据当前的binder线程计数器的值来构造新创建的binder线程, 线程名”Binder_%X”，X是十六进制。当然，线程池的线程数也有上限，默认情况下为16，所以，可以看到 Binder_1 ~ Binder_F 这样的线程命名。</p></blockquote><p>聪明的你看到这或许已经能够想到解决办法了，在这个IO写操作上加一个超时机制，并且这个超时小于Watchdog的超时，不就可以让线程释放它所占有的锁了吗？ 是的，这确实可以作为一个临时解决方案(Workaround)，或者说一个保护机制。但我们可以再往深处想一想，这个IO写操作为什么会阻塞：</p><ul><li>是不是IO缓冲区满了，导致写阻塞呢？</li><li>是不是写操作有什么锁，导致这个write方法在等锁呢？</li><li>是不是当前系统的IO负载过于高，导致写操作效率很低呢？</li></ul><p>这都需要我们再进一步从日志中去找原因。如果已有的日志不全，找不到论据，我们还需要设计场景来验证假设，解决问题的难度陡然上升。</p><h3 id="3-3-场景还原"><a href="#3-3-场景还原" class="headerlink" title="3.3 场景还原"></a>3.3 场景还原</h3><p>我们经历了两个关键步骤：</p><ol><li>通过event或system类型的日志，发现了Watchdog杀掉system_server导致系统重启</li><li>通过traces日志，发了导致Watchdog出现的具体线程操作</li></ol><p>这两个过程基本就涵盖了Watchdog的运行机制了，但这并没有解决问题啊。我们需要找到线程阻塞的原因是什么，然而，线程阻塞的原因就千奇百怪了。 如果有问题出现的现场，并且问题可以重现，那么我们可以通过调试的手段来分析问题产生的原因。 如果问题只是偶然出现，甚至只有一堆日志，我们就需要从日志中来还原问题出现的场景，这一步才是真正考验大家Android&#x2F;Linux功底的地方。</p><p>继续以上述问题为例，我们来进一步还原问题出现的场景，从Java层的函数调用栈来看：</p><ul><li>首先，跨进程发起了Binder.dump()方法的调用：at android.os.Binder.dump(Binder.java:324)</li><li>然后，进入了WMS的dump()：at com.android.server.wm.WindowManagerService.dump(WindowManagerService.java:12654)</li><li>接着，发生了写文件操作：at java.io.FileOutputStream.write(FileOutputStream.java:186)</li><li>最后，调用了JNI方法：at libcore.io.Posix.writeBytes(Native method)</li></ul><p><strong>Binder_C</strong>线程要出现这种函数调用栈，我们可以初步确定是Android接受了如下命令 (dumpsys原理请查阅<a href="http://duanqz.github.io/2015-07-19-Intro-to-dumpsys">dumpsys介绍</a>一文)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ adb shell dumpsys window<br></code></pre></td></tr></table></figure><p>当通过命令行运行以上命令时，客户端(PC)的adb server会向服务端(手机)的adbd发送指令， adbd进程会fork出一个叫做dumpsys的子进程，dumpsys进程再利用Binder机制和system_server通信 (adb的实现原理可以查阅<a href="http://duanqz.github.io/2015-05-21-Intro-adb">adb介绍</a>一文)。</p><p>仅凭这个还是分析不出问题所在，我们需要启用内核的日志了。当调用JNI方法libcore.io.Posix.writeBytes()时，会触发系统调用， Linux会从用户态切换到内核态，内核的函数调用栈也可以从traces中找到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">kernel: __switch_to+0x74/0x8c<br>kernel: pipe_wait+0x60/0x9c<br>kernel: pipe_write+0x278/0x5cc<br>kernel: do_sync_write+0x90/0xcc<br>kernel: vfs_write+0xa4/0x194<br>kernel: SyS_write+0x40/0x8c<br>kernel: cpu_switch_to+0x48/0x4c<br></code></pre></td></tr></table></figure><p>在Java层，明确指明要写文件(FileOutputStream)，正常情况下，系统调用write()就完事了，但Kernel却打开了一个管道，最终阻塞在了pipe_wait()方法。 什么场景下会打开一个管道，而且管道会阻塞呢？一系列的猜想和验证过程接踵而至。</p><p>这里有必要先补充一些基础知识了：</p><ul><li><p><strong><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/11/03/2751593.html">Linux进程间通信之管道(pipe)</a></strong></p><p>Linux的管道实现借助了文件系统的file结构和VFS(Virtual File System)，通过将两个file结构指向同一个临时的VFS索引节点，而这个VFS索引节点又指向一个物理页面时， 实际上就建立了一个管道。</p><p>这就解释了为什么发起系统调用write的时候，打开了一个管道。因为dumpsys和system_server进程，将自己的file结构指向了同一个VFS索引节点。</p></li><li><p><strong><a href="http://blog.csdn.net/sj13051180/article/details/47865803">管道挂起的案例</a></strong></p><p>管道是一个生产者-消费者模型，当缓冲区满时，则生产者不能往管道中再写数据了，需等到消费者读数据。如果消费者来不及处理缓冲区的数据，或者锁定缓冲区，则生产者就挂起了。</p><p>结合到例子中的场景，system_server进程无法往管道中写数据，很可能是dumpsys进程一直忙碌来不及处理新的数据。</p></li></ul><p>接下来，需要再从日志中寻找dumpsys进程的运行状态了：</p><ul><li>是不是dumpsys进程的负载太高？</li><li>是不是dumpsys进程死掉了，导致一直没有处理缓冲区数据？</li><li>是不是dumpsys进程有死锁？</li></ul><p>接下来的分析过程已经偏离Watchdog机制越来越远了，我们点到为止。</p><p>小伙伴们可以看到，场景还原涉及到的知识点非常之宽泛，而且有一定的深度。在没有现场的情况下，伴随一系列的假设和验证过程，充满了不确定性和发现问题的喜悦。 正所谓，同问题做斗争，其乐无穷！</p><p><strong>至此，我们分析Watchdog问题的惯用方法，回答前面提出来的第二个问题：</strong></p><p><strong>通过event或system类型的logcat日志，检索Watchdog出现的关键信息；通过traces，分析出导致Watchdog检查超时的直接原因；通过其他日志，还原出问题出现的场景。</strong></p><h2 id="4-实例分析"><a href="#4-实例分析" class="headerlink" title="4.实例分析"></a>4.实例分析</h2><p>在上面介绍Watchdog问题分析方法的时候，我们其实已经举了一个例子。通常，比较容易定位导致Watchdog出现的直接原因(Direct Cause)，但很难找到更深层次的原因(Root Cause)。 这个小节，我们再介绍一个实例，来分析Watchdog出现的另一种场景。诚然，仅凭几个例子，远不够涵盖Watchdog的所有问题，我们的章法还是按照一定的方法论来深究问题。</p><p>回顾一下解决问题三部曲：</p><ol><li>日志获取。日志种类繁多，分析Watchdog问题，宁滥毋缺</li><li>问题定位。从logcat中锁定watchdog的出现，从traces锁定直接原因</li><li>场景还原。结合各类日志，不断假设验证</li></ol><p><strong>以CPU占用过高的场景为例：<a href="http://duanqz.github.io/2015-10-12-Watchdog-Analysis">下载该问题的全部日志</a></strong></p><p><strong>从sys_log中，检索到了Watchdog的出现关键信息</strong></p><blockquote><p>TIPS: 在sys_log中搜索关键字”WATCHDOG KILLING SYSTEM PROCESS”</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bas">10-14 17:10:51.548   892  1403 W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked in handler on ActivityManager (ActivityManager)<br></code></pre></td></tr></table></figure><p>这是一个Watchdog的<strong>Looper Checker</strong>超时，由于ActivityManager这个线程一直处于忙碌状态，导致Watchdog检查超时。 Watchdog出现的时间是<strong>10-14 17:10:51.548</strong>左右，需要从traces.txt中找到这个时间段的system_server进程的函数调用栈信息， system_server的进程号是892。</p><p><strong>从traces.txt中找到对应的函数调用栈</strong></p><p>traces.txt包含很多进程在不同时间段的函数调用栈信息，为了检索的方便，首先可以将traces.txt分块。 笔者写了一个<a href="https://github.com/duanqz">工具</a>，可以从traces.txt文件中分割出指定进程号的函数调用栈信息。</p><blockquote><p>TIPS: 在system_server的traces中(通过工具分割出的system_server_892_2015-10-14-17:09:06文件)搜索关键字”ActivityManager”</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;ActivityManager&quot;</span> prio=5 tid=17 TimedWaiting<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=1 dsCount=0 obj=0x12c0e6d0 self=0x7f84caf000<br>  | sysTid=938 <span class="hljs-built_in">nice</span>=-2 cgrp=default <span class="hljs-built_in">sched</span>=0/0 handle=0x7f7d887000<br>  | state=S schedstat=( 107864628645 628257779012 60356 ) utm=7799 stm=2987 core=2 HZ=100<br>  | stack=0x7f6e68f000-0x7f6e691000 stackSize=1036KB<br>  | held mutexes=<br>  at java.lang.Object.<span class="hljs-built_in">wait</span>!(Native method)<br>  - waiting on &lt;0x264ff09d&gt; (a com.android.server.am.ActivityManagerService<span class="hljs-variable">$5</span>)<br>  at java.lang.Object.<span class="hljs-built_in">wait</span>(Object.java:422)<br>  at com.android.server.am.ActivityManagerService.dumpStackTraces(ActivityManagerService.java:5395)<br>  at com.android.server.am.ActivityManagerService.dumpStackTraces(ActivityManagerService.java:5282)<br>  at com.android.server.am.ActivityManagerService<span class="hljs-variable">$AnrActivityManagerService</span>.dumpStackTraces(ActivityManagerService.java:22676)<br>  at com.mediatek.anrmanager.ANRManager<span class="hljs-variable">$AnrDumpMgr</span>.dumpAnrDebugInfoLocked(SourceFile:1023)<br>  at com.mediatek.anrmanager.ANRManager<span class="hljs-variable">$AnrDumpMgr</span>.dumpAnrDebugInfo(SourceFile:881)<br>  at com.android.server.am.ActivityManagerService.appNotResponding(ActivityManagerService.java:6122)<br>  - locked &lt;0x21c77912&gt; (a com.mediatek.anrmanager.ANRManager<span class="hljs-variable">$AnrDumpRecord</span>)<br>  at com.android.server.am.BroadcastQueue<span class="hljs-variable">$AppNotResponding</span>.run(BroadcastQueue.java:228)<br>  at android.os.Handler.handleCallback(Handler.java:815)<br>  at android.os.Handler.dispatchMessage(Handler.java:104)<br>  at android.os.Looper.loop(Looper.java:192)<br>  at android.os.HandlerThread.run(HandlerThread.java:61)<br>  at com.android.server.ServiceThread.run(ServiceThread.java:46)<br></code></pre></td></tr></table></figure><p>ActivityManager线程实际上运行着AMS的消息队列，这个函数调用栈的关键信息：</p><ul><li>线程状态为TimedWaiting, 这表示当前线程阻塞在一个超时的wait()方法</li><li>正在处理广播消息超时发生的ANR(Application Not Responding)，需要将当前的函数调用栈打印出来</li><li>最终在&lt;0x264ff09d&gt;等待，可以从<a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActivityManagerService.java#4830">AMS的源码</a> 中找到这一处锁的源码，因为dumpStackTraces()会写文件，所以AMS设计了一个200毫秒的超时锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">observer.wait(<span class="hljs-number">200</span>);  <span class="hljs-comment">// Wait for write-close, give up after 200msec</span><br></code></pre></td></tr></table></figure><p><strong>还原问题的场景</strong></p><p>从ActivityManager这个线程的调用栈，我们就会有一些疑惑：</p><ul><li>是哪个应用发生了ANR？为什么会发生ANR？</li><li>超时锁只用200毫秒就释放了，为什么会导致Watchdog检查超时？(AMS的Looper默认超时是1分钟)</li></ul><p>带着这些疑惑，我们再回到日志中：</p><p>从sys_log中，可以检索到Watchdog出现的时间点(<strong>17:10:51.548</strong>)之前，com.android.systemui发生了ANR，从而引发AMS打印函数调用栈:</p><blockquote><p>⭐<strong>TIPS: 在sys_log中检索”ANR in”关键字或在event_log中检索”anr”关键字</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager: ANR in com.android.systemui, time=<span class="hljs-number">27097912</span><br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager: Reason: Broadcast of Intent &#123; act=android.intent.action.TIME_TICK flg=<span class="hljs-number">0x50000114</span> (has extras) &#125;<br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager: Load: <span class="hljs-number">89.22</span> / <span class="hljs-number">288.15</span> / <span class="hljs-number">201.91</span><br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager: Android time :[<span class="hljs-number">2015</span>-<span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.14</span>] [<span class="hljs-number">27280.396</span>]<br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager: CPU usage from 17016ms to 0ms ago:<br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager:   <span class="hljs-number">358</span>% <span class="hljs-number">23682</span>/float_bessel: <span class="hljs-number">358</span>% user + <span class="hljs-number">0</span>% kernel<br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager:   <span class="hljs-number">57</span>% <span class="hljs-number">23604</span>/debuggerd64: <span class="hljs-number">3.8</span>% user + <span class="hljs-number">53</span>% kernel / faults: <span class="hljs-number">11369</span> minor<br><span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">17</span>:<span class="hljs-number">10</span>:<span class="hljs-number">04.215</span>   <span class="hljs-number">892</span>   <span class="hljs-number">938</span> E ANRManager:   <span class="hljs-number">2</span>% <span class="hljs-number">892</span>/system_server: <span class="hljs-number">0.9</span>% user + <span class="hljs-number">1</span>% kernel / faults: <span class="hljs-number">136</span> minor<br></code></pre></td></tr></table></figure><p>从这个日志信息中，我们两个疑惑就释然了：</p><p>发生ANR之前的CPU负载远高于正常情况好几倍(Load： 89.22 &#x2F; 288.15 &#x2F; 201.91)，在这种CPU负载下，com.android.systemui进程发生处理广播消息超时(Reason: Broadcast of Intent)再正常不过了。 在这之前CPU都被<strong>float_bessel</strong>这个进程给占了，这货仅凭一己之力就耗了358%的CPU资源。</p><p>observer.wait(200)在调用后，便进入排队等待唤醒状态(Waiting)，在等待200毫秒后，便重新开始申请CPU资源，而此时，CPU资源一直被<strong>float_bessel</strong>占着没有释放，所以该线程一直在等CPU资源。 等了1分钟后，Watchdog跳出来说“不行，你已经等了1分钟了，handler处理其他消息了”。</p><p>在多核情况下，CPU的使用率统计会累加多个核的使用率，所以会出现超过100%的情况。那么<strong>float_bessel</strong>究竟是什么呢？它是一个Linux的测试样本，贝塞尔函数的计算，耗的就是CPU。</p><p>这样，该问题的场景我们就还原出来了：在压力测试的环境下，CPU被<strong>float_bessel</strong>运算占用，导致com.android.systemui进程发生ANR，从而引发AMS打印trace; 但由于AMS一直等不到CPU资源，Watchdog检测超时，杀掉system_server进程，系统重启。</p><p>对于压力测试而言，我们一般会设定一个通过标准，在某些压力情况下，出现一些错误是允许的。对于Android实际用户的使用场景而言，本例中的压力通常是不存在的，所以在实际项目中，这种类型的Watchdog问题，我们一般不解决。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>Android中Watchdog用来看护system_server进程，system_server进程运行着系统最终要的服务，譬如AMS、PKMS、WMS等， 当这些服务不能正常运转时，Watchdog可能会杀掉system_server，让系统重启。</p><p>Watchdog的实现利用了锁和消息队列机制。当system_server发生死锁或消息队列一直处于忙碌状态时，则认为系统已经没有响应了(System Not Responding)。</p><p>在分析Watchdog问题的时候，首先要有详尽的日志，其次要能定位出导致Watchdog超时的直接原因，最重要的是能还原出问题发生的场景。</p><blockquote><ol><li>从logcat中锁定watchdog的出现【WATCHDOG KILLING SYSTEM PROCESS:】</li><li>从traces锁定直接原因</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【实验】fork子进程超时控制</title>
    <link href="/2023/08/08/fork%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/08/08/fork%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="【实验】fork子进程超时控制"><a href="#【实验】fork子进程超时控制" class="headerlink" title="【实验】fork子进程超时控制"></a>【实验】fork子进程超时控制</h1><h2 id="1-waitpid函数"><a href="#1-waitpid函数" class="headerlink" title="1.waitpid函数"></a>1.waitpid函数</h2><p><a href="https://blog.csdn.net/qq_21438461/article/details/130318658">https://blog.csdn.net/qq_21438461/article/details/130318658</a></p><img src="/2023/08/08/fork%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/image-20230808232639527.png" alt="image-20230808232639527" style="zoom:80%;"><h2 id="2-实验"><a href="#2-实验" class="headerlink" title="2.实验"></a>2.实验</h2><h3 id="2-1-子进程超时"><a href="#2-1-子进程超时" class="headerlink" title="2.1 子进程超时"></a>2.1 子进程超时</h3><p>假设子进程是超时的情况</p><ul><li>子进程假设需要阻塞5秒，而父进程做超时判断：超过3秒就给子进程发送kill 9命令</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pid;<br><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>);<br>        _exit(<span class="hljs-number">127</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork child process failed\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> cout = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">pid_t</span> pidNo;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        pidNo = <span class="hljs-built_in">waitpid</span>(pid, &amp;status, WNOHANG);<br>        <span class="hljs-keyword">if</span> (pidNo == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cout &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">kill</span>(<span class="hljs-number">9</span>, pid);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;time out\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            cout--;<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pidNo == pid) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process exit\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>    &#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;count = %d\n&quot;</span>, cout);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/08/08/fork%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/image-20230808225916097.png" alt="image-20230808225916097" style="zoom: 80%;"><h3 id="2-2-子进程执行正常退出"><a href="#2-2-子进程执行正常退出" class="headerlink" title="2.2 子进程执行正常退出"></a>2.2 子进程执行正常退出</h3><p>子进程不会超时，正常退出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pid;<br><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">5</span>);<br>        _exit(<span class="hljs-number">127</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork child process failed\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> cout = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">pid_t</span> pidNo;<br>    <span class="hljs-built_in">usleep</span>(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 很重要，先阻塞父进程5000us=5us</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        pidNo = <span class="hljs-built_in">waitpid</span>(pid, &amp;status, WNOHANG);<br>        <span class="hljs-keyword">if</span> (pidNo == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cout &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">kill</span>(<span class="hljs-number">9</span>, pid);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;time out\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            cout--;<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pidNo == pid) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process exit\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;count = %d\n&quot;</span>, cout);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/08/08/fork%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/image-20230808231541388.png" alt="image-20230808231541388" style="zoom: 80%;"><h2 id="3-两个现象"><a href="#3-两个现象" class="headerlink" title="3.两个现象"></a>3.两个现象</h2><h3 id="3-1-超时不准确"><a href="#3-1-超时不准确" class="headerlink" title="3.1 超时不准确"></a>3.1 超时不准确</h3><p>1.如果使用了usleep函数，发现有问题，<strong>超时不准确</strong></p><ul><li>子进程阻塞了5s，用count和usleep组合为3s，但实际运行了5s</li><li>最后发现即使5s过去了， count值还剩850，说明3000个1ms走完可能要花费远大于3s</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pid;<br><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>);<br>        _exit(<span class="hljs-number">127</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork child process failed\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> cout = <span class="hljs-number">3000</span>;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">pid_t</span> pidNo;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        pidNo = <span class="hljs-built_in">waitpid</span>(pid, &amp;status, WNOHANG);<br>        <span class="hljs-keyword">if</span> (pidNo == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cout &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">kill</span>(<span class="hljs-number">9</span>, pid);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;time out\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            cout--;<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">1000</span>);  <span class="hljs-comment">// 1000us=1ms</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pidNo == pid) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process exit\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;count = %d\n&quot;</span>, cout);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/08/08/fork%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/image-20230808230433343.png" alt="image-20230808230433343" style="zoom: 80%;"><p><strong>测试一下3000个1ms走完要多久</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">3000</span>;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3000</span>; i++) &#123;<br>        usleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/08/08/fork%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/image-20230808230828799.png" alt="image-20230808230828799" style="zoom:80%;"><p>🔴 <strong>对于不同性能的机器，时间函数准确度不同，这对用户显然是不能接受的！</strong></p><h3 id="3-2-时间滞后"><a href="#3-2-时间滞后" class="headerlink" title="3.2 时间滞后"></a>3.2 时间滞后</h3><ul><li>子进程只执行了5us，但是程序走完却花了1s，从count检出，其多等待了1s</li><li>所以其实时间是滞后的，这也是为什么我在2.2节中在while循环前先阻塞父进程5000us(5ms)的原因；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> pid;<br><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        usleep(<span class="hljs-number">5</span>);<br>        _exit(<span class="hljs-number">127</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork child process failed\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">cout</span> = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">pid_t</span> pidNo;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        pidNo = waitpid(pid, &amp;status, WNOHANG);<br>        <span class="hljs-keyword">if</span> (pidNo == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cout</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>                kill(<span class="hljs-number">9</span>, pid);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;time out\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">cout</span>--;<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pidNo == pid) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process exit\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;count = %d\n&quot;</span>, <span class="hljs-built_in">cout</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/08/08/fork%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/image-20230808231706623.png" alt="image-20230808231706623" style="zoom:80%;"><h3 id="3-3-体会"><a href="#3-3-体会" class="headerlink" title="3.3 体会"></a>3.3 体会</h3><p>根据3.1和3.2之间，我们要平衡好对用户体验的差别。</p><ul><li>即使子进程执行成功了，让用户多等1s</li><li>另外如果while循环中使用了usleep，但却达不到实际的计时效果。</li></ul><p>所以我的建议是在while前循环中牺牲一点点的时间【阻塞父进程一小会】，然后在while循环里面使用粒度更高的sleep函数。至于while前面阻塞多久，while循环里面一次sleep(x)，x取多少，需要一个平衡点。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统checkpoint特性</title>
    <link href="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/"/>
    <url>/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统checkpoint特性"><a href="#f2fs文件系统checkpoint特性" class="headerlink" title="f2fs文件系统checkpoint特性"></a>f2fs文件系统checkpoint特性</h1><p>相较于很多文章一上来解读代码，我更愿意从问题出现的背景开始讲起，一个技术如果没有时代背景，他的出现显得像个怪胎。</p><h2 id="崩溃一致性问题"><a href="#崩溃一致性问题" class="headerlink" title="崩溃一致性问题"></a>崩溃一致性问题</h2><p>对于一般的文件系统而言，如果我要对文件做追加动作，我们需要做哪些事情呢，罗列一下：</p><ol><li>文件关联的inode表明了文件的基本属性，所以当我们往一个文件里面追加内容的时候，inode的大小，修改时间等都需要修改；这个在f2fs文件系统里面就是f2fs_node啦。</li><li>当需要添加的内容很大的时候，需要分配额外的数据块；在f2fs文件系统里面表现为Data Block也就是Data Segment里面的一个个block</li><li>在FAT文件系统里面通常使用簇链Cluster Chain来表示一个完整的文件，当我们添加文件的内容时需要将原先指向EOF的Cluster指向新增的Cluster，而新增的Cluster指向EOF；在F2fs文件系统里面通常使用Node Block来表示一个完整的文件，当我们添加文件的内容时需要更改node block里面的i_addr或者指向的direct node和indirect node。</li><li>另外一个对于F2fs文件系统比较特殊的是，在元数据区域内有NAT，SIT和SSA区域，当我们添加文件内容时，需要更新元数据区。</li></ol><p>我们将上面的内容进行抽象，即Inode修改，MetaData修改，和Data Block修改。用一个集合表示<code>&#123;INode，Metadata，DataBlock&#125;</code>，所以我们要修改的Block起码涉及3处，假如在这个集合任意一处发生了系统崩溃或者系统断电，那么将造成一个问题，三个区域的数据内容对不上，这样就引发了崩溃一致性问题。</p><hr><h2 id="解决崩溃一致性问题"><a href="#解决崩溃一致性问题" class="headerlink" title="解决崩溃一致性问题"></a>解决崩溃一致性问题</h2><p>崩溃一致性问题，在一般的教科书上，通常有2种方式：FSCK和Jounral机制。</p><ul><li>Fsck基本原理就是检查目录项数据与元数据是否一样，如果不一样的话，通过一定的算法进行Recovery【要么修改目录项保持和元数据一样，要么根据元数据修改目录项，这个看起来是废话，但是对于fsck.msdos这就是裁剪簇链或者更新目录项的基本思想】</li><li>本文不探讨Fsck，解决崩溃一致性问题比较有效的还是Journal机制，也就是写日志，也是借鉴了数据库的思想。</li></ul><blockquote><p>这里借助南大蒋炎岩老师的思路往下说：</p></blockquote><p>对于一个二叉树，有2个视角，一个是数据结构视角，一个是文件操作视角。</p><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230807231209215.png" alt="image-20230807231209215" style="zoom:80%;"><p>中序遍历的结果为：<strong>12345</strong></p><p>从文件操作的角度看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-number">4</span><br><span class="hljs-keyword">insert</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">insert</span> <span class="hljs-number">5</span><br><span class="hljs-keyword">insert</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">insert</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>这样我们就可以通过记录所有的文件操作，反向还原出这棵树的原样。</p><hr><p><strong>两个“视角”</strong></p><ol><li>存储实际数据结构<ul><li>文件系统的”直观”表示</li><li>crash unsafe</li></ul></li><li>Append-only记录所有历史操作<ul><li>“重做”所有操作得到数据结构的当前状态</li><li>容易实现崩溃一致性</li></ul></li></ol><p><strong>两者的融合</strong></p><ul><li>数据结构发生时，用（2）append-only记录日志</li><li>日志落盘后，用（1）更新数据结构</li><li>崩溃后，重放日志并清除（称为redo log；相应也可以undo log）</li></ul><h2 id="抽象Journal过程"><a href="#抽象Journal过程" class="headerlink" title="抽象Journal过程"></a>抽象Journal过程</h2><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230817222646785.png" alt="image-20230817222646785" style="zoom:67%;"><ol><li><p>通过bread扫描磁盘找到可以写入新的journal的起始位置</p></li><li><p>开始bwrite写入TxBegin，表示事务开始了</p></li><li><p>开始bwrite写入许多的文件操作</p></li><li><p>文件操作写完之后，一定要先调用bflush确保前面所有的操作日志落盘</p></li><li><p>bwrite写入TxEnd，表示整个事务结束了</p></li><li><p>最后一样要调用bflush，确保整个是事务数据都落盘了</p><ul><li><p>当存在系统崩溃Crash</p></li><li><p>恢复的时候只要看有没有TxEnd标志，如果没有就将整个事务Transaction全部丢弃</p></li><li><p>只要有TxEnd，就能100%确保前面的所有操作日志已经落盘了</p></li></ul></li><li><p>后面就真正的去更新数据区域Main Data Area里面的数据块就行了</p></li></ol><hr><p><strong>Journaling的优化：</strong></p><p>现在磁盘都需要写入双份的日志journal</p><ul><li>批处理(xv6;jbd)<ul><li>多次系统调用的Tx合并成一个，减少log大小</li><li>jdb：定期writeback</li></ul></li><li>CheckSum(Ext4)<ul><li>不再标记TxBegin&#x2F;TxEnd</li><li>直接标记Tx的长度和checksum</li><li>当Tx的长度和checksum相等，表明是一次完整的journal</li></ul></li><li>Metadata journaling(ext4 default)<ul><li>数据占磁盘写入的绝大部分<ul><li>只对inode和bitmap做journaling可以提高性能</li></ul></li><li>保证文件系统的目录结构是一样的，但数据可能丢失</li></ul></li></ul><h2 id="书面化的Journal"><a href="#书面化的Journal" class="headerlink" title="书面化的Journal"></a>书面化的Journal</h2><p>✉️ <strong>摘抄自：《操作系统导论》</strong></p><blockquote><p>对于一致更新问题，最流行的解决方案可能是从数据库管理系统的世界中借鉴的一个想法。这种名为预写日志（write-ahead logging）的想法，是为了解决这类问题而发明的。在文件系统中，出于历史原因，我们通常将预写日志称为日志（journaling）。第一个实现它的文件系统是 Cedar ，但许多现代文件系统都使用这个想法，包括 Linux ext3 和 ext4、reiserfs、IBM 的 JFS、SGI 的 XFS 和 Windows NTFS。</p></blockquote><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230817224041664.png" alt="image-20230817224041664" style="zoom:80%;"><blockquote><p>这里的加检查点可能还是比较抽象，简单的说：</p><p>数据日志（data journaling）的工作原理是，在将 inode、位图和数据块写入磁盘位置之前，先将它们写入日志。对于这个请求添加事务标记构成一个事务，一旦这个事务安全地存在于磁盘上，我们就可以在系统中打一个时间戳，表明整个操作日志已经顺利落盘了。打完时间戳，就开始将inode、位图和数据块写入到磁盘。这个整个过程成为加检查点，所以checkpoint是一个行为，是一个动作，在f2fs文件系统里面表现为do_checkpoint函数。当我们恢复的时候只要找到最近的一个时间戳，把它记录的事务日志重做一遍就行。</p></blockquote><blockquote><p><strong>数据恢复的过程：</strong></p><p>如果崩溃发生在事务被安全地写入日志之前，那只需要简单地跳过待执行的更新。如果在事务已提交到日志之后，但在加检查点完成之前发生崩溃，可以在系统引导时，文件系统恢复过程将扫描日志，并查找已提交到磁盘的事务。然后将这些事务重放（replayed），文件系统再次尝试将事务中的块写入它们最终的磁盘位置，称为<strong>重做日志（redo logging）</strong>。</p></blockquote><hr><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230817223902687.png" alt="image-20230817223902687" style="zoom: 80%;"><h2 id="数据库的前滚恢复和后滚恢复"><a href="#数据库的前滚恢复和后滚恢复" class="headerlink" title="数据库的前滚恢复和后滚恢复"></a>数据库的前滚恢复和后滚恢复</h2><p><strong>注：不针对某一个具体的数据库，这里只讨论思想</strong></p><p><strong>前滚：</strong></p><blockquote><p>未完全提交的事务，即该事务已经被执行commit命令了，只是现在该事务修改所对应的脏数据块中只有一部分被写到磁盘上的数据文件中，还有一部分已经被置为提交标记的脏块还在内存上，如果此时数据库实例崩溃了，则当数据库实例恢复时，就需要用前滚（这个机制）来完成事务的完全提交，即将先前那部分已经被置为提交标记且还在内存上的脏块写入到磁盘上的数据文件中。</p></blockquote><p><strong>回滚（后滚）：</strong></p><blockquote><p>未提交的事务，即该事务未被执行commit命令。但是此时，该事务修改的脏块中也有可能一部分脏块写入到数据文件中了。如果此时数据库实例崩溃了，则当数据库实例恢复时，就需要用回滚（这个机制）来将先前那部分已经写入到数据文件的脏块从数据文件上撤销掉。</p></blockquote><p><strong>数据库Crash Recovery过程：</strong></p><ol><li>首先进行前滚：在重做日志redolog中找到最近检查点位置，然后从该检查点位置开始往下，应用所有的重做条目，从而在buffer cache里又恢复了实例崩溃那个时间点的状态。这个过程叫做前滚，前滚完毕以后，buffer cache里既有崩溃时已经提交还没有写入数据文件的脏数据块，也还有事务被突然终止，而导致的既没有提交又没有回滚的事务所弄脏的数据块。</li><li>前滚一旦完毕，立即打开数据库。但是，这时的数据库中还含有那些中间状态的、既没有提交又没有回滚的脏块，这种脏块是不能存在于数据库中的，因为它们并没有被提交，必须被回滚。打开数据库以后，进程会在后台进行回滚。</li></ol><p><strong>数据库Crash Recovery示例：</strong></p><p>程序员在9:00:00打卡开始上班，触发了5个事务，分别是T1，T2，T3，T4，T5。在9:07:46的时候，T3和T5完成（commit），在9:08:00的时候发生了检查点事件，此时系统将对数据区的更改都写入到磁盘数据文件中，在9:08:27时，系统异常断电，因此9:08:00到9:08:27之间的数据操作都仅仅记录在redo log中，并没有将这些修改写入到磁盘数据文件中。当重新启动数据库时，会进行Crash Recovery，整个过程分为前滚和后滚。前滚是指9:08:00至9:08:27的操作重新保存到Buffer Cache中，由于这些操作都记录在了redo log中，因此只需要从redo log中读取这些操作并执行即可。前滚执行完毕以后，会立即打开数据库，此时数据库吃鱼异常关闭前的状态。打开数据库后进入回滚，回滚阶段是指将未提交的事务回滚，即示例中的T1、T2和T4回滚，此时数据库恢复正常。</p><blockquote><p>需要注意一下：不是只有commit才会触发写入redo log，事务开始后会有各种场景触发redo log写入。</p></blockquote><h2 id="F2FS文件系统Checkpoint机制"><a href="#F2FS文件系统Checkpoint机制" class="headerlink" title="F2FS文件系统Checkpoint机制"></a>F2FS文件系统Checkpoint机制</h2><h3 id="f2fs-checkpoint数据结构"><a href="#f2fs-checkpoint数据结构" class="headerlink" title="f2fs_checkpoint数据结构"></a>f2fs_checkpoint数据结构</h3><p>首先我们看论文《F2FS: A New File System for Flash Storage》怎么说的</p><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230820215948710.png" alt="image-20230820215948710" style="zoom:50%;"><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230820220002296.png" alt="image-20230820220002296" style="zoom:50%;"><p>checkpoint区域主要有以下几个部分：</p><ul><li>Header和footer：在每一个checkpoint pack中都有header和footer。checkpoint会在header和footer中都存储一个cp版本号，随着每一次checkpoint动作发生，会依次递增。当进行挂载的时候，当cp_pack中的header和footer相等认为该cp是有效的，否则备份区域有效。如果主备份区域都是有效的，选择时间点最近的一个cp区域。</li><li>nat_bitmap和sit_bitmap：nat_bitmap表示当前的block是在nat主区还是nat备区；sit_bitmap表示当前segment的分配情况【存疑，是否也是用于区分主备区】。</li><li>nat_journal和sit_journal：是nat区域和sit区域的journal日志，详见：<a href="https://anmuxixixi.github.io/2023/07/23/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FJournal%E6%9C%BA%E5%88%B6/">f2fs文件系统Journal机制_</a></li><li>summary blocks of active segments：</li><li>Orphan block：存放孤儿节点打信息。</li></ul><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/1.png" alt="在这里插入图片描述" style="zoom:80%;"><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/5.png" alt="在这里插入图片描述" style="zoom:80%;"><p>对应的数据结构为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_checkpoint</span> &#123;</span><br>    __le64 checkpoint_ver;      <span class="hljs-comment">/* checkpoint block version number */</span><br>    __le64 user_block_count;    <span class="hljs-comment">/* # of user blocks */</span><br>    __le64 valid_block_count;   <span class="hljs-comment">/* # of valid blocks in main area */</span><br>    __le32 rsvd_segment_count;  <span class="hljs-comment">/* # of reserved segments for gc */</span><br>    __le32 free_segment_count;  <span class="hljs-comment">/* # of free segments in main area */</span><br><br>    <span class="hljs-comment">/* information of current node segments */</span><br>    __le32 cur_node_segno[MAX_ACTIVE_NODE_LOGS];<br>    __le16 cur_node_blkoff[MAX_ACTIVE_NODE_LOGS];<br>    <span class="hljs-comment">/* information of current data segments */</span><br>    __le32 cur_data_segno[MAX_ACTIVE_DATA_LOGS];<br>    __le16 cur_data_blkoff[MAX_ACTIVE_DATA_LOGS];<br>    __le32 ckpt_flags;      <span class="hljs-comment">/* Flags : umount and journal_present */</span><br>    __le32 cp_pack_total_block_count;   <span class="hljs-comment">/* total # of one cp pack */</span><br>    __le32 cp_pack_start_sum;   <span class="hljs-comment">/* start block number of data summary */</span><br>    __le32 valid_node_count;    <span class="hljs-comment">/* Total number of valid nodes */</span><br>    __le32 valid_inode_count;   <span class="hljs-comment">/* Total number of valid inodes */</span><br>    __le32 next_free_nid;       <span class="hljs-comment">/* Next free node number */</span><br>    __le32 checksum_offset;     <span class="hljs-comment">/* checksum offset inside cp block */</span><br>    __le64 elapsed_time;        <span class="hljs-comment">/* mounted time */</span><br>    <span class="hljs-comment">/* allocation type of current segment */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> alloc_type[MAX_ACTIVE_LOGS];<br><br>    <span class="hljs-comment">/* SIT and NAT version bitmap */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sit_nat_version_bitmap[];<br>&#125; __packed;<br></code></pre></td></tr></table></figure><h3 id="checkpoint作用"><a href="#checkpoint作用" class="headerlink" title="checkpoint作用"></a>checkpoint作用</h3><p>看论文《F2FS: A New File System for Flash Storage》怎么说的</p><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230820215120800.png" alt="image-20230820215120800" style="zoom:50%;"><p>从F2FS的磁盘布局可以了解到，F2FS有一个元数据区域，用于集中管理磁盘所有的block的信息，因此F2FS使用了检查点(checkpointing)机制去维护文件系统的恢复点(recovery point)，这个恢复点用于在系统突然崩溃的时候，元数据区域依然能够正确地将数据重新读取出来。因此保证元数据区域的有效性以及恢复性。当F2FS需要通过 <code>fsync</code> 或 <code>umount</code> 等命令对系统进行同步的时候，F2FS会触发一次Checkpoint机制，它会完成以下的工作:</p><ol><li>页缓存的脏node和dentry block会刷写回到磁盘;</li><li>挂起系统其他的写行为，如create，unlink，mkdir；</li><li>将系统的meta data，如NAT、SIT、SSA的数据写回磁盘;</li><li>更新checkpoint的状态，包括checkpoint的版本，NAT和SIT的bitmaps以及journals，SSA，Orphan inode</li></ol><h3 id="后滚恢复原理Roll-Back-Recovery"><a href="#后滚恢复原理Roll-Back-Recovery" class="headerlink" title="后滚恢复原理Roll-Back Recovery"></a>后滚恢复原理Roll-Back Recovery</h3><p>看论文《F2FS: A New File System for Flash Storage》怎么说的</p><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230727232432068.png" alt="image-20230727232432068" style="zoom: 50%;"><p>突然出现断电异常以后，F2FS会回滚到最近的一次检查点。为了确保最少有一个稳定的检查点，F2fS会维护两份checkpoint pack，如果一个checkpoint pack的头部和尾部是一致的，我们认为他是有效的，否则就丢弃它里面的内容。</p><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230727232815934.png" alt="image-20230727232815934" style="zoom: 50%;"><p>后滚恢复发生的F2FS文件系统挂载的时候，它会去检查checkpoint pack的头部和尾部。如果2个checkpoint pack都是有效的，F2FS会比较cp1和cp2的版本，最终会选择版本最新的那一个。同时会去检查选择的cp是否存在孤儿节点，如果存在会将它引用的数据块全部截断。</p><hr><p>因为后滚恢复发生在了mount阶段，先简单说下调用调用栈：</p><p><strong>f2fs_mount -&gt; f2fs_fill_super -&gt; f2fs_get_valid_checkpoint</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f2fs_get_valid_checkpoint</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi)</span> &#123;<br>sbi-&gt;ckpt = f2fs_kvzalloc(sbi, array_size(blk_size, cp_blks),<br>  GFP_KERNEL);<br>    <br>    <span class="hljs-comment">// cp1的起始地址</span><br>cp_start_blk_no = le32_to_cpu(fsb-&gt;cp_blkaddr);<br>    <span class="hljs-comment">// 获取cp1的版本号，同时cp1是一个页，对应了cp区域的一个block</span><br>cp1 = validate_checkpoint(sbi, cp_start_blk_no, &amp;cp1_version);<br><br><span class="hljs-comment">// cp2的起始地址</span><br>cp_start_blk_no += ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-number">1</span>) &lt;&lt;<br>le32_to_cpu(fsb-&gt;log_blocks_per_seg);<br>    <span class="hljs-comment">// 获取cp2的版本号，同时cp2是一个页，对应了cp区域的一个block</span><br>cp2 = validate_checkpoint(sbi, cp_start_blk_no, &amp;cp2_version);<br><br>    <span class="hljs-comment">// 如果2个cp pack都是有效的，选择最新的那个</span><br><span class="hljs-keyword">if</span> (cp1 &amp;&amp; cp2) &#123;<br><span class="hljs-keyword">if</span> (ver_after(cp2_version, cp1_version))<br>cur_page = cp2;<br><span class="hljs-keyword">else</span><br>cur_page = cp1;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cp1) &#123;<br>cur_page = cp1;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cp2) &#123;<br>cur_page = cp2;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>err = -EFSCORRUPTED;<br><span class="hljs-keyword">goto</span> fail_no_cp;<br>&#125;<br><br>cp_block = (<span class="hljs-keyword">struct</span> f2fs_checkpoint *)page_address(cur_page);<br><span class="hljs-built_in">memcpy</span>(sbi-&gt;ckpt, cp_block, blk_size);  <span class="hljs-comment">// 拷贝到内存中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我不想花太多的经历去研究所谓的checksum算法，也就是如何确保头部和尾部是一样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">validate_checkpoint</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi,</span><br><span class="hljs-params"><span class="hljs-type">block_t</span> cp_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> *version)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">cp_page_1</span> =</span> <span class="hljs-literal">NULL</span>, *cp_page_2 = <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_checkpoint</span> *<span class="hljs-title">cp_block</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> cur_version = <span class="hljs-number">0</span>, pre_version = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> err;<br><br>    <span class="hljs-comment">// 获取cp pack中page1的版本号【也就是头部】</span><br>err = get_checkpoint_version(sbi, cp_addr, &amp;cp_block, &amp;cp_page_1, version);<br>pre_version = *version;<br><br>    <span class="hljs-comment">// 获取cp pack中page2的版本号【也就是尾部】</span><br>cp_addr += le32_to_cpu(cp_block-&gt;cp_pack_total_block_count) - <span class="hljs-number">1</span>;<br>err = get_checkpoint_version(sbi, cp_addr, &amp;cp_block, &amp;cp_page_2, version);<br>cur_version = *version;<br><br>    <span class="hljs-comment">// 判断头部尾部是不是相等</span><br><span class="hljs-keyword">if</span> (cur_version == pre_version) &#123;<br>*version = cur_version;<br>f2fs_put_page(cp_page_2, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> cp_page_1;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就不去研究这个crc值怎么算的了：</p><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230727234038768.png" alt="image-20230727234038768" style="zoom: 67%;"><ul><li>首先获取到cp起始位置偏移0xffc后的4个字节值</li><li>然后计算cp区域的crc值</li><li>将计算出来的值和cp区域保存的值比较，判断是不是一致的，也就是判断CP区域的数据是不是记录全了，日志是不是完备的。</li></ul><hr><p>算了，简单说一下CP区域里面保存的那个<strong>cp起始位置偏移0xffc后的4个字节值</strong>怎么来的？</p><ol><li>当我们执行mkfs.f2fs格式化磁盘的时候，会调用这里</li></ol><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230727234351910.png" alt="image-20230727234351910" style="zoom:75%;"><ol start="2"><li>计算CRC值以后记录到对应的位置</li></ol><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230727234432799.png" alt="image-20230727234432799" style="zoom:75%;"><h3 id="前滚恢复原理Roll-Forward-Recovery"><a href="#前滚恢复原理Roll-Forward-Recovery" class="headerlink" title="前滚恢复原理Roll-Forward Recovery"></a>前滚恢复原理Roll-Forward Recovery</h3><p>还是先看论文《F2FS: A New File System for Flash Storage》怎么说的</p><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230820214217698.png" alt="image-20230820214217698" style="zoom:50%;"><img src="/2023/07/26/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fcheckpoint%E7%89%B9%E6%80%A7/image-20230820214243206.png" alt="image-20230820214243206" style="zoom:50%;"><p>应用程序常常会调用fsync完成一些同步性的请求，为了满足这个同步性的请求，一个简单的方法是每次调用fsync都写一次Checkpoint。然而，由于Checkpoint需要同时写入大量与调用fsync的应用程序无关的node、 dentry block等数据，因此这是一个大开销的操作，会影响到手机的流畅性。</p><p>因此，F2FS使用了高效的前滚恢复方式以优化fsync的性能。核心的概念是只写入data block和direct node到磁盘，但是而不写入其他元数据。F2FS具体实现是在fsync操作完成之后，给每一个相关的direct node加上一个特殊的标记位。当系统后滚恢复到了一个稳定的Checkpoint后，F2FS会选择性地(通过标记位)通过前滚恢复恢复一些已经fsync到磁盘，但是没有被元数据索引的一些数据。</p><p>一个典型的场景是：当完成一次写操作后，需要更新node page和data block，然后执行fsync，node page以及data block在submit bio后就完成了数据写入磁盘。此时需要注意的是nat bitmap是在checkpoit的地方更新的，优化后的fsync，不会每一次fsync都会执行checkpoint。但是如果在checkpoint之前出现了宕机，虽然node page和data page本身已经写入了磁盘，但是丢失了nat bitmap，因此无法索引这些已经写入磁盘的node page和data page，这时就要利用前滚恢复机制，重新建立索引。</p><p>前滚恢复的原理如下:</p><ol><li>假设上一次稳定的Checkpoint的日志位置是N</li><li>F2FS收集了日志位置是N+n的，含有特殊标记位的direct node block，这些block之间组成一个list用于表示node information，其中n表示上一次稳定的Checkpoint之后写入了多少个block。通过这个list中的node information，系统将距离上一次稳定的Checkpoint最靠近的被更新的node block(日志位置是N-n)，载入到cache当中。</li><li>比较日志位置是N-n和N+n的数据是否一致，如果不一致则使用N+n的数据覆盖已经缓存的N-n的node block，然后标记为脏。</li><li>执行写Checkpoint流程，刷新元数据。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>日志型文件系统</title>
    <link href="/2023/07/26/%E6%97%A5%E5%BF%97%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/07/26/%E6%97%A5%E5%BF%97%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="日志型文件系统"><a href="#日志型文件系统" class="headerlink" title="日志型文件系统"></a>日志型文件系统</h1><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/107558961">https://zhuanlan.zhihu.com/p/107558961</a></p></blockquote><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p><strong>日志式文件系统 （Journaling filesystem）</strong></p><ol><li><p>预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息；</p></li><li><p>实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据；</p></li><li><p>结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。</p></li></ol><p><strong>日志式文件的功能：</strong>数据的记录过程中发生了问题，那么系统只要去检查日志记录区块，就可以知道哪个文件发生了问题，针对该问题做一致性的检查，不必对整块filesystem去检查，这样就可以达到快速修复filesystem的能力。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>位于磁盘上的文件系统需要面临的一个问题是：当系统crash或者意外掉电的时候，如何维持数据的一致性。比如现在为了完成某项功能，需要同时更新文件系统中的两个数据结构A和B，因为磁盘每次只能响应一次读写请求，势必造成A和B其中一者的更新先被磁盘接收处理。如果正好在其中一个更新完成后发生了掉电或者crash，那么就会造成不一致的状态。</p><p>假设一个文件系统在磁盘上的分布是这样的：其中包括一个文件的inode（即I[v1]），data block（即Da）和记录分配状态的inode bitmap, data bitmap。</p><img src="/2023/07/26/%E6%97%A5%E5%BF%97%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/v2-0d1621b2e45ee4a48f2e02cb7f9b3ba8_720w.jpeg" alt="img" style="zoom:67%;"><p>现在要在文件末尾追加一部分内容，那么需要分配一个新的data block（即Db），这会导致inode和data bitmap都发生相应的变化。</p><img src="/2023/07/26/%E6%97%A5%E5%BF%97%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/v2-f26dfcb482ef977fc5ff81480b38266f_720w.webp" alt="img" style="zoom:67%;"><p>因此需要对磁盘的三个不同位置（3个blocks）分别进行写操作，如果在这三次写操作的间隙发生了crash，那么可能出现若干种情况：只更新了其中一个部分，或者只更新了其中的两个部分。</p><p>传统的Unix系统对此的解决办法是使用fsck工具，但是fsck通常需要在发生crash重启后，扫描整个磁盘，繁琐且速度较慢，因此目前更流行的做法是使用日志（<strong>Journaling</strong>）。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>日志型文件系统的基本思想是这样的：在真正更新磁盘上的数据之前，先往磁盘上写入一些信息，这些信息主要是描述接下来要更新什么，相当于 <strong>wrtie ahead</strong>，因此这种方式又被称为write-ahead logging。</p><p>这样，即便发生crash，也可通过记录的日志信息，回溯并恢复crash前正在进行的操作（称为<strong>replay</strong>）。在更新的时候增加一点额外的操作，换来了recovery时所需的工作量的减少。</p><p>在Linux中，ext2文件系统将磁盘划分成若干个block groups，每个block group包含一个inode bitmap, data bitmap, inodes和若干个data blocks，它没有使用日志。</p><img src="/2023/07/26/%E6%97%A5%E5%BF%97%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/v2-2815b51c09d65b8aa50b604409709e7e_720w.png" alt="img" style="zoom:67%;"><p>而在ext3文件系统中，加入了对日志的支持，日志部分单独占据一块磁盘空间。</p><img src="/2023/07/26/%E6%97%A5%E5%BF%97%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/v2-0341a084fee9daf8237093a781776845_720w.png" alt="img" style="zoom:67%;"><p>还是前面那个例子，现在我们要更新磁盘上的inode（I[v2]）, bitmap（B[v2]）和data block （Db）。在更新这个数据之前，我们把这个更新操作的步骤（称为一个 <strong>transcation</strong>），加上分别表示这个transcation开始和结束的TxB和TxE，写入磁盘。</p><p>Transaction的概念起源于数据库领域，它有助于在操作未能完成的情况下保证数据的一致性。同一transcation的TxB和TxE具有相同的sequence number。</p><img src="/2023/07/26/%E6%97%A5%E5%BF%97%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/v2-610cee7e2e5d28b1484ffd19c283724b_720w.png" alt="img" style="zoom:67%;"><p>在一个记录步骤信息的transcation完成之后，才真正地更新磁盘上的文件数据（这一步称为<strong>checkpoint</strong>）。</p><p>Journal是为了保证数据一致性的，而journal本身也是由多个部分组成，那在写入journal的过程中发生了crash怎么办？由于I&#x2F;O scheduling等原因，各个部分不一定是按照提交的顺序写入的（out of order），那么可能出现下图所示的这种情况：缺少了Db，但TxB和TxE都存在，系统恢复的时候会误以为这是一个完整的transcation。</p><img src="/2023/07/26/%E6%97%A5%E5%BF%97%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/v2-e5655c491410121e939d313582cef477_720w.png" alt="img" style="zoom:67%;"><p>解决的办法是使用<strong>write barrier</strong>。写入除TxE以外的部分后（这一步叫做 <strong>journal write</strong>），执行一次barrier操作（对于支持journal checksum的ext4文件系统，此步骤可省略）。如果在此期间crash了，由于没有TxE，这个transcation会被认为是不完整的，重启后就不会试图恢复这个transcation所代表的步骤。</p><img src="/2023/07/26/%E6%97%A5%E5%BF%97%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/v2-a752af2b794d9a74641d06f9d9c53d42_720w.png" alt="img" style="zoom:67%;"><p>待journal write顺利完成以后，再写入TxE（这一步叫做 <strong>journal commit</strong>），然后再执行一次barrier操作，以保证数据的写入是发生在journal完成之后（write barrier在保证数据一一致性的同时，会不可避免地对性能造成影响，如果能够接受不使用barrier带来的潜在风险，可以在mount文件系统的时候使用”nobarrier”选项）。</p><img src="/2023/07/26/%E6%97%A5%E5%BF%97%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/v2-bd63060e028328e458000e3f02821a7d_720w.png" alt="img" style="zoom:67%;"><p>因此，在日志型文件系统中，一个完整的数据写操作由”journal write”，”journal commit”和”checkpoint”三部分组成。写操作完成后，就可以释放journal本身所占据的磁盘空间了。</p><img src="/2023/07/26/%E6%97%A5%E5%BF%97%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/v2-02e661cc552def6708c125fa3c13a344_720w.webp" alt="img" style="zoom:67%;"><p>至此，涉及多个block的写操作的数据一致性问题算是有了保证，但这基于的是一个block的数据要么完全写了，要么完全没写的前提，那会不会出现一个block的数据只写了一部分的情况呢（half-written）？这其实是一个<strong>原子性</strong>的问题，由磁盘本身提供保障，即对一个block的操作必须是原子的（不可分割的）。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>journal好是好，不过要多做的工作也是显而易见的，别的不说，磁盘的I&#x2F;O负载首先就会蹭蹭地上升。那有什么办法可以优化吗？（此处的「优化」是真的优化哈，不是公司裁人的那种所谓“优化”）。</p><p>一种比较容易想到的方法是将多个journal的操作进行聚合处理，这种batching的思想在软件设计中也是随处可见的。结合到日志型文件系统自身的过程，还可以将journal中对”Db”的记录移除，即journal中只包含对inode和bitmap更新的记录。</p><img src="/2023/07/26/%E6%97%A5%E5%BF%97%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/v2-fccba8c55b41fa08d0f581e4b716b325_720w.png" alt="img" style="zoom:67%;"><p>此时，write barrier只能保证对meta data（包括inode和bitmap）的真实写操作发生在journal的写操作之后，由于磁盘写操作的out of order特性，user data的真实写操作则可能发生在此过程中的任何节点，这种模式被称为”<strong>Writeback</strong>“。</p><p>允许out of order对性能的提升当然是有裨益的，但如果crash是发生在journal写操作之后，meta data的真实写操作之前（假设也在user data的写操作之前），那么进行文件系统的recover时，meta data的写操作会被replay，但是user data的写操作不会，这将有可能造成同一文件的meta data和user data的不一致（图1左侧部分）。</p><img src="/2023/07/26/%E6%97%A5%E5%BF%97%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/v2-76c1b29f6675ea1e888018c85c10fd78_720w.webp" alt="img" style="zoom: 80%;"><p>不过呢，Writeback模式相对完全不用journal的模式，造成不一致的概率降低了，不一致带来的危害也降低了，作为性能和稳健的平衡，还是有相当的可取之处的。如果想把稳健性再提高一点呢，就再多做出一点限制：即保证对user data的真实写操作发生在journal的写操作之前，这就是”<strong>Ordered</strong>“模式。</p><p>对于Ordered的模式，如果crash发生在user data的写操作之后，journal的写操作之前，那么将造成这一部分user data的丢失，不过不会造成不一致的问题。如果crash发生在journal的写操作之后，meta data的真实写操作之前，那么完全可以通过replay来还原。</p><p>可见，从”Writeback”模式，到”Ordered”模式（同为<strong>Metadata Journal</strong>），再到本文最开始介绍的基本模式（<strong>Data Journal</strong>），数据丢失和不一致的风险是依次降低的，而对性能的损耗则是依次升高的。现代的文件系统通常会提供多种模式的选择，供不同场景下的用户使用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统Journal机制</title>
    <link href="/2023/07/23/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FJournal%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/07/23/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FJournal%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统Journal机制"><a href="#f2fs文件系统Journal机制" class="headerlink" title="f2fs文件系统Journal机制"></a>f2fs文件系统Journal机制</h1><blockquote><p>参考：<a href="https://blog.csdn.net/u011649400/article/details/106957151">https://blog.csdn.net/u011649400/article/details/106957151</a></p></blockquote><h2 id="Journal机制的介绍"><a href="#Journal机制的介绍" class="headerlink" title="Journal机制的介绍"></a>Journal机制的介绍</h2><p>当F2FS进行文件读写的时候，根据 f2fs_node 的设计以及闪存设备异地更新的特性，每修改一个数据块，都需要改动 f2fs_node 的地址映射，以及NAT，SIT等信息。但是如果仅仅因为一个小改动，例如修改一个块，就需要改动这么多数据，然后再写入磁盘，这样既会导致性能下降，也会导致闪存寿命的下降。</p><p>因此F2FS设计了journal机制，用于将这些对SIT和NAT区域的数据的修改暂存在Checkpoint区域的 <code>f2fs_journal</code> 中，这种设计可以<strong>减少NAT和SIT的更新产生的大量的I&#x2F;O</strong>。</p><p>产生大量I&#x2F;O的原因是，sit和nat的值会<strong>随机</strong>更新，由于flash的机制，即使更新SIT&#x2F;NAT其中的一个entry，都要将这个entry所在的整个NAT&#x2F;SIT的block进行重写。如用户更新了多个node(segment)，每一个node&#x2F;segment的更改都要更新了其中一个entry，即<code>f2fs_nat_entry</code>(<code>f2fs_sit_entry</code>)。假设这些需要更新的entry都不在通过一个<code>f2fs_nat_block</code>(<code>f2fs_sit_block</code>)，那么系统就要将所有的block更新，从而产生大量的4KB的I&#x2F;O，即使只改动其中一个entry。</p><p>F2FS则是通过journal机制，将这些随机更新的f2fs_nat_entry(f2fs_sit_entry)都会尝试集中写到checkpoint区域的f2fs_journal当中，即把随机更新的NAT&#x2F;SIT的block需要更新的entry都集中写到同一个block，从而减少I&#x2F;O的写入。<strong>如果f2fs_journal的空间还没用尽，系统就会将更新的NAT&#x2F;SIT entry写入journal中，如果这些journal用尽了，才回写到NAT&#x2F;SIT区域当中。</strong></p><h2 id="Journal涉及到的数据结构"><a href="#Journal涉及到的数据结构" class="headerlink" title="Journal涉及到的数据结构"></a>Journal涉及到的数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_journal</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__le16 n_nats; <span class="hljs-comment">/* 这个journal里面包含多少个nat_journal对象 */</span><br>__le16 n_sits; <span class="hljs-comment">/* 这个journal里面包含多少个sit_journal对象 */</span><br>&#125;;<br><span class="hljs-comment">/* spare area is used by NAT or SIT journals or extra info */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nat_journal</span> <span class="hljs-title">nat_j</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_journal</span> <span class="hljs-title">sit_j</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_extra_info</span> <span class="hljs-title">info</span>;</span><br>&#125;;<br>&#125; __packed;<br></code></pre></td></tr></table></figure><p><code>f2fs_journal</code> 可以保存NAT的journal也可以保存SIT的journal，以下分别分析:</p><h3 id="NAT-Journal"><a href="#NAT-Journal" class="headerlink" title="NAT Journal"></a>NAT Journal</h3><p>每一个<code>nat_journal</code>都对应了一个node，记录了这个node是属于哪一个inode，以及这个node的在flash设备的物理地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nat_journal</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nat_journal_entry</span> <span class="hljs-title">entries</span>[<span class="hljs-title">NAT_JOURNAL_ENTRIES</span>];</span><br>__u8 reserved[NAT_JOURNAL_RESERVED];<br>&#125; __packed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nat_journal_entry</span> &#123;</span><br>__le32 nid; <span class="hljs-comment">/* 当前node的nid信息 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nat_entry</span> <span class="hljs-title">ne</span>;</span><br>&#125; __packed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nat_entry</span> &#123;</span><br>__u8 version;<span class="hljs-comment">/* latest version of cached nat entry */</span><br>__le32 ino;<span class="hljs-comment">/* 属于哪一个inode */</span><br>__le32 block_addr;<span class="hljs-comment">/* flash设备的物理地址 */</span><br>&#125; __packed;<br></code></pre></td></tr></table></figure><h3 id="SIT-Journal"><a href="#SIT-Journal" class="headerlink" title="SIT Journal"></a>SIT Journal</h3><p>每一个<code>sit_journal</code>都对应了一个segment，记录了该segment的有效block的数目 <code>vblocks</code> 以及 它的分配状态bitmap <code>valid_map</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_journal</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_journal_entry</span> <span class="hljs-title">entries</span>[<span class="hljs-title">SIT_JOURNAL_ENTRIES</span>];</span><br>__u8 reserved[SIT_JOURNAL_RESERVED];<br>&#125; __packed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_journal_entry</span> &#123;</span><br>__le32 segno; <span class="hljs-comment">/* 当前的segment number */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_sit_entry</span> <span class="hljs-title">se</span>;</span><br>&#125; __packed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_sit_entry</span> &#123;</span><br>__le16 vblocks;<span class="hljs-comment">/* 有效block的数目 */</span><br>__u8 valid_map[SIT_VBLOCK_MAP_SIZE]; <span class="hljs-comment">/* SIT_VBLOCK_MAP_SIZE=64，64*8=512可以表示每一个块的valid状态 */</span><br>__le64 mtime;<span class="hljs-comment">/* 用于GC的victim segment selection */</span><br>&#125; __packed;<br></code></pre></td></tr></table></figure><h2 id="Journal机制的实现"><a href="#Journal机制的实现" class="headerlink" title="Journal机制的实现"></a>Journal机制的实现</h2><p>前面提及Journal机制主要用于将频繁的NAT和SIT的更新集中写到checkpoint区域的<code>f2fs_journal</code>中，从而提高性能，延长闪存颗粒的寿命。去分析Journal机制如何实现时，首先我们需要分析，系统什么时候会读写NAT、SIT区域的数据:</p><ul><li><strong>NAT:</strong> 更新一个node的物理地址，获取一个node的物理地址</li><li><strong>SIT:</strong> 分配segment中的block，回收segment中的block</li></ul><p>🔴 因此这里关注如何获取一个node的物理地址，以及一个segment的block分配状态。</p><h3 id="通过Journal获取一个node的物理地址"><a href="#通过Journal获取一个node的物理地址" class="headerlink" title="通过Journal获取一个node的物理地址"></a>通过Journal获取一个node的物理地址</h3><p>F2FS一般是通过<code>f2fs_get_node_info</code>函数，根据传入的nid值，找到对应的物理地址。首先从内存中找一下nid有没有cache，如果没有则使用journal寻址，如果还是没有采取NAT找，最后找到之后将这个entry的信息，加入到cache中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f2fs_get_node_info</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">nid_t</span> nid,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> node_info *ni)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nm_info</span> *<span class="hljs-title">nm_i</span> =</span> NM_I(sbi);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">curseg_info</span> *<span class="hljs-title">curseg</span> =</span> CURSEG_I(sbi, CURSEG_HOT_DATA);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_journal</span> *<span class="hljs-title">journal</span> =</span> curseg-&gt;journal;<br><span class="hljs-type">nid_t</span> start_nid = START_NID(nid); <span class="hljs-comment">// 计算这个nid所在的f2fs_nat_block的第一个nid</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nat_block</span> *<span class="hljs-title">nat_blk</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nat_entry</span> <span class="hljs-title">ne</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nat_entry</span> *<span class="hljs-title">e</span>;</span><br><span class="hljs-type">pgoff_t</span> index;<br><span class="hljs-type">int</span> i;<br><br>ni-&gt;nid = nid;<br><br><span class="hljs-comment">/* 根据nid从cache寻找物理地址信息 */</span><br>e = __lookup_nat_cache(nm_i, nid);<br><span class="hljs-keyword">if</span> (e) &#123; <span class="hljs-comment">// 如果有就返回</span><br>ni-&gt;ino = nat_get_ino(e);<br>ni-&gt;blk_addr = nat_get_blkaddr(e);<br>ni-&gt;version = nat_get_version(e);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-built_in">memset</span>(&amp;ne, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> f2fs_nat_entry));<br><br><span class="hljs-comment">/* 再去journal找 */</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 根据nid从journal找nat_entry的信息，如果 i&gt;=0 ，</span><br><span class="hljs-comment"> * 则表示journal有这个信息，否则表示journal不存在这个nid的信息 </span><br><span class="hljs-comment"> * */</span><br>i = f2fs_lookup_journal_in_cursum(journal, NAT_JOURNAL, nid, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>ne = nat_in_journal(journal, i); <span class="hljs-comment">// 将journal中的nat_entry返回出来</span><br>node_info_from_raw_nat(ni, &amp;ne); <span class="hljs-comment">// 读到node_info中</span><br>&#125;<br><span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">goto</span> cache; <span class="hljs-comment">// 在journal找到了，直接就返回</span><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 如果journal都没有，就要从NAT读取</span><br><span class="hljs-comment"> * 先根据这个nid计算一下所属的f2fs_nat_block的偏移，即物理地址</span><br><span class="hljs-comment"> * */</span><br>index = current_nat_addr(sbi, nid);<br><br><span class="hljs-comment">/* 根据f2fs_nat_block偏移，将从磁盘读取出来 */</span><br>page = f2fs_get_meta_page(sbi, index); <br><span class="hljs-comment">/* 将数据转换为f2fs_nat_block的形式 */</span><br>nat_blk = (<span class="hljs-keyword">struct</span> f2fs_nat_block *)page_address(page);<br><span class="hljs-comment">/* start_nid是这个nat_block的第一个nid，</span><br><span class="hljs-comment"> * 减去它就可以找出当前nid在nat_block内的偏移，然后都取出来 </span><br><span class="hljs-comment"> * */</span><br>ne = nat_blk-&gt;entries[nid - start_nid];<br><span class="hljs-comment">/* 根据读取出来的entry转为为ne的值，返回给调用函数 */</span><br>node_info_from_raw_nat(ni, &amp;ne);<br>f2fs_put_page(page, <span class="hljs-number">1</span>);<br>cache:<br><span class="hljs-comment">/* 如果cache不存在自然要缓存一下到内存中 */</span><br>cache_nat_entry(sbi, nid, &amp;ne); <span class="hljs-comment">// 缓存这个node_entry</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里有个有趣的函数<strong>current_nat_addr</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pgoff_t</span> <span class="hljs-title function_">current_nat_addr</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi, <span class="hljs-type">nid_t</span> start)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nm_info</span> *<span class="hljs-title">nm_i</span> =</span> NM_I(sbi);<br><span class="hljs-type">pgoff_t</span> block_off;<br><span class="hljs-type">pgoff_t</span> block_addr;<br><br>    <span class="hljs-comment">// 计算偏移量</span><br>block_off = NAT_BLOCK_OFFSET(start);<br><br>    <span class="hljs-comment">// 计算在主区中的偏移量</span><br>block_addr = (<span class="hljs-type">pgoff_t</span>)(nm_i-&gt;nat_blkaddr +<br>(block_off &lt;&lt; <span class="hljs-number">1</span>) -<br>(block_off &amp; (sbi-&gt;blocks_per_seg - <span class="hljs-number">1</span>)));<br><br>    <span class="hljs-comment">// nat_bitmap指明是在主区还是备区</span><br>    <span class="hljs-comment">// 如果在备区，还要加上blocks_per_seg</span><br><span class="hljs-keyword">if</span> (f2fs_test_bit(block_off, nm_i-&gt;nat_bitmap))<br>block_addr += sbi-&gt;blocks_per_seg;<br><br><span class="hljs-keyword">return</span> block_addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个NAT区域的布局为：</p><blockquote><p>来源：<a href="https://blog.csdn.net/geshifei/article/details/126390920">https://blog.csdn.net/geshifei/article/details/126390920</a></p></blockquote><img src="/2023/07/23/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FJournal%E6%9C%BA%E5%88%B6/e70cb7105d434b019d36cf0992dd232f.jpeg" alt="img" style="zoom:80%;"><p>我们假设当前的需要知道<strong>nid&#x3D;233870</strong>对应的物理Block位置，</p><p>（1）根据<code>#define NAT_BLOCK_OFFSET(start_nid) ((start_nid) / NAT_ENTRY_PER_BLOCK)</code>算出block_off为514</p><p>（2）那么它应该在第2个Segment的第2个位置，也就是<strong>偏移1026位置</strong></p><img src="/2023/07/23/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FJournal%E6%9C%BA%E5%88%B6/image-20230723223652646.png" alt="image-20230723223652646" style="zoom:67%;"><p>（3）我们需要将偏移量block_off &lt;&lt; 1（乘2），因为多算了它在备份区域里面的数量，所以减去<strong>block_off &amp; (sbi-&gt;blocks_per_seg - 1)</strong></p><p>（4）即nat_blkaddr + 514 × 2 - (514 &amp; 511) &#x3D; nat_blkaddr  + 1028 - 2 &#x3D; <strong>nat_blkaddr + 1026</strong></p><h3 id="通过Journal获取一个segment的block分配状态"><a href="#通过Journal获取一个segment的block分配状态" class="headerlink" title="通过Journal获取一个segment的block分配状态"></a>通过Journal获取一个segment的block分配状态</h3><p>F2FS一般是通过get_seg_entry函数根据segment number(segno)获取对应的entry。由于segment的entry的数目比node entry少很多，所以F2FS将所有的segment的entry都读入了内存，参考<a href="https://blog.csdn.net/u011649400/article/details/102490983">Segment结构</a>这一节。因此系统中读取segmeng entry的状态是简单的数组访问:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* seg_entry是f2fs_sit_entry的内存结构，同样记录了vblock valid_bitmap等信息 */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> seg_entry *<span class="hljs-title function_">get_seg_entry</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> f2fs_sb_info *sbi,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> segno)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_info</span> *<span class="hljs-title">sit_i</span> =</span> SIT_I(sbi); <span class="hljs-comment">// 获取segment的内存管理结构</span><br><span class="hljs-keyword">return</span> &amp;sit_i-&gt;sentries[segno]; <span class="hljs-comment">// 根据segno返回entry</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>f2fs文件系统布局</title>
    <link href="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/"/>
    <url>/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="f2fs文件系统布局"><a href="#f2fs文件系统布局" class="headerlink" title="f2fs文件系统布局"></a>f2fs文件系统布局</h1><p>💌 感谢<a href="https://blog.csdn.net/jasonactions/article/details/122409327">HZero.chen</a>，让我对f2fs文件系统的布局有了更深刻的认识~文章许多图片都来来自于他的文章，仅作本人学习备忘</p><h2 id="1-准备实验环境"><a href="#1-准备实验环境" class="headerlink" title="1.准备实验环境"></a>1.准备实验环境</h2><p>我们首先创建一个镜像，将其格式化为f2fs文件系统，并与loop设备进行绑定，随后进行挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install -y f2fs-tools             // 安装f2fs工具<br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=f2fs.img bs=4K count=51200  // 创建200M的f2fs.img<br>mkfs.f2fs -l f2fs f2fs.img                     // 格式化为f2fs<br>sudo losetup /dev/loop0 f2fs.img               // 将loop0与f2fs.img绑定【可以通过losetup -f查看当前空闲loop设备】<br>sudo mount /dev/loop0 ./mntf2fs/               // 将loop0进行挂载<br></code></pre></td></tr></table></figure><p>为了模拟真实的f2fs文件系统的flash设备，我们往里面放一些材料</p><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20230719212612079.png" alt="image-20230719212612079" style="zoom: 80%;"><ul><li>foo.txt是一个文本文件，里面只有一句话就是hello amx</li><li>meinv.jpg是一个jpg格式的图片，大小约为5.40Mb</li></ul><h2 id="2-整体布局"><a href="#2-整体布局" class="headerlink" title="2.整体布局"></a>2.整体布局</h2><blockquote><p>这张图来自于论文：《<strong>F2FS: A New File System for Flash Storage</strong>》</p></blockquote><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/1.png" alt="在这里插入图片描述" style="zoom: 80%;"><p>可以看到整体布局是常规的文件系统布局方式：<strong>超级块 + 元数据区 + 用户数据区</strong>；</p><ul><li>元数据区分为了CP、SIT、NAT、SSA四个区域，这四个区域都是以Segment为单位进行对齐的。</li><li>因f2fs为日志结构文件系统LFS，所以其用户数据区也称为日志区Main Area。f2fs不同于传统的LFS将所有的数据都存储在一个日志里面，f2fs将其划分为了Node Segment和Data Segment，又根据其是否经常改动划分为了Hot、Warm和Cold，因此总共是6种形式。</li></ul><hr><p><strong>f2fs基本数据单位</strong></p><ul><li><strong>block</strong>: F2FS的数据存储的基本单位是block，大小为4KB，整个flash设备被格式化为多个block组成的结构。很多数据结构也被设计为4KB的大小，这是因为很多flash设备单次IO的读写都是基于4KB的倍数进行。</li><li><strong>segment</strong>: segment是管理block的结构，一个segment的大小是512个block，也就是2MB。</li><li><strong>section</strong>: 默认情况下一个segment等于一个section，section是GC的基本操作单位，每次GC都会从section中选出特定的segment进行回收。F2FS将section分为了6类，分别是hot-node，warm-node，cold-node，hot-data，warm-data，cold-data，hot-&gt;cold表示了数据的从高到低的修改频率，通过不同类型section：进行gc的时候可针对使用hot的section进行gc，以降低gc的时间开销。</li><li><strong>zone</strong>: 默认情况一个zone等于一个section，与物理设备有关，大部分情况下用不上</li></ul><h3 id="2-1-超级块SuperBlock"><a href="#2-1-超级块SuperBlock" class="headerlink" title="2.1 超级块SuperBlock"></a>2.1 超级块SuperBlock</h3><p>值得注意的是，f2fs的superblock不是从0x0开始，而是预留了1KB，即其偏移量为0x400</p><blockquote><p>读者可以通过<strong>hexdump</strong>命令查看supeblock或者通过<strong>ultra edit</strong>手动查看</p></blockquote><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20230719213848821.png" alt="image-20230719213848821" style="zoom:80%;"><p>🔴 <strong>注意</strong>：我们这里只关注Disk本身的布局方式，而不关注其在内存中的表现形式！</p><p>其对应了<code>f2fs_super_block</code>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_super_block</span> &#123;</span><br>__le32 magic;<span class="hljs-comment">/* Magic Number */</span><br>__le16 major_ver;<span class="hljs-comment">/* Major Version */</span><br>__le16 minor_ver;<span class="hljs-comment">/* Minor Version */</span><br>__le32 log_sectorsize;<span class="hljs-comment">/* log2 sector size in bytes */</span><br>__le32 log_sectors_per_block;<span class="hljs-comment">/* log2 # of sectors per block */</span><br>__le32 log_blocksize;<span class="hljs-comment">/* log2 block size in bytes */</span><br>__le32 log_blocks_per_seg;<span class="hljs-comment">/* log2 # of blocks per segment */</span><br>__le32 segs_per_sec;<span class="hljs-comment">/* # of segments per section */</span><br>__le32 secs_per_zone;<span class="hljs-comment">/* # of sections per zone */</span><br>__le32 checksum_offset;<span class="hljs-comment">/* checksum offset inside super block */</span><br>__le64 block_count;<span class="hljs-comment">/* total # of user blocks */</span><br>__le32 section_count;<span class="hljs-comment">/* total # of sections */</span><br>__le32 segment_count;<span class="hljs-comment">/* total # of segments */</span><br>__le32 segment_count_ckpt;<span class="hljs-comment">/* # of segments for checkpoint */</span><br>__le32 segment_count_sit;<span class="hljs-comment">/* # of segments for SIT */</span><br>__le32 segment_count_nat;<span class="hljs-comment">/* # of segments for NAT */</span><br>__le32 segment_count_ssa;<span class="hljs-comment">/* # of segments for SSA */</span><br>__le32 segment_count_main;<span class="hljs-comment">/* # of segments for main area */</span><br>__le32 segment0_blkaddr;<span class="hljs-comment">/* start block address of segment 0 */</span><br>__le32 cp_blkaddr;<span class="hljs-comment">/* start block address of checkpoint */</span><br>__le32 sit_blkaddr;<span class="hljs-comment">/* start block address of SIT */</span><br>__le32 nat_blkaddr;<span class="hljs-comment">/* start block address of NAT */</span><br>__le32 ssa_blkaddr;<span class="hljs-comment">/* start block address of SSA */</span><br>__le32 main_blkaddr;<span class="hljs-comment">/* start block address of main area */</span><br>__le32 root_ino;<span class="hljs-comment">/* root inode number */</span><br>__le32 node_ino;<span class="hljs-comment">/* node inode number */</span><br>__le32 meta_ino;<span class="hljs-comment">/* meta inode number */</span><br>__u8 uuid[<span class="hljs-number">16</span>];<span class="hljs-comment">/* 128-bit uuid for volume */</span><br>__le16 volume_name[MAX_VOLUME_NAME];<span class="hljs-comment">/* volume name */</span><br>__le32 extension_count;<span class="hljs-comment">/* # of extensions below */</span><br>__u8 extension_list[F2FS_MAX_EXTENSION][F2FS_EXTENSION_LEN];<span class="hljs-comment">/* extension array */</span><br>__le32 cp_payload;<br>__u8 version[VERSION_LEN];<span class="hljs-comment">/* the kernel version */</span><br>__u8 init_version[VERSION_LEN];<span class="hljs-comment">/* the initial kernel version */</span><br>__le32 feature;<span class="hljs-comment">/* defined features */</span><br>__u8 encryption_level;<span class="hljs-comment">/* versioning level for encryption */</span><br>__u8 encrypt_pw_salt[<span class="hljs-number">16</span>];<span class="hljs-comment">/* Salt used for string2key algorithm */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_device</span> <span class="hljs-title">devs</span>[<span class="hljs-title">MAX_DEVICES</span>];</span><span class="hljs-comment">/* device list */</span><br>__le32 qf_ino[F2FS_MAX_QUOTAS];<span class="hljs-comment">/* quota inode numbers */</span><br>__u8 hot_ext_count;<span class="hljs-comment">/* # of hot file extension */</span><br>__le16  s_encoding;<span class="hljs-comment">/* Filename charset encoding */</span><br>__le16  s_encoding_flags;<span class="hljs-comment">/* Filename charset encoding flags */</span><br>__u8 reserved[<span class="hljs-number">306</span>];<span class="hljs-comment">/* valid reserved region */</span><br>__le32 crc;<span class="hljs-comment">/* checksum of superblock */</span><br>&#125; __packed;<br></code></pre></td></tr></table></figure><ul><li><strong>第一个SuperBlock(sb#1)如下所示【偏移0x400】：</strong></li></ul><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/2.png" alt="在这里插入图片描述" style="zoom:67%;"><ul><li><strong>第二个SuperBlock(sb#2)如下所示【偏移0x1400】：</strong></li></ul><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/3.png" alt="在这里插入图片描述" style="zoom: 50%;"><blockquote><p>以下内容来自：<a href="https://zhuanlan.zhihu.com/p/634651371">https://zhuanlan.zhihu.com/p/634651371</a></p></blockquote><ul><li><p><strong>magic</strong>：f2fs的魔数字，用来检查SuperBlock是否破损，其内容固定为0xF2F52010。</p></li><li><p><strong>major_ver、minor_ver</strong>：这两个是Linux用于标识一个块设备的主次号，主次号可以确定系统中的每一个块设备。</p></li><li><p><strong>log_sectorsize</strong>：块设备中一个扇区大小，普通设备是512，此处是对2取对数后的结果，所以是9。</p></li><li><p><strong>log_sectors_per_block</strong>：一个block对应扇区数，并对2取对数后的结果，一个block是4KB，而sector是512，所以结果是3。</p></li><li><p><strong>log_blocksize</strong>：一个block大小对2取对数的结果，也即log2(4096)，结果是12。</p></li><li><p><strong>log_blocks_per_seg</strong>：一个segment对应的block数目，并对2取对数的结果，结果是9。</p></li><li><p><strong>segs_per_sec、secs_per_zone</strong>：分别是一个section对应的segmeng数量和一个zone对应的section数量，默认两者均为1。</p></li><li><p><strong>crc_offset、crc</strong>：SuperBlock中的crc字段偏移量，crc则是该SuperBlock结构体的crc计算结果，用于检查SuperBlock的正确性。其中这两个字段由F2FS_FEATURE_SB_CHKSUM标记位控制，如果设置了该标记，mkfs才会真正写入这两个字段的内容。</p></li><li><p><strong>block_count</strong>：整个块设备的block个数，需要做4KB对齐，如果对应多个设备，计算的是所有设备的block个数。</p></li><li><p><strong>section_count</strong>：Main Area对应的section个数，如果是多设备，需要全部计算。</p></li><li><p><strong>segment_count_ckpt</strong>：CP区域所占的segment数，CP区域固定占2个segment。</p></li><li><p><strong>segment_count_sit</strong>：SIT区域所占用的segment数，这个是根据segment_count的值确定的，一个f2fs_sit_entry结构体占74字节，所以一个block可容纳56个f2fs_sit_entry，也即一个segment可容纳28672个f2fs_sit_entry，对应的是56G。但由于SIT有一个备份区域，所以每56G的大小就需要2个segment。注意：SIT区域管理系统中所有的segment，包括CP区域和SIT区域自身。</p></li><li><p><strong>segment_count_nat</strong>：NAT区域所占用的segment数，对应的是从NAT区域开始的所有block（包括NAT、SSA、Node、Data区域）。一个f2fs_nat_entry大小是9字节，所以一个block对应455个f2fs_nat_entry。同样，NAT区域也有一个备份区。</p></li><li><p><strong>segment_count_ssa</strong>：SSA区域所占用的segmeng数，一个SSA Block对应的是一个segment信息。同时需要注意的是，SSA区域主要是用于GC流程的，如果f2fs在mkfs的时候指定了只读属性，那么该区域也就没必要的。对应的是从SSA区域开始的所有segment的管理。SSA区域不做备份。</p></li><li><p><strong>segment_count_main</strong>：Main Area区域对应的segment数，包括Node和Data的区域。</p></li><li><p><strong>segment0_blkaddr</strong>：第一个segment的开始对应的block号，注意：本来第一个segment应该对应的是SuperBlock，但是f2fs是从CP区域开始对segment进行编码的，所以对应的是CP区域的开始block。</p></li><li><p>⭐<strong>cp_blkaddr</strong>：CP区域的起始block号，和segment0_blkaddr一样。</p></li><li><p>⭐<strong>sit_blkaddr</strong>：SIT区域的起始block号。</p></li><li><p>⭐<strong>nat_blkaddr</strong>：NAT区域的起始block号。</p></li><li><p>⭐<strong>ssa_blkaddr</strong>：SSA区域的起始block号。</p></li><li><p>⭐<strong>main_blkaddr</strong>：Main Area开始的block号。</p></li><li><p><strong>root_ino、meta_ino、node_ino</strong>：分别是root inode号，固定是3；元数据inode号，固定是2；Node对应的inode号，固定是1。其中root_ino是根目录的inode号，在文件系统挂载的是时候初始化，而meta_ino则对应元数据区域，缓存元数据的page cache；node_ino则对应的是所有node的page cache</p></li><li><p><strong>uuid</strong>：随机值盐值，用于计算inode的crc。</p></li><li><p><strong>volume_name</strong>：分区名。</p></li><li><p><strong>extension_list</strong>：可以通过ioctl设定将哪些文件标记为cold，一般是读多写少的文件，例如：mp3、gif等等</p></li><li><p><strong>version</strong>：mkfs时的linux的版本号。</p></li><li><p><strong>feature</strong>：mkfs指定的特性列表，例如：加密、SuperBlock的crc检查等等。&#x2F;sys&#x2F;fs&#x2F;f2fs&#x2F;features&#x2F;表示文件系统支持的特性。</p></li><li><p><strong>encrypt_pw_salt</strong>：密钥的加密盐值，可通过ioctl获取。</p></li><li><p><strong>devs</strong>：文件系统对应的设备列表，每个设备都有各自的地址访问，在写数据的时候需要遍历所有设备。</p></li><li><p><strong>s_encoding、s_encoding_flags</strong>：文件名编码格式？</p></li><li><p><strong>s_stop_reason</strong>：CP停止的原因（CP失败的原因？）</p></li><li><p><strong>s_errors</strong>：文件系统损坏的原因。</p></li></ul><h3 id="2-2-CheckPoint"><a href="#2-2-CheckPoint" class="headerlink" title="2.2 CheckPoint"></a>2.2 CheckPoint</h3><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/4.png" alt="在这里插入图片描述" style="zoom: 67%;"><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/5.png" alt="在这里插入图片描述" style="zoom: 67%;"><blockquote><p>如上为cp block的总体布局，分为两种：<strong>nomal mode</strong>和<strong>compact mode</strong>.通过镜像可知，本文创建的镜像的CP为compact mode<br>ckpt_flags的值是5，通过ckpt_flags &amp; CP_COMPACT_SUM_FLAG的值也可以知道，它就是compact mode.<br>cp区域主要包含两个cp pack，每个cp pack占据一个segment。</p></blockquote><h4 id="2-2-1-cp-page-1"><a href="#2-2-1-cp-page-1" class="headerlink" title="2.2.1 cp page 1"></a>2.2.1 cp page 1</h4><p>其对应的数据结构为<code>f2fs_checkpoint</code>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_checkpoint</span> &#123;</span><br>__le64 checkpoint_ver;<span class="hljs-comment">/* checkpoint block version number */</span><br>__le64 user_block_count;<span class="hljs-comment">/* # of user blocks */</span><br>__le64 valid_block_count;<span class="hljs-comment">/* # of valid blocks in main area */</span><br>__le32 rsvd_segment_count;<span class="hljs-comment">/* # of reserved segments for gc */</span><br>__le32 overprov_segment_count;<span class="hljs-comment">/* # of overprovision segments */</span><br>__le32 free_segment_count;<span class="hljs-comment">/* # of free segments in main area */</span><br><br><span class="hljs-comment">/* information of current node segments */</span><br>__le32 cur_node_segno[MAX_ACTIVE_NODE_LOGS];<br>__le16 cur_node_blkoff[MAX_ACTIVE_NODE_LOGS];<br><span class="hljs-comment">/* information of current data segments */</span><br>__le32 cur_data_segno[MAX_ACTIVE_DATA_LOGS];<br>__le16 cur_data_blkoff[MAX_ACTIVE_DATA_LOGS];<br>__le32 ckpt_flags;<span class="hljs-comment">/* Flags : umount and journal_present */</span><br>__le32 cp_pack_total_block_count;<span class="hljs-comment">/* total # of one cp pack */</span><br>__le32 cp_pack_start_sum;<span class="hljs-comment">/* start block number of data summary */</span><br>__le32 valid_node_count;<span class="hljs-comment">/* Total number of valid nodes */</span><br>__le32 valid_inode_count;<span class="hljs-comment">/* Total number of valid inodes */</span><br>__le32 next_free_nid;<span class="hljs-comment">/* Next free node number */</span><br>__le32 sit_ver_bitmap_bytesize;<span class="hljs-comment">/* Default value 64 */</span><br>__le32 nat_ver_bitmap_bytesize; <span class="hljs-comment">/* Default value 256 */</span><br>__le32 checksum_offset;<span class="hljs-comment">/* checksum offset inside cp block */</span><br>__le64 elapsed_time;<span class="hljs-comment">/* mounted time */</span><br><span class="hljs-comment">/* allocation type of current segment */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> alloc_type[MAX_ACTIVE_LOGS];<br><br><span class="hljs-comment">/* SIT and NAT version bitmap */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sit_nat_version_bitmap[<span class="hljs-number">1</span>];<br>&#125; __packed;<br></code></pre></td></tr></table></figure><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/6.png" alt="在这里插入图片描述" style="zoom: 50%;"><blockquote><p>上面为HZero.chen博客中的数据，下面是我自己实验的数据</p></blockquote><hr><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20230719233445458.png" alt="image-20230719233445458" style="zoom:67%;"><ul><li><p><strong>checkpoint_ver</strong>：0x69d7b561</p></li><li><p><strong>user_block_count</strong>：0x7a00(31232)，4096&#x2F;512&#x3D;8个segment,而main area有56个segment，其它48个segment为overprovision segment</p></li><li><p><strong>valid_block_count</strong>：0x56d(1389)</p></li><li><p><strong>rsvd_segment_count</strong>：0x15(31)，保留了21个segment</p></li><li><p><strong>overprov_segment_count</strong>：0x1f(31)</p></li><li><p><strong>free_segment_count</strong>：0x54(84)</p></li><li><p><strong>cur_node_segno</strong></p><ul><li>0x01、0x02</li></ul></li></ul><p>—-cur_node_blkoff—-<br>0x00000006<br>0x0000000C<br>0x00000000</p><p>—-cur_data_segno—-<br>0x00000034<br>0x00000001<br>0x00000000|</p><p>—-cur_data_blkoff—-<br>0x00000005<br>0x00000003<br>0x00000001</p><p>ckpt_flags:0x5</p><p>cp_pack_total_block_count:0x6</p><p>cp_pack_start_sum:0x1</p><p>valid_node_count:0x5</p><p>valid_inode_count:0x5</p><p>next_free_nid:0x8</p><p>sit_ver_bitmap_bytesize:0x40</p><p>nat_ver_bitmap_bytesize:0x40</p><p>checksum_offset:0xffc</p><p>elapsed_time:40</p><p>allocation type of current segment<br>0x00000000|0x00000000|0x00000000|0x00000000|0x00000000|0x00000000|0x00000000|<br>0x00000000|0x00000000|0x00000000|0x00000000|0x00000000|0x00000000|0x00000000|<br>0x00000000|0x00000000|</p><p>sit_nat_version_bitmap:0x0</p><p>&#x2F;&#x2F; TODO</p><h4 id="2-2-2-NAT-Journal"><a href="#2-2-2-NAT-Journal" class="headerlink" title="2.2.2 NAT Journal"></a>2.2.2 NAT Journal</h4><p>在f2fs中存在journal机制，通过联合体<code>f2fs_journal</code>表示，所以它既可以表示NAT，又可以表示SIT</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_journal</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__le16 n_nats;<br>__le16 n_sits;<br>&#125;;<br><span class="hljs-comment">/* spare area is used by NAT or SIT journals or extra info */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nat_journal</span> <span class="hljs-title">nat_j</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_journal</span> <span class="hljs-title">sit_j</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_extra_info</span> <span class="hljs-title">info</span>;</span><br>&#125;;<br>&#125; __packed;<br></code></pre></td></tr></table></figure><p>这里先以NAT为例，前面16位小端为nats，后面的是nat_journal结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nat_journal</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nat_journal_entry</span> <span class="hljs-title">entries</span>[<span class="hljs-title">NAT_JOURNAL_ENTRIES</span>];</span><br>__u8 reserved[NAT_JOURNAL_RESERVED];<br>&#125; __packed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nat_journal_entry</span> &#123;</span><br>__le32 nid;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nat_entry</span> <span class="hljs-title">ne</span>;</span><br>&#125; __packed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nat_entry</span> &#123;</span><br>__u8 version;<span class="hljs-comment">/* latest version of cached nat entry */</span><br>__le32 ino;<span class="hljs-comment">/* inode number */</span><br>__le32 block_addr;<span class="hljs-comment">/* block address */</span><br>&#125; __packed;<br></code></pre></td></tr></table></figure><p>说白了里面存储的也是<strong>f2fs_nat_entry</strong></p><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20230719234855034.png" alt="image-20230719234855034" style="zoom:67%;"><p>前面2个字节0x05表示nats，随后的4个字节0x00000003表示的是nid，后面即使f2fs_nat_entry结构体了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">00            version      0x00<br>00 00 00 03   ino          0x03(3)<br>00 00 10 04   block_addr   0x1004(4100)<br></code></pre></td></tr></table></figure><p>我们一般会<strong>dump.f2fs -n 0~-1 f2fs.img</strong>查看nat的信息，结果会保存在<code>dump_nat</code>中</p><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20230719235441702.png" alt="image-20230719235441702" style="zoom:67%;"><p>以第一个<strong>nid:3</strong>为例，与上面的nat journal完美的对上了，同理这里面的信息都与nat journal一一对应。</p><h4 id="2-2-3-SIT-Journal"><a href="#2-2-3-SIT-Journal" class="headerlink" title="2.2.3 SIT Journal"></a>2.2.3 SIT Journal</h4><p>如2.2.2所说，f2fs_journal结构体既能表示nat，也能表示sit【因为内部成员是联合体】，那么这边应该表示的是sit</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_journal</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_journal_entry</span> <span class="hljs-title">entries</span>[<span class="hljs-title">SIT_JOURNAL_ENTRIES</span>];</span><br>__u8 reserved[SIT_JOURNAL_RESERVED];<br>&#125; __packed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sit_journal_entry</span> &#123;</span><br>__le32 segno;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_sit_entry</span> <span class="hljs-title">se</span>;</span><br>&#125; __packed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_sit_entry</span> &#123;</span><br>__le16 vblocks;<span class="hljs-comment">/* reference above */</span><br>__u8 valid_map[SIT_VBLOCK_MAP_SIZE];<span class="hljs-comment">/* bitmap for valid blocks */</span><br>__le64 mtime;<span class="hljs-comment">/* segment age for cleaning */</span><br>&#125; __packed;<br></code></pre></td></tr></table></figure><p>说白了里面存储的也是<strong>f2fs_sit_entry</strong></p><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20230719235854137.png" alt="image-20230719235854137" style="zoom:67%;"><h3 id="2-3-SIT"><a href="#2-3-SIT" class="headerlink" title="2.3 SIT"></a>2.3 SIT</h3><p>SIT区域由N个struct f2fs_sit_block组成，每一个struct f2fs_sit_block包含了55个struct f2fs_sit_entry，每一个entry对应了一个segment的管理状态。每一个entry包含了三个变量: vblocks(记录这个segment有多少个block已经被使用了)，valid_map(记录这个segment里面的哪一些block是无效的)，mtime(表示修改时间)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_sit_block</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_sit_entry</span> <span class="hljs-title">entries</span>[<span class="hljs-title">SIT_ENTRY_PER_BLOCK</span>];</span><br>&#125; __packed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_sit_entry</span> &#123;</span><br>__le16 vblocks;<span class="hljs-comment">/* reference above */</span><br>__u8 valid_map[SIT_VBLOCK_MAP_SIZE];<span class="hljs-comment">/* bitmap for valid blocks */</span><br>__le64 mtime;<span class="hljs-comment">/* segment age for cleaning */</span><br>&#125; __packed;<br></code></pre></td></tr></table></figure><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20230724233134094.png" alt="image-20230724233134094" style="zoom:67%;"><p><strong>注意到内核代码里面有一个很有意思的注释：</strong></p><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20230724232829641.png" alt="image-20230724232829641" style="zoom: 67%;"><p>在f2fs_sit_entry的第一个字段vblocks其代表的含义为：</p><ul><li><p>**[15:10]**表示当前Segment类型是属于哪一种，HOT&#x2F;WARM&#x2F;COLD * NODE&#x2F;DATA</p></li><li><p>**[9:0]**表示有效块的数量</p></li><li><p>这2个值也对应了<strong>dump_sit</strong>中的值</p></li></ul><hr><p>首先我们验证一下上面的注释是否是正确的：</p><p>观察到第一个Segment 0的前2个字节为0xc01 &#x3D; 0000 1100 0000 0001，其<strong>高[15:10]位为0000 11 &#x3D;  3，低[9:0]位为00 0000 0001 &#x3D; 1</strong>，可以看到下面的dump_sit中<strong>segno: 0</strong>对应的<strong>seg_type: 3</strong>，<strong>vblocks: 1</strong></p><p>通过<strong>dump.f2fs -s 0~-1 f2fs.img</strong> 看一下SIT的整体情况</p><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20230724232531598.png" alt="image-20230724232531598" style="zoom:67%;"><p>我们再来看一个有趣的现象，观察<strong>segno: 9</strong>，发现它是一个Warm Node，</p><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20230724233756028.png" alt="image-20230724233756028" style="zoom:80%;"><p>这个segment偏移量为9，前面已经有9个Segment了，一个Segment为2MB，而Main Area的起始位置为<strong>0x100000</strong>，所以</p><ul><li><strong>SegNo 9</strong>的物理起始地址为：<strong>0x20000(2M) * 0x9 + 0x100000 &#x3D; 0x1300000</strong></li></ul><p>又注意到e0这个位置前面总共59个字节，也就是472Bit，我们知道这是一个位图，其代表了前472个Block都是无效的，其大小总共为：</p><ul><li><strong>472 * 4096 &#x3D; 1,933,312Byte  &#x3D; 0x1D8000</strong></li></ul><p>下面开始看0xe0(11100000)其表示了从第472个Block开始的8个块，其中第472，473，474个Block是有效的，总共3个，这也验证了dump_sit的vblocks为3。</p><ul><li>计算出第472个Block的位置为<strong>0x1300000 + 0x1D8000 &#x3D; 0x14D8000</strong></li></ul><h3 id="2-4-NAT"><a href="#2-4-NAT" class="headerlink" title="2.4 NAT"></a>2.4 NAT</h3><img src="/2023/07/19/f2fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80/image-20230723231428571.png" alt="image-20230723231428571" style="zoom:80%;"><p>这里一开始我很奇怪，为啥这里只有3个inode，即node_ino:1、meta_ino:2、root_ino:3，那其余文件的inode去哪里了，不是说NAT维护了一张inode no和block addr的表吗。</p><p>这里其实是由于Journal机制，为了不频繁读写NAT，所以将nat的改动先存放在了nat journal中，所以这也是为什么nat journal和NAT区域都是按照<strong>f2fs_nat_entry</strong> 排布的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">f2fs_nat_entry</span> &#123;</span><br>__u8 version;<span class="hljs-comment">/* latest version of cached nat entry */</span><br>__le32 ino;<span class="hljs-comment">/* inode number */</span><br>__le32 block_addr;<span class="hljs-comment">/* block address */</span><br>&#125; __packed;<br></code></pre></td></tr></table></figure><p>只有当nat journal区域撑满了放不下了，才会刷写到磁盘对应的NAT区域中。</p><hr><p>我们做个实验，写一个shell脚本<code>f2fs.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>for i in &#123;1..2000&#125;<br>do<br>fileName=&quot;hello&quot;$&#123;i&#125;<br>touch /home/amx/Desktop/f2fs/mntf2fs/$&#123;fileName&#125;.txt<br>echo &quot;hello amx&quot;$&#123;i&#125; &gt;&gt; /home/amx/Desktop/f2fs/mntf2fs/$&#123;fileName&#125;.txt<br>done<br></code></pre></td></tr></table></figure><blockquote><p>功能就是创建2000个文件，文件名为hello[i]，向里面写入hello amx[i]</p></blockquote><p>执行这个脚本，再次<code>hexdump -C -s 0xA00000 -n 2097152 f2fs.img</code>就可以看到NAT区域已经更新了【如果没更新，就把for循环次数放大】。后续直接 <strong>rm -rf hello</strong>*删掉这些文件即可</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>块设备驱动</title>
    <link href="/2023/07/16/%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    <url>/2023/07/16/%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="块设备驱动"><a href="#块设备驱动" class="headerlink" title="块设备驱动"></a>块设备驱动</h1><blockquote><p>转载自：<a href="https://mshrimp.github.io/2020/04/19/Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">https://mshrimp.github.io/2020/04/19/Linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</a></p></blockquote><h2 id="1-块设备结构"><a href="#1-块设备结构" class="headerlink" title="1.块设备结构"></a>1.块设备结构</h2><p><strong>段（Segments）</strong>：由若干个块组成；是Linux内存管理机制中一个内存页或内存页的一部分；</p><p><strong>块（Blocks）</strong>：由Linux制定对内核或文件系统等数据处理的基本单位；通常通常为4096个字节，由1个或多个扇区组成；</p><p><strong>扇区（Sectors）</strong>：块设备的基本单位，是一个固定的硬件单位，制定了设备最少能够传输的数据量；通常在512字节到32768字节之间，默认：512字节；</p><p>块是连续扇区的序列，块长度总是扇区长度的整数倍；块的最大长度，受特定体系结构的内存页长度限制；</p><p>块设备使用请求队列，缓存并重排读写数据块的请求，用高效的方式读取数据；块设备的每个设备都关联了请求队列；对块设备的读写请求不会立即执行，这些请求会汇总起来，经过协同之后传输到设备；</p><h2 id="2-块设备驱动框架"><a href="#2-块设备驱动框架" class="headerlink" title="2.块设备驱动框架"></a>2.块设备驱动框架</h2><img src="/2023/07/16/%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/块设备驱动架构图.jpg" alt="块设备驱动架构图" style="zoom:80%;"><hr><img src="/2023/07/16/%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/100045938-83907-1.png" alt="img" style="zoom:67%;"><ul><li>块设备的应用在Linux中是一个完整的子系统。</li><li>在Linux中，驱动对块设备的输入或输出(I&#x2F;O)操作，都会向块设备发出一个请求，在驱动中用<strong>request</strong>结构体描述。但对于一些磁盘设备而言请求的速度很慢，这时候内核就提供一种队列的机制把这些I&#x2F;O请求添加到队列中（即：请求队列），在驱动中用<strong>request_queue</strong>结构体描述。在向块设备提交这些请求前内核会先执行请求的合并和排序预操作，以提高访问的效率，然后再由内核中的I&#x2F;O调度程序子系统来负责提交  I&#x2F;O 请求，  调度程序将磁盘资源分配给系统中所有挂起的块 I&#x2F;O  请求，其工作是管理块设备的请求队列，决定队列中的请求的排列顺序以及什么时候派发请求到设备。</li><li>由通用块层(Generic Block Layer)负责维持一个I&#x2F;O请求在上层文件系统与底层物理磁盘之间的关系。在通用块层中，通常用一个bio结构体来对应一个I&#x2F;O请求。</li><li>Linux提供了一个gendisk数据结构体，用来表示一个独立的磁盘设备或分区，用于对底层物理磁盘进行访问。在gendisk中有一个类似字符设备中file_operations的硬件操作结构指针，是block_device_operations结构体。</li><li>当多个请求提交给块设备时，执行效率依赖于请求的顺序。如果所有的请求是同一个方向（如：写数据），执行效率是最大的。内核在调用块设备驱动程序例程处理请求之前，先收集I&#x2F;O请求并将请求排序，然后，将连续扇区操作的多个请求进行合并以提高执行效率（内核算法会自己做，不用你管），对I&#x2F;O请求排序的算法称为电梯算法（elevator algorithm）。电梯算法在I&#x2F;O调度层完成。</li></ul><h2 id="3-重要结构及操作"><a href="#3-重要结构及操作" class="headerlink" title="3.重要结构及操作"></a>3.重要结构及操作</h2><h3 id="3-1-注册块设备驱动程序"><a href="#3-1-注册块设备驱动程序" class="headerlink" title="3.1 注册块设备驱动程序"></a>3.1 注册块设备驱动程序</h3><ul><li>向内核注册块设备驱动程序</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">register_blkdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>name：设备名字，是在&#x2F;proc&#x2F;devices中显示的名字</p><p>major：设备的主设备号，如果major&#x3D;0，则分配一个主设备号</p></blockquote><p>该函数的调用是可选的，完成的工作：</p><blockquote><ol><li>如果需要的话分配一个动态的主设备号</li><li>在&#x2F;proc&#x2F;devices中创建一个入口项</li></ol></blockquote><ul><li>注销块设备驱动程序</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_blkdev</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br></code></pre></td></tr></table></figure><hr><p>如下用例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> sbull_major = <span class="hljs-number">0</span>;<br>sbull_major = register_blkdev(sbull_major, <span class="hljs-string">&quot;sbull&quot;</span>);<br><span class="hljs-keyword">if</span> (sbull_major &lt; <span class="hljs-number">0</span>) &#123;<br>printk(KERN_WARNNING <span class="hljs-string">&quot;sbull: unable to get major number\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EBUSY;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/fs.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device</span> &#123;</span><br>    <span class="hljs-type">dev_t</span>           bd_dev;  <span class="hljs-comment">/* not a kdev_t - it&#x27;s a search key */</span><br>    <span class="hljs-type">int</span>         bd_openers;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *      <span class="hljs-title">bd_inode</span>;</span>   <span class="hljs-comment">/* will die */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *    <span class="hljs-title">bd_super</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span>        <span class="hljs-title">bd_mutex</span>;</span>   <span class="hljs-comment">/* open/close mutex */</span><br>    <span class="hljs-type">void</span> *          bd_claiming;<br>    <span class="hljs-type">void</span> *          bd_holder;<br>    <span class="hljs-type">int</span>         bd_holders;<br>    <span class="hljs-type">bool</span>            bd_write_holder;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">bd_holder_disks</span>;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device</span> *   <span class="hljs-title">bd_contains</span>;</span><br>    <span class="hljs-type">unsigned</span>        bd_block_size;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hd_struct</span> *  <span class="hljs-title">bd_part</span>;</span><br>    <span class="hljs-comment">/* number of times partitions within this device have been opened. */</span><br>    <span class="hljs-type">unsigned</span>        bd_part_count;<br>    <span class="hljs-type">int</span>         bd_invalidated;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gendisk</span> *    <span class="hljs-title">bd_disk</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *  <span class="hljs-title">bd_queue</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">bd_list</span>;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Private data.  You must have bd_claim&#x27;ed the block_device</span><br><span class="hljs-comment">     * to use this.  <span class="hljs-doctag">NOTE:</span>  bd_claim allows an owner to claim</span><br><span class="hljs-comment">     * the same device multiple times, the owner must take special</span><br><span class="hljs-comment">     * care to not mess up bd_private for that case.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>       bd_private;<br><br>    <span class="hljs-comment">/* The counter of freeze processes */</span><br>    <span class="hljs-type">int</span>         bd_fsfreeze_count;<br>    <span class="hljs-comment">/* Mutex for freeze */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span>        <span class="hljs-title">bd_fsfreeze_mutex</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-2-块设备操作"><a href="#3-2-块设备操作" class="headerlink" title="3.2 块设备操作"></a>3.2 块设备操作</h3><p>字符设备使用file_operations结构，来告诉系统字符设备驱动的操作接口；</p><p>块设备使用block_device_operations结构，来告诉系统块设备驱动的操作接口；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/blkdev.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device_operations</span> &#123;</span><br>    <span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">fmode_t</span>);<br>    <span class="hljs-type">void</span> (*release) (<span class="hljs-keyword">struct</span> gendisk *, <span class="hljs-type">fmode_t</span>);<br>    <span class="hljs-type">int</span> (*rw_page)(<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">sector_t</span>, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">bool</span>);<br>    <span class="hljs-type">int</span> (*ioctl) (<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">fmode_t</span>, <span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br>    <span class="hljs-type">int</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-type">fmode_t</span>, <span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br>......<br>    <span class="hljs-comment">/* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */</span><br>    <span class="hljs-type">int</span> (*media_changed) (<span class="hljs-keyword">struct</span> gendisk *);<br>    <span class="hljs-type">int</span> (*getgeo)(<span class="hljs-keyword">struct</span> block_device *, <span class="hljs-keyword">struct</span> hd_geometry *);<br>......<br>&#125;;<br></code></pre></td></tr></table></figure><p>和字符设备驱动不同，块设备驱动的block_device_operations操作集中没有负责读和写数据的函数；在块设备驱动中，这些操作是由request函数处理的；</p><h3 id="3-3-注册磁盘"><a href="#3-3-注册磁盘" class="headerlink" title="3.3 注册磁盘"></a>3.3 注册磁盘</h3><p>为了管理独立的磁盘，需要使用struct gendisk结构体，内核使用gendisk结构表示一个独立的磁盘设备，还可以表示分区；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/genhd.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gendisk</span> &#123;</span><br>    <span class="hljs-type">int</span> major;          <span class="hljs-comment">/* major number of driver */</span><br>    <span class="hljs-type">int</span> first_minor;<br>    <span class="hljs-type">int</span> minors;                     <span class="hljs-comment">/* maximum number of minors, =1 for</span><br><span class="hljs-comment">                                         * disks that can&#x27;t be partitioned. */</span><br>    <span class="hljs-type">char</span> disk_name[DISK_NAME_LEN];  <span class="hljs-comment">/* name of major driver */</span><br>    <span class="hljs-type">char</span> *(*devnode)(<span class="hljs-keyword">struct</span> gendisk *gd, <span class="hljs-type">umode_t</span> *mode);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hd_struct</span> <span class="hljs-title">part0</span>;</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device_operations</span> *<span class="hljs-title">fops</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">queue</span>;</span><br>......<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>major：指定驱动程序的主设备号</p><p>first_minor和minors：从设备号的可能范围</p><p>disk_name：磁盘名称，在&#x2F;proc&#x2F;partitions 和 sysfs 中表示该磁盘</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> disk_name[DISK_NAME_LEN];<br></code></pre></td></tr></table></figure><p>显示在&#x2F;proc&#x2F;partitions 和 sysfs 中</p><p>对于每一个分区来说，都有一个hd_struct结构体，用于描述该分区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/genhd.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hd_struct</span> &#123;</span><br>    <span class="hljs-type">sector_t</span> start_sect;<br>    <span class="hljs-type">sector_t</span> nr_sects;<br>    <span class="hljs-type">seqcount_t</span> nr_sects_seq;<br>......<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition_meta_info</span> *<span class="hljs-title">info</span>;</span><br>......<br>&#125;;<br></code></pre></td></tr></table></figure><p>start_sect和nr_sects：定义了该分区在块设备上的起始扇区和长度，唯一地描述了该分区</p><p>拥有了设备内存和请求队列，就可以分配、初始化及安装gendisk结构；在struct gendisk是动态分配的结构，需要内核进行初始化，驱动必须通过alloc_disk分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> gendisk *<span class="hljs-title function_">alloc_disk</span><span class="hljs-params">(<span class="hljs-type">int</span> minors)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>minors：是该磁盘使用的从设备号的数目；</p></blockquote><p>卸载磁盘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">del_gendisk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *disk)</span><br></code></pre></td></tr></table></figure><p>gendisk是一个引用计数结构，get_disk和put_disk函数负责处理引用计数；调用del_gendisk后，该结构可能继续存在；</p><p>为了使gendisk结构的磁盘设备生效，需要初始化结构，并将磁盘或分区信息添加到内核链表；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">add_disk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gendisk *gd)</span>;<br></code></pre></td></tr></table></figure><p>调用add_disk后，磁盘设备将被激活，并随时会调用它提供的操作方法，因此在驱动程序完全被初始化并且能够响应对磁盘的请求前，不要调用add_disk；</p><h3 id="3-4-请求队列"><a href="#3-4-请求队列" class="headerlink" title="3.4 请求队列"></a>3.4 请求队列</h3><p>块设备驱动程序的核心是请求函数，包含请求处理过程；</p><ul><li>有I&#x2F;O调度类设备，使用blk_init_queue()函数：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> request_queue *<span class="hljs-title function_">blk_init_queue</span><span class="hljs-params">(request_fn_proc *rfn, <span class="hljs-type">spinlock_t</span> *lock)</span><br></code></pre></td></tr></table></figure><ul><li>无I&#x2F;O调度类设备，使用blk_alloc_queue()函数：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// block/blk-core.c</span><br><span class="hljs-keyword">struct</span> request_queue *<span class="hljs-title function_">blk_alloc_queue</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> gfp_mask)</span><br><span class="hljs-comment">// block/blk-settings.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">blk_queue_make_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, make_request_fn *mfn)</span><br></code></pre></td></tr></table></figure><p>从请求队列中提取请求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// block/blk-core.c</span><br><span class="hljs-keyword">struct</span> request *<span class="hljs-title function_">blk_fetch_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q)</span><br></code></pre></td></tr></table></figure><p>在卸载函数中使用的清除请求队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// block/blk-core.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">blk_cleanup_queue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q)</span><br></code></pre></td></tr></table></figure><p>块设备的读写请求放置在请求队列中，在struct gendisk中，通过struct request_queue *queue指针指向请求队列；请求队列用数据结构struct request_queue表示；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/blkdev.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">queue_head</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span>      *<span class="hljs-title">last_merge</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elevator_queue</span>   *<span class="hljs-title">elevator</span>;</span><br>......<br>    request_fn_proc     *request_fn;<br>    make_request_fn     *make_request_fn;<br>......<br>    <span class="hljs-type">void</span>            *queuedata;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">icq_list</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_limits</span> <span class="hljs-title">limits</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_flush_queue</span>  *<span class="hljs-title">fq</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">requeue_list</span>;</span><br>    <span class="hljs-type">spinlock_t</span>      requeue_lock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">delayed_work</span> <span class="hljs-title">requeue_work</span>;</span><br>......<br>&#125;;<br></code></pre></td></tr></table></figure><p>queue_head：表头，用于构建一个IO请求的双链表；链表每个元素代表向块设备读取数据的一个请求；内核会重排该链表，以得到更好的IO性能；</p><p>与每个块设备驱动程序相关的I&#x2F;O请求队列用request_queue结构体描述，而每个request_queue队列中的请求用request结构体描述；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/blkdev.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">queuelist</span>;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">q</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_ctx</span> *<span class="hljs-title">mq_ctx</span>;</span><br><br>    <span class="hljs-comment">/* the following two fields are internal, NEVER access directly */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __data_len;    <span class="hljs-comment">/* total data len */</span><br>    <span class="hljs-type">sector_t</span> __sector;      <span class="hljs-comment">/* sector cursor */</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> *<span class="hljs-title">bio</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> *<span class="hljs-title">biotail</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">next_rq</span>;</span><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>request结构体关联了struct bio，struct bio结构体是块I&#x2F;O操作在页级粒度的底层描述；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/blk_types.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span>      *<span class="hljs-title">bi_next</span>;</span>   <span class="hljs-comment">/* request queue link */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device</span> *<span class="hljs-title">bi_bdev</span>;</span><br>    <span class="hljs-type">int</span>         bi_error;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>      bi_flags;   <span class="hljs-comment">/* status, command, etc */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>      bi_ioprio;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bvec_iter</span>    <span class="hljs-title">bi_iter</span>;</span><br><br>    <span class="hljs-type">atomic_t</span>        __bi_remaining;<br>    <span class="hljs-type">bio_end_io_t</span>        *bi_end_io;<br>    <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>      bi_vcnt;    <span class="hljs-comment">/* how many bio_vec&#x27;s */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>      bi_max_vecs;    <span class="hljs-comment">/* max bvl_vecs we can hold */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span>      *<span class="hljs-title">bi_io_vec</span>;</span> <span class="hljs-comment">/* the actual vec list */</span><br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>块数据通过bio_vec结构体数组在内部被表示成I&#x2F;O向量；每个bio_vec数组元素由三元组组成（即，页、页偏移、长度），表示该块I&#x2F;O的一个段；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/bvec.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">bv_page</span>;</span><span class="hljs-comment">// 页指针</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>    bv_len;<span class="hljs-comment">// 传输的字节数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>    bv_offset;<span class="hljs-comment">// 偏移位置</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>struct bvec_iter结构体用来记录当前bvec被处理的情况，用于遍历bio；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/bvec.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bvec_iter</span> &#123;</span><br>    <span class="hljs-type">sector_t</span>        bi_sector;  <span class="hljs-comment">/* device address in 512 byte sectors */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>bi_size;    <span class="hljs-comment">/* residual I/O count */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>bi_idx;     <span class="hljs-comment">/* current index into bvl_vec */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>bi_bvec_done;   <span class="hljs-comment">/* number of bytes completed in current bvec */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-5-数据结构之间的关系"><a href="#3-5-数据结构之间的关系" class="headerlink" title="3.5 数据结构之间的关系"></a>3.5 数据结构之间的关系</h3><img src="/2023/07/16/%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/image-20230716175745706.png" alt="image-20230716175745706" style="zoom:80%;"><p><strong>块设备数据结构间的关系如下所示：</strong></p><img src="/2023/07/16/%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/块设备数据结构间的关系.png" alt="块设备数据结构间的关系" style="zoom:80%;"><p>bio、bio_vector和Page之间的关系如下所示：</p><img src="/2023/07/16/%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/100045938-83908-2.png" alt="img" style="zoom:80%;"><h2 id="4-块设备驱动的初始化"><a href="#4-块设备驱动的初始化" class="headerlink" title="4.块设备驱动的初始化"></a>4.块设备驱动的初始化</h2><h2 id="千峰视频"><a href="#千峰视频" class="headerlink" title="千峰视频"></a>千峰视频</h2><p><a href="https://www.bilibili.com/video/BV1dG4y1E7x1?p=1&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">https://www.bilibili.com/video/BV1dG4y1E7x1?p=1&amp;vd_source=0a2a531b678f5afe0a34f933b2fbdcb4</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是页缓存Page Cache</title>
    <link href="/2023/07/16/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%B5%E7%BC%93%E5%AD%98Page-Cache/"/>
    <url>/2023/07/16/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%B5%E7%BC%93%E5%AD%98Page-Cache/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是页缓存Page-Cache"><a href="#什么是页缓存Page-Cache" class="headerlink" title="什么是页缓存Page Cache"></a>什么是页缓存Page Cache</h1><blockquote><p>转载自：<a href="https://cloud.tencent.com/developer/article/1848933">https://cloud.tencent.com/developer/article/1848933</a></p></blockquote><p>我们知道文件一般存放在硬盘（机械硬盘或固态硬盘）中，CPU 并不能直接访问硬盘中的数据，而是需要先将硬盘中的数据读入到内存中，然后才能被 CPU 访问。</p><p>由于读写硬盘的速度比读写内存要慢很多（DDR4 内存读写速度是机械硬盘500倍，是固态硬盘的200倍），所以为了避免每次读写文件时，都需要对硬盘进行读写操作，Linux 内核使用 <code>页缓存（Page Cache）</code> 机制来对文件中的数据进行缓存。</p><blockquote><p>本文使用的 Linux 内核版本为：Linux-2.6.23</p></blockquote><h2 id="什么是也页缓存"><a href="#什么是也页缓存" class="headerlink" title="什么是也页缓存"></a>什么是也页缓存</h2><p>为了提升对文件的读写效率，<strong>Linux 内核会以页大小（4KB）为单位，将文件划分为多数据块</strong>。当用户对文件中的某个数据块进行读写操作时，内核首先会<u>申请一个内存页（称为 <code>页缓存</code>）</u>与文件中的数据块进行绑定。如下图所示：</p><img src="/2023/07/16/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%B5%E7%BC%93%E5%AD%98Page-Cache/1200.png" alt="img" style="zoom: 67%;"><p>如上图所示，当用户对文件进行读写时，实际上是对文件的 <code>页缓存</code> 进行读写。所以对文件进行读写操作时，会分以下两种情况进行处理：</p><ul><li>当从文件中读取数据时，如果要读取的数据所在的页缓存已经存在，那么就直接把页缓存的数据拷贝给用户即可。否则，内核首先会申请一个空闲的内存页（页缓存），然后从文件中读取数据到页缓存，并且把页缓存的数据拷贝给用户。</li><li>当向文件中写入数据时，如果要写入的数据所在的页缓存已经存在，那么直接把新数据写入到页缓存即可。否则，内核首先会申请一个空闲的内存页（页缓存），然后从文件中读取数据到页缓存，并且把新数据写入到页缓存中。对于被修改的页缓存，内核会定时把这些页缓存刷新到文件中。</li></ul><h2 id="页缓存的实现"><a href="#页缓存的实现" class="headerlink" title="页缓存的实现"></a>页缓存的实现</h2><p>前面主要介绍了页缓存的作用和原理，接下来我们将会分析 Linux 内核是怎么实现页缓存机制的。</p><ol><li><strong>address_space</strong></li></ol><p>在 Linux 内核中，使用 <code>file</code> 对象来描述一个被打开的文件，其中有个名为 <code>f_mapping</code> 的字段，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *<span class="hljs-title">f_mapping</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>从上面代码可以看出，<code>f_mapping</code> 字段的类型为 <code>address_space</code> 结构，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>           *<span class="hljs-title">host</span>;</span>      <span class="hljs-comment">/* owner: inode, block_device */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_root</span> <span class="hljs-title">page_tree</span>;</span>  <span class="hljs-comment">/* radix tree of all pages */</span><br>    <span class="hljs-type">rwlock_t</span>               tree_lock;  <span class="hljs-comment">/* and rwlock protecting it */</span><br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>address_space</code> 结构其中的一个作用就是用于存储文件的 <code>页缓存</code>，下面介绍一下各个字段的作用：</p><ul><li><code>host</code>：指向当前 <code>address_space</code> 对象所属的文件 <code>inode</code> 对象（每个文件都使用一个 <code>inode</code> 对象表示）。</li><li><code>page_tree</code>：用于存储当前文件的 <code>页缓存</code>。</li><li><code>tree_lock</code>：用于防止并发访问 <code>page_tree</code> 导致的资源竞争问题。</li></ul><p>从 <code>address_space</code> 对象的定义可以看出，文件的 <code>页缓存</code> 使用了 <code>radix树</code> 来存储。</p><blockquote><p><code>radix树</code>：又名基数树，它使用键值（key-value）对的形式来保存数据，并且可以通过键快速查找到其对应的值。内核以文件读写操作中的数据 <code>偏移量</code> 作为键，以数据偏移量所在的 <code>页缓存</code> 作为值，存储在 <code>address_space</code> 结构的 <code>page_tree</code> 字段中。</p></blockquote><p>下图展示了上述各个结构之间的关系：</p><img src="/2023/07/16/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%B5%E7%BC%93%E5%AD%98Page-Cache/1200-1689498860578-3.png" alt="img" style="zoom: 80%;"><ol start="2"><li><strong>读文件操作</strong></li></ol><p>现在我们来分析一下读取文件数据的过程，用户可以通过调用 <code>read</code> 系统调用来读取文件中的数据，其调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">read()<br>└→ sys_read()<br>   └→ vfs_read()<br>      └→ do_sync_read()<br>         └→ generic_file_aio_read()<br>            └→ do_generic_file_read()<br>               └→ do_generic_mapping_read()<br></code></pre></td></tr></table></figure><p>从上面的调用链可以看出，<code>read</code> 系统调用最终会调用 <code>do_generic_mapping_read</code> 函数来读取文件中的数据，其实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">do_generic_mapping_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> address_space *mapping,</span><br><span class="hljs-params">                        <span class="hljs-keyword">struct</span> file_ra_state *_ra,</span><br><span class="hljs-params">                        <span class="hljs-keyword">struct</span> file *filp,</span><br><span class="hljs-params">                        <span class="hljs-type">loff_t</span> *ppos,</span><br><span class="hljs-params">                        <span class="hljs-type">read_descriptor_t</span> *desc,</span><br><span class="hljs-params">                        <span class="hljs-type">read_actor_t</span> actor)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> =</span> mapping-&gt;host;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> index;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">cached_page</span>;</span><br>    ...<br><br>    cached_page = <span class="hljs-literal">NULL</span>;<br>    index = *ppos &gt;&gt; PAGE_CACHE_SHIFT;<br>    ...<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br>        ...<br><br>find_page:<br>        <span class="hljs-comment">// 1. 查找文件偏移量所在的页缓存是否存在</span><br>        page = find_get_page(mapping, index);<br>        <span class="hljs-keyword">if</span> (!page) &#123;<br>            ...<br>            <span class="hljs-comment">// 2. 如果页缓存不存在, 那么跳到 no_cached_page 进行处理</span><br>            <span class="hljs-keyword">goto</span> no_cached_page; <br>        &#125;<br>        ...<br><br>page_ok:<br>        ...<br>        <span class="hljs-comment">// 3. 如果页缓存存在, 那么把页缓存的数据拷贝到用户应用程序的内存中</span><br>        ret = actor(desc, page, offset, nr);<br>        ...<br>        <span class="hljs-keyword">if</span> (ret == nr &amp;&amp; desc-&gt;count)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">goto</span> out;<br>        ...<br><br>readpage:<br>        <span class="hljs-comment">// 4. 从文件读取数据到页缓存中</span><br>        error = mapping-&gt;a_ops-&gt;readpage(filp, page);<br>        ...<br>        <span class="hljs-keyword">goto</span> page_ok;<br>        ...<br><br>no_cached_page:<br>        <span class="hljs-keyword">if</span> (!cached_page) &#123;<br>            <span class="hljs-comment">// 5. 申请一个内存页作为页缓存</span><br>            cached_page = page_cache_alloc_cold(mapping);<br>            ...<br>        &#125;<br><br>        <span class="hljs-comment">// 6. 把新申请的页缓存添加到文件页缓存中</span><br>        error = add_to_page_cache_lru(cached_page, mapping, index, GFP_KERNEL);<br>        ...<br>        page = cached_page;<br>        cached_page = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">goto</span> readpage;<br>    &#125;<br><br>out:<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>do_generic_mapping_read</code> 函数的实现比较复杂，经过精简后，上面代码只留下最重要的逻辑，可以归纳为以下几个步骤：</p><ul><li>通过调用 <code>find_get_page</code> 函数查找要读取的文件偏移量所对应的页缓存是否存在，如果存在就把页缓存中的数据拷贝到应用程序的内存中。</li><li>否则调用 <code>page_cache_alloc_cold</code> 函数申请一个空闲的内存页作为新的页缓存，并且通过调用 <code>add_to_page_cache_lru</code> 函数把新申请的页缓存添加到文件页缓存和 LRU 队列中（后面会介绍）。</li><li>通过调用 <code>readpage</code> 接口从文件中读取数据到页缓存中，并且把页缓存的数据拷贝到应用程序的内存中。</li></ul><p>从上面代码可以看出，当页缓存不存在时会申请一块空闲的内存页作为页缓存，并且通过调用 <code>add_to_page_cache_lru</code> 函数把其添加到文件的页缓存和 LRU 队列中。我们来看看 <code>add_to_page_cache_lru</code> 函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-type">int</span> <span class="hljs-title function_">add_to_page_cache_lru</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-keyword">struct</span> address_space *mapping,</span><br><span class="hljs-params">                           <span class="hljs-type">pgoff_t</span> offset, <span class="hljs-type">gfp_t</span> gfp_mask)</span><br>&#123;<br>    <span class="hljs-comment">// 1. 把页缓存添加到文件页缓存中</span><br>    <span class="hljs-type">int</span> ret = add_to_page_cache(page, mapping, offset, gfp_mask);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>        lru_cache_add(page); <span class="hljs-comment">// 2. 把页缓存添加到 LRU 队列中</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>add_to_page_cache_lru</code> 函数主要完成两个工作：</p><ul><li>通过调用 <code>add_to_page_cache</code> 函数把页缓存添加到文件页缓存中，也就是添加到 <code>address_space</code> 结构的 <code>page_tree</code> 字段中。</li><li>通过调用 <code>lru_cache_add</code> 函数把页缓存添加到 LRU 队列中。LRU 队列用于当系统内存不足时，对页缓存进行清理时使用。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 <code>页缓存</code> 的作用和原理，并且介绍了在读取文件数据时对页缓存的处理过程。本文并没有介绍写文件操作对应的页缓存处理和当系统内存不足时怎么释放页缓存，有兴趣的话可以自行阅读相关的代码实现。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>struct结构体内存对齐</title>
    <link href="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://www.cnblogs.com/hyacinthLJP/p/16041690.html">https://www.cnblogs.com/hyacinthLJP/p/16041690.html</a></p><p>作者： <a href="https://www.cnblogs.com/hyacinthLJP">MElephant</a></p></blockquote><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>我们自定义两个结构体 A 和 B：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c1;<br>    <span class="hljs-type">char</span> c2;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> d;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c1;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> c2;<br>    <span class="hljs-type">double</span> d;<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过定义我们可以看出，结构体 A 和 B 拥有相同的成员，只不过在排列顺序上有所不同；</p><p>众所周知，char 类型占 1 个字节，int 类型占 4 个字节，double 类型占 8 个字节</p><p>那么，这两个结构体所占内存空间大小为多少呢？占用的空间是否相同？</p><p>空口无凭，让我们通过编译器告诉我们答案（我使用的是 VS2022，X86）。</p><p>在 main() 函数中输出如下语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;结构体A所占内存大小为：%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(A));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;结构体B所占内存大小为：%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(B));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行之前，先盲猜一个结果：</p><p> <code>sizeof(A) = sizeof(B) = sizeof(c1)+sizeof(c2)+sizeof(i)+sizeof(d) = 1+1+4+8 = 14</code></p><p>到底对不对呢？让我们来看看运行结果：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322175926325-808092561.png" alt="img" style="zoom: 80%;"><p>amazing~~</p><p>竟然一个都没猜对，这究竟是怎么回事呢？</p><p>下面开始进入今天的主题——struct 内存对齐。</p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>一种提高内存访问速度的策略，CPU 在访问未对齐的内存可能需要经过两次的内存访问，而经过内存对齐一次就可以了。</p><p>假定现在有一个 32 位处理器，那这个处理器一次性读取或写入都是四字节。</p><p>假设现在有一个 32 位处理器要读取一个 int 类型的变量，在内存对齐的情况下，处理器是这样进行读取的：</p><p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322180540589-204374352.png" alt="img" style="zoom:80%;">那如果数据存储没有按照内存对齐的方式进行的话，处理器就会这样进行读取：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322180810600-1218351587.png" alt="img" style="zoom:80%;"><p>对比内存对齐和内存没有对齐两种情况我们可以明显地看到，在内存对齐的情况下，取得这个 int型 变量只需要经过一次寻址（0~3）；</p><p>但在内存没有对齐的情况下，取得这个 int型 变量需要经过两次的寻址（0<del>3 和 4</del>7），然后再合并数据。</p><p>通过上述的分析，我们可以知道内存对齐能够提升性能，这也是我们要进行内存对齐的原因之一。</p><h2 id="内存对齐的原则"><a href="#内存对齐的原则" class="headerlink" title="内存对齐的原则"></a>内存对齐的原则</h2><ol><li>对于结构体的各个成员，除了第一个成员的偏移量为 0 外，其余成员的偏移量是 其实际长度 的整数倍，如果不是，则在前一个成员后面补充字节。</li><li>结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍。</li><li>如程序中有 #pragma pack(n) 预编译指令，则所有成员对齐以 n字节 为准（即偏移量是n的整数倍），不再考虑当前类型以及最大结构体内类型。</li></ol><p>下面通过样例来分享一下我的见解，为方便理解，声明如下：</p><ul><li>定义的结构体包含 char , short , int , double类型各一个，并通过不同的组合构造出不同的结构体 Test01 , Test02 , Test03 , Test04</li><li>内存地址的编号设置为 0~24</li><li>char 类型占1 个 字节，并用橙色填充</li><li>short 类型占 2个 字节，并用黄色填充</li><li>int 类型占 4个 字节，并用绿色填充</li><li>double 类型占 8个 字节，并用蓝色填充</li><li>补充字节用黑色填充</li></ul><h3 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test01</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">short</span> s;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> d;<br>&#125;t1;<br></code></pre></td></tr></table></figure><p>内存分布情况：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322210431773-1594212085.png" alt="img" style="zoom:80%;"><ul><li>第一个成员 c 的偏移量为 0，所以成员 c 的内存空间的首地址为 0</li><li>第二个成员 s 的内存空间的首地址为 2 号地址，偏移量为 2 - 0 &#x3D; 2</li><li>第三个成员 i 的内存空间的首地址为 4 号地址，偏移量为 4 - 0 &#x3D; 4</li><li>第三个成员 d 的内存空间的首地址为 8 号地址，偏移量为 8 - 0 &#x3D; 8</li><li>Test01 所占内存大小为 16 个字节</li></ul><p>让我们通过输出来验证一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">showTest01</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test01所占内存大小：%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(Test01));<br>    <span class="hljs-comment">//并按照声明顺序输出 Test01 中的成员变量地址对应的十六进制</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;t1.c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;t1.s);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;t1.i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;t1.d);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322212203167-1077116233.png" alt="img" style="zoom:80%;"><p>我们将输出的十六进制地址转化为十进制：</p><blockquote><p> 00209400 -&gt; 2135040</p><p> 00209402 -&gt; 2135042</p><p> 00209404 -&gt; 2135044</p><p> 00209408 -&gt; 2135048</p></blockquote><ul><li>以第一个成员 c 的起始地址为起点</li><li>第二个成员 s 的偏移量为 2</li><li>第三个成员 i 的偏移量为 4</li><li>第四个成员 d 的偏移量为 8</li><li>所占内存大小为 16</li></ul><p>验证成功！</p><h3 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h3><p>调换一下成员顺序，再次测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test02</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">double</span> d;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">short</span> s;<br>&#125;t2;<br></code></pre></td></tr></table></figure><p>内存分布情况：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322213003845-1448339865.png" alt="img" style="zoom:80%;"><ul><li>第一个成员 c 的偏移量为 0，所以成员 c 的内存空间的首地址为 0</li><li>第二个成员 d 的内存空间的首地址为 8 号地址，偏移量为 8 - 0 &#x3D; 8（double 类型的整倍数）</li><li>第三个成员 i 的内存空间的首地址为 16 号地址，偏移量为 16 - 0 &#x3D; 16（int 类型的整倍数）</li><li>第三个成员 s 的内存空间的首地址为 20 号地址，偏移量为 20 - 0 &#x3D; 20（short 类型的整倍数）</li><li>Test02 所占内存大小为 24 个字节（结构体占用内存大小是结构体内最大数据成员 double 的最小整数倍：24 &#x2F; 8 &#x3D; 4）</li></ul><p>接着通过输出来验证一下：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322213218244-1085267920.png" alt="img" style="zoom:80%;"><p>我们将输出的十六进制地址转化为十进制：</p><blockquote><p> 007C9410 -&gt; 8164368</p><p> 007C9418 -&gt; 8164376</p><p> 007C9420 -&gt; 8164384</p><p> 007C9424 -&gt; 8164388</p></blockquote><ul><li>以第一个成员 c 的起始地址为起点</li><li>第二个成员 d 的偏移量为 8164376 - 8164368 &#x3D; 8 </li><li>第三个成员 i 的偏移量为 8164384 - 8164368 &#x3D; 16 </li><li>第四个成员 d 的偏移量为 8164388 - 8164368 &#x3D; 20 </li><li>所占内存大小为 24</li></ul><p>验证成功！</p><h3 id="实验3-amp-实验4"><a href="#实验3-amp-实验4" class="headerlink" title="实验3 &amp; 实验4"></a>实验3 &amp; 实验4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test03</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">short</span> s;<br>    <span class="hljs-type">double</span> d;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> i;<br>&#125;t3;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test04</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">double</span> d;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">short</span> s;<br>&#125;t4;<br></code></pre></td></tr></table></figure><p>内存分布情况：</p><img src="/2023/07/11/struct%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/1494888-20220322214300062-750016192.png" alt="img" style="zoom:80%;"><p>可自行输出验证！！！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过自行模拟，再回过头看看内存对齐的原则，是不是有种恍然大明白的感觉~</p><p>通过模拟上述不同情况，你会发现同种类型的成员变量通过不同的组合，所占用的总内存是不相同的；</p><p>那么，关于结构体内成员定义的顺序应该遵循这样一个原则：按照长度递增的顺序依次定义各个成员。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>System DE Master Key流程分析</title>
    <link href="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="System-DE-Master-Key流程分析"><a href="#System-DE-Master-Key流程分析" class="headerlink" title="System DE Master Key流程分析"></a>System DE Master Key流程分析</h1><blockquote><p>参考：<a href="https://blog.csdn.net/cs_tech/article/details/127593457?spm=1001.2014.3001.5506">https://blog.csdn.net/cs_tech/article/details/127593457?spm=1001.2014.3001.5506</a></p><p>仅作自己学习备忘，侵权联系删除</p></blockquote><h2 id="1-创建-System-DE-Master-Key-流程"><a href="#1-创建-System-DE-Master-Key-流程" class="headerlink" title="1. 创建 System DE Master Key 流程"></a>1. 创建 System DE Master Key 流程</h2><p>下图展示了在设备第一次启动时，创建 System DE Master Key 的完整流程，在这个章节会对其拆分，分别介绍。</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/b325b451b58545b2aa95646471b01109.png" alt="img" style="zoom:80%;"><h3 id="1-1-创建-System-DE-Master-Key"><a href="#1-1-创建-System-DE-Master-Key" class="headerlink" title="1.1 创建 System DE Master Key"></a>1.1 创建 System DE Master Key</h3><p>在 vold 函数 fscrypt_initialize_systemwide_keys 中，Vold 通过 keymaster HAL 向 keymaster TA 请求创建 Master Key。在请求参数中， km::TAG_STORAGE_KEY 表明了创建一个用于存储器加密的 Master Key，HLOS 将这个 key 用作 System DE Master Key。</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/a564146a9d814d8987692446b88e4d1f.png" alt="img" style="zoom: 50%;"><p>这里要注意 keymaster TA 不会直接将 Master Key 的明文直接返回到 HLOS，而是 Master Key Blob。那么 Master Key Blob 是怎么生成的？</p><ol><li>KM TA 首选创建一个 AES 算法加密 key，作为 Master Key；</li><li>使用由 SHK 派生出来的 KEK 将 Master Key 加密，并把密文存放到特殊数据结构，即 key blob；</li><li>再使用由 SHK 派生出来的 HMAC Key 通过 HMAC 算法对 key blob 签名；</li><li>这样就生成了 Master Key Blob，返回到 HLOS 的 Vold；</li></ol><p><strong>疑问：SHK 是什么？KEK 是什么？HMAC Key 是什么？</strong></p><p>① SHK 是设备使能 secure boot 后，生成的一个每个设备唯一、软件或者固件无法导出的 key，TZ 可以从 SHK 派生出各种用途的 key。</p><p>② KEK 派生自 SHK ，用于加密 KM TA 生成的 key，因为 key 不允许暴露在 HLOS：</p><ul><li>当 HLOS 请求 KM TA 生成 key 时，可以使用 KEK 将 key 加密成 key blob 后返回给 HLOS；</li><li>key 只能在 secure world 下使用（包括：加密、解密、签名、校验等操作）。因此时 HLOS 有需求时，请求 KM TA 执行相关操作，需要将数据和 key blob 一起传给 KM TA，KM TA 使用 KEK 解密 key blob 得到 key，再对数据执行相关的操作；</li></ul><p>③ HMAC Key 派生自 SHK ，用于对 key blob 签名，保证了  key blob 不被恶意篡改或者检查是否损坏；</p><p><strong>疑问：为什么 TZ 要将 key 加密后返回 HLOS 呢？</strong></p><p>在实际用户场景中，各种各样的进程可能会创建几十个甚至几百个用于各种各样的任务的 key，加密后返回 HLOS，由使用者自行管理，那么 TZ 就无需维护较大的存储区域以及这些 key 与客户端的联系。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> KeyGeneration <span class="hljs-title">makeGen</span><span class="hljs-params">(<span class="hljs-type">const</span> EncryptionOptions&amp; options)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> KeyGeneration&#123;FSCRYPT_MAX_KEY_SIZE, <span class="hljs-literal">true</span>, options.use_hw_wrapped_key&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">retrieveOrGenerateKey</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key_path, <span class="hljs-type">const</span> std::string&amp; tmp_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-type">const</span> KeyAuthentication&amp; key_authentication, <span class="hljs-type">const</span> KeyGeneration&amp; gen,</span></span><br><span class="hljs-params"><span class="hljs-function">                           KeyBuffer* key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pathExists</span>(key_path)) &#123;<br>        <span class="hljs-built_in">LOG</span>(DEBUG) &lt;&lt; <span class="hljs-string">&quot;Key exists, using: &quot;</span> &lt;&lt; key_path;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">retrieveKey</span>(key_path, key_authentication, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!gen.allow_gen) &#123;<br>            <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;No key found in &quot;</span> &lt;&lt; key_path;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Creating new key in &quot;</span> &lt;&lt; key_path;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateStorageKey</span>(gen, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 生成Master Key</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">storeKeyAtomically</span>(key_path, tmp_path, key_authentication, *key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 生成最终的加密秘钥encrypted key</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里先调用generateStorageKey生成Master Key：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">generateStorageKey</span><span class="hljs-params">(<span class="hljs-type">const</span> KeyGeneration&amp; gen, KeyBuffer* key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (gen.use_hw_wrapped_key) &#123;  <span class="hljs-comment">/* 使用硬件生成密钥 */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">generateWrappedStorageKey</span>(key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">/* 纯软生成随机秘钥 */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">randomKey</span>(gen.keysize, key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用generateWrappedStorageKey生成秘钥</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">generateWrappedStorageKey</span><span class="hljs-params">(KeyBuffer* key)</span> </span>&#123;<br>    Keymaster keymaster;  <span class="hljs-comment">// 创建对象</span><br>    <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string key_temp;<br>    <span class="hljs-keyword">auto</span> paramBuilder = km::<span class="hljs-built_in">AuthorizationSetBuilder</span>().<span class="hljs-built_in">AesEncryptionKey</span>(AES_KEY_BYTES * <span class="hljs-number">8</span>);<br>    paramBuilder.<span class="hljs-built_in">Authorization</span>(km::TAG_STORAGE_KEY);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeymasterKey</span>(keymaster, paramBuilder, &amp;key_temp)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//</span><br>    *key = <span class="hljs-built_in">KeyBuffer</span>(key_temp.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-built_in">memcpy</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(key-&gt;<span class="hljs-built_in">data</span>()), key_temp.<span class="hljs-built_in">c_str</span>(), key-&gt;<span class="hljs-built_in">size</span>());  <span class="hljs-comment">// 将临时生成的秘钥拷贝到key中</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">generateKeymasterKey</span><span class="hljs-params">(Keymaster&amp; keymaster,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> km::AuthorizationSetBuilder&amp; paramBuilder,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 std::string* key)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> paramsWithRollback = paramBuilder;<br>    paramsWithRollback.<span class="hljs-built_in">Authorization</span>(km::TAG_ROLLBACK_RESISTANCE);<br>    <span class="hljs-keyword">if</span> (!keymaster.<span class="hljs-built_in">generateKey</span>(paramsWithRollback, key)) &#123; <span class="hljs-comment">// 调用keymaster对象的generateKey方法</span><br>        <span class="hljs-keyword">if</span> (!keymaster.<span class="hljs-built_in">generateKey</span>(paramBuilder, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Keymaster::generateKey</span><span class="hljs-params">(<span class="hljs-type">const</span> km::AuthorizationSet&amp; inParams, std::string* key)</span> </span>&#123;<br>    ks2::KeyDescriptor in_key = &#123;<br>            .domain = ks2::Domain::BLOB,<br>            .alias = std::<span class="hljs-literal">nullopt</span>,<br>            .nspace = VOLD_NAMESPACE,<br>            .blob = std::<span class="hljs-literal">nullopt</span>,<br>    &#125;;<br>    ks2::KeyMetadata keyMetadata;<br>    <span class="hljs-comment">// securityLevel是共享智能指针std::shared_ptr&lt;ks2::IKeystoreSecurityLevel&gt; securityLevel;</span><br>    <span class="hljs-keyword">auto</span> rc = securityLevel-&gt;<span class="hljs-built_in">generateKey</span>(in_key, std::<span class="hljs-literal">nullopt</span>, inParams.<span class="hljs-built_in">vector_data</span>(), <span class="hljs-number">0</span>, &#123;&#125;, &amp;keyMetadata);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">logKeystore2ExceptionIfPresent</span>(rc, <span class="hljs-string">&quot;generateKey&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (keyMetadata.key.blob == std::<span class="hljs-literal">nullopt</span>) &#123;<br>        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;keystore2 generated key blob was null&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (key) *key = std::<span class="hljs-built_in">string</span>(keyMetadata.key.blob-&gt;<span class="hljs-built_in">begin</span>(), keyMetadata.key.blob-&gt;<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-built_in">zeroize_vector</span>(keyMetadata.key.blob.<span class="hljs-built_in">value</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>这里面有个地方需要说明一下，IKeystoreSecurityLevel这个里面提供的aidl接口，参考<a href="https://blog.csdn.net/weixin_42135087/article/details/125172636">https://blog.csdn.net/weixin_42135087/article/details/125172636</a></p></blockquote><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230711231226553.png" alt="image-20230711231226553" style="zoom:67%;"><h3 id="1-2-HLOS-把-System-DE-Master-Key-Blob-加密后保存到文件系统"><a href="#1-2-HLOS-把-System-DE-Master-Key-Blob-加密后保存到文件系统" class="headerlink" title="1.2 HLOS 把 System DE Master Key Blob 加密后保存到文件系统"></a>1.2 HLOS 把 System DE Master Key Blob 加密后保存到文件系统</h3><p>在上一个步骤中，KM TA 创建了 Master Key （ km::TAG_STORAGE_KEY FBE），并以 key blob 的形式返回到 HLOS。在 vold 收到 Master Key Blob 后，又将这个 key blob 加密后保存到文件系统中。</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/da064c351cf545baac70a0203018796f.png" alt="img" style="zoom: 67%;"><p><strong>疑问：Master Key Blob 已经是密文了，为什么 vold 还要将 key blob 二次加密？</strong></p><p>这个操作似乎有点多余，如果对 key 加密一次不安全，那么加密两次也不见得更安全，或者为什么不加密更多次呢？</p><p>这里我们要从 FBE 的设计来看，<strong>Google 把 userdata 分区划分了不同安全等级的存储位置，但仅使用不同的密钥并不能体现出安全等级这个概念，而是要从对密钥的约束来体现，比如经过什么样的认证后，哪些位置的数据才允许访问，言下之意就是对应的加密密钥才允许被使用。</strong>那怎么认证呢？</p><p>System DE Master Key 的安全认证正是通过二次加密来体现的，但是加密 Master Key 的 key （KEK） 怎么做到这一点呢？System DE 的设计初衷就是相应的存储位置是设备绑定，即这些存储位置的数据只能在特定的设备（CPU、存储器绑定）上才能解密和访问。Master Key 只负责用户加解密文件的数据，但是特定的设备怎么保证呢？</p><p>这就是加密 Master Key 的 key 要达成的目标，我们把这个 key 称作 KSK（Key Strorage Key，这不是专有名词，而是按照 Google 代码变量名来命名 ）。</p><p>从流程图中可以看出，在创建 KSK 时需要指定 app id（即表明谁创建的？）。同样后续使用这个 key 时，也必须指定相同的 appid。appid 的组成中包括设备绑定的信息（每台设备，KSK 的 appid 不一样，因为从它的创建流程可以看出，包括两个随机数 Secdiscardable 和 storage_binding_info.seed）。不仅如此，在 KM TA 内部还会将 secure boot 状态、设备锁状态、安全补丁日期等等信息和 KSK 绑定，在使用 KSK 之前，会校验相关的信息是否严格匹配，只有完全满足后，KSK 才允许用于解密 Master Blob。这些约束的实现都是在 KM TA 完成的。</p><p>这里举几个实际的例子说明：</p><blockquote><p><strong>例1：把一台设备的存储器所有数据，dump 到另外一台完全一致的设备上，用户数据为什么无法解密？</strong></p><p>因为 KSK 已经和 secure boot 状态绑定，在另外一台设备上，无法知道 EKE，进而无法解密 KSK blob，KSK 即无法被使用。当然被 KSK 加密的 master key blob 也无法解密，自然获取不到 master key 。实际实现不只如此简单，这里不做详细介绍。</p><p><strong>例2：同一台设备，如果 OTA 更新到安全补丁日期升级的软件后，再回滚到旧软件版本，用户数据为什么无法解密？</strong></p><p>因为 KSK 已经和安全补丁日期绑定，安全补丁日期不能减小。安全补丁日期回滚后，KSK 将不可用。</p><p><strong>例3：设备第一次开机是在设备锁（也叫 fastboot锁）锁定的情况下开机，那么 unlock 设备锁后，用户数据为什么无法解密？</strong></p><p>因为 KSK 和设备锁的状态绑定，如果设备锁的状态出现反转，KSK 将不可用。</p></blockquote><p><strong>疑问：加密 Master Key Blob 的 key KSK 从何而来 ？</strong></p><p>和 Master Key 类似，都是由 KM TA 创建的，并以 key blob 的形式返回 HLOS，由 vold 自行管理。这里注意创建 key 时，参数 km::AuthorizationSet 不一样，这就导致在 KM TA 内部，它们的管理和用途都是不一样。</p><p>vold 请求 KM TA 创建 KSK 所使用的 appid的参数、KSK Blob、加密后的 Master Key Blob 被存储到 &#x2F;data&#x2F;unencrypted&#x2F;key&#x2F;：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ls /data/unencrypted/key/ -l</span><br>total 16<br>-rw------- 1 root root   268 1970-01-03 04:47 encrypted_key<br>-rw------- 1 root root   194 1970-01-03 04:47 keymaster_key_blob<br>-rw------- 1 root root 16384 1970-01-03 04:47 secdiscardable<br>-rw------- 1 root root    10 1970-01-03 04:47 stretching<br>-rw------- 1 root root     1 1970-01-03 04:47 version<br></code></pre></td></tr></table></figure><p><strong>疑问：第一次开机时，为什么要把 KSK blob  和 加密后的 Master Key Blob 保存到文件系统？</strong></p><p>后续每次开机，可以直接通过 KSK blob （&#x2F;data&#x2F;unencrypted&#x2F;key&#x2F;keymaster_key_blob）解密Master Key Blob 的密文（&#x2F;data&#x2F;unencrypted&#x2F;keyencrypted_key）得到 Master Key Blob，这个动作是在 TZ 内部完成的，有了 Master Key Blob，那么可以将 Master Key 安装到 kernel keyring，详见下文。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">storeKey</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; dir, <span class="hljs-type">const</span> KeyAuthentication&amp; auth, <span class="hljs-type">const</span> KeyBuffer&amp; key)</span> </span>&#123;<br><span class="hljs-comment">// 将kCurrentVersion(1)写入到/data/unencrypted/key/version</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kCurrentVersion, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_version)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string secdiscardable_hash;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">createSecdiscardable</span>(dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_secdiscardable, &amp;secdiscardable_hash)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string stretching = <span class="hljs-built_in">getStretching</span>(auth);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(stretching, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_stretching)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string appId;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateAppId</span>(auth, stretching, secdiscardable_hash, &amp;appId)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string encryptedKey;<br>    <span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;<br>        Keymaster keymaster;<br>        <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        std::string kmKey;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeyStorageKey</span>(keymaster, appId, &amp;kmKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kmKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_keymaster_key_blob)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        km::AuthorizationSet keyParams = <span class="hljs-built_in">beginParams</span>(appId);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithKeymasterKey</span>(keymaster, dir, keyParams, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithoutKeymaster</span>(appId, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(encryptedKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_encrypted_key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">FsyncDirectory</span>(dir)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-1-写入version"><a href="#1-2-1-写入version" class="headerlink" title="1.2.1 写入version"></a>1.2.1 写入version</h4><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230711231926237.png" alt="image-20230711231926237" style="zoom: 67%;"><h4 id="1-2-2-写入secdiscardable"><a href="#1-2-2-写入secdiscardable" class="headerlink" title="1.2.2 写入secdiscardable"></a>1.2.2 写入secdiscardable</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// filename: /data/unencrypted/key/secdiscardable</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">createSecdiscardable</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename, std::string* hash)</span> </span>&#123;<br>    std::string secdiscardable;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">readRandomBytesOrLog</span>(SECDISCARDABLE_BYTES, &amp;secdiscardable)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 通过/dev/urandom生成随机数</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(secdiscardable, filename)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 将生成的随机数保存到/data/unencrypted/key/secdiscardable</span><br>    <span class="hljs-built_in">hashWithPrefix</span>(kHashPrefix_secdiscardable, secdiscardable, hash); <span class="hljs-comment">// 将生成的随机数取hash</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-3-写入stretching"><a href="#1-2-3-写入stretching" class="headerlink" title="1.2.3 写入stretching"></a>1.2.3 写入stretching</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string stretching = <span class="hljs-built_in">getStretching</span>(auth); <span class="hljs-comment">// 如果有锁屏密码值为none，没有锁屏密码为nopassword</span><br><span class="hljs-built_in">writeStringToFile</span>(stretching, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_stretching);<span class="hljs-comment">// 将stretching值写入到/data/unencrypted/key/stretching</span><br><br><br><span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">getStretching</span><span class="hljs-params">(<span class="hljs-type">const</span> KeyAuthentication&amp; auth)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;<br>        <span class="hljs-keyword">return</span> kStretch_nopassword;  <span class="hljs-comment">// nopassword</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> kStretch_none;  <span class="hljs-comment">// none</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里得说下什么情况下，auth的usesKeymaster返回true</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712213844099.png" alt="image-20230712213844099" style="zoom:50%;"><p>我们知道这个secret是从FWK传下来的锁屏Credential。</p><p><strong>所以如果secret为空，也就是没有设置锁屏密码，返回True！</strong></p><h4 id="1-2-4-写入keymaster-key-blob"><a href="#1-2-4-写入keymaster-key-blob" class="headerlink" title="1.2.4 写入keymaster_key_blob"></a>1.2.4 写入keymaster_key_blob</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string appId;<br><span class="hljs-comment">// // 生成appId，如果设置了锁屏密码，则为appId = secdiscardable_hash + auth.secret；没有设置锁屏密码，则appId = secdiscardable_hash</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateAppId</span>(auth, stretching, secdiscardable_hash, &amp;appId)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>std::string encryptedKey;<br><span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;  <span class="hljs-comment">// 没有锁屏密码的时候</span><br>    Keymaster keymaster;<br>    <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string kmKey;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeyStorageKey</span>(keymaster, appId, &amp;kmKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 将生成的KSK Blob写入到/data/unencrypted/key/keymaster_key_blob</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kmKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_keymaster_key_blob)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    km::AuthorizationSet keyParams = <span class="hljs-built_in">beginParams</span>(appId);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithKeymasterKey</span>(keymaster, dir, keyParams, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 有锁屏密码的时候生成随机encryptedKey</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithoutKeymaster</span>(appId, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）generateKeyStorageKey生成KSK Blob</p><p>这里System CE Master Key走的是keymaster管理分支</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">generateKeyStorageKey<br>     -&gt; generateKeymasterKey<br>    -&gt; keymaster.generateKey<br></code></pre></td></tr></table></figure><p>最终还是调用了keymaster的generateKey方法（1.1节创建Master Key的时候已经创建过一次了），不同点在于：</p><ul><li>第一次生成的是Master Key的Blob</li><li>这次生成的是KeyStorageKey（简称KSK）的Blob</li><li>至于为什么要再生成KSK Blob，上面博主已经写得很清楚了</li></ul><p>（2）encryptWithKeymasterKey将生成的KSK Blob对Master Key Blob二次加密，生成最终的encryptedKey</p><h4 id="1-2-5-写入encrypted-key"><a href="#1-2-5-写入encrypted-key" class="headerlink" title="1.2.5 写入encrypted_key"></a>1.2.5 写入encrypted_key</h4><p>上面生成了最终的加密秘钥encrypted_key，随后写入到&#x2F;data&#x2F;unencrypted&#x2F;key&#x2F;encrypted_key</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712215850630.png" alt="image-20230712215850630" style="zoom:67%;"><h3 id="1-3-安装-Master-Key-到-kernel-keyring"><a href="#1-3-安装-Master-Key-到-kernel-keyring" class="headerlink" title="1.3 安装 Master Key 到 kernel keyring"></a>1.3 安装 Master Key 到 kernel keyring</h3><p>在上一步骤中，已经成功创建了 Master Key，那接下来就是要把 Master Key 注册到 kernel keyring。在文件 I&#x2F;O 时可以通过  Encryption Policy 的 master_key_identifier 字段从 kernel keyring 中找到 Master Key。</p><p>在这个步骤中的两个重点操作：</p><ol><li>安装 Master Key 到 kernel keyring；</li><li>生成 Master Key 的 master_key_identifier；</li></ol><p>软件流程图如下所示：</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/d231d91958ff4902bc5118818bb13942.png" alt="img" style="zoom: 80%;"><p>流程图比较复杂，接下来根据疑问来分解图中的步骤。</p><p><strong>疑问： Master Key 不是不允许暴露在 HLOS 吗？那注册到 kernel keyring 的 Master Key 从何而来？</strong></p><p>实际上是 Master Key 的 Wrapped Key 被注册到 kernel keyring ，毕竟 Master Key 确实不能暴露在 HLOS。那 Wrapped Key 从何而来？</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/e885b34443284656a74001cbcaaef2c1.png" alt="img" style="zoom: 80%;"><p> 从图中可知，生成 Wrapped Key 的过程：</p><ol><li>vold 把 Master Key Blob 传送到 KM TA，请求创建 Wrapped Key；</li><li>KM TA 使用 HMAC Key 校验 Master Key Blob ；</li><li>KM TA 使用 KEK 解密 Master Key Blob 得到 Master Key；</li><li>KM TA 使用 Ephemeral Key 通过 AES Wrap Key RFC3394 Algorithm 生成 Master Key 的 Wrapped Key<ol><li>Ephemeral Key：从 SHK  派生而来，但是每次设备重启（cold reboot）都会改变，意味着 Wrapped Key 每次设置重启都不一样；</li><li>AES Wrap Key RFC3394 Algorithm：详见 <a href="https://www.ietf.org/rfc/rfc3394.txt">Advanced Encryption Standard (AES) Key Wrap Algorithm</a></li></ol></li><li>KM TA 将生成的 Wrapped Key 返回 HLOS vold；</li><li>Vold 通过系统调用 ioctl  FS_IOC_ADD_ENCRYPTION_KEY，将 Wrapped Key 安装到 Kernel Keyring</li></ol><blockquote><ul><li>相反，KM TA 可以使用 Ephemeral Key 通过 AES Unwrap Key RFC3394 Algorithm  将 Wrapped Key 转成 Master Key。因此后面 HLOS 再软件流程中可以把  Wrapped Key 当作 Master Key，在实际执行操作时，KM TA 会将 Wrapped Key 自动转换成 Master Key 后再执行；</li><li>AES Wrap Key RFC3394 Algorithm 是什么？可以简单的理解为 AES 算法是专门用于数据加解密，而 AES Wrap Key RFC3394 Algorithm 专门用于加解密 AES Key;</li></ul></blockquote><p><strong>疑问：master_key_identifier 是怎么产生的？怎么通过 master_key_identifier 找到 Master Key？</strong></p><p>首先给出一张软件流程图，可以看到 master_key_identifier  是在安装 Wrapped Key 的过程中生成的，并且随系统调用返回到 vold 进程。<br><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/9ef600a59078447a938051efb9099422.png" alt="img" style="zoom:80%;"></p><p>生成 master_key_identifier  的步骤有：</p><ol><li>Kernel 函数 fscrypt_derive_raw_secret 将 Wrapped Key 发送到 TZ KM TA，请求 Master Key 派生 raw secret ；</li><li>KM TA 接收到请求后，使用 Ephemeral Key 通过 Unwrap Wrapped Key 得到 Master Key；</li><li>KM TA 通过 KDF ，使得 Master Key 派生出一个 key，并将这个派生 key 返回 HLOS Linux kernel</li><li>Linux Kernel 使用从 TZ 返回的派生 key 作为 KDF key，继续通过 KDF 派生出一个 key，这个 key 作为 master_key_identifier；</li></ol><hr><h4 id="1-3-1-重要的数据结构"><a href="#1-3-1-重要的数据结构" class="headerlink" title="1.3.1 重要的数据结构"></a>1.3.1 重要的数据结构</h4><h5 id="1-3-1-1-结构体key"><a href="#1-3-1-1-结构体key" class="headerlink" title="1.3.1.1 结构体key"></a>1.3.1.1 结构体key</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> &#123;</span><br><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyring_index_key</span> <span class="hljs-title">index_key</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>hash;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>len_desc;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key_type</span>*<span class="hljs-title">type</span>;</span><span class="hljs-comment">/* type of key */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key_tag</span>*<span class="hljs-title">domain_tag</span>;</span><span class="hljs-comment">/* Domain of operation */</span><br><span class="hljs-type">char</span>*description;<br>&#125;;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">key_payload</span> <span class="hljs-title">payload</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-comment">/* Keyring bits */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">name_link</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">assoc_array</span> <span class="hljs-title">keys</span>;</span><br>&#125;;<br>&#125;;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>有几个值得注意的点：</p><ul><li>index_key，类型为keyring_index_key，最终我们要通过这个变量获取master key</li><li>keyring和key的区别在于，keyring有一个keys关联数组，其类型为assoc_array，这个关联数组中存储了所有的master key</li></ul><h5 id="1-3-1-2-结构体变量key-type-keyring"><a href="#1-3-1-2-结构体变量key-type-keyring" class="headerlink" title="1.3.1.2 结构体变量key_type_keyring"></a>1.3.1.2 结构体变量key_type_keyring</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key_type</span> <span class="hljs-title">key_type_keyring</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;keyring&quot;</span>,<br>.def_datalen= <span class="hljs-number">0</span>,<br>.preparse= keyring_preparse,<br>.free_preparse= keyring_free_preparse,<br>.instantiate= keyring_instantiate,<br>.revoke= keyring_revoke,<br>.destroy= keyring_destroy,<br>.describe= keyring_describe,<br>.read= keyring_read,<br>&#125;;<br></code></pre></td></tr></table></figure><p>关于keyring相关的操作都在这个结构体里面了…</p><h4 id="1-3-2-添加秘钥"><a href="#1-3-2-添加秘钥" class="headerlink" title="1.3.2 添加秘钥"></a>1.3.2 添加秘钥</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fscrypt_ioctl_add_key</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">void</span> __user *_uarg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> file_inode(filp)-&gt;i_sb;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fscrypt_add_key_arg</span> __<span class="hljs-title">user</span> *<span class="hljs-title">uarg</span> =</span> _uarg;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fscrypt_add_key_arg</span> <span class="hljs-title">arg</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fscrypt_master_key_secret</span> <span class="hljs-title">secret</span>;</span><br><span class="hljs-type">int</span> err;<br><br>    <span class="hljs-comment">// 将用户空间的参数传入到内核空间,这里传进来的就是master key</span><br><span class="hljs-keyword">if</span> (copy_from_user(&amp;arg, uarg, <span class="hljs-keyword">sizeof</span>(arg))) <span class="hljs-keyword">return</span> -EFAULT;<br><br><span class="hljs-built_in">memset</span>(&amp;secret, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(secret));<br><br>err = add_master_key(sb, &amp;secret, &amp;arg.key_spec);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230717225544268.png" alt="image-20230717225544268" style="zoom: 50%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add_master_key</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> fscrypt_master_key_secret *secret,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> fscrypt_key_specifier *key_spec)</span> &#123;<br>    <span class="hljs-keyword">return</span> do_add_master_key(sb, secret, key_spec);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_add_master_key</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb,</span><br><span class="hljs-params">     <span class="hljs-keyword">struct</span> fscrypt_master_key_secret *secret,</span><br><span class="hljs-params">     <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> fscrypt_key_specifier *mk_spec)</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-title function_">DEFINE_MUTEX</span><span class="hljs-params">(fscrypt_add_key_mutex)</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">key</span>;</span><br><span class="hljs-type">int</span> err;<br><br>mutex_lock(&amp;fscrypt_add_key_mutex); <span class="hljs-comment">/* serialize find + link */</span><br>key = fscrypt_find_master_key(sb, mk_spec);<br><span class="hljs-keyword">if</span> (IS_ERR(key)) &#123;<br>err = allocate_filesystem_keyring(sb);<br>err = add_new_master_key(secret, mk_spec, sb-&gt;s_master_keys);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">allocate_filesystem_keyring</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb)</span> &#123;<br><span class="hljs-type">char</span> description[FSCRYPT_FS_KEYRING_DESCRIPTION_SIZE];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">keyring</span>;</span><br>    <br>    <span class="hljs-comment">// 将sb-&gt;s_id格式化成[&quot;fscrypt-%s&quot;, sb-&gt;s_id]保存到description变量中</span><br>    <span class="hljs-comment">// 这边的sb-&gt;s_id就是Data分区对应的设备名，如fscrypt-sda61</span><br>format_fs_keyring_description(description, sb);  <br>keyring = keyring_alloc(description, GLOBAL_ROOT_UID, GLOBAL_ROOT_GID, current_cred(), KEY_POS_SEARCH |<br>  KEY_USR_SEARCH | KEY_USR_READ | KEY_USR_VIEW, KEY_ALLOC_NOT_IN_QUOTA, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// ----------------------------------------------------------------------------</span><br><span class="hljs-keyword">struct</span> key *<span class="hljs-title function_">keyring_alloc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *description, <span class="hljs-type">kuid_t</span> uid, <span class="hljs-type">kgid_t</span> gid,</span><br><span class="hljs-params">  <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> cred *cred, <span class="hljs-type">key_perm_t</span> perm,</span><br><span class="hljs-params">  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> key_restriction *restrict_link,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> key *dest)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">keyring</span>;</span><br><br>    <span class="hljs-comment">// 申请keyring，将description设置到keyring的index_key成员变量中</span><br>keyring = key_alloc(&amp;key_type_keyring, description, uid, gid, cred, perm, flags, restrict_link);<br><span class="hljs-keyword">if</span> (!IS_ERR(keyring)) &#123;<br>ret = key_instantiate_and_link(keyring, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, dest, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> keyring;<br>&#125;<br><br><span class="hljs-keyword">struct</span> key *<span class="hljs-title function_">key_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> key_type *type, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *desc,</span><br><span class="hljs-params">      <span class="hljs-type">kuid_t</span> uid, <span class="hljs-type">kgid_t</span> gid, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> cred *cred,</span><br><span class="hljs-params">      <span class="hljs-type">key_perm_t</span> perm, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> key_restriction *restrict_link)</span> &#123;<br><span class="hljs-comment">// ...</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">key</span>;</span><br>key-&gt;index_key.desc_len = desclen;<br>key-&gt;index_key.description = kmemdup(desc, desclen + <span class="hljs-number">1</span>, GFP_KERNEL);<br>key-&gt;index_key.type = type;<br>key_set_index_key(&amp;key-&gt;index_key);<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-User-0-CE-Master-Key"><a href="#2-User-0-CE-Master-Key" class="headerlink" title="2.User.0 CE Master Key"></a>2.User.0 CE Master Key</h2><p>当用户设置用户锁屏密码后， User CE Master  key 的认证方式会改变，受用户密码保护，只有密码校验成功后，才能得到 User.0 CE Master Key，并将其安装到 kernel keyring。</p><p>User.0 CE Master Key 相关的认证数据被存储到目录 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;current 下。我们对比一下未设置锁屏密码和设置锁屏密码后，该目录下的文件差异：</p><ul><li>未设置锁屏密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; adb shell <span class="hljs-built_in">ls</span> /data/misc/vold/user_keys/ce/0/current -l<br>-rw------- 1 root root   268 2022-11-05 22:08 encrypted_key<br>-rw------- 1 root root   194 2022-11-05 22:08 keymaster_key_blob<br>-rw------- 1 root root 16384 2022-11-05 22:08 secdiscardable<br>-rw------- 1 root root    10 2022-11-05 22:08 stretching<br>-rw------- 1 root root     1 2022-11-05 22:08 version<br></code></pre></td></tr></table></figure><ul><li>设置锁屏密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; adb shell <span class="hljs-built_in">ls</span> /data/misc/vold/user_keys/ce/0/current -l<br>-rw------- 1 root root   268 2022-11-05 22:11 encrypted_key<br>-rw------- 1 root root 16384 2022-11-05 22:11 secdiscardable<br>-rw------- 1 root root     4 2022-11-05 22:11 stretching<br>-rw------- 1 root root     1 2022-11-05 22:11 version<br></code></pre></td></tr></table></figure><p>可以看到设置锁屏密码后，少了文件 keymaster_key_blob。在介绍 System DE Master Key 时已经知道，keymaster_key_blob 是 KM TA 创建的一个用于加密 Master Key Blob 的 key（上文称其为 KSK），用于保证 Master Key Blob 的安全性，作为设备绑定认证的一种实现，即 KSK 只能在唯一的设备（和CPU、存储器等器件绑定）上可用。</p><p>在用户设置锁屏密码后，认证更加严格，不仅要唯一的设备，而且需要用户输入正确的锁屏密码。因此，Master Key Blob  不再用 KSK 加密，它已经不能满足需求。</p><p><strong>疑问：encrypted_key 仍然存在，表明仍然使用对 Master Key Blob 加密的方式实现认证。但是加密 Master Key Blob 的 key 从哪里来？和用户锁屏密码存在什么关系？</strong></p><p>我们先看以下用户设置锁屏密码时，导致 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;current 下文件内容变化的流程：</p><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/9ff061c0788748cbadc82023fc2f90b6.png" alt="img" style="zoom:80%;"><p>AuthenticationToken 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthenticationToken</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> mVersion;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Here is the relationship between these fields:</span><br><span class="hljs-comment"> * Generate two random block P0 and P1. P1 is recorded in mEscrowSplit1 but P0 is not.</span><br><span class="hljs-comment"> * mSyntheticPassword = hash(P0 || P1)</span><br><span class="hljs-comment"> * E0 = P0 encrypted under syntheticPassword, recoreded in mEncryptedEscrowSplit0.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-meta">@NonNull</span> <span class="hljs-type">byte</span>[] mSyntheticPassword;<br><span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-type">byte</span>[] mEncryptedEscrowSplit0;<br><span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-type">byte</span>[] mEscrowSplit1;<br> <br>AuthenticationToken(<span class="hljs-type">byte</span> version) &#123;<br>mVersion = version;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Derives a subkey from the synthetic password. For v3 and later synthetic passwords the</span><br><span class="hljs-comment"> * subkeys are 256-bit; for v1 and v2 they are 512-bit.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] deriveSubkey(<span class="hljs-type">byte</span>[] personalization) &#123;<br><span class="hljs-keyword">if</span> (mVersion == SYNTHETIC_PASSWORD_VERSION_V3) &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">SP800Derive</span>(mSyntheticPassword))<br>.withContext(personalization, PERSONALISATION_CONTEXT);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> SyntheticPasswordCrypto.personalisedHash(personalization,<br>mSyntheticPassword);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] deriveDiskEncryptionKey() &#123;<br><span class="hljs-keyword">return</span> deriveSubkey(PERSONALIZATION_FBE_KEY);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Re-creates synthetic password from both escrow splits. See javadoc for</span><br><span class="hljs-comment"> * AuthenticationToken.mSyntheticPassword for details on what each block means.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recreate</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] escrowSplit0, <span class="hljs-type">byte</span>[] escrowSplit1)</span> &#123;<br>mSyntheticPassword = bytesToHex(SyntheticPasswordCrypto.personalisedHash(<br>PERSONALIZATION_SP_SPLIT, escrowSplit0, escrowSplit1));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Assign escrow data to this auth token. This is a prerequisite to call</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> AuthenticationToken#recreateFromEscrow&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEscrowData</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> <span class="hljs-type">byte</span>[] encryptedEscrowSplit0,</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> <span class="hljs-type">byte</span>[] escrowSplit1)</span> &#123;<br>mEncryptedEscrowSplit0 = encryptedEscrowSplit0;<br>mEscrowSplit1 = escrowSplit1;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Generates a new random synthetic password with escrow data.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> AuthenticationToken <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">AuthenticationToken</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthenticationToken</span>(SYNTHETIC_PASSWORD_VERSION_V3);<br><span class="hljs-type">byte</span>[] escrowSplit0 = secureRandom(SYNTHETIC_PASSWORD_LENGTH);<br><span class="hljs-type">byte</span>[] escrowSplit1 = secureRandom(SYNTHETIC_PASSWORD_LENGTH);<br>result.recreate(escrowSplit0, escrowSplit1);<br><span class="hljs-type">byte</span>[] encrypteEscrowSplit0 = SyntheticPasswordCrypto.encrypt(result.mSyntheticPassword,<br>PERSONALIZATION_E0, escrowSplit0);<br>result.setEscrowData(encrypteEscrowSplit0,  escrowSplit1);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结合代码和流程图可以看到，用户设置密码后，框架会直接调到 vold 执行更换 MasterKey 认证方式：</p><ol><li>调用函数 fscrypt_add_user_key_auth(user_id, serial, secret_hex），增加对 CE Master Key 的认证方式：<ol><li>首先，加载 keymaster_key_blob ，使用 KSK 解密 encrypted_key，得到 Master CE Key Blob；</li><li>接着，生成新的 appid，appid 由 fscrypt_add_user_key_auth 传入的参数 secret_hex 组成；</li><li>将 appid Hash 成 AES Key;</li><li>使用生成的 AES Key 加密  Master CE Key Blob，得到 encrypted_key；</li><li>将新的认证数据存储到 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;cx0000000000 下；</li><li>此时 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0 下已经存在两种 CE Master Key 的认证方式，如下所示</li></ol></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 老的认证方式，通过 KM key KSK 认证</span><br>&gt; adb shell <span class="hljs-built_in">ls</span> /data/misc/vold/user_keys/ce/0/current<br>encrypted_key<br>keymaster_key_blob<br>secdiscardable<br>stretching<br>version<br> <br><span class="hljs-comment"># 新的认证方式，通过用户密码校验认证</span><br>&gt; adb shell <span class="hljs-built_in">ls</span> /data/misc/vold/user_keys/ce/0/cx0000000000<br>encrypted_key<br>secdiscardable<br>stretching<br>version<br></code></pre></td></tr></table></figure><ol start="2"><li>调用 fscrypt_fixate_newest_user_key_auth，清除老的认证方式，改用用户密码认证，完成后，&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;cx0000000000 的内容将覆盖 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;current。vold 会打出如下的 log ：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">vold    : fscrypt_fixate_newest_user_key_auth 0<br>vold    : Deleting key /data/misc/vold/user_keys/ce/0/current/keymaster_key_blob from Keymaster<br>vold    : /system/bin/secdiscard<br>vold    :     --<br>vold    :     /data/misc/vold/user_keys/ce/0/current/encrypted_key<br>vold    :     /data/misc/vold/user_keys/ce/0/current/secdiscardable<br>vold    :     /data/misc/vold/user_keys/ce/0/current/keymaster_key_blob<br>vold    : /system/bin/rm<br>vold    :     -rf<br>vold    :     /data/misc/vold/user_keys/ce/0/current<br>vold    : Renaming /data/misc/vold/user_keys/ce/0/cx0000000000 to /data/misc/vold/user_keys/ce/0/current<br></code></pre></td></tr></table></figure><hr><h3 id="2-1-token与secret"><a href="#2-1-token与secret" class="headerlink" title="2.1 token与secret"></a>2.1 token与secret</h3><p>在Android系统重的设置密码、清除密码、修改密码，都是调用到LockSettingsService.java的setLockCredential函数进行的，而setLockCredential又调用了setLockCredentialInternal。【引用：<a href="https://blog.csdn.net/weixin_42135087/article/details/109726612?spm=1001.2014.3001.5506%E3%80%91">https://blog.csdn.net/weixin_42135087/article/details/109726612?spm=1001.2014.3001.5506】</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从[代码改变世界ctw](https://blog.csdn.net/weixin_42135087)大哥的博客中可以知道，当我们创建了设置用户密码的时候会调用到setLockCredentialInternal ，下面的调用栈如下：</span><br><br>setLockCredentialInternal -&gt; setUserKeyProtection -&gt; addUserKeyAuth<br></code></pre></td></tr></table></figure><p>⭐ 在我阅读代码的时候，暂且将：</p><ul><li>token理解成TEE世界发给我们的令牌，只有这个令牌我们才能做我们的事情，其本质是一个byte[]数组<ul><li>推荐文章：<a href="https://blog.csdn.net/weixin_42800689/article/details/84071690">auth认证相关</a>、<a href="https://blog.csdn.net/weixin_42135087/article/details/107861296">android密码解锁&#x2F;指纹解锁返回的authToken深度解剖</a></li><li>经过gatekeeper、生物认证（人脸、指纹）验证后返回的authToken，该authToken是经过了共享Hmackey签名的。所以在keystore使用一些功能的时候，会传下来这个authtoken，必须验证这个authtoken，才能进行后面的业务逻辑。【来源：<a href="https://blog.csdn.net/weixin_42135087/article/details/124565234">android gatekeeper(locksetting密码锁)学习这一篇就够了</a>】</li><li>🔕但是注意一下：<strong>FBE是不需要这个authtoken的</strong></li></ul></li><li>secret就理解成锁屏密码，只不过会从密码包装一下变成了LockscreenCredential对象，又通过secretFromCredential包装成了一个byte数组</li></ul><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712233532925.png" alt="image-20230712233532925" style="zoom: 50%;"><h3 id="2-2-addUserKeyAuth层层调用"><a href="#2-2-addUserKeyAuth层层调用" class="headerlink" title="2.2  addUserKeyAuth层层调用"></a>2.2  addUserKeyAuth层层调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\locksettings\LockSettingsService.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUserKeyAuth</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> mUserManager.getUserInfo(userId);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">callingId</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>    <span class="hljs-comment">// 调用SMS的addUserKeyAuth方法</span><br>    mStorageManager.addUserKeyAuth(userId, userInfo.serialNumber, token, secret);<br>&#125;<br><br><span class="hljs-comment">// ---------------------------------------------------------------</span><br><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\StorageManagerService.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUserKeyAuth</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">int</span> serialNumber, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret)</span> &#123;<br>    mVold.addUserKeyAuth(userId, serialNumber, encodeBytes(token), encodeBytes(secret));<br>&#125;<br><br><span class="hljs-comment">// ---------------------------------------------------------------</span><br><span class="hljs-comment">// system\vold\VoldNativeService.cpp</span><br>binder::Status VoldNativeService::addUserKeyAuth(int32_t userId, int32_t userSerial,<br>                                                 const std::string&amp; token,<br>                                                 const std::string&amp; secret) &#123;<br>    <span class="hljs-keyword">if</span> (!token_empty(token)) &#123;<br>        LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;Vold doesn&#x27;t use auth tokens, but non-empty token passed to addUserKeyAuth.&quot;</span>;<br>        <span class="hljs-keyword">return</span> binder::Status::fromServiceSpecificError(-EINVAL);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> translateBool(fscrypt_add_user_key_auth(userId, userSerial, secret));<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的注释可以看出，Vold服务是不需要AuthToken的，所以不需要向FBE传递。</p><h3 id="2-3-fscrypt-add-user-key-auth开始添加用户权限"><a href="#2-3-fscrypt-add-user-key-auth开始添加用户权限" class="headerlink" title="2.3 fscrypt_add_user_key_auth开始添加用户权限"></a>2.3 fscrypt_add_user_key_auth开始添加用户权限</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fscrypt_add_user_key_auth</span><span class="hljs-params">(<span class="hljs-type">userid_t</span> user_id, <span class="hljs-type">int</span> serial, <span class="hljs-type">const</span> std::string&amp; secret_hex)</span> </span>&#123;<br><span class="hljs-comment">// 判断是否支持文件级加密</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">fscrypt_is_native</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 还原锁屏码</span><br>    <span class="hljs-keyword">auto</span> auth = <span class="hljs-built_in">authentication_from_hex</span>(secret_hex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fscrypt_rewrap_user_key</span>(user_id, serial, kEmptyAuthentication, *auth);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用fscrypt_rewrap_user_key</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">fscrypt_rewrap_user_key</span><span class="hljs-params">(<span class="hljs-type">userid_t</span> user_id, <span class="hljs-type">int</span> serial,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> android::vold::KeyAuthentication&amp; retrieve_auth,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> android::vold::KeyAuthentication&amp; store_auth)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前用户的CE_KEY目录: /data/misc/vold/user_keys/ce/&lt;userid&gt;</span><br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> directory_path = <span class="hljs-built_in">get_ce_key_directory_path</span>(user_id);<br>    KeyBuffer ce_key;<br>    std::string ce_key_current_path = <span class="hljs-built_in">get_ce_key_current_path</span>(directory_path); <span class="hljs-comment">// /data/misc/vold/user_keys/ce/&lt;userid&gt;/current</span><br>    <span class="hljs-built_in">retrieveKey</span>(ce_key_current_path, kEmptyAuthentication, &amp;ce_key);<br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> paths = <span class="hljs-built_in">get_ce_key_paths</span>(directory_path);<br>    std::string ce_key_path;<br>    <span class="hljs-comment">// 新路径: /data/misc/vold/user_keys/ce/&lt;userid&gt;/current/cx%010u，例如/data/misc/vold/user_keys/ce/0/current/cx0000000000</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">get_ce_key_new_path</span>(directory_path, paths, &amp;ce_key_path)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// user_key_temp: /data/misc/vold/user_keys/temp</span><br>    <span class="hljs-comment">// 保存CE Key</span><br>    <span class="hljs-keyword">if</span> (!android::vold::<span class="hljs-built_in">storeKeyAtomically</span>(ce_key_path, user_key_temp, store_auth, ce_key))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>历史总是惊人的相似【1.1节创建System DE Master Key】</strong>，这里又调用storeKeyAtomically保存当前用户的User CE Master Key</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">storeKeyAtomically</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key_path, <span class="hljs-type">const</span> std::string&amp; tmp_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> KeyAuthentication&amp; auth, <span class="hljs-type">const</span> KeyBuffer&amp; key)</span> </span>&#123;<br>    <span class="hljs-comment">// 后面会将tmp_path换成Key_path，所以我直接改为key_path</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">storeKey</span>(key_path, auth, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用storeKey【⭐ 这里所有的操作即使都是在&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;temp中处理的，只是后面会有RenameKeyDir和FsyncParentDirectory操作，只要操作成功了，就相当于<code>/data/misc/vold/user_keys/ce/&lt;userid&gt;/current</code>】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">storeKey</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; dir, <span class="hljs-type">const</span> KeyAuthentication&amp; auth, <span class="hljs-type">const</span> KeyBuffer&amp; key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">mkdir</span>(dir.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0700</span>)) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;key mkdir &quot;</span> &lt;&lt; dir;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 向/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/version中写入1</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kCurrentVersion, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_version)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 创建随机的secdiscardable_hash值</span><br>    std::string secdiscardable_hash;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">createSecdiscardable</span>(dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_secdiscardable, &amp;secdiscardable_hash)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 如果有锁屏密码，则stretching为none; 如果没有锁屏密码，则stretching为nopassword</span><br>    std::string stretching = <span class="hljs-built_in">getStretching</span>(auth);<br>    <span class="hljs-comment">// 向/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/stretching中写入stretching的值</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(stretching, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_stretching)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 生成appId，如果设置了锁屏密码，则为appId = hash + auth.secret；没有设置锁屏密码，则appId = hash</span><br>    std::string appId;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateAppId</span>(auth, stretching, secdiscardable_hash, &amp;appId)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string encryptedKey;<br>    <span class="hljs-comment">// 如果没有设置锁屏密码，使用keymaster管理</span><br>    <span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;<br>        Keymaster keymaster;<br>        <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        std::string kmKey;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeyStorageKey</span>(keymaster, appId, &amp;kmKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kmKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_keymaster_key_blob)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        km::AuthorizationSet keyParams = <span class="hljs-built_in">beginParams</span>(appId);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithKeymasterKey</span>(keymaster, dir, keyParams, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 设置了锁屏密码，不适用keymaster</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithoutKeymaster</span>(appId, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将加密后的CE key写入/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/encrypted_key</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(encryptedKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_encrypted_key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">FsyncDirectory</span>(dir)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>非常感谢大佬的博客，收益良多。在博主的基础上，加上了自己的一点点理解。</p><p>其中：</p><ul><li>每一个小节分界线以上是博主原文</li><li>分界线以下是我的理解</li></ul><hr><img src="/2023/07/11/System-DE-Master-Key%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20230712233104163.png" alt="image-20230712233104163" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贺利坚汇编原理学习笔记</title>
    <link href="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="贺利坚汇编原理学习笔记"><a href="#贺利坚汇编原理学习笔记" class="headerlink" title="贺利坚汇编原理学习笔记"></a>贺利坚汇编原理学习笔记</h1><h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1.绪论"></a>1.绪论</h2><h2 id="2-寄存器与内存"><a href="#2-寄存器与内存" class="headerlink" title="2.寄存器与内存"></a>2.寄存器与内存</h2><h3 id="2-1-寄存器与数据存储"><a href="#2-1-寄存器与数据存储" class="headerlink" title="2.1 寄存器与数据存储"></a>2.1 寄存器与数据存储</h3><p>CPU的组成：</p><ul><li>运算器进行信息处理</li><li>寄存器进行信息存储</li><li>控制器协调各种器件进行工作</li><li>内部总线实现CPU内部各个器件之间的联系</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710233214391.png" alt="image-20230710233214391" style="zoom: 67%;"><p><strong>寄存器是CPU内部的信息存储单元</strong></p><p>8086CPU有14个寄存器：</p><ul><li>通用寄存器：AX、BX、CX、DX</li><li>编制寄存器：SI、DI</li><li>指针寄存器：SP、BP</li><li>指令指针寄存器：IP</li><li>段寄存器：CS、SS、DS、ES</li><li>标志寄存器：PSW</li></ul><p><strong>共性：8086CPU所有的寄存器都是16位的，可以存放两个字节</strong></p><h4 id="2-1-1-通用寄存器——以AX为例"><a href="#2-1-1-通用寄存器——以AX为例" class="headerlink" title="2.1.1 通用寄存器——以AX为例"></a>2.1.1 通用寄存器——以AX为例</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710233531410.png" alt="image-20230710233531410" style="zoom:50%;"><ul><li>一个寄存器存储一个16的数据<ul><li>最大值为2^16-1</li></ul></li><li>例如：在AX中存储18D，换算成16进制为12H，换算成2进制为10010B</li><li>例如：在AX中存储20000D，换算成16进制为4E20H，换算成2进制为0100111000100000B</li></ul><h4 id="2-1-2-如何兼容8位CPU"><a href="#2-1-2-如何兼容8位CPU" class="headerlink" title="2.1.2 如何兼容8位CPU"></a>2.1.2 如何兼容8位CPU</h4><p>8086上一代CPU中的寄存器都是8位的，如何保证程序的兼容性</p><blockquote><p>通用寄存器均可以分为两个独立的8位寄存器使用</p></blockquote><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710233807727.png" alt="image-20230710233807727" style="zoom:67%;"><ul><li>AX可以分为AH和AL</li><li>BX可以分为BH和BL</li><li>CX可以分为CH和CL</li><li>DX可以分为DH和DL</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710233838706.png" alt="image-20230710233838706" style="zoom:80%;"><h4 id="2-1-3-“字”在寄存器中的存储"><a href="#2-1-3-“字”在寄存器中的存储" class="headerlink" title="2.1.3 “字”在寄存器中的存储"></a>2.1.3 “字”在寄存器中的存储</h4><ul><li>8086是16位CPU<ul><li>8086的字长(word size)为16bit</li></ul></li><li>一个字(word)可以存在一个16位寄存器中<ul><li>这个字的高位字节存在这个寄存器的高8位寄存器</li><li>这个字的低位字节存在这个寄存器的低8位寄存器</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710233936082.png" alt="image-20230710233936082" style="zoom: 67%;"><h3 id="2-2-mov和add指令"><a href="#2-2-mov和add指令" class="headerlink" title="2.2 mov和add指令"></a>2.2 mov和add指令</h3><h4 id="2-2-1-学习汇编指令——用中学"><a href="#2-2-1-学习汇编指令——用中学" class="headerlink" title="2.2.1 学习汇编指令——用中学"></a>2.2.1 学习汇编指令——用中学</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710234028265.png" alt="image-20230710234028265" style="zoom:80%;"><h4 id="2-2-2-写出汇编指令执行的结果-1"><a href="#2-2-2-写出汇编指令执行的结果-1" class="headerlink" title="2.2.2 写出汇编指令执行的结果(1)"></a>2.2.2 写出汇编指令执行的结果(1)</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710234058102.png" alt="image-20230710234058102" style="zoom:80%;"><h4 id="2-2-3-写出汇编指令执行的结果-2"><a href="#2-2-3-写出汇编指令执行的结果-2" class="headerlink" title="2.2.3 写出汇编指令执行的结果(2)"></a>2.2.3 写出汇编指令执行的结果(2)</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710234149190.png" alt="image-20230710234149190" style="zoom:80%;"><h3 id="2-3-确定物理地址的办法"><a href="#2-3-确定物理地址的办法" class="headerlink" title="2.3 确定物理地址的办法"></a>2.3 确定物理地址的办法</h3><h4 id="2-3-1-物理地址"><a href="#2-3-1-物理地址" class="headerlink" title="2.3.1 物理地址"></a>2.3.1 物理地址</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710234217377.png" alt="image-20230710234217377" style="zoom:67%;"><ul><li>CPU访问内存单元时要给出内存单元的地址。</li><li>所有的内存单元构成的存储空间是一个一维的线性空间。</li><li>每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为<strong>物理地址</strong>。</li><li>事实：<ul><li>8086有20位地址总线，可传送20位地址，<strong>寻址能力为1M</strong>。</li><li>8086是16位结构的CPU<ul><li>运算器一次最多可以处理16位的数据，寄存器的最大宽度为16位</li><li>在8086内部处理的、传输、暂存的地址也是16位，<strong>寻址能力也只有64KB</strong>！</li></ul></li></ul></li><li><strong>问题：8086如何处理在寻址空间上的这个矛盾？！</strong></li></ul><hr><p><strong>8086CPU给出物理地址的方法</strong></p><ul><li>8086CPU的解决方法<ul><li>用两个16位地址(段地址、偏移地址)合成一个20位的物理地址。</li></ul></li><li>地址加法器合成物理地址的方法：<ul><li>物理地址&#x3D;段地址×16+偏移地址</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710234435359.png" alt="image-20230710234435359" style="zoom:67%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710234448354.png" alt="image-20230710234448354" style="zoom: 50%;"><h4 id="2-3-2-演示：物理地址-x3D-段地址×16-偏移地址"><a href="#2-3-2-演示：物理地址-x3D-段地址×16-偏移地址" class="headerlink" title="2.3.2 演示：物理地址&#x3D;段地址×16+偏移地址"></a>2.3.2 演示：物理地址&#x3D;段地址×16+偏移地址</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/寻址.gif" style="zoom:67%;"><p><strong>思考：段地址是123CH，可否？</strong></p><blockquote><p>可以，段地址×16+偏移地址&#x3D;0x123C8，还是没变</p></blockquote><h4 id="2-3-3-“段地址×16-偏移地址-x3D-物理地址”的本质"><a href="#2-3-3-“段地址×16-偏移地址-x3D-物理地址”的本质" class="headerlink" title="2.3.3 “段地址×16+偏移地址&#x3D;物理地址”的本质"></a>2.3.3 “段地址×16+偏移地址&#x3D;物理地址”的本质</h4><ul><li><p>要解决的问题</p><ul><li>用两个16位的地址（段地址、偏移地址），相加得到一个20位的物理地址</li></ul></li><li><p>本质含义</p><ul><li>CPU在访问内存时，用一个基础地址（段地址×16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</li></ul></li></ul><h3 id="2-4-内存的分段表示法"><a href="#2-4-内存的分段表示法" class="headerlink" title="2.4 内存的分段表示法"></a>2.4 内存的分段表示法</h3><h4 id="2-4-1-用分段的方式管理内存"><a href="#2-4-1-用分段的方式管理内存" class="headerlink" title="2.4.1 用分段的方式管理内存"></a>2.4.1 用分段的方式管理内存</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710235315274.png" alt="image-20230710235315274" style="zoom: 67%;"><h4 id="2-4-2-同一段内存，多种分段方案"><a href="#2-4-2-同一段内存，多种分段方案" class="headerlink" title="2.4.2 同一段内存，多种分段方案"></a>2.4.2 同一段内存，多种分段方案</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710235333716.png" alt="image-20230710235333716" style="zoom: 67%;"><h4 id="2-4-3-用不同的段地址和偏移地址形成同一个物理地址"><a href="#2-4-3-用不同的段地址和偏移地址形成同一个物理地址" class="headerlink" title="2.4.3 用不同的段地址和偏移地址形成同一个物理地址"></a>2.4.3 用不同的段地址和偏移地址形成同一个物理地址</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710235404944.png" alt="image-20230710235404944" style="zoom:67%;"><h3 id="2-5-Debug的使用"><a href="#2-5-Debug的使用" class="headerlink" title="2.5 Debug的使用"></a>2.5 Debug的使用</h3><h3 id="2-6-CS、IP与代码段"><a href="#2-6-CS、IP与代码段" class="headerlink" title="2.6 CS、IP与代码段"></a>2.6 CS、IP与代码段</h3><p>两个关键的寄存器：</p><ul><li>CS：代码段寄存器</li><li>IP：指令指针寄存器</li><li>⭐<strong>CS:IP：CPU将内存中CS:IP指向的内容当做指令执行</strong></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230814230353121.png" alt="image-20230814230353121" style="zoom:67%;"><p><strong>示例：在CS和IP指示下代码的执行</strong></p><ul><li>8086CPU当前状态：CS中内容为2000H，IP中内容为0000H</li><li>内存20000H~20009H处存放着可执行的机器代码‘</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230814230512608.png" alt="image-20230814230512608" style="zoom:67%;"><p><strong>8086PC工作过程的简要描述：</strong></p><ol><li>从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器</li><li>IP&#x3D;IP+所读指令的长度，从而指向下一条指令</li><li>执行指令。转到步骤（1），重复这个过程</li></ol><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CSIP使用.gif" style="zoom:67%;"><p><strong>DEBUG演示：</strong></p><ul><li>使用<strong>r</strong>命令查看当前所有寄存器的值</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230814230955255.png" alt="image-20230814230955255" style="zoom:67%;"><ul><li>使用<strong>rcs</strong>和<strong>rip</strong>改变cs和ip的值</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230814231054600.png" alt="image-20230814231054600" style="zoom:80%;"><ul><li><p>使用<strong>a</strong>命令写入汇编指令</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230814231121068.png" alt="image-20230814231121068" style="zoom:67%;"></li><li><p>使用t命令执行指令</p></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230814231312265.png" alt="image-20230814231312265" style="zoom:67%;"><blockquote><p>再次强调：<strong>内存中每个位置到底存的是数据还是指令，如果是CS:IP指向的那就是指令</strong></p></blockquote><h3 id="2-7-jmp指令"><a href="#2-7-jmp指令" class="headerlink" title="2.7 jmp指令"></a>2.7 jmp指令</h3><p>事实：执行何处的指令，取决于CS:IP</p><p>应用：可以通过改变CS、IP中的内容，来控制CPU要执行的目标指令</p><p>问题：如何改变CS、IP的值？</p><ul><li><p>方法1：Debug 中的 R 命令可以改变寄存器的值——rcs, rip</p></li><li><p>Debug是调试手段，并非程序方式！</p></li><li><p>方法2：用指令修改</p></li><li><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230814232606821.png" alt="image-20230814232606821" style="zoom:67%;"></li><li><p><strong>方法3：转移指令 jmp</strong></p></li></ul><h4 id="2-7-1-转移指令jmp"><a href="#2-7-1-转移指令jmp" class="headerlink" title="2.7.1 转移指令jmp"></a>2.7.1 转移指令jmp</h4><p><strong>同时修改CS、IP的内容</strong></p><ul><li>jmp 段地址：偏移地址</li><li>jmp 2AE3:3</li><li>jmp 3:0B16</li></ul><p><strong>功能：用指令中给出的段地址修改CS，偏移地址修改IP。</strong></p><p><strong>仅修改IP的内容</strong></p><ul><li>jmp 某一合法寄存器</li><li>jmp ax （类似于 mov IP, ax）</li><li>jmp bx</li></ul><p><strong>功能：用寄存器中的值修改IP。</strong></p><h4 id="2-7-2-案例分析"><a href="#2-7-2-案例分析" class="headerlink" title="2.7.2 案例分析"></a>2.7.2 案例分析</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230814232824634.png" alt="image-20230814232824634" style="zoom:80%;"><p><strong>DEBUG调试</strong></p><ul><li>通过<strong>a</strong>命令写入指令</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230814232859407.png" alt="image-20230814232859407" style="zoom:67%;"><ul><li><p>修改<strong>rcs，rip</strong>起始地址</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230814232939498-1692026986451-1.png" alt="image-20230814232939498" style="zoom:67%;"></li><li><p>通过<strong>t</strong>指令单步调试</p></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230814233023823.png" alt="image-20230814233023823" style="zoom:67%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230814233101872-1692027062908-3.png" alt="image-20230814233101872" style="zoom:67%;"><h3 id="2-8-内存中字的存储"><a href="#2-8-内存中字的存储" class="headerlink" title="2.8 内存中字的存储"></a>2.8 内存中字的存储</h3><h4 id="2-8-1-内存中字的存储"><a href="#2-8-1-内存中字的存储" class="headerlink" title="2.8.1 内存中字的存储"></a>2.8.1 内存中字的存储</h4><p>事实：对8086CPU，16位作为一个字</p><p>问题：16位的字存储在一个16位的寄存器中，如何存储？</p><p>回答：高8位放高字节，低8位放低字节</p><p>问题：16位的字在<strong>内存</strong>中需要2个连续字节存储，怎么存放？</p><p>回答： 低位字节存在低地址单元，高位字节存在高地址单元</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231017223725866.png" alt="image-20231017223725866" style="zoom:67%;"><h4 id="2-8-2-字单元"><a href="#2-8-2-字单元" class="headerlink" title="2.8.2 字单元"></a>2.8.2 字单元</h4><p><strong>字单元</strong>：由两个地址连续的内存单元组成，存放一个字型数据（16位）</p><p><strong>原理</strong>：在一个字单元中，低地址单元存放低位字节，高地址单元存放高位字节</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231017223822854.png" alt="image-20231017223822854" style="zoom:80%;"><ul><li>在起始地址为0的单元中，存放的是4E20H</li><li>在起始地址为2的单元中，存放的是0012H</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231017223854704.png" alt="image-20231017223854704" style="zoom:67%;"><h3 id="2-9-用DS和-addresss-实现字的传送"><a href="#2-9-用DS和-addresss-实现字的传送" class="headerlink" title="2.9 用DS和[addresss]实现字的传送"></a>2.9 用DS和[addresss]实现字的传送</h3><h4 id="2-9-1-要解决的问题：CPU从内存单元中要读取的数据"><a href="#2-9-1-要解决的问题：CPU从内存单元中要读取的数据" class="headerlink" title="2.9.1 要解决的问题：CPU从内存单元中要读取的数据"></a>2.9.1 要解决的问题：CPU从内存单元中要读取的数据</h4><p>要求：CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址</p><p>原理：在8086 PC中，内存地址由段地址和偏移地址组成（段地址:偏移地址）</p><p>解决方案：DS和[address]配合</p><ul><li>用DS寄存器存放要修改的数据的段地址</li><li>偏移地址用[…]形式给出</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231017224210041.png" alt="image-20231017224210041" style="zoom:67%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231017224225895.png" alt="image-20231017224225895" style="zoom:80%;"><h4 id="2-9-2-字的传送"><a href="#2-9-2-字的传送" class="headerlink" title="2.9.2 字的传送"></a>2.9.2 字的传送</h4><p>8086CPU可以一次性传送一个字（16位的数据）</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231017224322736.png" alt="image-20231017224322736" style="zoom:67%;"><h4 id="2-9-3-案例分析"><a href="#2-9-3-案例分析" class="headerlink" title="2.9.3 案例分析"></a>2.9.3 案例分析</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231017224347327.png" alt="image-20231017224347327" style="zoom: 50%;"><ul><li>mov ax, 1000H：将1000H存放在AX寄存器中</li><li>mov ds, ax：将ax寄存器的值赋值给ds寄存器，即现在段地址为1000H</li><li>mov ax, [0]：将1000:0的值【即1123，因为ax是16位的，为字符型寄存器】赋值给ax寄存器</li><li>mov bx, [2]：将1000:2的值【即6622，因为bx也是字符型寄存器】赋值给bx寄存器</li><li>mov cx, [1]：将1000:1的值【即2211，因为cx也是字符型寄存器】赋值给cx寄存器</li><li>add bx, [1]：将bx加上1000:1的值 &#x3D; 6622H + 2211H &#x3D; 8833H</li><li>add cx, [2]：将cx加上1000:2的值 &#x3D; 2211H + 6622H &#x3D; 8833H</li></ul><p>调试结果：</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231017224431299.png" alt="image-20231017224431299" style="zoom:80%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231017225144131.png" alt="image-20231017225144131" style="zoom:80%;"><h3 id="2-10-DS与数据段"><a href="#2-10-DS与数据段" class="headerlink" title="2.10 DS与数据段"></a>2.10 DS与数据段</h3><h4 id="2-10-1-对内存单元中数据的访问"><a href="#2-10-1-对内存单元中数据的访问" class="headerlink" title="2.10.1 对内存单元中数据的访问"></a>2.10.1 对内存单元中数据的访问</h4><p>对于8096 PC机，可以根据需要将一组内存单元定义为一个段。</p><ul><li>物理地址&#x3D;段地址×16+偏移地址</li><li>将一组长度为N（N≤64K）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段</li></ul><p>例：用123B0H~123B9H的空间来存放数据</p><ul><li>段地址：123BH　起始偏移地址：0000H　长度：10字节</li><li>段地址：1230H　起始偏移地址：00B0H　长度：10字节</li></ul><p><strong>处理方法</strong>：(DS):([address])</p><ul><li>用DS存放数据段的段地址</li><li>用相关指令访问数据段中的具体单元，单元地址由[address]指出</li></ul><h4 id="2-10-2-将123B0H-123BAH的内存单元定义为数据段"><a href="#2-10-2-将123B0H-123BAH的内存单元定义为数据段" class="headerlink" title="2.10.2 将123B0H~123BAH的内存单元定义为数据段"></a>2.10.2 将123B0H~123BAH的内存单元定义为数据段</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231017230500913.png" alt="image-20231017230500913" style="zoom:80%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231017230529058.png" alt="image-20231017230529058" style="zoom: 67%;"><h4 id="2-10-3-用DS和-address-形式访问内存中数据段方法小结"><a href="#2-10-3-用DS和-address-形式访问内存中数据段方法小结" class="headerlink" title="2.10.3 用DS和[address]形式访问内存中数据段方法小结"></a>2.10.3 用DS和[address]形式访问内存中数据段方法小结</h4><ul><li>字在内存中存储时 ，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中。</li><li>用 mov 指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中</li><li>[address]表示一个偏移地址为address的内存单元。</li><li>在内存和寄存器之间传送字符型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。</li><li>mov、add、sub是具有两个操作对象的指令，访问内存中的数据段（对照：jmp是具有一个操作对象的指令，对应内存中的代码段）</li><li>可以根据自己的推测，在Debug中实验指令的新格式。</li></ul><h3 id="2-11-栈及栈操作的实现"><a href="#2-11-栈及栈操作的实现" class="headerlink" title="2.11  栈及栈操作的实现"></a>2.11  栈及栈操作的实现</h3><h4 id="2-11-1-栈结构"><a href="#2-11-1-栈结构" class="headerlink" title="2.11.1 栈结构"></a>2.11.1 栈结构</h4><ul><li>栈是一种只能在一端进行插入或删除操作的数据结构。</li><li>栈有2个基本的操作：入栈和出栈<ul><li>入栈：将一个新的元素放到栈顶</li><li>出栈：从栈顶取出一个元素</li></ul></li><li>栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出</li><li>栈的操作规则：LIFO（Last In First Out，后进先出）</li><li>CPU提供的栈机制<ul><li>现金的CPU中都有栈的设计</li><li>8086 CPU提供相关的指令，支持用栈的方式访问内存空间</li><li>基于8086 CPU的编程，可以将一段内存当作栈来使用</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019224356757.png" alt="image-20231019224356757" style="zoom:80%;"><hr><p><strong>例：现将10000H~1000FH内存当作栈来使用……</strong></p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019224507713.png" alt="image-20231019224507713" style="zoom:80%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019224524046.png" alt="image-20231019224524046" style="zoom:80%;"><h4 id="2-11-2-栈的操作"><a href="#2-11-2-栈的操作" class="headerlink" title="2.11.2 栈的操作"></a>2.11.2 栈的操作</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019224551005.png" alt="image-20231019224551005" style="zoom:67%;"><p>执行前内存空间：</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019224616181.png" alt="image-20231019224616181" style="zoom: 67%;"><p>执行栈操作后：</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019224637070.png" alt="image-20231019224637070" style="zoom: 67%;"><h4 id="2-11-3-push指令和pop指令的执行过程"><a href="#2-11-3-push指令和pop指令的执行过程" class="headerlink" title="2.11.3 push指令和pop指令的执行过程"></a>2.11.3 push指令和pop指令的执行过程</h4><p>🎆<strong>push ax</strong></p><ul><li>SP&#x3D;SP-2</li><li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li></ul><p>🎆<strong>pop ax</strong></p><ul><li>将SS:SP指向的内存单元处的数据送入ax中</li><li>SP&#x3D;SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li></ul><h4 id="2-11-4-执行入栈或出栈时如何保证不越界"><a href="#2-11-4-执行入栈或出栈时如何保证不越界" class="headerlink" title="2.11.4 执行入栈或出栈时如何保证不越界"></a>2.11.4 执行入栈或出栈时如何保证不越界</h4><p><strong>8086 CPU不保证对栈的操作不会越界；</strong></p><p>8086CPU只知道栈顶在何处（由SS:SP指示），不知道程序安排的栈空间有多大。</p><p>我们在编程的时候要自己操心栈顶越界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的越界；防止出栈时空了仍然继续出栈而导致的越界。</p><h4 id="2-11-5-栈的小结"><a href="#2-11-5-栈的小结" class="headerlink" title="2.11.5 栈的小结"></a>2.11.5 栈的小结</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019225239376.png" alt="image-20231019225239376" style="zoom:67%;"><h3 id="2-12-关于段的总结"><a href="#2-12-关于段的总结" class="headerlink" title="2.12 关于段的总结"></a>2.12 关于段的总结</h3><h4 id="2-12-1-各种段"><a href="#2-12-1-各种段" class="headerlink" title="2.12.1 各种段"></a>2.12.1 各种段</h4><p>✅基础：<strong>物理地址 &#x3D; 段地址 × 16 + 偏移地址</strong></p><p>做法：</p><ul><li>编程时，可以根据需要将一组内存单元定义为一个段</li><li>可以将起始地址为16的倍数，长度为N（N≤64K）的一组地址连续的内存单元，定义为一个段</li><li>将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元——在程序中可以完成由程序员安排</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019225602999.png" alt="image-20231019225602999" style="zoom: 80%;"><h2 id="3-汇编语言程序"><a href="#3-汇编语言程序" class="headerlink" title="3.汇编语言程序"></a>3.汇编语言程序</h2><h3 id="3-1-用汇编语言写源程序"><a href="#3-1-用汇编语言写源程序" class="headerlink" title="3.1 用汇编语言写源程序"></a>3.1 用汇编语言写源程序</h3><h4 id="3-1-1-用汇编语言编写程序的工作过程"><a href="#3-1-1-用汇编语言编写程序的工作过程" class="headerlink" title="3.1.1 用汇编语言编写程序的工作过程"></a>3.1.1 用汇编语言编写程序的工作过程</h4><p>🎆<strong>汇编程序：包含汇编指令和伪指令的文本</strong></p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019233615304.png" alt="image-20231019233615304" style="zoom:80%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019233706662.png" alt="image-20231019233706662" style="zoom: 80%;"><p><strong>伪指令：没有对应的机器码指令，最终不被CPU执行</strong></p><blockquote><p>谁来执行伪指令呢？</p><p>伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作</p></blockquote><p>程序返回：程序运行结束后，将CPU的控制权交给使它得以运行的程序（常为DOS系统）【8086CPU固定位：mov ax,4c00h；int 21h】</p><h4 id="3-1-2-程序中三种伪指令"><a href="#3-1-2-程序中三种伪指令" class="headerlink" title="3.1.2 程序中三种伪指令"></a>3.1.2 程序中三种伪指令</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019233938706.png" alt="image-20231019233938706" style="zoom:67%;"><h4 id="3-1-3-源程序经编译链接后变为机器码"><a href="#3-1-3-源程序经编译链接后变为机器码" class="headerlink" title="3.1.3 源程序经编译链接后变为机器码"></a>3.1.3 源程序经编译链接后变为机器码</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019234020855.png" alt="image-20231019234020855" style="zoom:67%;"><h4 id="3-1-4-如何写出一个程序来"><a href="#3-1-4-如何写出一个程序来" class="headerlink" title="3.1.4 如何写出一个程序来"></a>3.1.4 如何写出一个程序来</h4><ol><li>定义一个段</li><li>实现处理任务</li><li>指出程序在何处结束</li><li>段与段寄存器关联</li><li>加上程序返回的代码</li></ol><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019234134875.png" alt="image-20231019234134875" style="zoom:67%;"><h3 id="3-2-由源程序到程序执行"><a href="#3-2-由源程序到程序执行" class="headerlink" title="3.2 由源程序到程序执行"></a>3.2 由源程序到程序执行</h3><h4 id="3-2-1-编辑源程序"><a href="#3-2-1-编辑源程序" class="headerlink" title="3.2.1 编辑源程序"></a>3.2.1 编辑源程序</h4><p>在<code>D:\MASM</code>创建文件<code>p4-1.asm</code>，并写入汇编指令</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231025232807914.png" alt="image-20231025232807914" style="zoom:80%;"><h4 id="3-2-2-编译"><a href="#3-2-2-编译" class="headerlink" title="3.2.2 编译"></a>3.2.2 编译</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231025232927777.png" alt="image-20231025232927777" style="zoom:67%;"><ul><li>目标文件（*.OBJ）是我们对一个源程序进行编译要得到的最终结果。</li><li>列表文件（*.LST）是编译器将源程序编译为目标文件的过程中产生的中间结果。</li><li>交叉引用文件（*.CRF）同列表文件一样，是编译器将源程序编译为目标文件过程中产生的中间结果。</li><li>对源程序的编译结束，编译器输出的最后两行告诉我们这个源程序没有警告错误和必须要改正的错误。</li></ul><h4 id="3-2-3-连接"><a href="#3-2-3-连接" class="headerlink" title="3.2.3 连接"></a>3.2.3 连接</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231025233038026.png" alt="image-20231025233038026" style="zoom:80%;"><ul><li>可执行文件(.EXE)是我们对一个程序进行连接要得到的最终结果。</li><li>映像文件(.MAP)是连接程序将目标文件连接为可执行文件过程中产生的中间结果。</li><li>库文件(.LIB)里包含了一些可以调用的子程序，如果我们的程序中调用了某一个库文件中的子程序，就需要<br>在连接的时候，将这个库文件和我们的目标文件连接到一起，生成可执行文件。</li><li>no stack segment，一个“没有栈段”的警告错误 ，当前可以不理会这个错误。</li></ul><h4 id="3-2-4-执行可执行程序"><a href="#3-2-4-执行可执行程序" class="headerlink" title="3.2.4 执行可执行程序"></a>3.2.4 执行可执行程序</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231025233149391.png" alt="image-20231025233149391" style="zoom:80%;"><ul><li>我们的程序没有像显示器输出任何信息。程序只是做了一些将数据送入寄存器和加法的操作，而这些事情，我们不可能从显示屏上看出来。</li><li>程序执行完成后，返回，屏幕上再次出现操作系统的提示符。</li></ul><h3 id="3-3-运行及跟踪"><a href="#3-3-运行及跟踪" class="headerlink" title="3.3 运行及跟踪"></a>3.3 运行及跟踪</h3><h4 id="3-3-1-用Debug装载程序"><a href="#3-3-1-用Debug装载程序" class="headerlink" title="3.3.1 用Debug装载程序"></a>3.3.1 用Debug装载程序</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231025233325126.png" alt="image-20231025233325126" style="zoom:80%;"><ul><li><p>程序加载后，DS中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0 ，则程序所在的内存区的地址为：DS:0。</p></li><li><p>这个内存区的前256 个字节存PSP，DOS用来和程序进行通信。</p></li><li><p>从 256字节处向后的空间存放的是程序，CS的值为DS+100H。</p></li><li><p>程序加载后，CX中存放代码的长度（字节）。</p></li></ul><h4 id="3-3-2-用Debug单步执行程序"><a href="#3-3-2-用Debug单步执行程序" class="headerlink" title="3.3.2 用Debug单步执行程序"></a>3.3.2 用Debug单步执行程序</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231025233439215.png" alt="image-20231025233439215" style="zoom:80%;"><h4 id="3-3-3-其他调试指令"><a href="#3-3-3-其他调试指令" class="headerlink" title="3.3.3 其他调试指令"></a>3.3.3 其他调试指令</h4><p><strong>继续命令P(Proceed)：类似</strong>T命令，逐条执行指令、显示结果。但遇子程序、中断等时，直接执行，然后显示结果。</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231025233541049.png" alt="image-20231025233541049" style="zoom:67%;"><p><strong>运行命令G(Go)：</strong>从指定地址处开始运行程序，直到遇到断点或者程序正常结束。</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231025233613363.png" alt="image-20231025233613363" style="zoom: 67%;"><h3 id="3-4-…-和-…"><a href="#3-4-…-和-…" class="headerlink" title="3.4 […]和(…)"></a>3.4 […]和(…)</h3><h4 id="3-4-1-…-的规定与-…-的约定"><a href="#3-4-1-…-的规定与-…-的约定" class="headerlink" title="3.4.1 […]的规定与(…)的约定"></a>3.4.1 […]的规定与(…)的约定</h4><ul><li>[…]——(汇编语法规定)表示一个内存单元</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231025233721670.png" alt="image-20231025233721670" style="zoom:67%;"><ul><li>(…)——(为学习方便做出的约定)表示一个内存单元或寄存器中的内容</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231025233755039.png" alt="image-20231025233755039" style="zoom:80%;"><h4 id="3-4-2-符号idata表示常量"><a href="#3-4-2-符号idata表示常量" class="headerlink" title="3.4.2 符号idata表示常量"></a>3.4.2 符号idata表示常量</h4><ul><li>mov ax,[idata]：代表mov ax,[1]、mov ax,[2]、mov ax,[3]…</li><li>mov bx,idata：代表mov bx,1、mov bx,2、mov bx,3…</li><li>mov ds,idata：代表mov ds,1、mov ds,2…(都是非法指令)</li></ul><h4 id="3-4-3-案例分析"><a href="#3-4-3-案例分析" class="headerlink" title="3.4.3 案例分析"></a>3.4.3 案例分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,200H<br>mov ds,ax<br>mov bx,1000H<br>mov ax,[bx]<br>inc bx<br>inc bx<br>mov [bx],ax<br>inc bx<br>inc bx<br>mov [bx],ax<br>inc bx<br>mov [bx],al<br>inc bx<br>mov [bx],al<br></code></pre></td></tr></table></figure><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/寄存器.gif" alt="image-20231025233755039" style="zoom:50%;"><h3 id="3-5-Loop指令"><a href="#3-5-Loop指令" class="headerlink" title="3.5 Loop指令"></a>3.5 Loop指令</h3><h4 id="3-5-1-loop指令"><a href="#3-5-1-loop指令" class="headerlink" title="3.5.1 loop指令"></a>3.5.1 loop指令</h4><p>功能：实现循环（计数型循环）</p><ul><li>CPU执行loop指令时要进行的操作<ul><li>(cx)&#x3D;(cx)-1</li><li>判断cx中的值，不为零转至标号处执行程序，为零则向下执行</li></ul></li></ul><p>要求：</p><ul><li>cx 中要提前存放循环次数，因为(cx)影响着loop指令的执行结果</li><li>要定义一个标号</li></ul><blockquote><p>其实就相当于do while循环【提前一次，后判断类型】</p></blockquote><h4 id="3-5-2-案例分析"><a href="#3-5-2-案例分析" class="headerlink" title="3.5.2 案例分析"></a>3.5.2 案例分析</h4><ol><li>编程计算2^12</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>mov ax,2<br>mov cx,11<br>  s:add ax,ax<br>  loop s<br>  <br>  mov ax,4c00h<br>  int 21h<br>code ends<br>end<br></code></pre></td></tr></table></figure><ol start="2"><li>计算123×236，结果存储在ax中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>mov ax,0<br>mov cx,236<br>  s:add ax,123<br>  loop s<br>  <br>  mov ax,4c00h<br>  int 21h<br>code ends<br>end<br></code></pre></td></tr></table></figure><ol start="3"><li>计算ffff:0006<strong>字节</strong>单元中的数乘以3，结果存储在dx中</li></ol><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231026230503145.png" alt="image-20231026230503145" style="zoom:67%;"><h3 id="3-6-段前缀的使用"><a href="#3-6-段前缀的使用" class="headerlink" title="3.6 段前缀的使用"></a>3.6 段前缀的使用</h3><h4 id="3-6-1-引入段前缀：一个“异常”现象及对策"><a href="#3-6-1-引入段前缀：一个“异常”现象及对策" class="headerlink" title="3.6.1 引入段前缀：一个“异常”现象及对策"></a>3.6.1 引入段前缀：一个“异常”现象及对策</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231026230756028.png" alt="image-20231026230756028" style="zoom:80%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231026230828068.png" alt="image-20231026230828068" style="zoom:67%;"><h4 id="3-6-2-访问连续的内存单元——loop和-bx-联手"><a href="#3-6-2-访问连续的内存单元——loop和-bx-联手" class="headerlink" title="3.6.2 访问连续的内存单元——loop和[bx]联手"></a>3.6.2 访问连续的内存单元——loop和[bx]联手</h4><p><strong>问题</strong>：计算ffff:0~ffff:b字节单元中的数据的和，结果存储在dx中</p><p><strong>分析：</strong></p><ul><li>运算后的结果是否会超出 dx 所能存储的范围？<ul><li>ffff:0～ffff:b内存单元中的数据是字节型数据，范围在0～255之间，12个这样的数据相加，结果不会大于 65535，可以在dx中存放下。</li></ul></li><li>是否可以将 ffff:0～ffff:b中的数据直接累加到dx中？<ul><li>add dx, ds:[addr] ;(dx)&#x3D;(dx)+?</li><li>期望：取出内存中的8位数据进行相加</li><li>实际：取出的是内存中的16位数据</li></ul></li><li>是否可以将 ffff:0～ffff:b中的数据直接累加到dl中？<ul><li>add dl, ds:[addr] ;(dl)&#x3D;(dl)+?</li><li>期望：取出内存中的8位数据相加</li><li>实际：取出的是内存中的8位数据，但很有可能造成进位丢失。</li></ul></li><li>对策：取出8位数据，加到16位的寄存器</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231026231029785.png" alt="image-20231026231029785" style="zoom:80%;"><hr><p>那么问题的计算为：</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231026231104392.png" alt="image-20231026231104392" style="zoom:67%;"><h4 id="3-6-3-段前缀的使用"><a href="#3-6-3-段前缀的使用" class="headerlink" title="3.6.3 段前缀的使用"></a>3.6.3 段前缀的使用</h4><p><strong>问题：</strong>将内存ffff:0~ffff:b中的数据拷贝到 0:200~0:20b单元中</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231026231317864.png" alt="image-20231026231317864" style="zoom:50%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231026231334269.png" alt="image-20231026231334269" style="zoom: 80%;"><p><strong>疑问1：为什么mov ax,0020h表示内存单元0:200</strong></p><blockquote><p>因为20:0和0:200表示的是同一个物理段地址，都是512</p></blockquote><p><strong>疑问2：dl的作用</strong></p><blockquote><p>将dl作为中介，将ffff:0内存单元中的数据暂存dl，后期将其拷贝到0:200</p></blockquote><p><strong>疑问3：原始方案哪里效率低？</strong></p><blockquote><p>其都是用将ax中的值拷贝到ds中，这样每次循环都有一次多余的内存搬运</p><p>使用附加段寄存器，即ds不变，一直表示ffff:0开始的内存地址，而es表示的是0:200的地址</p></blockquote><h3 id="3-7-在代码段中使用数据"><a href="#3-7-在代码段中使用数据" class="headerlink" title="3.7 在代码段中使用数据"></a>3.7 在代码段中使用数据</h3><h4 id="3-7-1-问题：这样作是危险的！"><a href="#3-7-1-问题：这样作是危险的！" class="headerlink" title="3.7.1 问题：这样作是危险的！"></a>3.7.1 问题：这样作是危险的！</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231026233116017.png" alt="image-20231026233116017" style="zoom:80%;"><h4 id="3-7-2-有问题的案例"><a href="#3-7-2-有问题的案例" class="headerlink" title="3.7.2 有问题的案例"></a>3.7.2 有问题的案例</h4><blockquote><p><strong>注意：</strong>我们知道代码的框架为</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019233938706.png" alt="image-20231019233938706" style="zoom:50%;"><p>理论上数据段和代码段是分开的，这里只是在codeseg中使用dw声明了数据段；这也是本小节【3.7 在代码段中使用数据】的作用。</p></blockquote><hr><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231026233147770.png" alt="image-20231026233147770" style="zoom:80%;"><p>但是这个代码存在问题：代码开始地址是cs:0，而这里是数据段</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231026233240390.png" alt="image-20231026233240390" style="zoom:80%;"><h4 id="3-7-3-改进代码"><a href="#3-7-3-改进代码" class="headerlink" title="3.7.3 改进代码"></a>3.7.3 改进代码</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231026233536229.png" alt="image-20231026233536229" style="zoom:67%;"><p>此时，代码段真正的开始地址是0010（IP&#x3D;0010）</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231026233635364.png" alt="image-20231026233635364" style="zoom:67%;"><h3 id="3-8-在代码段中使用栈"><a href="#3-8-在代码段中使用栈" class="headerlink" title="3.8 在代码段中使用栈"></a>3.8 在代码段中使用栈</h3><h4 id="3-8-1-在代码段中使用栈：以数据逆序存放为例"><a href="#3-8-1-在代码段中使用栈：以数据逆序存放为例" class="headerlink" title="3.8.1 在代码段中使用栈：以数据逆序存放为例"></a>3.8.1 在代码段中使用栈：以数据逆序存放为例</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110230247901.png" alt="image-20231110230247901" style="zoom:67%;"><p>程序的思路大致如下：</p><ul><li>程序运行时，定义的数据存放在cs:0~cs:F单元中，共8个字单元。</li><li>依次将这8个字单元中的数据入栈，然后再依次出栈到这 8 个字单元中，从而实现数据的逆序存放。</li><li>栈需要的内存空间，在程序中通过定义“空”数据来取得</li></ul><h4 id="3-8-2-数据逆序存放程序"><a href="#3-8-2-数据逆序存放程序" class="headerlink" title="3.8.2 数据逆序存放程序"></a>3.8.2 数据逆序存放程序</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110230402736.png" alt="image-20231110230402736" style="zoom:80%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H<br>dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br><br>start: mov ax,cs<br>   mov ss,ax<br>   mov sp,30h<br>   mov bx,0<br>   mov cx,8<br>s: push cs:[bx]<br>   add bx,2<br>   loop s<br><br>   mov bx,0<br>   mov cx,8<br>s0:pop cs:[bx]<br>   add bx,2<br>   loop s0<br>   <br>   mov ax,4c00h<br>   int 21h<br><br>code ends<br>end start<br></code></pre></td></tr></table></figure><h3 id="3-9-将数据、代码、栈放入不同段"><a href="#3-9-将数据、代码、栈放入不同段" class="headerlink" title="3.9 将数据、代码、栈放入不同段"></a>3.9 将数据、代码、栈放入不同段</h3><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110230955692.png" alt="image-20231110230955692" style="zoom:80%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code,ds:data,ss:stack<br>data segment<br>dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H<br>data ends<br>stack segment<br>dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br>stack ends<br><br>code segment<br>start: mov ax,stack<br>   mov ss,ax<br>   mov sp,20h<br>   mov ax,data<br>   mov ds,ax<br>   <br>   mov bx,0<br>   mov cx,8<br>s: push [bx]<br>   add bx,2<br>   loop s<br><br>   mov bx,0<br>   mov cx,8<br>s0:pop [bx]<br>   add bx,2<br>   loop s0<br>   <br>   mov ax,4c00h<br>   int 21h<br>  <br>code ends<br>end start<br></code></pre></td></tr></table></figure><h2 id="4-寄存器"><a href="#4-寄存器" class="headerlink" title="4.寄存器"></a>4.寄存器</h2><h3 id="4-1-处理字符问题"><a href="#4-1-处理字符问题" class="headerlink" title="4.1 处理字符问题"></a>4.1 处理字符问题</h3><p>汇编程序中，用 <strong>‘……’</strong> 的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的ASCII码。</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110233558883.png" alt="image-20231110233558883" style="zoom:80%;"><blockquote><p>这里起始在贺老师的P23讲过，在代码段开始的前256个字节(0x100)存放了段前缀用来存放数据。</p></blockquote><p>🎆这里值得注意的是：大小写转换的规律，字符的ASCII码相差了0x20H</p><h4 id="4-1-1-大小写转换的问题"><a href="#4-1-1-大小写转换的问题" class="headerlink" title="4.1.1 大小写转换的问题"></a>4.1.1 大小写转换的问题</h4><p>问题：对dataseg中的字符串</p><ul><li>第一个字符串：小写字母转换为大写字母<ul><li>若字母是小写，转大写；如本身是大写，不变</li></ul></li><li>第二个字符串：大写字母转换为小写字母<ul><li>若字母是大写，转小写；若本身是小写，不变</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110233913928.png" alt="image-20231110233913928" style="zoom:50%;"><p>这里我们可以用到**与运算 **和 <strong>或运算</strong></p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110234103528.png" alt="image-20231110234103528" style="zoom:80%;"><h4 id="4-1-2-程序：解决大小写问题"><a href="#4-1-2-程序：解决大小写问题" class="headerlink" title="4.1.2 程序：解决大小写问题"></a>4.1.2 程序：解决大小写问题</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110234134851.png" alt="image-20231110234134851" style="zoom: 60%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110234159040.png" alt="image-20231110234159040" style="zoom:67%;"><h3 id="4-2-bx-idata-方式寻址"><a href="#4-2-bx-idata-方式寻址" class="headerlink" title="4.2 [bx+idata]方式寻址"></a>4.2 [bx+idata]方式寻址</h3><h4 id="4-2-1-bx-idata-的含义"><a href="#4-2-1-bx-idata-的含义" class="headerlink" title="4.2.1 [bx+idata]的含义"></a>4.2.1 [bx+idata]的含义</h4><ul><li>[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata（bx中的数值加上idata）。</li><li>mov ax,[bx+200] &#x2F; mov ax,[200+bx] 的含义<ul><li>将一个内存单元的内容送入ax</li><li>这个内存单元的长度为2字节（字单元），存放一个字</li><li>内存单元的段地址在ds中，偏移地址为200加上bx中的值</li><li>数学化的描述为：(ax)&#x3D;((ds)*16+bx+200)</li></ul></li><li>指令mov ax,[bx+200]的其他写法<ul><li>mov ax,[200+bx]</li><li>mov ax,200[bx]</li><li>mov ax,[bx].200</li></ul></li></ul><h4 id="4-2-2-应用：用-bx-idata-的方式进行数组的处理"><a href="#4-2-2-应用：用-bx-idata-的方式进行数组的处理" class="headerlink" title="4.2.2 应用：用[bx+idata]的方式进行数组的处理"></a>4.2.2 应用：用[bx+idata]的方式进行数组的处理</h4><p><strong>问题：</strong>在codesg中填写代码，将datasg中定义的</p><ul><li>第一个字符串，转化为大写</li><li>第二个字符串转化为小写</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111214422664.png" alt="image-20231111214422664" style="zoom:67%;"><h4 id="4-2-3-在Debug中执行"><a href="#4-2-3-在Debug中执行" class="headerlink" title="4.2.3 在Debug中执行"></a>4.2.3 在Debug中执行</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111214444899.png" alt="image-20231111214444899" style="zoom: 90%;"><h3 id="4-3-SI和DI寄存器"><a href="#4-3-SI和DI寄存器" class="headerlink" title="4.3 SI和DI寄存器"></a>4.3 SI和DI寄存器</h3><h4 id="4-3-1-CPU内部的寄存器"><a href="#4-3-1-CPU内部的寄存器" class="headerlink" title="4.3.1 CPU内部的寄存器"></a>4.3.1 CPU内部的寄存器</h4><p>8086 CPU有14个寄存器：</p><ul><li>通用寄存器：AX、BX、CX、DX</li><li><strong>变址寄存器：SI、DI</strong></li><li>指针寄存器：SP、BP</li><li>指令指针寄存器： IP</li><li>段寄存器：CS、SS、DS、ES</li><li>标志寄存器：PSW</li></ul><h4 id="4-3-2-SI和DI常执行与地址有关的操作"><a href="#4-3-2-SI和DI常执行与地址有关的操作" class="headerlink" title="4.3.2 SI和DI常执行与地址有关的操作"></a>4.3.2 SI和DI常执行与地址有关的操作</h4><p>SI 和 DI 是8086CPU中和BX功能相近的寄存器</p><blockquote><p>区别：SI和DI不能够分成两个8 位寄存器来使用。</p></blockquote><ul><li>BX：通用寄存器，在计算存储器地址时，常作为基址寄存器用</li><li>SI：source index，源变址寄存器</li><li>DI：destination index，目标变址寄存器</li></ul><h4 id="4-3-3-应用SI和DI"><a href="#4-3-3-应用SI和DI" class="headerlink" title="4.3.3 应用SI和DI"></a>4.3.3 应用SI和DI</h4><p><strong>问题：</strong>用寄存器SI和DI实现将字符串**’welcome to masm!’**复制到它后面的数据区中。</p><p>思路：</p><ol><li>用ds:si指向要复制的原始字符串</li><li>用ds:di指向目的空间</li><li>然后用一个循环完成复制</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:codeseg,ds:dataseg<br>dataseg segement<br>db &#x27;Welcome to masm!&#x27;<br>db &#x27;................&#x27;<br>dataseg ends<br>codeseg segment<br>start:mov ax,dataseg<br>mov ds,ax<br><br>mov si,0<br>mov di,16<br>mov cx,8<br>s:mov ax,[si]<br>mov [di],ax<br>add si,2<br>add di,2<br>loop s<br><br>mov ax,4c00j<br>int 21h<br>codeseg ends<br>end start<br></code></pre></td></tr></table></figure><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111215522599.png" alt="image-20231111215522599" style="zoom: 60%;"><h3 id="4-4-bx-si-和-bx-di-方式寻址"><a href="#4-4-bx-si-和-bx-di-方式寻址" class="headerlink" title="4.4 [bx+si] 和 [bx+di]方式寻址"></a>4.4 [bx+si] 和 [bx+di]方式寻址</h3><h4 id="4-4-1-bx-si-和-bx-di-方式指定地址"><a href="#4-4-1-bx-si-和-bx-di-方式指定地址" class="headerlink" title="4.4.1 [bx+si] 和 [bx+di]方式指定地址"></a>4.4.1 [bx+si] 和 [bx+di]方式指定地址</h4><ul><li><p>[bx+si]表示一个内存单元，偏移地址为(bx)+(si)（即bx中的数值加上si中的数值）。</p></li><li><p>指令mov ax,[bx+si]的含义：</p><ul><li>将一个内存单元的内容送入ax</li><li>这个内存单元的长度为2字节（字单元），存放一个字</li><li>偏移地址为bx中的数值加上si中的数值</li><li>段地址在ds中</li></ul></li><li><p>指令mov ax,[bx+si]的数学化的描述：(ax)&#x3D;( (ds)*16+(bx)+(si))</p></li><li><p>mov ax,[bx+si]的其他写法：mov ax,[bx][si]</p></li></ul><h4 id="4-4-2-应用案例"><a href="#4-4-2-应用案例" class="headerlink" title="4.4.2 应用案例"></a>4.4.2 应用案例</h4><p>内存中数据：2000:1000 BE 00 06 00 00 00 ….</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111222346551.png" alt="image-20231111222346551" style="zoom: 40%;"><p>程序执行完成以后：</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111222404831.png" alt="image-20231111222404831" style="zoom: 50%;"><h3 id="4-5-bx-si-idata-和-bx-di-idata"><a href="#4-5-bx-si-idata-和-bx-di-idata" class="headerlink" title="4.5 [bx+si+idata]和[bx+di+idata]"></a>4.5 [bx+si+idata]和[bx+di+idata]</h3><h4 id="4-5-1-bx-si-idata-和-bx-di-idata-方式指定地址"><a href="#4-5-1-bx-si-idata-和-bx-di-idata-方式指定地址" class="headerlink" title="4.5.1 [bx+si+idata]和[bx+di+idata]方式指定地址"></a>4.5.1 [bx+si+idata]和[bx+di+idata]方式指定地址</h4><ul><li><p>bx+si+idata]表示一个内存单元：偏移地址为(bx)+(si)+idata，即bx中的数值加上si中的数值再加上idata</p></li><li><p>指令mov ax,[bx+si+idata]的含义</p><ul><li>将一个内存单元的内容送入ax</li><li>这个内存单元的长度为2字节（字单元），存放一个字</li><li>偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中</li></ul></li><li><p>数学化的描述：(ax)&#x3D;( (ds)*16+(bx)+(si)+idata)</p></li><li><p>指令mov ax,[bx+si+idata]的其他写法</p></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111222724356.png" alt="image-20231111222724356" style="zoom:80%;"><h4 id="4-5-2-应用案例"><a href="#4-5-2-应用案例" class="headerlink" title="4.5.2 应用案例"></a>4.5.2 应用案例</h4><p>内存中数据：2000:1000 BE 00 06 00 00 00 ….</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111222751863.png" alt="image-20231111222751863" style="zoom: 60%;"><p>程序完成以后：</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111222821711.png" alt="image-20231111222821711" style="zoom: 50%;"><h3 id="4-6-不同的寻址方式的灵活应用"><a href="#4-6-不同的寻址方式的灵活应用" class="headerlink" title="4.6 不同的寻址方式的灵活应用"></a>4.6 不同的寻址方式的灵活应用</h3><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111225708887.png" alt="image-20231111225708887" style="zoom:80%;"><h4 id="4-6-1-案例1：头一个字母改为大写字母"><a href="#4-6-1-案例1：头一个字母改为大写字母" class="headerlink" title="4.6.1 案例1：头一个字母改为大写字母"></a>4.6.1 案例1：头一个字母改为大写字母</h4><p><strong>问题：</strong>编程将datasg段中每个单词的头一个字母改为大写字母。</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111225811584.png" alt="image-20231111225811584" style="zoom:80%;"><p>思路：使用[bx+data]的方式，因为每个单词的相对地址都是固定的，只是基址（第一行、第二行…）需要换</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111225829214.png" alt="image-20231111225829214" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">    mov ax,datasg<br>    mov ds,ax<br><br>    mov bx,0<br>    mov cx,6<br>s:  mov al,[bx+3]<br>and al,11011111b<br>mov [bx+3],al<br>add bx,16<br>loop s<br></code></pre></td></tr></table></figure><h4 id="4-6-2-案例2：双重循环处理"><a href="#4-6-2-案例2：双重循环处理" class="headerlink" title="4.6.2 案例2：双重循环处理"></a>4.6.2 案例2：双重循环处理</h4><p><strong>问题：</strong>编程将datasg段中每个单词改为大写字母。</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111230125070.png" alt="image-20231111230125070" style="zoom:67%;"><p><strong>问题抽象：</strong></p><ul><li>4个字符串，看成一个4行16列的二维数组</li><li>要修改二维数据的每一行的前3列</li><li>构造4×3的二重数组</li></ul><p><strong>思路：</strong></p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111230234039.png" alt="image-20231111230234039" style="zoom:80%;"><p><strong>方案0：</strong></p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111230243711.png" alt="image-20231111230243711" style="zoom:67%;"><blockquote><p>当第一个循环处理完了，此时cx为0，则外层循环不会执行</p></blockquote><p><strong>方法1：</strong></p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111230328737.png" alt="image-20231111230328737" style="zoom:50%;"><p><strong>方法2：</strong></p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111230350736.png" alt="image-20231111230350736" style="zoom: 50%;"><p>🎆 <strong>方法3：（推荐）</strong>，前面的其他解法需要设置中间介质存储，当出现三重循环可能会有问题</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111230422845.png" alt="image-20231111230422845" style="zoom: 50%;"><h3 id="4-7-不同寻址方式演示"><a href="#4-7-不同寻址方式演示" class="headerlink" title="4.7 不同寻址方式演示"></a>4.7 不同寻址方式演示</h3><h4 id="4-7-1-直接寻址过程"><a href="#4-7-1-直接寻址过程" class="headerlink" title="4.7.1 直接寻址过程"></a>4.7.1 直接寻址过程</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/直接寻址过程.gif" alt="image-20231111222821711" style="zoom:50%;"><h4 id="4-7-2-简接寻址过程"><a href="#4-7-2-简接寻址过程" class="headerlink" title="4.7.2 简接寻址过程"></a>4.7.2 简接寻址过程</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/间接寻址过程.gif" alt="image-20231111222821711" style="zoom:50%;"><h4 id="4-7-3-相对寻址过程"><a href="#4-7-3-相对寻址过程" class="headerlink" title="4.7.3 相对寻址过程"></a>4.7.3 相对寻址过程</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/相对寻址过程.gif" alt="image-20231111222821711" style="zoom:50%;"><h4 id="4-7-4-基址变址寻址过程"><a href="#4-7-4-基址变址寻址过程" class="headerlink" title="4.7.4 基址变址寻址过程"></a>4.7.4 基址变址寻址过程</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/基址变址寻址过程.gif" alt="image-20231111222821711" style="zoom:50%;"><h4 id="4-7-5-相对基址变址寻址过程"><a href="#4-7-5-相对基址变址寻址过程" class="headerlink" title="4.7.5 相对基址变址寻址过程"></a>4.7.5 相对基址变址寻址过程</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/相对基址变址寻址过程.gif" alt="image-20231111222821711" style="zoom:50%;"><blockquote><p>这里有个小小的错误，地址加法器中应该是 ds*16 + bx + si + 1，动画中少了加1，但最终的要找的内存单元是对的</p></blockquote><h3 id="4-8-bp寄存器"><a href="#4-8-bp寄存器" class="headerlink" title="4.8 bp寄存器"></a>4.8 bp寄存器</h3><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111224722444.png" alt="image-20231111224722444" style="zoom:80%;"><blockquote><p>注意：bx默认的基址是ds段，bp默认指ss段</p></blockquote><h3 id="4-9-数组在哪里，有多长？"><a href="#4-9-数组在哪里，有多长？" class="headerlink" title="4.9 数组在哪里，有多长？"></a>4.9 数组在哪里，有多长？</h3><h4 id="4-9-1-汇编语言中数据位置的表达"><a href="#4-9-1-汇编语言中数据位置的表达" class="headerlink" title="4.9.1 汇编语言中数据位置的表达"></a>4.9.1 汇编语言中数据位置的表达</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111224937285.png" alt="image-20231111224937285" style="zoom: 67%;"><h4 id="4-9-2-指令要处理的数据有多长？"><a href="#4-9-2-指令要处理的数据有多长？" class="headerlink" title="4.9.2 指令要处理的数据有多长？"></a>4.9.2 指令要处理的数据有多长？</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111225006820.png" alt="image-20231111225006820" style="zoom: 67%;"><h3 id="4-10-寻址方式的综合应用"><a href="#4-10-寻址方式的综合应用" class="headerlink" title="4.10 寻址方式的综合应用"></a>4.10 寻址方式的综合应用</h3><h4 id="4-10-1-应用问题"><a href="#4-10-1-应用问题" class="headerlink" title="4.10.1 应用问题"></a>4.10.1 应用问题</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111225123350.png" alt="image-20231111225123350" style="zoom:80%;"><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,seg<br>mov ds,ax<br>mov bx,60h<br>mov word ptr [bx+0ch],11<br>mov word ptr [bx+0eh],13<br><br>mov si,0<br>mov byte ptr [bx+10h+si],&#x27;H&#x27;<br>inc si<br>mov byte ptr [bx+10h+si],&#x27;O&#x27;<br>inc si<br>mov byte ptr [bx+10h+si],&#x27;U&#x27;<br></code></pre></td></tr></table></figure><h4 id="4-10-2-C语言和汇编的处理方式对比"><a href="#4-10-2-C语言和汇编的处理方式对比" class="headerlink" title="4.10.2 C语言和汇编的处理方式对比"></a>4.10.2 C语言和汇编的处理方式对比</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111225405800.png" alt="image-20231111225405800" style="zoom: 50%;"><h3 id="4-11-用div指令实现除法"><a href="#4-11-用div指令实现除法" class="headerlink" title="4.11 用div指令实现除法"></a>4.11 用div指令实现除法</h3><h4 id="4-11-1-div指令"><a href="#4-11-1-div指令" class="headerlink" title="4.11.1 div指令"></a>4.11.1 div指令</h4><p>div是除法指令，使用div作除法的时候</p><ul><li>被除数：（默认）放在AX或DX和AX中</li><li>除数：8位或16位，在寄存器或内存单元中</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112204734926.png" alt="image-20231112204734926" style="zoom:80%;"><blockquote><p>如果除数是8位内存或寄存器，则被除数处于AX中</p><p>如果除数是16位内存或寄存器，则被除数位于DX和AX中</p></blockquote><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112204842121.png" alt="image-20231112204842121" style="zoom:67%;"><h4 id="4-11-2-div指令示例"><a href="#4-11-2-div指令示例" class="headerlink" title="4.11.2 div指令示例"></a>4.11.2 div指令示例</h4><p>编程：利用除法指令计算 100001&#x2F;100</p><ul><li>100001D&#x3D;186A1H</li><li>需要进行16位的除法</li><li>用dx和ax两个寄存器联合存放186A1H</li><li>用bx存放除数100D&#x3D;64H</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112205034655.png" alt="image-20231112205034655" style="zoom: 50%;"><p>编程：利用除法指令计算 1001&#x2F;100</p><ul><li>进行8除法即可</li><li>在ax寄存器存放被除数3E9H</li><li>用bx存放除数100D&#x3D;64H</li></ul><h4 id="4-11-3-在内存单元中实施除法"><a href="#4-11-3-在内存单元中实施除法" class="headerlink" title="4.11.3 在内存单元中实施除法"></a>4.11.3 在内存单元中实施除法</h4><ul><li>双字型数据的定义(例示)</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112205224931.png" alt="image-20231112205224931" style="zoom:60%;"><p>例：用div 计算data段中第一个数据除以第二个数据后的结果，商存放在第3个数据的存储单元中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">data segment<br>dd 100001<br>dw 100<br>dw 0<br>data ends<br>code segment<br>mov ax,data<br>mov ds,ax<br>mov ax,ds:[0]<br>mov dx,ds:[2]<br>div word ptr ds:[4]<br>mov ds:[6],ax<br>code ends<br></code></pre></td></tr></table></figure><h3 id="4-12-用dup设置内存空间"><a href="#4-12-用dup设置内存空间" class="headerlink" title="4.12 用dup设置内存空间"></a>4.12 用dup设置内存空间</h3><h4 id="4-12-1-dup功能和用法"><a href="#4-12-1-dup功能和用法" class="headerlink" title="4.12.1 dup功能和用法"></a>4.12.1 dup功能和用法</h4><p>功能：dup和db、dw、dd 等数据定义伪指令配合使用，用来进行数据的重复。</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112205458273.png" alt="image-20231112205458273" style="zoom: 67%;"><p>dup的使用格式：</p><ul><li>db重复的次数dup（重复的字节型数据）</li><li>dw重复的次数dup（重复的字型数据）</li><li>dd重复的次数dup（重复的双子数据）</li></ul><h4 id="4-12-2-dup用途"><a href="#4-12-2-dup用途" class="headerlink" title="4.12.2 dup用途"></a>4.12.2 dup用途</h4><p>示例：定义一个200字节的栈段</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112205624778.png" alt="image-20231112205624778" style="zoom:67%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112205630893.png" alt="image-20231112205630893" style="zoom:67%;"><h2 id="5-流程转移与子程序"><a href="#5-流程转移与子程序" class="headerlink" title="5.流程转移与子程序"></a>5.流程转移与子程序</h2><h3 id="5-1-操作符offset"><a href="#5-1-操作符offset" class="headerlink" title="5.1 操作符offset"></a>5.1 操作符offset</h3><h4 id="5-1-1-用操作符offset取得标号的偏移地址"><a href="#5-1-1-用操作符offset取得标号的偏移地址" class="headerlink" title="5.1.1 用操作符offset取得标号的偏移地址"></a>5.1.1 用操作符offset取得标号的偏移地址</h4><p><strong>格式：</strong>offset 标号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:codeseg<br>codeseg segment<br>start:  mov ax,offset start   ; 相当于mov ax,0<br>    s:  mov ax,offset s       ; 相当于mov ax,3<br>codeseg ends<br>end start<br></code></pre></td></tr></table></figure><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115225802336.png" alt="image-20231115225802336" style="zoom: 50%;"><h4 id="5-1-2-练习"><a href="#5-1-2-练习" class="headerlink" title="5.1.2 练习"></a>5.1.2 练习</h4><p><strong>问题：</strong>有如下程序段，添写2条指令，使该程序在运行中将s处的一条指令复制到s0处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:codesg<br>codesg segment<br>s:  mov ax,bx<br>    mov si,offset s<br>    mov di,offset s0<br>    mov ax,cs:[si]<br>    mov cs:[di],ax<br>s0: nop<br>nop<br>codeseg ends<br>ends  ;nop的机器码占一个字节，起“占位”作用<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li>s和s0处的指令所在的内存单元的地址是多少？<ul><li>cs:offset s 和cs:offset s0</li></ul></li><li>将s处的指令复制到s0处，就是________<ul><li>就是将cs:offset s 处的数据复制到cs:offset s0处</li></ul></li><li>地址如何表示？<ul><li>段地址已知在cs中，偏移地址已经送入si和di中</li></ul></li><li>要复制的数据有多长？<ul><li>mov ax,bx指令的长度为两个字节，即1个字。</li></ul></li></ul><h3 id="5-2-jmp指令"><a href="#5-2-jmp指令" class="headerlink" title="5.2 jmp指令"></a>5.2 jmp指令</h3><h4 id="5-2-1-jmp指令——无条件转移"><a href="#5-2-1-jmp指令——无条件转移" class="headerlink" title="5.2.1 jmp指令——无条件转移"></a>5.2.1 jmp指令——无条件转移</h4><p><strong>jmp指令的功能：</strong>无条件转移，可以只修改IP，也可以同时修改CS和IP</p><p>jmp指令要给出两种信息：</p><ul><li>转移的目的地址</li><li>转移的距离<ul><li>段间转移（远转移）： jmp 2000:1000</li><li>段内短转移： jmp short 标号 ; IP的修改范围为 -128~127，8位的位移</li><li>段内近转移： jmp near ptr 标号 ; IP的修改范围为 -32768~32767，16位的位移</li></ul></li></ul><h4 id="5-2-2-jmp指令：依据位移进行转移"><a href="#5-2-2-jmp指令：依据位移进行转移" class="headerlink" title="5.2.2 jmp指令：依据位移进行转移"></a>5.2.2 jmp指令：依据位移进行转移</h4><p><strong>引子：</strong>常见指令中的立即数均在机器指令中有体现</p><p><strong>问题：</strong>jmp short 指令中，转移到了哪里？</p><blockquote><p>jmp short 的机器指令中，包含的是跳转到指令的相对位置，而不是转移的目标地址。</p></blockquote><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115230436427.png" alt="image-20231115230436427" style="zoom:50%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115230444733.png" alt="image-20231115230444733" style="zoom:50%;"><p>第一个程序jmp short s指令的读取和执行：</p><p>（1）(IP)&#x3D;0003，CS:IP指向EB 05(jmp 的机器码)</p><p>（2）读取指令码EB 05进入指令缓冲器；</p><p>（3）(IP)&#x3D;(IP)+所读取指令的长度&#x3D;(IP)+2&#x3D;0005，CS:IP指向add ax, 0001；</p><p>（4）CPU执行指令缓冲器中的指令EB05；</p><p>（5）指令EB <strong>05</strong>执行后，(IP)&#x3D;(IP)+<strong>05</strong>&#x3D;000AH，CS:IP指向inc ax</p><h4 id="5-2-3-两种段内转移"><a href="#5-2-3-两种段内转移" class="headerlink" title="5.2.3 两种段内转移"></a>5.2.3 两种段内转移</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115230820219.png" alt="image-20231115230820219" style="zoom:50%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115230831757.png" alt="image-20231115230831757" style="zoom: 50%;"><h4 id="5-2-4-远转移：jmp-far-ptr-标号"><a href="#5-2-4-远转移：jmp-far-ptr-标号" class="headerlink" title="5.2.4 远转移：jmp far ptr 标号"></a>5.2.4 远转移：jmp far ptr 标号</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115230909267.png" alt="image-20231115230909267" style="zoom:80%;"><h4 id="5-2-5-转移地址在寄存器中的jmp指令"><a href="#5-2-5-转移地址在寄存器中的jmp指令" class="headerlink" title="5.2.5 转移地址在寄存器中的jmp指令"></a>5.2.5 转移地址在寄存器中的jmp指令</h4><p>指令格式：jmp 16位寄存器</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115230953946.png" alt="image-20231115230953946" style="zoom:67%;"><h4 id="5-2-6-转移地址在内存中的jmp指令"><a href="#5-2-6-转移地址在内存中的jmp指令" class="headerlink" title="5.2.6 转移地址在内存中的jmp指令"></a>5.2.6 转移地址在内存中的jmp指令</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115231012570.png" alt="image-20231115231012570" style="zoom:67%;"><h4 id="5-2-7-jmp指令小结"><a href="#5-2-7-jmp指令小结" class="headerlink" title="5.2.7 jmp指令小结"></a>5.2.7 jmp指令小结</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115231033431.png" alt="image-20231115231033431" style="zoom:67%;"><h3 id="5-3-call指令和ret指令"><a href="#5-3-call指令和ret指令" class="headerlink" title="5.3 call指令和ret指令"></a>5.3 call指令和ret指令</h3><h4 id="5-3-1-call指令"><a href="#5-3-1-call指令" class="headerlink" title="5.3.1 call指令"></a>5.3.1 call指令</h4><p>字面意思：调用子程序</p><p>实质：流程转移（call指令实现转移的方法和 jmp 指令的原理相似）</p><p>格式：call 标号</p><p><strong>CPU执行call指令，进行两步操作：</strong></p><ul><li>将当前的IP 或 CS和IP 压入栈中</li><li>转移到标号处执行指令</li></ul><p><strong>call标号：</strong></p><ul><li>16位位移&#x3D; “标号”处的地址－call指令后的第一个字节的地址；</li><li>16位位移的范围为 -32768~32767，用补码表示；</li><li>16位位移由编译程序在编译时算出。</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121232508424.png" alt="image-20231121232508424" style="zoom:80%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121232516058.png" alt="image-20231121232516058" style="zoom:80%;"><h4 id="5-3-2-指令”call-far-ptr标号”实现的是段间转移"><a href="#5-3-2-指令”call-far-ptr标号”实现的是段间转移" class="headerlink" title="5.3.2 指令”call far ptr标号”实现的是段间转移"></a>5.3.2 指令”call far ptr标号”实现的是段间转移</h4><p>CPU执行“ call far ptr 标号”时的操作</p><blockquote><p>(sp) &#x3D; (sp) – 2</p><p>((ss) ×16+(sp)) &#x3D; (CS)</p><p>(sp) &#x3D; (sp) – 2</p><p>((ss) ×16+(sp)) &#x3D; (IP)</p><ul><li>(CS) &#x3D; 标号所在的段地址</li><li>(IP) &#x3D; 标号所在的偏移地址</li></ul></blockquote><p>“ call far ptr 标号” 相当于</p><blockquote><p>push CS</p><p>push IP</p><p>jmp far ptr 标号</p></blockquote><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121232759181.png" alt="image-20231121232759181" style="zoom: 50%;"><h4 id="5-3-3-转移地址在寄存器中的call指令"><a href="#5-3-3-转移地址在寄存器中的call指令" class="headerlink" title="5.3.3 转移地址在寄存器中的call指令"></a>5.3.3 转移地址在寄存器中的call指令</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121232833839.png" alt="image-20231121232833839" style="zoom:80%;"><h4 id="5-3-4-转移指令在内存中的call指令"><a href="#5-3-4-转移指令在内存中的call指令" class="headerlink" title="5.3.4 转移指令在内存中的call指令"></a>5.3.4 转移指令在内存中的call指令</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121232900240.png" alt="image-20231121232900240" style="zoom: 67%;"><h4 id="5-3-5-返回指令：ret和retf"><a href="#5-3-5-返回指令：ret和retf" class="headerlink" title="5.3.5 返回指令：ret和retf"></a>5.3.5 返回指令：ret和retf</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121232939435.png" alt="image-20231121232939435" style="zoom:67%;"><h3 id="5-4-call和ret的配合使用"><a href="#5-4-call和ret的配合使用" class="headerlink" title="5.4 call和ret的配合使用"></a>5.4 call和ret的配合使用</h3><h4 id="5-4-1-具有子程序的源程序的框架"><a href="#5-4-1-具有子程序的源程序的框架" class="headerlink" title="5.4.1 具有子程序的源程序的框架"></a>5.4.1 具有子程序的源程序的框架</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121233111259.png" alt="image-20231121233111259" style="zoom:67%;"><h4 id="5-4-2-call和ret的配合使用"><a href="#5-4-2-call和ret的配合使用" class="headerlink" title="5.4.2 call和ret的配合使用"></a>5.4.2 call和ret的配合使用</h4><p>例：计算2的N次方，计算前，N的值由CX提供</p><blockquote><p>提示：这个程序没有栈段，是比较危险的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>start: mov ax,1<br>   mov cx,3<br>   call s<br>   mov bx,ax<br>   mov ax,4c00h<br>   int 21h<br>s: add ax,ax<br>   loop s<br>   ret<br>code ends<br>end start<br></code></pre></td></tr></table></figure><p>debug结果：</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121233449096.png" alt="image-20231121233449096" style="zoom:67%;"><p>单步调试结果：</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121233515697.png" alt="image-20231121233515697" style="zoom:67%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121233532438.png" alt="image-20231121233532438" style="zoom:67%;"><h4 id="5-4-3-为call和ret指令设置栈"><a href="#5-4-3-为call和ret指令设置栈" class="headerlink" title="5.4.3 为call和ret指令设置栈"></a>5.4.3 为call和ret指令设置栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code, ss:stack<br>stack segment<br>   db 8 dup(0)<br>   db 8 dup(0)<br>stack ends<br>code segment<br>start: mov ax,1<br>   mov cx,3<br>   call s<br>   mov bx,ax<br>   mov ax,4c00h<br>   int 21h<br>s: add ax,ax<br>   loop s<br>   ret<br>code ends<br>end start<br></code></pre></td></tr></table></figure><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121233751028.png" alt="image-20231121233751028" style="zoom: 67%;"><h3 id="5-5-mul指令"><a href="#5-5-mul指令" class="headerlink" title="5.5 mul指令"></a>5.5 mul指令</h3><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240303183904011.png" alt="image-20240303183904011" style="zoom: 67%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240303183919422.png" alt="image-20240303183919422" style="zoom:67%;"><h3 id="5-6-汇编语言的模块化程序设计"><a href="#5-6-汇编语言的模块化程序设计" class="headerlink" title="5.6 汇编语言的模块化程序设计"></a>5.6 汇编语言的模块化程序设计</h3><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240303184058864.png" alt="image-20240303184058864" style="zoom:80%;"><p>模块化调用路径：main -&gt; sub1 -&gt; sub2</p><blockquote><p>调用子程序：call指令</p><p>返回：ret指令</p><p>子程序：根据提供的参数处理一定的事务，处理后，将结果（返回值）提供给调用者</p></blockquote><h4 id="5-6-1-参数和结果的传递的问题"><a href="#5-6-1-参数和结果的传递的问题" class="headerlink" title="5.6.1 参数和结果的传递的问题"></a>5.6.1 参数和结果的传递的问题</h4><p>问题：根据提供的N，计算N的3次方</p><p>考虑：（1）我们将参数N存储在什么地方？（2）计算得到的数值，存储在什么地方？</p><p>方案：（1）用寄存器传递参数（2）用内存单元进行参数传递（3）用栈传递参数</p><p>C语言的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">cube</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>    <span class="hljs-type">int</span> f;<br>    f = x * x;<br>    f = f * x;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, cube(<span class="hljs-number">2</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-6-2-用寄存器来存储参数和结果是最常使用的方法"><a href="#5-6-2-用寄存器来存储参数和结果是最常使用的方法" class="headerlink" title="5.6.2 用寄存器来存储参数和结果是最常使用的方法"></a>5.6.2 用寄存器来存储参数和结果是最常使用的方法</h4><p>用寄存器传递参数：</p><ul><li>参数放到bx中，即(bx)&#x3D;x</li><li>子程序中用到多个mul指令计算N^3</li><li>将结果放到dx和ax中：(dx:ax)&#x3D;N^3</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>data segment<br>dw 1,2,3,4,5,6,7,8<br>dd 0,0,0,0,0,0,0,0<br>data ends<br>code segment<br>start: mov ax,data<br>mov ds,ax<br>mov si,0<br>mov di,16<br>mov cx,8<br>s:  mov bx,[si]<br>call cube<br>mov [di],ax<br>mov [di].2,ax<br>add si,2<br>add di,4<br>loop s<br><br>mov ax,4c00h<br>int 21h<br><br> cube:  mov ax,bx<br>mul bx<br>mul bx<br>ret<br>code ends<br>end start<br></code></pre></td></tr></table></figure><p>结果如下：</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240303185212685.png" alt="image-20240303185212685" style="zoom: 67%;"><h4 id="5-6-3-用内存单元批量传递数据"><a href="#5-6-3-用内存单元批量传递数据" class="headerlink" title="5.6.3 用内存单元批量传递数据"></a>5.6.3 用内存单元批量传递数据</h4><p>方案：</p><ul><li>将数据放到内存中，然后将它们放到内存空间的首地址放在寄存器中，传递给需要的子程序</li><li>对于具有批量数据的返回结果，也可用同样的方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:cdoe<br>data segment<br>db &#x27;conversation&#x27;<br>data ends<br>code segment<br>start:   mov ax,data<br>  mov ds,ax<br>  mov si,0<br>  mov cx,12<br>  call capital<br>  mov ax,4c00h<br>  int 21h<br>capital:  and bypte ptr [si],11011111b<br>  inc si<br>  loop capital<br>  ret<br><br>code ends<br>end start<br></code></pre></td></tr></table></figure><p>将所有的小写字母改成大写字母后结果如下：</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240303185939593.png" alt="image-20240303185939593" style="zoom:67%;"><h4 id="5-6-4-用栈传递参数"><a href="#5-6-4-用栈传递参数" class="headerlink" title="5.6.4 用栈传递参数"></a>5.6.4 用栈传递参数</h4><p>原理：由调用者将需要传递给子程序的参数压入栈中，子程序从栈中取得参数</p><p>任务：计算 (a - b) ^ 3，a、b为word型数据</p><p>（1）进入子程序前，参数a、b入栈</p><p>（2）调用子程序，将使栈顶存放IP</p><p>（3）结果：(dx:ax)&#x3D;(a-b)^3</p><p>例：设 a &#x3D; 3 、b &#x3D; 1 ，计算：( a – b ) ^ 3</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240303214615586.png" alt="image-20240303214615586" style="zoom: 80%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm">difcute: push bp<br> mov bp,sp<br> mov ax,[bp+4]<br> sub ax,[bp+6]<br> mov bp,ax<br> mul bp<br> mul bp<br> pop bp<br> ret 4<br></code></pre></td></tr></table></figure><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240303214741610.png" alt="image-20240303214741610" style="zoom: 50%;"><p>Q1：为什么这里需要寄存器bp？寄存器bp的值有没有被改动？</p><p>A1： <code>push bp</code> 是将bp中的内容送入SS:SP指向的内存单元中，此时这个内存单元就会保存bp的旧值，然后SS:SP指向新栈顶。最后<code>pop bp</code>的时候会把这个内存单元的值重新赋值到bp寄存器里面。</p><p>A2：为什么要使用bp寄存器，前面的内容提到过，bp寄存器默认是SS段的(stack segment)，用它来做偏移地址，很方便。</p><h3 id="5-7-寄存器冲突问题"><a href="#5-7-寄存器冲突问题" class="headerlink" title="5.7 寄存器冲突问题"></a>5.7 寄存器冲突问题</h3><h4 id="5-7-1-问题引入"><a href="#5-7-1-问题引入" class="headerlink" title="5.7.1 问题引入"></a>5.7.1 问题引入</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240303225236381.png" alt="image-20240303225236381" style="zoom:67%;"><p>这里cx既可以用于循环，又用于读取数据，最后cx&#x3D;0的时候返回上面的s区域，此时再去loop s，对cx-1，此时cx会越界成FFFF</p><h4 id="5-7-2-寄存器冲突问题的解决"><a href="#5-7-2-寄存器冲突问题的解决" class="headerlink" title="5.7.2 寄存器冲突问题的解决"></a>5.7.2 寄存器冲突问题的解决</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240303225415284.png" alt="image-20240303225415284" style="zoom:80%;"><h4 id="5-7-3-寄存器冲突问题的解决示例"><a href="#5-7-3-寄存器冲突问题的解决示例" class="headerlink" title="5.7.3 寄存器冲突问题的解决示例"></a>5.7.3 寄存器冲突问题的解决示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>data segment<br>db &#x27;word&#x27;0<br>db &#x27;unix&#x27;0<br>db &#x27;wind&#x27;0<br>db &#x27;good&#x27;0<br>data ends<br><br>code segment<br>start:   mov ax,data<br> mov ds,ax<br> mov bx,0<br> mov cx,4<br>s:   mov si,bx<br> call capital<br> add bx,5<br> loop s<br> mov ax,4c00h<br> int 21h<br>capital: push cx<br> push si<br>change:  mov cl,[si]<br> mov ch,0<br> jcxz ok<br> and byte ptr [si],11011111<br> inc si<br> jmp short change<br>ok:  pop si<br> pop cx<br> ret<br><br>code ends<br>end start<br></code></pre></td></tr></table></figure><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240303230013763.png" alt="image-20240303230013763" style="zoom:80%;"><p><a href="https://blog.csdn.net/struggle_w/article/details/123221670">https://blog.csdn.net/struggle_w/article/details/123221670</a></p><h3 id="5-8-标志寄存器"><a href="#5-8-标志寄存器" class="headerlink" title="5.8 标志寄存器"></a>5.8 标志寄存器</h3><h4 id="5-8-1-认识标志寄存器的特殊之处"><a href="#5-8-1-认识标志寄存器的特殊之处" class="headerlink" title="5.8.1 认识标志寄存器的特殊之处"></a>5.8.1 认识标志寄存器的特殊之处</h4><ul><li>标志寄存器的结构<ul><li>flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息</li><li>8086CPU中没有使用flag的1、3、5、12、13、14、15位，这些位不具有任何含义</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240304231430845.png" alt="image-20240304231430845" style="zoom:67%;"><ul><li><p>标志寄存器的作用</p><ul><li>用来存储相关指令的某些执行结果</li><li>用来为CPU执行相关指令提供行为依据</li><li>用来控制CPU的相关工作方式</li></ul></li><li><p>直接访问标志寄存器的方法</p><ul><li>pushf ：将标志寄存器的值压栈</li><li>popf ：从栈中弹出数据，送入标志寄存器中</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240304231442019.png" alt="image-20240304231442019" style="zoom:80%;"><h4 id="5-8-2-ZF-零标志-Zero-Flag"><a href="#5-8-2-ZF-零标志-Zero-Flag" class="headerlink" title="5.8.2 ZF-零标志(Zero Flag)"></a>5.8.2 ZF-零标志(Zero Flag)</h4><ul><li>ZF标记相关指令的计算结果是否为 0 <ul><li>ZF&#x3D;1，表示“结果是0 ” ，1表示”逻辑真”</li><li>ZF&#x3D;0，表示“结果不是0” ，0表示“逻辑假”</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240304231553015.png" alt="image-20240304231553015" style="zoom: 67%;"><h4 id="5-8-3-PF-奇偶标志-Parity-Flag"><a href="#5-8-3-PF-奇偶标志-Parity-Flag" class="headerlink" title="5.8.3 PF-奇偶标志(Parity Flag)"></a>5.8.3 PF-奇偶标志(Parity Flag)</h4><ul><li>PF记录指令执行后，结果的所有二进制位中1的个数：<ul><li>1的个数为偶数，PF &#x3D; 1；</li><li>1的个数为奇数，PF &#x3D; 0;</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240304231653626.png" alt="image-20240304231653626" style="zoom: 67%;"><h4 id="5-8-4-SF-符号标志-Sign-Flag-【有符号数】"><a href="#5-8-4-SF-符号标志-Sign-Flag-【有符号数】" class="headerlink" title="5.8.4 SF-符号标志(Sign Flag)【有符号数】"></a>5.8.4 SF-符号标志(Sign Flag)【有符号数】</h4><ul><li>SF记录指令执行后，将结果视为有符号数<ul><li>结果为负，SF &#x3D; 1；</li><li>结果为非负，SF &#x3D; 0；</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240304231752734.png" alt="image-20240304231752734" style="zoom:67%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240304231820589.png" alt="image-20240304231820589" style="zoom:80%;"><h4 id="5-8-5-CF-进位标志-Carry-Flag"><a href="#5-8-5-CF-进位标志-Carry-Flag" class="headerlink" title="5.8.5 CF-进位标志(Carry Flag)"></a>5.8.5 CF-进位标志(Carry Flag)</h4><ul><li>在进行无符号数运算的时候，CF记录了运 算结果的最高有效位向更高位的进位值， 或从更高位的借位值。<ul><li>CF记录指令执行后，有进位或借位，CF &#x3D; 1；无进位或借位，CF &#x3D; 0</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240304231936728.png" alt="image-20240304231936728" style="zoom:67%;"><h4 id="5-8-6-OF-溢出标志-Overflow-Flag-【有符号数】"><a href="#5-8-6-OF-溢出标志-Overflow-Flag-【有符号数】" class="headerlink" title="5.8.6 OF-溢出标志(Overflow Flag)【有符号数】"></a>5.8.6 OF-溢出标志(Overflow Flag)【有符号数】</h4><ul><li>在进行有符号数运算的时候，如结果超过了机器所能表示的范围称为溢出。<ul><li>OF记录有符号数操作指令执行后，有溢出，OF &#x3D; 1；无溢出，OF &#x3D; 0</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240304232034695.png" alt="image-20240304232034695" style="zoom:80%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240304232043454.png" alt="image-20240304232043454" style="zoom:80%;"><h3 id="5-9-带进（借）位的加减法"><a href="#5-9-带进（借）位的加减法" class="headerlink" title="5.9 带进（借）位的加减法"></a>5.9 带进（借）位的加减法</h3><h4 id="5-9-1-adc-带进位加法指令"><a href="#5-9-1-adc-带进位加法指令" class="headerlink" title="5.9.1 adc - 带进位加法指令"></a>5.9.1 adc - 带进位加法指令</h4><ul><li>adc是带进位加法指令 ，它利用了CF位上记录的进位值。<ul><li>格式：adc 操作对象1,操作对象2</li><li>功能：操作对象1&#x3D;操作对象1+操作对象2+CF</li><li>例：adc ax,bx 实现的功能是：(ax)&#x3D;(ax)+(bx)+CF</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240305230140896.png" alt="image-20240305230140896" style="zoom:80%;"><h4 id="5-9-2-adc指令应用：大数相加"><a href="#5-9-2-adc指令应用：大数相加" class="headerlink" title="5.9.2 adc指令应用：大数相加"></a>5.9.2 adc指令应用：大数相加</h4><p>问题：8086指令提供add指令，完成8位或16位加法，有更大的数相加时，如何做？例如32位、64位、24位</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240305230235890.png" alt="image-20240305230235890" style="zoom:80%;"><p>🧸<strong>妙啊，妙啊</strong></p><h4 id="5-9-3-128位数据的相加"><a href="#5-9-3-128位数据的相加" class="headerlink" title="5.9.3 128位数据的相加"></a>5.9.3 128位数据的相加</h4><p><strong>问题：</strong>编写一个子程序，对两个128位数据进行相加。</p><p>名称：add128</p><p>功能：两个逆序存放的128位数据进行相加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">data segment<br>    dw 0A452H,0A8F5H,78E6H,0A8EH,8B7AH,54F6H,0F04H,671EH<br>    dw 0E71EH,0EF04H,54F6H,8B7AH,0A8EH,78E6H,58F5H,0452H<br>data end<br></code></pre></td></tr></table></figure><p>数据为128位，需要8个字单元，由低地址单元到高地址 单元，依次存放由低到高的各个字。</p><p><strong>分析：</strong></p><ul><li>ds:si指向存储第一个数的内存空间</li><li>ds:di指向存储第二个数的内存空间</li><li>运算结果存储在第一个数的存储空间中</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240305230635245.png" alt="image-20240305230635245" style="zoom: 80%;"><p><strong>Q1：sub ax,ax可否替换为mov ax,0</strong></p><p>A1：不可以 ，sub ax,ax目的是为了清零cf寄存器，为下一次调用子程序做初始化cf</p><p><strong>Q2：两个inc di是否可以替换为add di,2</strong></p><p>A2：不可以，如果di+2后溢出了，会污染cf寄存器</p><h3 id="5-9-4-ssb指令"><a href="#5-9-4-ssb指令" class="headerlink" title="5.9.4 ssb指令"></a>5.9.4 ssb指令</h3><ul><li>sbb：带借位减法指令<ul><li>格式：sbb 操作对象1,操作对象2</li><li>功能：操作对象1&#x3D;操作对象1–操作对象2–CF</li><li>与sub区别：利用CF位上记录的借位值</li><li>比如：sbb ax,b，实现功能： (ax) &#x3D; (ax) – (bx)</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240305230944934.png" alt="image-20240305230944934" style="zoom: 75%;"><h3 id="5-10-cmp与条件转移指令"><a href="#5-10-cmp与条件转移指令" class="headerlink" title="5.10 cmp与条件转移指令"></a>5.10 cmp与条件转移指令</h3><h4 id="5-10-1-cmp指令"><a href="#5-10-1-cmp指令" class="headerlink" title="5.10.1 cmp指令"></a>5.10.1 cmp指令</h4><ul><li>cmp指令<ul><li>格式：cmp 操作对象1,操作对</li><li>功能：计算操作对象1–操作对象2</li></ul></li><li>应用：<ul><li>其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果</li></ul></li></ul><blockquote><p>cmp 是比较指令，功能相当于减法指令，只是 不保存结果。</p><p>cmp 指令执行后，将对标志寄存器产生影响。</p></blockquote><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240305232631338.png" alt="image-20240305232631338" style="zoom:67%;"><h4 id="5-10-2-无符号数比较与标志位取值"><a href="#5-10-2-无符号数比较与标志位取值" class="headerlink" title="5.10.2 无符号数比较与标志位取值"></a>5.10.2 无符号数比较与标志位取值</h4><p><strong>思路：</strong>通过cmp 指令执行后相关标志位的值，可以看出比较的结果</p><ul><li>指令：cmp ax,b</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240305232840562.png" alt="image-20240305232840562" style="zoom:80%;"><h4 id="5-10-3-条件转移指令"><a href="#5-10-3-条件转移指令" class="headerlink" title="5.10.3 条件转移指令"></a>5.10.3 条件转移指令</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240305232932548.png" alt="image-20240305232932548" style="zoom:67%;"><h4 id="5-10-4-条件转移指令的使用"><a href="#5-10-4-条件转移指令的使用" class="headerlink" title="5.10.4 条件转移指令的使用"></a>5.10.4 条件转移指令的使用</h4><ul><li>jxxx系列指令和cmp指令配合，构造条件转移指<ul><li>不必再考虑cmp指令对相关标志位的影响和jxxx指令对相关标志位的检测</li><li>可以直接考虑cmp和jxxx指令配合使用时表现出来的逻辑含义</li></ul></li><li>jxxx系列指令和cmp指令配合实现高级语言中if语句的功能</li></ul><p><strong>例1：用汇编语言和C语言实现以下功能：如果(ah)&#x3D;(bh)，则(ah)&#x3D;(ah)+(ah)，否则(ah)&#x3D;(ah)+(bh)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (a == b) &#123;<br>    a += a;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    a += b;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">cmp ah,bh<br>je s<br>add ah,bh<br>jmp short ok<br>s:  add ah,bh<br>ok: ret<br></code></pre></td></tr></table></figure><p><strong>例2：给出下面一组数据：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">data segment<br>db 8,11,8,1,5,63,38<br>data ends<br></code></pre></td></tr></table></figure><p>请编程实现如下统计，用ax保存统计结果</p><p><strong>（1）统计数值为8的字节的个数</strong></p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240305233803864.png" alt="image-20240305233803864" style="zoom: 80%;"><p><strong>（2）统计数值大于8的字节的个数</strong></p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240305233822669.png" alt="image-20240305233822669" style="zoom:80%;"><p><strong>（3）统计数值小于8的字节的个数</strong></p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240305233838883.png" alt="image-20240305233838883" style="zoom:80%;"><h3 id="5-11-DF标志和串传送指令"><a href="#5-11-DF标志和串传送指令" class="headerlink" title="5.11 DF标志和串传送指令"></a>5.11 DF标志和串传送指令</h3><p>编程：将data段中的第一个字符串复制到它后面的空间中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">data segment<br>    db &#x27;Welcome to masm!&#x27;<br>    db 16 dup (0)<br>data ends<br></code></pre></td></tr></table></figure><p>以前我们的写法是这样的，现在要用更简洁的写法</p><h4 id="5-11-1-DF标志和串传送指令"><a href="#5-11-1-DF标志和串传送指令" class="headerlink" title="5.11.1 DF标志和串传送指令"></a>5.11.1 DF标志和串传送指令</h4><ul><li>功能<ul><li>在串处理指令中，控制每次操作后si，di的增减。</li><li>DF &#x3D; 0：每次操作后si，di递增；</li><li>DF &#x3D; 1：每次操作后si，di递减。</li></ul></li><li>对DF位进行设置的指令：<ul><li>cld指令：将标志寄存器的DF位设为0(clear)</li><li>std指令：将标志寄存器的DF位设为1(setup)</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240305235352330.png" alt="image-20240305235352330" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asm">data segment<br>    db &#x27;Welcome to masm!&#x27;<br>    db 16 dup (0)<br>data ends<br><br>code segment<br>start: mov ax,data<br>mov ds,ax<br>mov si,0<br>mov es,ax<br>mov di,16<br>cld<br>mov cx,16<br>s:movsb<br>loops<br>code ends<br>end start<br></code></pre></td></tr></table></figure><h4 id="5-11-2-rep指令"><a href="#5-11-2-rep指令" class="headerlink" title="5.11.2 rep指令"></a>5.11.2 rep指令</h4><ul><li>rep指令常和串传送指令搭配使用</li><li>功能：根据cx的值，重复执行后面的指令</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240305235614090.png" alt="image-20240305235614090" style="zoom:80%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240305235622143.png" alt="image-20240305235622143" style="zoom:80%;"><h2 id="6-中断及外部设备从操作"><a href="#6-中断及外部设备从操作" class="headerlink" title="6.中断及外部设备从操作"></a>6.中断及外部设备从操作</h2><h3 id="6-1-移位指令"><a href="#6-1-移位指令" class="headerlink" title="6.1 移位指令"></a>6.1 移位指令</h3><h4 id="6-1-1-移位指令"><a href="#6-1-1-移位指令" class="headerlink" title="6.1.1 移位指令"></a>6.1.1 移位指令</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240307230827387.png" alt="image-20240307230827387" style="zoom: 67%;"><h4 id="6-1-2-逻辑移位指令shl和shr"><a href="#6-1-2-逻辑移位指令shl和shr" class="headerlink" title="6.1.2 逻辑移位指令shl和shr"></a>6.1.2 逻辑移位指令shl和shr</h4><ul><li><p>SHL OPR, CNT，将OPR逻辑左移CNT位</p><ul><li>将寄存器或内存单元中的数据向左移位</li><li>将最后移出的一位写入CF中</li><li>最低位用0补充</li></ul></li><li><p>shl指令操作实例</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov al,01010001b<br>mov cl,3<br>shl al,cl<br></code></pre></td></tr></table></figure><p>结果：(al)&#x3D;10001000b  CF&#x3D;0</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240307231027733.png" alt="image-20240307231027733" style="zoom:80%;"><p>左移3次之后，最后一位位0，所以CF&#x3D;0</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240307231054757.png" alt="image-20240307231054757" style="zoom:67%;"><h3 id="6-2-操作显存数据"><a href="#6-2-操作显存数据" class="headerlink" title="6.2 操作显存数据"></a>6.2 操作显存数据</h3><h4 id="6-2-1-显示的原理"><a href="#6-2-1-显示的原理" class="headerlink" title="6.2.1 显示的原理"></a>6.2.1 显示的原理</h4><p><strong>屏幕上的内容&#x3D;显存中的数据</strong></p><ul><li>🧸对于8086CPU，显存地址空间为0x<strong>B8000h~0xBFFFF</strong>，共32K的空间，是80*25彩色字符模式第0页的显示缓冲区</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240307231508991.png" alt="image-20240307231508991" style="zoom:67%;"><h4 id="6-2-2-显示缓冲区的结构"><a href="#6-2-2-显示缓冲区的结构" class="headerlink" title="6.2.2 显示缓冲区的结构"></a>6.2.2 显示缓冲区的结构</h4><p>80*25彩色字符模式</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240307231548037.png" alt="image-20240307231548037" style="zoom:67%;"><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240307231607907.png" alt="image-20240307231607907" style="zoom:67%;"><p>下面的示例为显示ABCD不同的颜色：第一个字节为41，对应字符为A；属性字节为42(0000 0010)，背景为000(黑色)，前景也就是字符颜色为010(绿色)</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240307231655253.png" alt="image-20240307231655253" style="zoom: 80%;"><h4 id="6-2-3-显示信息的一种”直接”方式"><a href="#6-2-3-显示信息的一种”直接”方式" class="headerlink" title="6.2.3 显示信息的一种”直接”方式"></a>6.2.3 显示信息的一种”直接”方式</h4><p>编程序，在屏幕的中间，白底蓝字，显示”Welcome to masm!”</p><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240307232011828.png" alt="image-20240307232011828" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:codeseg,ds:datasg<br>datasg segment<br>db &#x27;Welcome to masm!&#x27;<br>datasg ends<br><br>codeseg segment<br>start:mov ax,datasg<br>mov ds,ax<br>mov ax,0B800H<br>mov es,ax<br>mov si,0<br>mov di,160*12+80-16  ; 定位到中间行中间列，并定位到起始位置<br>mov cx,16<br>w:mov al,[si]<br>mov es:[di],al<br>inc di<br>mov al,71H<br>mov es:[di],al<br>inc si<br>inc di<br>loop w<br><br>mov ax,4c00h<br>int 21h<br>codeseg ends<br>end start<br></code></pre></td></tr></table></figure><h3 id="6-3-描述内存单元的标号"><a href="#6-3-描述内存单元的标号" class="headerlink" title="6.3 描述内存单元的标号"></a>6.3 描述内存单元的标号</h3><h4 id="6-3-1-关于标号"><a href="#6-3-1-关于标号" class="headerlink" title="6.3.1 关于标号"></a>6.3.1 关于标号</h4><ul><li>代码段中的标号可以用来 标记指令、段的起始地址</li><li>代码段中的数据也可以用 标号</li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240307232939157.png" alt="image-20240307232939157" style="zoom: 67%;"><h4 id="6-3-2-去了冒号的数据标号"><a href="#6-3-2-去了冒号的数据标号" class="headerlink" title="6.3.2 去了冒号的数据标号"></a>6.3.2 去了冒号的数据标号</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240307233344065.png" alt="image-20240307233344065" style="zoom:67%;"><ul><li>我们在code 段中使用的标号a、 b后面没有“ : ” ，它们同时描述 内存地址和单元长度的标号。</li><li><strong>标号a</strong><ul><li>地址code:0</li><li>以后的内存单元都是字节</li></ul></li><li><strong>标号b</strong><ul><li>地址code:8</li><li>以后的内存单元都是字</li></ul></li></ul><h4 id="6-3-3-数据标号同时描述内存地址和单元长度"><a href="#6-3-3-数据标号同时描述内存地址和单元长度" class="headerlink" title="6.3.3 数据标号同时描述内存地址和单元长度"></a>6.3.3 数据标号同时描述内存地址和单元长度</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240307233624935.png" alt="image-20240307233624935" style="zoom:67%;"><h4 id="6-3-4-更常见的方式：数据段中的数据标号"><a href="#6-3-4-更常见的方式：数据段中的数据标号" class="headerlink" title="6.3.4 更常见的方式：数据段中的数据标号"></a>6.3.4 更常见的方式：数据段中的数据标号</h4><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240307233800314.png" alt="image-20240307233800314" style="zoom:67%;"><p>🧑‍🎄<code>c dw offset a,offset b</code>：<strong>有点类似于C语言里面的指针，c里面存放了a和b的地址</strong></p><h3 id="6-4-数据的直接定址表"><a href="#6-4-数据的直接定址表" class="headerlink" title="6.4 数据的直接定址表"></a>6.4 数据的直接定址表</h3><p><strong>利用表，在两个数据集合之间建立一种映射关系，用查表的方法根据给出的数据得到其在另一集合中的对应数据。</strong></p><ul><li>应用示例：编写程序，计算sin(x)，x∈{0° ,30° ,60° ,90° ,120° ,150° ,180°}，并在屏幕中间显示计算结果。</li><li>常规解法：<ul><li>利用麦克劳林公式计算：</li></ul></li></ul><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240313222815307.png" alt="image-20240313222815307" style="zoom:67%;"><ul><li>空间换时间方案<ul><li>将所要计算得sin(x)的结果都存储到一张表中，然后用角度值来查表，找到对对应的sin(x)值</li><li>具体方法：<ul><li>用ax向子程序传递角度值</li><li>用角度值&#x2F;30为table表中的偏移，可以找到对应的字符串首地址</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>start:<br>mov al,60<br>call showsin<br>mov ax,4c00h<br>int 21h<br><br>    showsin: jmp short show<br>            table dw ag0,ag30,ag60,ag90,ag120,ag150,ag180 <br>            ag0   db&#x27;0&#x27;,0;sin 0=0<br>            ag30  db &#x27;0.5&#x27;,0;sin 30=0.5<br>            ag60  db &#x27;0.866&#x27;,0;sin 60=0.866<br>            ag90  db &#x27;1&#x27;,0<br>            ag120 db &#x27;0.866&#x27;,0<br>            ag150 db &#x27;0.5&#x27;,0<br>            ag180 db &#x27;0&#x27;,0<br>    show: push bx<br>            push es<br>            push si<br>            mov bx,0b800h<br>            mov es,bx<br><br>            ;计算出sin(x)对应结果字符串的偏移地址<br>            mov bl,30<br>            div bl;用角度值/30来得到相对于table的偏移<br>            mov bl,al<br>            mov bh,0<br>            add bx,bx;因为table中是字单元，需要再乘2<br>            mov bx,table[bx];bx中是对应结果字符串的偏移地址<br><br>            ;显示对应结果字符串到屏幕<br>            mov si,160*12+40*2<br>    shows: mov ah,cs:[bx]<br>            cmp ah,0<br>            je showret<br>            mov es:[si],ah<br>            inc bx<br>            add si,2<br>            jmp short shows<br><br>showret:pop si<br>            pop es<br>            pop bx<br>            ret<br><br>code ends<br>end start<br></code></pre></td></tr></table></figure><blockquote><p>备注：代码标号，不会影响代码段执行，会依次顺序执行，除非有jmp&#x2F;call指令</p></blockquote><img src="/2023/07/10/%E8%B4%BA%E5%88%A9%E5%9D%9A%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240313230336086.png" alt="image-20240313230336086" style="zoom:67%;">]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 文件级加密（File-based Encryption）之密钥管理</title>
    <link href="/2023/07/06/Android-%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86%EF%BC%88File-based-Encryption%EF%BC%89%E4%B9%8B%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/"/>
    <url>/2023/07/06/Android-%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86%EF%BC%88File-based-Encryption%EF%BC%89%E4%B9%8B%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-文件级加密（File-based-Encryption）之密钥管理"><a href="#Android-文件级加密（File-based-Encryption）之密钥管理" class="headerlink" title="Android 文件级加密（File-based Encryption）之密钥管理"></a>Android 文件级加密（File-based Encryption）之密钥管理</h1>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fsck_msdos学习笔记</title>
    <link href="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="fsck-msdos学习笔记"><a href="#fsck-msdos学习笔记" class="headerlink" title="fsck_msdos学习笔记"></a>fsck_msdos学习笔记</h1><h2 id="1-了解什么是FAT交叉链"><a href="#1-了解什么是FAT交叉链" class="headerlink" title="1.了解什么是FAT交叉链"></a>1.了解什么是FAT交叉链</h2><p>首先看一下这个定义：</p><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703214405538.png" alt="image-20230703214405538" style="zoom: 50%;"><blockquote><p>cross-linked files是那些指向了同一个簇的fat entry。</p></blockquote><p>下面我们再看这里给出的详细定义：<a href="http://www.edusoftmax.com/cross_linked_file.html">http://www.edusoftmax.com/cross_linked_file.html</a></p><blockquote><p>MS-DOS organizes the disk’s data area into sections called clusters or allocation units. Each file has its own directory entry, which includes the file name, size, attribute information, date, time, and the cluster where the start of the file is stored.</p><p>The file allocation table (FAT) includes an entry for each cluster. Each cluster’s entry includes either a code specifying that it is the last cluster in the file, or the number of the next cluster used by the file. Clusters can also be marked unusable, which CHKDSK reports as bad sectors.</p><p>When the computer tries to save data to the hard drive in a place where a file already exists, the two files become cross-linked. When this occurs, data from both files share the same sector on the hard drive causing both to become corrupt. In some cases, one of the cross-linked files can be saved, but often both must be deleted.</p><p>For example, suppose you have two files, each 512 bytes in size. Each file requires one cluster. If both files are marked as being located in cluster 5, then cluster 5 probably contains the file with the later date. You can confirm this by looking at it (if it’s a data file) or running it (if it’s a program).</p><p>Cross-linked files are generally created when the computer is improperly shut down or an application abnormally aborts.</p></blockquote><p>这里解释的也是相当的清楚，<strong>当计算机试图将数据保存到已经存在文件的硬盘时，这两个文件会交叉连接。</strong></p><hr><p>下面只是定义，看起来仍然比较的抽象，下面我画一个图进行说明：</p><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703215118346.png" alt="image-20230703215118346" style="zoom:67%;"><ul><li>假设文件hello1.txt的簇链为3-&gt;5-&gt;7-&gt;8</li><li>假设文件hello2.txt的簇链为4-&gt;6-&gt;7-&gt;8</li><li>可以发现两条链是相交的，且相交点在7这个位置！</li></ul><h2 id="2-Android-P之前fsck-msdos"><a href="#2-Android-P之前fsck-msdos" class="headerlink" title="2.Android P之前fsck_msdos"></a>2.Android P之前fsck_msdos</h2><p>前面读取bootblock啥的都比较简单就不贴了！</p><h3 id="2-1-读取fat表readfat"><a href="#2-1-读取fat表readfat" class="headerlink" title="2.1 读取fat表readfat"></a>2.1 读取fat表readfat</h3><p>这里先只看FAT32，其余的FAT12和FAT16都是大差不差的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">readfat</span><span class="hljs-params">(<span class="hljs-type">int</span> fs, <span class="hljs-keyword">struct</span> bootblock *boot, <span class="hljs-type">int</span> no, <span class="hljs-keyword">struct</span> fatEntry **fp)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fatEntry</span> *<span class="hljs-title">fat</span>;</span><br>u_char *buffer, *p;<br><span class="hljs-type">cl_t</span> cl;<br><span class="hljs-type">int</span> ret = FSOK;<br><br>boot-&gt;NumFree = boot-&gt;NumBad = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 读取FAT到buffer中</span><br><span class="hljs-keyword">if</span> (!_readfat(fs, boot, no, &amp;buffer))<br><span class="hljs-keyword">return</span> FSFATAL;<br><br>    <span class="hljs-comment">// 分配内存：最大为4G，具体见第4节</span><br>fat = <span class="hljs-built_in">calloc</span>(boot-&gt;NumClusters, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> fatEntry));<br><br><span class="hljs-keyword">switch</span> (boot-&gt;ClustMask) &#123;<br><span class="hljs-keyword">case</span> CLUST32_MASK:<br>p = buffer + <span class="hljs-number">8</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (cl = CLUST_FIRST; cl &lt; boot-&gt;NumClusters;) &#123;<br><span class="hljs-keyword">switch</span> (boot-&gt;ClustMask) &#123;<br><span class="hljs-keyword">case</span> CLUST32_MASK:<br>fat[cl].next = p[<span class="hljs-number">0</span>] + (p[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>) + (p[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>) + (p[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">24</span>);  <span class="hljs-comment">// 读取4个字节</span><br>fat[cl].next &amp;= boot-&gt;ClustMask; <span class="hljs-comment">// 与操作，通过掩码过滤前4位(保留位)</span><br>ret |= checkclnum(boot, no, cl, &amp;fat[cl].next); <span class="hljs-comment">// 检验簇的合法性</span><br>cl++; <span class="hljs-comment">// 簇++</span><br>p += <span class="hljs-number">4</span>; <span class="hljs-comment">// 每一个簇是4个字节，所以递增4</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">free</span>(buffer);<br>*fp = fat;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-检查fat表项checkfat"><a href="#2-2-检查fat表项checkfat" class="headerlink" title="2.2 检查fat表项checkfat"></a>2.2 检查fat表项checkfat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// external/fsck_msdos/fat.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">checkfat</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bootblock *boot, <span class="hljs-keyword">struct</span> fatEntry *fat)</span><br>&#123;<br><span class="hljs-type">cl_t</span> head, p, h, n;<br>u_int len;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> conf;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * pass 1: 确定所有的簇链</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (head = CLUST_FIRST; head &lt; boot-&gt;NumClusters; head++) &#123;<br><span class="hljs-comment">/* find next untravelled chain */</span><br><span class="hljs-keyword">if</span> (fat[head].head != <span class="hljs-number">0</span><span class="hljs-comment">/* 如果当前的head不是0，说明当前节点已经隶属于另外一条簇链了 */</span><br>    || fat[head].next == CLUST_FREE<br>    || fat[head].next == CLUST_BAD)<br><span class="hljs-keyword">continue</span>;<span class="hljs-comment">/* skip it. */</span><br><br><span class="hljs-comment">/* 遍历簇链：将链上的每一个节点设置为当前的簇链头head */</span><br><span class="hljs-keyword">for</span> (len = <span class="hljs-number">0</span>, p = head;<br>     p &gt;= CLUST_FIRST &amp;&amp; p &lt; boot-&gt;NumClusters &amp;&amp;<br>     fat[p].head != head;<br>     p = fat[p].next) &#123;<br>fat[p].head = head;<br>len++;<br>&#125;<br><br><span class="hljs-comment">/* 给簇链头设置簇链长度 */</span><br>fat[head].length = fat[head].next == CLUST_FREE ? <span class="hljs-number">0</span> : len;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * pass 2: 检查是否有交叉链</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (head = CLUST_FIRST; head &lt; boot-&gt;NumClusters; head++) &#123;<br><span class="hljs-comment">/* 找到簇链头 */</span><br><span class="hljs-keyword">if</span> (fat[head].head != head)<br><span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 退出循环的条件有2个</span><br>        <span class="hljs-comment">// 1.出现交叉链，也就是fat[n].fat.head!=head</span><br>        <span class="hljs-comment">// 2.簇链已经损坏</span><br><span class="hljs-keyword">for</span> (p = head,wdk=boot-&gt;NumClusters;<br>     (n = fat[p].next) &gt;= CLUST_FIRST &amp;&amp; n &lt; boot-&gt;NumClusters &amp;&amp; wdk;p = n,wdk--) &#123;<br><span class="hljs-keyword">if</span> (fat[n].head != head)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>        <span class="hljs-comment">// 情况一：如果是正常的结尾：包括FAT结尾或者文件簇链结尾</span><br><span class="hljs-keyword">if</span> (n &gt;= CLUST_EOFS)<br><span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">// 情况二：当前簇是空闲的或者在保留簇区域内</span><br><span class="hljs-keyword">if</span> (n == CLUST_FREE || n &gt;= CLUST_RSRVD) &#123;<br>pwarn(<span class="hljs-string">&quot;Cluster chain starting at %u ends with cluster marked %s\n&quot;</span>, head, rsrvdcltype(n));<br>ret |= tryclear(boot, fat, head, &amp;fat[p].next);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>        <span class="hljs-comment">// 情况三：当前簇在前2个簇以内或超出簇数量</span><br><span class="hljs-keyword">if</span> (n &lt; CLUST_FIRST || n &gt;= boot-&gt;NumClusters) &#123;<br>pwarn(<span class="hljs-string">&quot;Cluster chain starting at %u ends with cluster out of range (%u)\n&quot;</span>, head, n);<br>ret |= tryclear(boot, fat, head, &amp;fat[p].next);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>        <span class="hljs-comment">// 情况四：出现了交叉链</span><br>pwarn(<span class="hljs-string">&quot;Cluster chains starting at %u and %u are linked at cluster %u\n&quot;</span>, head, fat[n].head, n);<br>conf = tryclear(boot, fat, head, &amp;fat[p].next);<br>ret |= conf;<br>&#125;<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们以第1节中的交叉链为例进行说明，此时2个链的情况分别如下：</p><ul><li>簇链1：3-&gt;5-&gt;7-&gt;8</li></ul><table><thead><tr><th>节点</th><th>3</th><th>5</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>簇值</td><td>5</td><td>7</td><td>8</td><td>EOF</td></tr><tr><td>头</td><td>3</td><td>3</td><td>3</td><td>3</td></tr></tbody></table><ul><li>簇链2：4-&gt;6-&gt;7-&gt;8</li></ul><table><thead><tr><th>节点</th><th>4</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>簇值</td><td>6</td><td>7</td><td>8</td><td>EOF</td></tr><tr><td>头</td><td>4</td><td>4</td><td>4</td><td>4</td></tr></tbody></table><p>说明一下代码的执行流程：</p><ol><li>当遍历第一个簇链时，发现fat[7].next &#x3D; 8，此时fat[7].head &#x3D; 3，同理fat[8].head &#x3D; 3</li><li>但是当遍历第二哥簇链时，fat[7].head &#x3D; 4，同理fat[8].head &#x3D; 4</li></ol><p>因此交叉链出现，在p<strong>ass 2: 检查是否有交叉链</strong>时，就会检测出这是交叉链，因此此时<strong>fat[7].head !&#x3D; 3</strong></p><p>⭐此时就会触发一个流程，就是tryclear清除交叉链，总共有2种玩法：</p><ul><li>调用clearchain清理交叉点的簇，全部设置为FREE【这样破坏的就是第一个簇链】</li><li>直接将交叉点处设置为CLUST_EOF【这样第一个和第二个簇链都被破坏了】</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">tryclear</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bootblock *boot, <span class="hljs-keyword">struct</span> fatEntry *fat, <span class="hljs-type">cl_t</span> head, <span class="hljs-type">cl_t</span> *trunc)</span><br>&#123;<br><span class="hljs-keyword">if</span> (ask(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Clear chain starting at %u&quot;</span>, head)) &#123;<br>clearchain(boot, fat, head);<br><span class="hljs-keyword">return</span> FSFATMOD;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ask(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Truncate&quot;</span>)) &#123;<br>*trunc = CLUST_EOF;<br><span class="hljs-keyword">return</span> FSFATMOD;<br>&#125; <span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> FSERROR;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">clearchain</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bootblock *boot, <span class="hljs-keyword">struct</span> fatEntry *fat, <span class="hljs-type">cl_t</span> head)</span><br>&#123;<br><span class="hljs-type">cl_t</span> p, q;<br><br>   <span class="hljs-comment">// 遍历第一条簇链，将簇链的交叉点之前截断，全部设置为FREE</span><br><span class="hljs-keyword">for</span> (p = head; p &gt;= CLUST_FIRST &amp;&amp; p &lt; boot-&gt;NumClusters; p = q) &#123;<br><span class="hljs-keyword">if</span> (fat[p].head != head)<br><span class="hljs-keyword">break</span>;<br>q = fat[p].next;<br>fat[p].next = fat[p].head = CLUST_FREE;<br>fat[p].length = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Android-S开始fsck-msdos的处理"><a href="#3-Android-S开始fsck-msdos的处理" class="headerlink" title="3.Android S开始fsck_msdos的处理"></a>3.Android S开始fsck_msdos的处理</h2><p>此处是<strong>Li Xin</strong>大佬提交的代码，故而拜读其文章后不得赞叹，现贴出其思想学习：<a href="https://blog.delphij.net/posts/2021/06/fsck_msdosfs/">https://blog.delphij.net/posts/2021/06/fsck_msdosfs/</a></p><blockquote><p>我们在上面的代码中是在检查是否出现了交叉链，那么新的算法如下：</p><p>先假定所有的簇都是链头，然后一次遍历整个线性表，将被 <code>next</code> 指针引用的簇标记为不是链头。此方法只需遍历整个线性表，即 <code>O(N)</code>。 由此，我们将获得一个表示对应簇是否是簇链头的位映射图 （<code>headbitmap</code>）。</p><p>需要注意的是，这个方法标记的是每个节点是否是链头，而并不知道该节点对应的链头是谁， 自然也就无从立即知晓簇链的长度。该任务可以延后到检查目录项完整性的部分来进行， 因为目录项中保存了链簇头节点的位置，故而只需判断该簇是否是链头，如果是， 则沿着该簇链逐个遍历直到找到链尾并计算长度。</p></blockquote><h3 id="3-1-读取fat表-readfat"><a href="#3-1-读取fat表-readfat" class="headerlink" title="3.1 读取fat表_readfat"></a>3.1 读取fat表_readfat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br>_readfat(<span class="hljs-keyword">struct</span> fat_descriptor *fat)<br>&#123;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">size_t</span> i;<br><span class="hljs-type">off_t</span> off;<br><span class="hljs-type">size_t</span> readsize;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bootblock</span> *<span class="hljs-title">boot</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fat32_cache_entry</span> *<span class="hljs-title">entry</span>;</span><br><br>boot = boot_of_(fat);<br>fd = fd_of_(fat);<br>fat-&gt;fatsize = boot-&gt;FATsecs * boot-&gt;bpbBytesPerSec;<br><br>off = boot-&gt;bpbResSectors;<br>off *= boot-&gt;bpbBytesPerSec;<br><br>fat-&gt;is_mmapped = <span class="hljs-literal">false</span>;<br>fat-&gt;use_cache = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">/* Attempt to mmap() first */</span><br><span class="hljs-keyword">if</span> (allow_mmap) &#123;<br>fat-&gt;fatbuf = mmap(<span class="hljs-literal">NULL</span>, fat-&gt;fatsize,<br>PROT_READ | (rdonly ? <span class="hljs-number">0</span> : PROT_WRITE),<br>MAP_SHARED, fd_of_(fat), off);<br><span class="hljs-keyword">if</span> (fat-&gt;fatbuf != MAP_FAILED) &#123;<br>fat-&gt;is_mmapped = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Unfortunately, we were unable to mmap().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Only use the cache manager when it&#x27;s necessary, that is,</span><br><span class="hljs-comment"> * when the FAT is sufficiently large; in that case, only</span><br><span class="hljs-comment"> * read in the first 4 MiB of FAT into memory, and split the</span><br><span class="hljs-comment"> * buffer into chunks and insert to the LRU queue to populate</span><br><span class="hljs-comment"> * the cache with data.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (boot-&gt;ClustMask == CLUST32_MASK &amp;&amp;<br>    fat-&gt;fatsize &gt;= fat32_cache_size) &#123;<br>readsize = fat32_cache_size;<br>fat-&gt;use_cache = <span class="hljs-literal">true</span>;<br><br>fat-&gt;fat32_offset = boot-&gt;bpbResSectors * boot-&gt;bpbBytesPerSec;<br>fat-&gt;fat32_lastaddr = fat-&gt;fatsize &amp; ~(fat32_cache_chunk_size);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>readsize = fat-&gt;fatsize;<br>&#125;<br>fat-&gt;fatbuf = <span class="hljs-built_in">malloc</span>(readsize);<br><span class="hljs-keyword">if</span> (fat-&gt;fatbuf == <span class="hljs-literal">NULL</span>) &#123;<br>perr(<span class="hljs-string">&quot;No space for FAT (%zu)&quot;</span>, readsize);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (lseek(fd, off, SEEK_SET) != off) &#123;<br>perr(<span class="hljs-string">&quot;Unable to read FAT&quot;</span>);<br><span class="hljs-keyword">goto</span> err;<br>&#125;<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>)read(fd, fat-&gt;fatbuf, readsize) != readsize) &#123;<br>perr(<span class="hljs-string">&quot;Unable to read FAT&quot;</span>);<br><span class="hljs-keyword">goto</span> err;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When cache is used, split the buffer into chunks, and</span><br><span class="hljs-comment"> * connect the buffer into the cache.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (fat-&gt;use_cache) &#123;<br>TAILQ_INIT(&amp;fat-&gt;fat32_cache_head);<br>entry = <span class="hljs-built_in">calloc</span>(fat32_cache_entries, <span class="hljs-keyword">sizeof</span>(*entry));<br><span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">NULL</span>) &#123;<br>perr(<span class="hljs-string">&quot;No space for FAT cache (%zu of %zu)&quot;</span>,<br>    fat32_cache_entries, <span class="hljs-keyword">sizeof</span>(entry));<br><span class="hljs-keyword">goto</span> err;<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; fat32_cache_entries; i++) &#123;<br>entry[i].addr = fat32_cache_chunk_size * i;<br>entry[i].chunk = &amp;fat-&gt;fatbuf[entry[i].addr];<br>TAILQ_INSERT_TAIL(&amp;fat-&gt;fat32_cache_head,<br>    &amp;entry[i], entries);<br>&#125;<br>fat-&gt;fat32_cache_allentries = entry;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>err:<br><span class="hljs-built_in">free</span>(fat-&gt;fatbuf);<br>fat-&gt;fatbuf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面提到，FAT32最多可以有 2^28 个簇，这需要占用 1GiB 的空间。第一遍扫描时我们是把 FAT 作为一个线性表来做线性扫描的，完全没有任何必要将其整个载入内存。之后检查目录项时， 在极端情况（文件系统非常碎块化）时，我们可能会需要反复访问FAT的不同区域。</p><p>综合以上考虑，一个显然的解决方案就是增加一个缓存层，并将原先实现中直接读写 FAT 内部表现形式的部分改写为直接使用一个抽象的访问函数来进行操作，并将缓存的问题交给缓存层来进行。 操作系统已经为我们提供了一个很好的缓存实现，因此如果能用的话直接 <code>mmap(2)</code> 是最佳策略； 如果不能，则退而求其次，自己实现一个 LRU 队列。</p><p>前面提到 FAT12 和 FAT16 的最大尺寸都足够小，因此可以直接将其放进内存。FAT32 则分两种情况， 对于能使用操作系统的缓存系统的情况，我们只需把整个 FAT 映射到内存中并当作一个大数组访问即可； 对于自行实现 LRU 队列的情况，则创建一个 LRU 缓存池（尺寸是拍脑门定的 4MiB， 每个缓存块是 128kiB）。</p><p>LRU 的实现过于简单且并无特别，再次不再赘述，淘汰时如果缓存块发生过写操作，则将其写回磁盘原位置。</p><h3 id="3-2-通过位图检查表项"><a href="#3-2-通过位图检查表项" class="headerlink" title="3.2 通过位图检查表项"></a>3.2 通过位图检查表项</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 遍历 FAT 表并创建簇链头位图。</span><br><span class="hljs-comment"> * 首先假定每一个簇都是一个簇链的头，然后遍历整个 FAT 表，</span><br><span class="hljs-comment"> * 并将其中不是簇链头，即那些有其他簇将其指为后继节点的那些簇从该位图中删去，</span><br><span class="hljs-comment">         * 在此过程中修复一些明显的问题。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 每个 &quot;next&quot; 簇的可能取值如下：</span><br><span class="hljs-comment"> * a) CLUST_FREE 或 CLUST_BAD。当前簇不可能是簇链起点。</span><br><span class="hljs-comment"> * b) 超出范围的值。此时必须将簇链在此处切断。</span><br><span class="hljs-comment"> * c) 有效簇。这说明此簇 (nextcl) 不可能是簇链起点。</span><br><span class="hljs-comment"> *    在遍历过程中，每个簇最多只能被一个其他簇指为下一簇，</span><br><span class="hljs-comment"> *    因此若该簇已经被标记为不是簇起点，则表示出现了链交叉的情况，</span><br><span class="hljs-comment"> *    此时只能在当前簇切断。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 完成此扫描之后，簇链头位图中仍然为1的就是所有潜在的簇链头了。</span><br><span class="hljs-comment"> * 不过我们暂时还不知道它们是否以正确的EOF终结，也不知道它们的长度。</span><br><span class="hljs-comment">         * 这将在检查目录结构时由 checkchain() 进行，</span><br><span class="hljs-comment">         * 由于簇链只能属于一个文件，因此检查过的簇链头也将从位图中清除。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 最终，位图中余下的簇链头即为丢失簇链头。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">for</span> (cl = CLUST_FIRST; cl &lt; boot-&gt;NumClusters; cl++) &#123;<br>    nextcl = fat_get_cl_next(fat, cl);<br><br>    <span class="hljs-comment">/* 检查 nextcl 是否在有效范围 */</span><br>    <span class="hljs-keyword">if</span> (nextcl == CLUST_FREE) &#123;<br>        <span class="hljs-comment">/* 如果尚不知道最后一个未分配簇在哪，保存该簇号 */</span><br>        <span class="hljs-keyword">if</span> (boot-&gt;FSNext == <span class="hljs-number">0</span>) &#123;<br>            boot-&gt;FSNext = cl;<br>        &#125;<br>        <span class="hljs-comment">/* 该簇不可能是簇链头，标记 */</span><br>        <span class="hljs-keyword">if</span> (fat_is_cl_head(fat, cl)) &#123;<br>            fat_clear_cl_head(fat, cl);<br>        &#125;<br>        <span class="hljs-comment">/* 记账 */</span><br>        boot-&gt;NumFree++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextcl == CLUST_BAD) &#123;<br>        <span class="hljs-comment">/* 该簇不可能是簇链头，标记 */</span><br>        <span class="hljs-keyword">if</span> (fat_is_cl_head(fat, cl)) &#123;<br>            fat_clear_cl_head(fat, cl);<br>        &#125;<br>        <span class="hljs-comment">/* 记账 */</span><br>        boot-&gt;NumBad++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!valid_cl(fat, nextcl) &amp;&amp; nextcl &lt; CLUST_RSRVD) &#123;<br>        <span class="hljs-comment">/* 无效簇号，切断 */</span><br>        pwarn(<span class="hljs-string">&quot;Cluster %u continues with out of range &quot;</span><br>              <span class="hljs-string">&quot;cluster number %u\n&quot;</span>,<br>              cl,<br>              nextcl &amp; boot-&gt;ClustMask);<br>        <span class="hljs-keyword">if</span> (ask(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Truncate&quot;</span>)) &#123;<br>            ret |= fat_set_cl_next(fat, cl, CLUST_EOF);<br>            ret |= FSFATMOD;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valid_cl(fat, nextcl)) &#123;<br>        <span class="hljs-comment">/* 有效簇号，如果没有其他簇链引用过，则该簇一定不是簇链头 */</span><br>        <span class="hljs-keyword">if</span> (fat_is_cl_head(fat, nextcl)) &#123;<br>            fat_clear_cl_head(fat, nextcl);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/* 出现了交叉 */</span><br>            pwarn(<span class="hljs-string">&quot;Cluster %u crossed another chain at %u\n&quot;</span>,<br>                  cl, nextcl);<br>            <span class="hljs-keyword">if</span> (ask(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Truncate&quot;</span>)) &#123;<br>                ret |= fat_set_cl_next(fat, cl, CLUST_EOF);<br>                ret |= FSFATMOD;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>初始状态，所有的节点都是簇头：</li></ul><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703231451831.png" alt="image-20230703231451831" style="zoom:67%;"><ul><li>遍历到3的时候，这时候nextcl&#x3D;5，则此时是5有效的簇头，需要在位图中清理，置为F</li></ul><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703231548196.png" alt="image-20230703231548196" style="zoom:67%;"><ul><li>遍历到4的时候，这时候nextcl&#x3D;6，则此时是6是有效的簇头，需要为位图中清理，置为F</li></ul><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703231704977.png" alt="image-20230703231704977" style="zoom:67%;"><ul><li>遍历到5的时候，这时候nextcl&#x3D;6，此时发现<strong>6已经不是簇头</strong>了，说明之前已经有一个链占用了它，那么此时已经发生了交叉</li></ul><h2 id="4-两者的差异"><a href="#4-两者的差异" class="headerlink" title="4.两者的差异"></a>4.两者的差异</h2><p>在Android P里面，是将所有的Fat entry都读取到fatEntry这个数组中，最后一个个遍历fatEntry设置每一个节点的head来检验是否交叉：</p><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703232110410.png" alt="image-20230703232110410" style="zoom:50%;"><p>其开辟的内存calloc为 <code>NumberClusters * sizeof(fatEntry)</code></p><ul><li>已知Fat32最大支持的簇为2^28【虽然一个簇是32位，但是前4位是保留的，只用了28位】</li><li>fatEntry的大小为16字节【此处已经进行了内存对齐，都是32位】</li><li>最终开辟的内存为 2^32(Byte)&#x3D;4(GB)</li></ul><hr><p>而Android S里面是通过位图来检验是否发生了交叉</p><img src="/2023/07/03/fsck-msdos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703232906748.png" alt="image-20230703232906748" style="zoom: 50%;"><p>相较于之前的算法，我们可以认为fat_descriptor开辟的内存是微乎其微的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>fat文件系统学习一本通</title>
    <link href="/2023/06/30/fat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B8%80%E6%9C%AC%E9%80%9A/"/>
    <url>/2023/06/30/fat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B8%80%E6%9C%AC%E9%80%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="fat文件系统学习一本通"><a href="#fat文件系统学习一本通" class="headerlink" title="fat文件系统学习一本通"></a>fat文件系统学习一本通</h1><p>下面的是学习fat文件系统的顺序：</p><ul><li><p><a href="https://anmuxixixi.github.io/2023/06/29/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">vfat文件系统</a></p></li><li><p><a href="https://anmuxixixi.github.io/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">FAT文件系统原理</a></p></li><li><p><a href="https://anmuxixixi.github.io/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/">【实验】定位和提取FAT32分区的文件数据</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定位和提取FAT32分区的文件数据</title>
    <link href="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/"/>
    <url>/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="【实验】定位和提取FAT32分区的文件数据"><a href="#【实验】定位和提取FAT32分区的文件数据" class="headerlink" title="【实验】定位和提取FAT32分区的文件数据"></a>【实验】定位和提取FAT32分区的文件数据</h1><blockquote><p>转载自：<a href="https://ceyewan.top/p/27eb4295.html">https://ceyewan.top/p/27eb4295.html</a></p><p>仅用作自己记录，侵权联系删除！</p></blockquote><h2 id="使用-winHex-分析"><a href="#使用-winHex-分析" class="headerlink" title="使用 winHex 分析"></a>使用 winHex 分析</h2><p>这里要求的是直接从磁盘，文件系统的层面来提取数据。需要用到的工具是 winHex 。我们将 U 盘格式化为 FAT32 格式，创建一个文件，然后使用 winHex 将打开磁盘。先查看第一个扇区，得到的内容如下，可以提取出一些基本信息。</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221005195218939.png" alt="image-20221005195218939" style="zoom: 67%;"><ul><li>保留扇区数 0x0842</li><li>每簇扇区数 0x08</li><li>每扇区字节数 0x0200</li><li>FAT的个数 0x02</li><li>每个 FAT 占用的扇区数 0x00003BDF</li><li>BPB_RootClus 0x0002</li></ul><blockquote><p>FirstDataSector&#x3D;保留扇区数 + (FAT个数*每个FAT所占扇区数)</p><p>FirstSectorofCluster &#x3D; ((N-2)*每簇扇区数) + FirstDataSector</p></blockquote><p>我们通过上面可以求出根目录的扇区为： <code>0x0842 + 0x02 * 0x3BDF = 0x8000 = 32768</code> 。根目录扇区存储的内容就是根目录里的文件（夹）。查看这个扇区：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221005200017391.png" alt="image-20221005200017391" style="zoom: 67%;"><p>可以得到我们需要的文件（前八个字节是文件名）的起始簇号为 6 ，文件大小为 <code>0x12E = 302</code> ：</p><p>我们继续查看 FAT1 （扇区为 <code>0x0842</code>），FAT2 是 FAT1 的一个备份，这里面存储的是簇链：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221005200437307.png" alt="image-20221005200437307" style="zoom: 67%;"><p>我们可以看到第 6 个项就是一个结束项，说明我们的文件只有这一个簇。</p><p>文件第 6 簇的偏移 &#x3D; 更目录首簇偏移 + （文件某簇号 - 更目录首簇号）* 每簇扇区数</p><p>&#x3D; 32768 + （6 - 2）* 8 &#x3D; 32800，查看第 32800 到 32808 个扇区（一簇是八个扇区），就是文件内容：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221005200922882.png" alt="image-20221005200922882" style="zoom: 67%;"><p>现在我们再来考虑大文件的长文件名文件，长文件名会截取文件名的前 6 个字符和 ~i（i 取 1 到 5，从 1 开始，如果有了就后移）拼接成短文件名。短文件目录项上面是倒叙的长文件目录项，注意，上面长文件目录项使用的 unicode 编码（可能因为长文件名一般都不是纯 ASCII 码字符吧）：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221005202953894.png" alt="image-20221005202953894" style="zoom: 67%;"><p>我们可以看到，起始簇号为 7 ，大小为 <code>0x15D20 = 89376</code> 。继续查看 FAT1：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221005203255683.png" alt="image-20221005203255683" style="zoom: 67%;"><p>我们可以看到这个文件使用了从 7 到 <code>0x1C = 28</code> 这些簇，同理查看第 7 簇到第 28 簇的内容即可。也就是扇区 32808 到 32982 。注意，每簇 8 个扇区。</p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><p>python 的 read 就可以直接读取磁盘，读取后的文件对象 disk 可以通过 seek 方法控制偏移，从而读取不同位置的磁盘文件。我们读到的东西都是些 byte 类型，而且很奇怪，我们需要将其转化为 16 进制，对于 byte 类型的以 16 进制表示的数还是很难处理，因此我将其转化为了字符串。</p><ol><li>将以两个一组，逆序（小端序）的 16 进制数据转化为 10 进制数据：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_count</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    ans, beishu = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-built_in">dict</span> = &#123;&#125;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>(i)] = i<br>    <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]):<br>        <span class="hljs-built_in">dict</span>[c] = i + <span class="hljs-number">10</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-number">2</span>):<br>        ans += (<span class="hljs-built_in">dict</span>[s[i]] * <span class="hljs-number">16</span> + <span class="hljs-built_in">dict</span>[s[i + <span class="hljs-number">1</span>]]) * beishu<br>        beishu *= <span class="hljs-number">16</span> * <span class="hljs-number">16</span><br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><ol start="2"><li>读取 DBR 得到一些有用的数据，根目录的扇区号，FAT1 的扇区号，每个扇区的字节数，根目录的簇号和每簇的扇区数:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_DBR</span>(<span class="hljs-params">disk</span>):<br>    DBR = <span class="hljs-built_in">str</span>(binascii.hexlify(<br>        disk.read(<span class="hljs-number">512</span>)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]<br>    byte_per_sector = get_count(DBR[<span class="hljs-number">22</span>: <span class="hljs-number">26</span>])<br>    sector_per_clust = get_count(DBR[<span class="hljs-number">26</span>: <span class="hljs-number">28</span>])<br>    reserve_sector = get_count(DBR[<span class="hljs-number">28</span>: <span class="hljs-number">32</span>])<br>    count_fat = get_count(DBR[<span class="hljs-number">32</span>: <span class="hljs-number">34</span>])<br>    count_sector = get_count(DBR[<span class="hljs-number">64</span>: <span class="hljs-number">72</span>])<br>    sector_per_fat = get_count(DBR[<span class="hljs-number">72</span>: <span class="hljs-number">80</span>])<br>    BPB_RootClus = get_count(DBR[<span class="hljs-number">88</span>: <span class="hljs-number">96</span>])<br>    sector_of_root_dic = reserve_sector + count_fat * sector_per_fat<br>    <span class="hljs-keyword">return</span> sector_of_root_dic, reserve_sector, byte_per_sector, BPB_RootClus, sector_per_clust<br></code></pre></td></tr></table></figure><ol start="3"><li>通过 FAT1 和首簇得到簇链：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_clust_list</span>(<span class="hljs-params">fat1, first_clust</span>):<br>    ans = []<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        ans.append(first_clust)<br>        first_clust = get_count(fat1[first_clust * <span class="hljs-number">8</span>:(first_clust + <span class="hljs-number">1</span>) * <span class="hljs-number">8</span>])<br>        <span class="hljs-keyword">if</span> first_clust == <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0x0fffffff&#x27;</span>, <span class="hljs-number">16</span>):<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><ol start="4"><li>主函数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># 将文件路径切分</span><br>    file_list = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入文件路径：&quot;</span>).split(<span class="hljs-string">&quot;/&quot;</span>)<br>    <span class="hljs-comment"># 将文件夹名和文件名都转化为对应的 16 进制字符串</span><br>    real_filename = [<span class="hljs-built_in">str</span>(binascii.hexlify(<br>        <span class="hljs-built_in">bytes</span>(file_list[i], <span class="hljs-string">&#x27;utf-8&#x27;</span>)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(file_list))]<br>    <br>    <span class="hljs-comment"># 文件名不考虑后缀</span><br>    file_list[-<span class="hljs-number">1</span>] = file_list[-<span class="hljs-number">1</span>].split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 打开文件系统</span><br>    disk = <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;\\.\\&#x27;</span> + file_list[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;rb&#x27;</span>)<br>    <span class="hljs-comment"># 读取 DBR 得到一些用于的数据</span><br>    root_addr, fat1_addr, byte_per_sector, BPB_RootClus, sector_per_clust = read_DBR(<br>        disk)<br>    <span class="hljs-comment"># 最开始的簇链就是根目录</span><br>    clust_list = [BPB_RootClus]<br>    <span class="hljs-comment"># 对应每个文件（夹）名，通过簇链定位它的上一级目录的内容从而得到它的首簇，再得到簇链</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(file_list)):<br>        <span class="hljs-comment"># 注意要转大写</span><br>        filename = <span class="hljs-built_in">str</span>(binascii.hexlify(<br>            <span class="hljs-built_in">bytes</span>(file_list[i].upper(), <span class="hljs-string">&#x27;utf-8&#x27;</span>)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 扇区号还得乘以每个扇区的字节数才是偏移量</span><br>        disk.seek(<br>            (root_addr + (clust_list[<span class="hljs-number">0</span>] - BPB_RootClus) * sector_per_clust) * byte_per_sector)<br>        <span class="hljs-comment"># print((root_addr + (clust_list[0] - BPB_RootClus) * sector_per_clust))</span><br>        current_sector = <span class="hljs-built_in">str</span>(binascii.hexlify(<br>            disk.read(sector_per_clust * byte_per_sector)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># print(current_sector)</span><br>        <span class="hljs-comment"># print(filename)</span><br>        index = -<span class="hljs-number">1</span><br>        <span class="hljs-comment"># 短文件名，直接查看文件名对应的 16 进制字符串</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(filename) &lt;= <span class="hljs-number">16</span>:<br>            index = current_sector.find(filename)<br>            <span class="hljs-comment"># print(index)</span><br>        <span class="hljs-comment"># 长文件名查找 文件名的前 “6 个字符和 ~i‘ 然后再去和长文件目录项匹配</span><br>        <span class="hljs-keyword">else</span>:<br>            num = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">14</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">24</span>, <span class="hljs-number">28</span>, <span class="hljs-number">30</span>]<br>            <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):<br>                <span class="hljs-comment"># print(</span><br>                <span class="hljs-comment">#     filename[:12] + str(binascii.hexlify(bytes(&quot;~&quot; + str(number), &#x27;utf-8&#x27;)))[2:-1])</span><br>                index = current_sector.find(<br>                    filename[:<span class="hljs-number">12</span>] + <span class="hljs-built_in">str</span>(binascii.hexlify(<span class="hljs-built_in">bytes</span>(<span class="hljs-string">&quot;~&quot;</span> + <span class="hljs-built_in">str</span>(number), <span class="hljs-string">&#x27;utf-8&#x27;</span>)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>])<br>                temp = <span class="hljs-string">&quot;&quot;</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(real_filename[i]) / <span class="hljs-number">26</span>) + <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">13</span>):<br>                        temp += current_sector[index - <span class="hljs-number">64</span> * (<br>                            j + <span class="hljs-number">1</span>) + num[k] * <span class="hljs-number">2</span>: index - <span class="hljs-number">64</span> * (j + <span class="hljs-number">1</span>) + num[k] * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>]<br>                <span class="hljs-comment"># print(real_filename)</span><br>                <span class="hljs-comment"># print(temp)</span><br>                <span class="hljs-keyword">if</span> temp[:<span class="hljs-built_in">len</span>(real_filename[i])] == real_filename[i]:<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># print(index)</span><br>        <span class="hljs-comment"># 没找到这个文件名，说明是错误的地址</span><br>        <span class="hljs-keyword">if</span> index == -<span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;wrong path.&quot;</span>)<br>            exit(-<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 得到首簇</span><br>        first_clust = get_count(current_sector[index + <span class="hljs-number">40</span>:index + <span class="hljs-number">44</span>]) * \<br>            <span class="hljs-built_in">pow</span>(<span class="hljs-number">16</span>, <span class="hljs-number">4</span>) + get_count(current_sector[index + <span class="hljs-number">52</span>:index + <span class="hljs-number">56</span>])<br>        <span class="hljs-comment"># print(&quot;first_clust:&quot;, first_clust)</span><br>        <span class="hljs-comment"># 查找簇链</span><br>        disk.seek(fat1_addr * byte_per_sector)<br>        fat1 = <span class="hljs-built_in">str</span>(binascii.hexlify(<br>            disk.read(sector_per_clust * byte_per_sector)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]<br>        clust_list = get_clust_list(fat1, first_clust)<br>        <span class="hljs-built_in">print</span>(clust_list)<br>    <span class="hljs-comment"># 得到最后的文件的簇链，全部读取，然后写入到文件之中</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;copy.txt&quot;</span>, mode=<span class="hljs-string">&quot;w+&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>, newline=<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> clust <span class="hljs-keyword">in</span> clust_list:<br>            disk.seek(<br>                (root_addr + (clust - BPB_RootClus) * sector_per_clust) * byte_per_sector)<br>            filecontent = <span class="hljs-built_in">str</span>(binascii.hexlify(<br>                disk.read(sector_per_clust * byte_per_sector)))[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]<br>            <span class="hljs-comment"># print(binascii.unhexlify(filecontent.encode()).decode())</span><br>            s = binascii.unhexlify(filecontent.encode()).decode().rstrip(<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            f.write(s)<br>    <span class="hljs-comment"># print(filecontent)</span><br></code></pre></td></tr></table></figure><p>最后，展示一些结果：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221012205900741.png" alt="image-20221012205900741" style="zoom:80%;"><p>同样，实验了一下长文件夹名，长文件名和长簇链：</p><img src="/2023/06/30/%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%8F%90%E5%8F%96FAT32%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/image-20221012205951138.png" alt="image-20221012205951138" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】FAT文件系统原理</title>
    <link href="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <url>/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="【转载】FAT文件系统原理"><a href="#【转载】FAT文件系统原理" class="headerlink" title="【转载】FAT文件系统原理"></a>【转载】FAT文件系统原理</h1><blockquote><p>转载自：<a href="http://info.mrtlab.com/filesystem/FAT-principle-three.html">http://info.mrtlab.com/filesystem/FAT-principle-three.html</a></p><p>仅作为个人学习记录，侵权联系删除！</p></blockquote><p>FAT表(File Allocation Table 文件分配表)，是Microsoft在FAT文件系统中用于磁盘数据(文件)索引和定位引进的一种链式结构。假如把磁盘比作一本书，FAT表可以认为相当于书中的目录，而文件就是各个章节的内容。但FAT表的表示方法却与目录有很大的不同。</p><p>在FAT文件系统中，文件的存储依照FAT表制定的簇链式数据结构来进行。同时，FAT文件系统将组织数据时使用的目录也抽象为文件，以简化对数据的管理。</p><hr><p> ★存储过程假想：</p><p>我们模拟对一个分区存储数据的过程来说明FAT文件系统中数据的存储原则。</p><p>假定现在有一个空的完全没有存放数据的磁盘，大小为100KB，我们将其想象为线形的空间地址。为了存储管理上的便利，我们人为的将这100KB的空间均分成100份，每份1KB。我们来依次存储这样几个文件：A.TXT(大小10KB),B.TXT(大小53.6KB)，C.TXT(大小20.5KB)。</p><p>最起码能够想到，我们可以顺序的在这100KB空间中存放这3个文件。同时不要忘了，我们还要记下他们的大小和开始的位置，这样下次要用时才能找的到，这就像是目录。为了便于查找，我们假定用第1K的空间来存储他们的特征(属性)。还有，我们设计的存储单位是1KB，所以，A.TXT我们需要10个存储单位(为了说明方便，我们把存储单位叫做“簇”吧。也能少打点字，呵呵。)，B.TXT需要54个簇，C.TXT需要21个簇。可能有人会说B.TXT和C.TXT不是各自浪费了不到1簇的空间吗？干嘛不让他们紧挨着，不是省地方吗？我的回答是，如果按照这样的方式存储，目录中原本只需要记下簇号，现在还需要记下簇内的偏移，这样会增加目录的存储量，而且存取没有了规则，读取也不太方便，是得不偿失的。</p><p>根据上面所说的思想，我们设计了这样的图4.3.1所示的存储方式。</p><img src="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/9E224840581.gif" alt="img" style="zoom:100%;"><p>我们再考虑如何来写这三个文件的目录。对于每个文件而言，一定要记录的有：文件名，开始簇，大小，创建日期、时间，修改日期、时间，文件的读写属性等。这里大小能不能用结束簇来计算呢？一定不能，因为文件的大小不一定就是整数个簇的大小，否则的话像B.TXT的内容就是54KB的内容了，少了固然不行，可多了也是不行的。那么我们怎么记录呢？可以想象一下。为了管理上的方便，我们用数据库的管理方式来管理我们的目录。于是我把1KB再分成10份，假定开始簇号为0，定义每份100B的各个位置的代表含义如图4.3.2：</p><img src="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/D7224840866.gif" alt="img"><p>这样设计的结构绝对可以对文件进行正确的读写了。接着让我们设计的文件系统工作吧。先改动个文件，比如A.TXT，增加点内容吧！咦？增加后往哪里放呀，虽然存储块的后面有很多空间，但紧随其后B.TXT的数据还顶着呢？要是把A.TXT移到后边太浪费处理资源，而且也不一定解决问题。这个问题看来暂时解决不了。</p><p>那我们换个操作，把B.txt删了，b.txt的空间随之释放。这时候空间如图4.3.3，目录如图4.3.4：</p><img src="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/AF224840326.gif" alt="img"><p>这个操作看来还可以，我们接着做，在存入一个文件D.txt(大小为60.3KB),总共100簇的空间只用了31簇，还有68簇剩余，按说能放下。可是？往那里放呢？没有61个连续的空间了，目录行没办法写了，看来无连续块存储暂时也不行。</p><p>你一定能够想到我们可以在连续空间不够或增加文件长度的时候转移影响我们操作的其他文件，从而腾出空间来，但我要问你，那不是成天啥也不要干了，就是倒腾东西了吗？</p><p>看来我们设计的文件系统有致命的漏洞，怎么解决呢？。。。。</p><hr><p>其实可以这样解决：</p><p>首先我们允许文件的不连续存储。目录中依然只记录开始簇和文件的大小。那么我们怎么记录文件占用那些簇呢，以文件映射簇不太方便，因为文件名是不固定的。我们换个思想，可以用簇来映射文件，在整个存储空间的前部留下几簇来记录数据区中数据与簇号的关系。对于上例因为总空间也不大，所以用前部的1Kb的空间来记录这种对应，假设3个文件都存储，空间分配如图4.3.5，同时修改一下目录，如图4.3.6：</p><img src="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/FF224840997.gif" alt="img"><p>第一簇用来记录数据区中每一簇的被占用情况，暂时称其为文件分配表。结合文件分配表和文件目录就可以达到完全的文件读取了。我们想到，把文件分配表做成一个数据表，以图4.3.7的形式记录簇与数据的对应。</p><p>用图4.3.7的组织方式是完全可以实现对文件占有簇的记录的。但还不够效率。比如文件名在文件分配表中记录太多，浪费空间，而实际上在目录中已经记录了文件的开始簇了。所以可以改良一下，用链的方式来存放占有簇的关系，变成图4.3.8的组织方式。</p><img src="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/DC224840568.gif" alt="img"><p>参照图4.3.8来理解一下文件分配表的意义。如文件a.txt我们根据目录项中指定的a.txt的首簇为2，然后找到文件分配表的第2簇记录，上面登记的是3，我们就能确定下一簇是3。找到文件分配表的第3簇记录，上面登记的是4，我们就能确定下一簇是4……直到指到第11簇，发现下一个指向是FF，就是结束。文件便丝毫无误读取完毕。</p><p>我们再看上面提到的第三种情况，就是将b.txt删除以后，存入一个大小为60.3KB的d.txt。利用簇链可以很容易的实现。实现后的磁盘如图4.3.9 4.3.10 4.3.11：</p><img src="/2023/06/30/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/image-20230630230351647.png" alt="image-20230630230351647" style="zoom: 45%;">]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vfat文件系统</title>
    <link href="/2023/06/29/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/06/29/vfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="vfat文件系统"><a href="#vfat文件系统" class="headerlink" title="vfat文件系统"></a>vfat文件系统</h1><blockquote><p><a href="https://www.cnblogs.com/Chary/p/12981056.html">https://www.cnblogs.com/Chary/p/12981056.html</a></p></blockquote><h2 id="1-分析Vfat文件系统的DBR"><a href="#1-分析Vfat文件系统的DBR" class="headerlink" title="1.分析Vfat文件系统的DBR"></a>1.分析Vfat文件系统的DBR</h2><p>vfat文件系统的DBR有5部分组成，分别为跳转指令，OEM代号，BPB，引导程序和结束标志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs shell">00000000  eb 58 90 6d 6b 66 73 2e  66 61 74 00 02 08 20 00  |.X.mkfs.fat... .|<br>00000010  02 00 00 00 00 f8 00 00  3f 00 ff 00 00 08 00 00  |........?.......|<br>00000020  00 00 39 00 40 0e 00 00  00 00 00 00 02 00 00 00  |..9.@...........|<br>00000030  01 00 06 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000040  80 00 29 d7 6c d4 7e 4e  4f 20 4e 41 4d 45 20 20  |..).l.~NO NAME  |<br>00000050  20 20 46 41 54 33 32 20  20 20 0e 1f be 77 7c ac  |  FAT32   ...w|.|<br>00000060  22 c0 74 0b 56 b4 0e bb  07 00 cd 10 5e eb f0 32  |&quot;.t.V.......^..2|<br>00000070  e4 cd 16 cd 19 eb fe 54  68 69 73 20 69 73 20 6e  |.......This is n|<br>00000080  6f 74 20 61 20 62 6f 6f  74 61 62 6c 65 20 64 69  |ot a bootable di|<br>00000090  73 6b 2e 20 20 50 6c 65  61 73 65 20 69 6e 73 65  |sk.  Please inse|<br>000000a0  72 74 20 61 20 62 6f 6f  74 61 62 6c 65 20 66 6c  |rt a bootable fl|<br>000000b0  6f 70 70 79 20 61 6e 64  0d 0a 70 72 65 73 73 20  |oppy and..press |<br>000000c0  61 6e 79 20 6b 65 79 20  74 6f 20 74 72 79 20 61  |any key to try a|<br>000000d0  67 61 69 6e 20 2e 2e 2e  20 0d 0a 00 00 00 00 00  |gain ... .......|<br>000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|<br>00000200  52 52 61 41 00 00 00 00  00 00 00 00 00 00 00 00  |RRaA............|<br>00000210  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>000003e0  00 00 00 00 72 72 41 61  6b 1c 07 00 02 00 00 00  |....rrAak.......|<br>000003f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|<br>00000400  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>00000c00  eb 58 90 6d 6b 66 73 2e  66 61 74 00 02 08 20 00  |.X.mkfs.fat... .|<br>00000c10  02 00 00 00 00 f8 00 00  3f 00 ff 00 00 08 00 00  |........?.......|<br>00000c20  00 00 39 00 40 0e 00 00  00 00 00 00 02 00 00 00  |..9.@...........|<br>00000c30  01 00 06 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000c40  80 00 29 d7 6c d4 7e 4e  4f 20 4e 41 4d 45 20 20  |..).l.~NO NAME  |<br>00000c50  20 20 46 41 54 33 32 20  20 20 0e 1f be 77 7c ac  |  FAT32   ...w|.|<br>00000c60  22 c0 74 0b 56 b4 0e bb  07 00 cd 10 5e eb f0 32  |&quot;.t.V.......^..2|<br>00000c70  e4 cd 16 cd 19 eb fe 54  68 69 73 20 69 73 20 6e  |.......This is n|<br>00000c80  6f 74 20 61 20 62 6f 6f  74 61 62 6c 65 20 64 69  |ot a bootable di|<br>00000c90  73 6b 2e 20 20 50 6c 65  61 73 65 20 69 6e 73 65  |sk.  Please inse|<br>00000ca0  72 74 20 61 20 62 6f 6f  74 61 62 6c 65 20 66 6c  |rt a bootable fl|<br>00000cb0  6f 70 70 79 20 61 6e 64  0d 0a 70 72 65 73 73 20  |oppy and..press |<br>00000cc0  61 6e 79 20 6b 65 79 20  74 6f 20 74 72 79 20 61  |any key to try a|<br>00000cd0  67 61 69 6e 20 2e 2e 2e  20 0d 0a 00 00 00 00 00  |gain ... .......|<br>00000ce0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>00000df0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|<br>00000e00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>00004000  f8 ff ff 0f ff ff ff 0f  f8 ff ff 0f 00 00 00 00  |................|<br>00004010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>001cc000  f8 ff ff 0f ff ff ff 0f  f8 ff ff 0f 00 00 00 00  |................|<br>001cc010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>72000000<br></code></pre></td></tr></table></figure><p><strong>（1）跳转指令</strong></p><p><strong>E8 58 90 ：(跳转指令) 本身占2字节它将程序执行流程跳转到引导程序处。</strong></p><p><strong>（2）OEM代号</strong></p><p><strong>4D 53 57 49 4E 34 2E 31 :(OEM代号) 这部分占8字节，其内容由创建该文件系统的OEM厂商具体安排。</strong></p><p><strong>（3）BPB</strong></p><p>vfat的BPB从DBR的第12个字节开始，占用79字节，记录了有关该文件系统的重要信息，各参数解释如下表：</p><p><strong>前面53个字节是BPB，后面26个字节是扩展BPB。</strong></p><table><thead><tr><th>对应值</th><th>字段长度（Byte）</th><th>名称和定义</th><th>取值含义</th></tr></thead><tbody><tr><td>0x0200</td><td>2</td><td>扇区字节数（Byte Per Sector）</td><td>每个扇区512字节</td></tr><tr><td>0x08</td><td>1</td><td>每簇扇区数（Sector Per Cluster）</td><td>每簇8个扇区</td></tr><tr><td>0x0020</td><td>2</td><td>保留扇区数</td><td>保留32个扇区</td></tr><tr><td>0x02</td><td>1</td><td>FAT数</td><td>2个FAT</td></tr><tr><td>0x0000</td><td>2</td><td>根目录项数（只有FAT12&#x2F;FAT16使用此字段）</td><td>根目录项数为0</td></tr><tr><td>0x0000</td><td>2</td><td>小扇区数（只有FAT12&#x2F;FAT16使用此字段）</td><td>小扇区数为0</td></tr><tr><td>0xf8</td><td>1</td><td>媒体描述符（0xf8表示硬盘）</td><td>硬盘</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vold中fork子进程执行命令</title>
    <link href="/2023/06/26/vold%E4%B8%ADfork%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/06/26/vold%E4%B8%ADfork%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="vold中fork子进程执行命令"><a href="#vold中fork子进程执行命令" class="headerlink" title="vold中fork子进程执行命令"></a>vold中fork子进程执行命令</h1><blockquote><p>🍃 前置知识：</p><ul><li><a href="https://anmuxixixi.github.io/2023/06/26/linux%E4%B8%ADpipe%E5%92%8Cdup2%E8%AF%A6%E8%A7%A3/">linux中pipe和dup2详解</a></li><li><a href="https://anmuxixixi.github.io/2023/06/26/Linux%E4%B8%AD%E7%9A%84STDIN-FILENO%E5%92%8CSTDOUT-FILENO/">Linux中的STDIN_FILENO和STDOUT_FILENO_</a></li><li><a href="https://blog.csdn.net/duapple/article/details/126918593">记录fork子进程执行execl阻塞卡死的问题</a></li></ul></blockquote><h2 id="1-fork子进程执行命令"><a href="#1-fork子进程执行命令" class="headerlink" title="1.fork子进程执行命令"></a>1.fork子进程执行命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\vold\Utils.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">ForkExecvp</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt;&amp; args, std::vector&lt;std::string&gt;* output,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-type">security_context_t</span> context)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> argv = <span class="hljs-built_in">ConvertToArgv</span>(args);<br><br>    android::base::unique_fd pipe_read, pipe_write;<br>    <span class="hljs-keyword">if</span> (!android::base::<span class="hljs-built_in">Pipe</span>(&amp;pipe_read, &amp;pipe_write)) &#123;<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Pipe in ForkExecvp&quot;</span>;<br>        <span class="hljs-keyword">return</span> -errno;<br>    &#125;<br><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        pipe_read.<span class="hljs-built_in">reset</span>();<br>        <span class="hljs-comment">// 将STDOUT_FILENO(也就是终端输出)重定向到pipe_write</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dup2</span>(pipe_write.<span class="hljs-built_in">get</span>(), STDOUT_FILENO) == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;dup2 in ForkExecvp&quot;</span>;<br>            _exit(EXIT_FAILURE);<br>        &#125;<br>        pipe_write.<span class="hljs-built_in">reset</span>();<br>        <span class="hljs-comment">// 执行命令</span><br>        <span class="hljs-built_in">execvp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>**&gt;(argv.<span class="hljs-built_in">data</span>()));<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;exec in ForkExecvp&quot;</span>;<br>        _exit(EXIT_FAILURE);<br>    &#125;<br><br>    pipe_write.<span class="hljs-built_in">reset</span>();<br>    <span class="hljs-keyword">auto</span> st = <span class="hljs-built_in">ReadLinesFromFdAndLog</span>(output, std::<span class="hljs-built_in">move</span>(pipe_read));<br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> st;<br><br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-comment">// 等待子进程执行结束</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">waitpid</span>(pid, &amp;status, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;waitpid in ForkExecvp&quot;</span>;<br>        <span class="hljs-keyword">return</span> -errno;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br>---------------------------------------------------<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">status_t</span> <span class="hljs-title">ReadLinesFromFdAndLog</span><span class="hljs-params">(std::vector&lt;std::string&gt;* output,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      android::base::unique_fd ufd)</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;FILE, <span class="hljs-title">int</span> <span class="hljs-params">(*)</span><span class="hljs-params">(FILE*)</span>&gt; <span class="hljs-title">fp</span><span class="hljs-params">(android::base::Fdopen(std::move(ufd), <span class="hljs-string">&quot;r&quot;</span>), fclose)</span></span>;<br>    <span class="hljs-type">char</span> line[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fgets</span>(line, <span class="hljs-built_in">sizeof</span>(line), fp.<span class="hljs-built_in">get</span>()) != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">LOG</span>(DEBUG) &lt;&lt; line;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里其实就是fork子进程后理解调用exec族函数execvp去执行命令。</p><img src="/2023/06/26/vold%E4%B8%ADfork%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/image-20230626230653727.png" alt="image-20230626230653727" style="zoom: 80%;"><h2 id="2-异步执行fork子进程执行命令"><a href="#2-异步执行fork子进程执行命令" class="headerlink" title="2.异步执行fork子进程执行命令"></a>2.异步执行fork子进程执行命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">ForkExecvpAsync</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt;&amp; args)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> argv = <span class="hljs-built_in">ConvertToArgv</span>(args);<br><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 关闭了所有的流</span><br>        <span class="hljs-built_in">close</span>(STDIN_FILENO);<br>        <span class="hljs-built_in">close</span>(STDOUT_FILENO);<br>        <span class="hljs-built_in">close</span>(STDERR_FILENO);<br><span class="hljs-comment">// 执行命令行</span><br>        <span class="hljs-built_in">execvp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>**&gt;(argv.<span class="hljs-built_in">data</span>()));<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;exec in ForkExecvpAsync&quot;</span>;<br>        _exit(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">return</span> pid;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-差异"><a href="#3-差异" class="headerlink" title="3.差异"></a>3.差异</h2><p>ForkExecvp与ForkExecvpAsync对比后差异在于：</p><ul><li>ForkExecvp会将命令行执行的结果通过日志打印出来，而ForkExecvpAsync则执行执行命令行</li><li>ForkExecvp在多线程某种极端的情况下，可能发生死锁【<a href="https://blog.csdn.net/duapple/article/details/126918593%E3%80%91%E3%80%82">https://blog.csdn.net/duapple/article/details/126918593】。</a></li><li>使用了匿名管道的ForkExecvp是非异步的，而ForkExecvpAsync是异步的</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】linux中pipe和dup2详解</title>
    <link href="/2023/06/26/linux%E4%B8%ADpipe%E5%92%8Cdup2%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/06/26/linux%E4%B8%ADpipe%E5%92%8Cdup2%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="【转载】linux中pipe和dup2详解"><a href="#【转载】linux中pipe和dup2详解" class="headerlink" title="【转载】linux中pipe和dup2详解"></a>【转载】linux中pipe和dup2详解</h1><blockquote><p>转载自：<a href="https://www.cnblogs.com/Hxinguan/p/5007393.html">https://www.cnblogs.com/Hxinguan/p/5007393.html</a></p></blockquote><h2 id="1-什么是管道"><a href="#1-什么是管道" class="headerlink" title="1.什么是管道"></a>1.什么是管道</h2><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道； 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）； 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p><h2 id="2-管道的创建"><a href="#2-管道的创建" class="headerlink" title="2.管道的创建"></a>2.管道的创建</h2><p>int pipe(int fd[2])</p><p>该函数创建的管道的两端处于一个中间进程，在实际应用中并没有太大意义，一般在pipe()创建管道后，再fork()一个子进程，然后通过管道实现父子进程之间的通信。</p><h2 id="3-管道的读写规则"><a href="#3-管道的读写规则" class="headerlink" title="3.管道的读写规则"></a>3.管道的读写规则</h2><p>管道两端可分别用描述字fd[0]以及fd[1]来描述，需要注意的是，管道的两端是固定了任务的。即一端只能用于读，由描述字fd[0]表示，称其为管道读端；另一端则只能用于写，由描述字fd[1]来表示，称其为管道写端。</p><h2 id="4-pipe函数"><a href="#4-pipe函数" class="headerlink" title="4.pipe函数"></a>4.pipe函数</h2><p>头文件：#include&lt;unistd.h&gt;</p><p>函数原型： int pipe(int fd[2])</p><p>函数参数：fd[2],管道的两个文件描述符，之后就是可以直接操作这两个文件描述符。其中fd[0]为读取端，fd[1]为写入端</p><p>返回值：成功返回0，否则返回-1</p><ul><li><p>读fd[0]: close(fd[1]); read(fd[0], buf, BUF_SIZE);</p></li><li><p>写fd[1]: close(fd[0]); read(fd[1], buf, strlen(buf));</p></li></ul><h2 id="5-例子"><a href="#5-例子" class="headerlink" title="5.例子"></a>5.例子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">pipe</span>(fd) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is the father process, here write a string to the pipe\n&quot;</span>);<br>        <span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;Hello! write a string in the father process\n&quot;</span>;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">write</span>(fd[<span class="hljs-number">1</span>], s, <span class="hljs-built_in">sizeof</span>(s));              <span class="hljs-comment">// 向管道中写入数据</span><br><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is the child process, here read a string from the pipe\n&quot;</span>);<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">read</span>(fd[<span class="hljs-number">0</span>], buf, <span class="hljs-built_in">sizeof</span>(buf));          <span class="hljs-comment">//从管道中读取数据</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>    &#125;<br>    <span class="hljs-built_in">waitpid</span>(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><img src="/2023/06/26/linux%E4%B8%ADpipe%E5%92%8Cdup2%E8%AF%A6%E8%A7%A3/image-20230626220856696.png" alt="image-20230626220856696" style="zoom:80%;"><p>当管道中数据被读取后，管道为空。之后再read操作将默认的被阻塞，等待某些数据被写入。如需要设置为非阻塞，则可做如下设置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">fcntl</span>(filedes[<span class="hljs-number">0</span>], F_SETFL, O_NONBLOCK);<br><span class="hljs-built_in">fcntl</span>(filedes[<span class="hljs-number">1</span>], F_SETFL, O_NONBLOCK);<br></code></pre></td></tr></table></figure><h2 id="6-dup2读取"><a href="#6-dup2读取" class="headerlink" title="6.dup2读取"></a>6.dup2读取</h2><p>用来复制一个现存的文件描述符，使两个文件描述符指向同一个<code>file</code>结构体。</p><p>其中头文件：#include &lt;unistd.h&gt;</p><p>函数原型：int dup2(int oldhandle, int newhandle);</p><p>例子还是使用上面那个例子，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">int</span> newfd;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">pipe</span>(fd) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is the father process, here write a string to the pipe\n&quot;</span>);<br>        <span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;Hello! write a string in the father process\n&quot;</span>;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">write</span>(fd[<span class="hljs-number">1</span>], s, <span class="hljs-built_in">sizeof</span>(s));              <span class="hljs-comment">// 向管道中写入数据</span><br><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is the child process, here read a string from the pipe\n&quot;</span>);<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">0</span>], newfd);<br>        <span class="hljs-built_in">read</span>(newfd, buf, <span class="hljs-built_in">sizeof</span>(buf));          <span class="hljs-comment">//从管道中读取数据</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>    &#125;<br>    <span class="hljs-built_in">waitpid</span>(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行的结果还是一样。只是在36行代码中调用了dup2,把fd[0]复制给newfd。</p><img src="/2023/06/26/linux%E4%B8%ADpipe%E5%92%8Cdup2%E8%AF%A6%E8%A7%A3/image-20230626221136998.png" alt="image-20230626221136998" style="zoom:80%;"><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br> <br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILENME   <span class="hljs-string">&quot;1.txt&quot;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">O_RDWR: 可读可写</span><br><span class="hljs-comment">O_TRUNC: 会把原有内容删除  。 英文读：欧擦克</span><br><span class="hljs-comment">O_CREAT: 如果a.txt 没有这个文件，就会新建一个 a.txt</span><br><span class="hljs-comment">O_APPEND: 接续添加要写入的内容 。 英文读：欧额盆得</span><br><span class="hljs-comment">*/</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> fd1 = <span class="hljs-number">-1</span>, fd2 = <span class="hljs-number">-1</span>;<br><br>fd1 = <span class="hljs-built_in">open</span>(FILENME, O_RDWR | O_APPEND ); <br><br><span class="hljs-keyword">if</span> (fd1 &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd1 = %d.\n&quot;</span>, fd1);<br><br><span class="hljs-comment">//如果正确 就会返回新的 文件描述符 16 </span><br>fd2 = <span class="hljs-built_in">dup2</span>(fd1,<span class="hljs-number">16</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd2 = %d .\n&quot;</span>,fd2);<br><br><span class="hljs-comment">//因为只打开了 fd1, 所以只关闭fd1就可以了</span><br><span class="hljs-built_in">close</span>(fd1);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="/2023/06/26/linux%E4%B8%ADpipe%E5%92%8Cdup2%E8%AF%A6%E8%A7%A3/6766a5c4f0924a6aa4c0e99f3826b24b.png" alt="img" style="zoom: 80%;">]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的STDIN_FILENO和STDOUT_FILENO</title>
    <link href="/2023/06/26/Linux%E4%B8%AD%E7%9A%84STDIN-FILENO%E5%92%8CSTDOUT-FILENO/"/>
    <url>/2023/06/26/Linux%E4%B8%AD%E7%9A%84STDIN-FILENO%E5%92%8CSTDOUT-FILENO/</url>
    
    <content type="html"><![CDATA[<h1 id="【转载】Linux中的STDIN-FILENO和STDOUT-FILENO"><a href="#【转载】Linux中的STDIN-FILENO和STDOUT-FILENO" class="headerlink" title="【转载】Linux中的STDIN_FILENO和STDOUT_FILENO"></a>【转载】Linux中的STDIN_FILENO和STDOUT_FILENO</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/sinat_25457161/article/details/48548231?spm=1001.2014.3001.5506">https://blog.csdn.net/sinat_25457161/article/details/48548231?spm=1001.2014.3001.5506</a></p></blockquote><p><strong>说明：</strong></p><blockquote><p>STDIN_FILENO：接收键盘的输入</p><p>STDOUT_FILENO：向屏幕输出</p></blockquote><p><strong>程序：</strong></p><blockquote><p>接收用户在屏幕上输入的数据，并在屏幕上输出（要求使用read和wirte实现），用户输入quit就退出程序。</p></blockquote><p><strong>图解说明：</strong></p><img src="/2023/06/26/Linux%E4%B8%AD%E7%9A%84STDIN-FILENO%E5%92%8CSTDOUT-FILENO/20150918165941312.jpeg" alt="img" style="zoom:80%;"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *args[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义读取文件的缓冲区</span><br><span class="hljs-type">char</span> buf_read[<span class="hljs-number">1024</span>];<br><span class="hljs-comment">// 定义写入文件的缓冲区</span><br><span class="hljs-type">char</span> buf_write[<span class="hljs-number">1024</span>];<br><br><span class="hljs-comment">// 循环读取用户从键盘输入的信息</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">// 清空读取文件缓冲区中的内存</span><br><span class="hljs-built_in">memset</span>(buf_read, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buf_read));<br><span class="hljs-comment">// 清空写入文件缓冲区中的内存</span><br><span class="hljs-built_in">memset</span>(buf_write, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buf_write));<br><br><span class="hljs-comment">// 打印提示信息</span><br><span class="hljs-type">char</span> input_message[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;input some words : &quot;</span>;<br><span class="hljs-built_in">write</span>(STDOUT_FILENO, input_message, <span class="hljs-built_in">sizeof</span>(input_message));<br><span class="hljs-comment">// 读取用户的键盘输入信息</span><br><span class="hljs-built_in">read</span>(STDIN_FILENO, buf_read, <span class="hljs-built_in">sizeof</span>(buf_read));<br><span class="hljs-comment">// 判断用户输入的内容是否为quit</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(buf_read, <span class="hljs-string">&quot;quit&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 如果用户输入的是quit，程序退出循环</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 如果用户输入的不是quit</span><br><span class="hljs-comment">// 把内容拷贝到写入文件缓冲区中</span><br><span class="hljs-built_in">strcpy</span>(buf_write, buf_read);<br><span class="hljs-comment">// 打印提示信息</span><br><span class="hljs-type">char</span> output_message[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;output some words : &quot;</span>;<br><span class="hljs-built_in">write</span>(STDOUT_FILENO, output_message, <span class="hljs-built_in">sizeof</span>(output_message));<br><span class="hljs-comment">// 将信息显示在屏幕上</span><br><span class="hljs-built_in">write</span>(STDOUT_FILENO, buf_write, <span class="hljs-built_in">strlen</span>(buf_write));<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/06/26/Linux%E4%B8%AD%E7%9A%84STDIN-FILENO%E5%92%8CSTDOUT-FILENO/image-20230626215903169.png" alt="image-20230626215903169" style="zoom:80%;"><p>程序实现了，没有使用scanf和printf，从键盘接收用户输入和将用户输入的信息打印到屏幕上。</p>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【科普】非对称加密技术（公钥体系）【公钥 私钥 数字签名 CA证书】</title>
    <link href="/2023/06/24/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%EF%BC%88%E5%85%AC%E9%92%A5%E4%BD%93%E7%B3%BB%EF%BC%89%E3%80%90%E5%85%AC%E9%92%A5-%E7%A7%81%E9%92%A5-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-CA%E8%AF%81%E4%B9%A6%E3%80%91/"/>
    <url>/2023/06/24/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%EF%BC%88%E5%85%AC%E9%92%A5%E4%BD%93%E7%B3%BB%EF%BC%89%E3%80%90%E5%85%AC%E9%92%A5-%E7%A7%81%E9%92%A5-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-CA%E8%AF%81%E4%B9%A6%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="【科普】非对称加密技术（公钥体系）【公钥-私钥-数字签名-CA证书】"><a href="#【科普】非对称加密技术（公钥体系）【公钥-私钥-数字签名-CA证书】" class="headerlink" title="【科普】非对称加密技术（公钥体系）【公钥 私钥 数字签名 CA证书】"></a>【科普】非对称加密技术（公钥体系）【公钥 私钥 数字签名 CA证书】</h1><p><a href="https://www.bilibili.com/video/BV15P4y1S7Jw/">https://www.bilibili.com/video/BV15P4y1S7Jw/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【实验】openssl模拟证书的生成过程</title>
    <link href="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="【实验】openssl模拟证书的生成过程"><a href="#【实验】openssl模拟证书的生成过程" class="headerlink" title="【实验】openssl模拟证书的生成过程"></a>【实验】openssl模拟证书的生成过程</h1><blockquote><p>实验内容来自：<a href="https://www.cnblogs.com/frisk/p/12628159.html">https://www.cnblogs.com/frisk/p/12628159.html</a></p><p>🔕基础知识参考博客先进行回顾！！！</p></blockquote><p>🥇 <strong>openssl x509工具主要用于输出证书信息, 签署证书请求文件、自签署、转换证书格式等。它就像是一个完整的小型的CA工具箱。</strong></p><p><strong>（1）运营商私钥</strong></p><p> 模拟生成运营商的私钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">需要经常输入密码</span><br>openssl genrsa -des3 -out server_private.key 2048 会有输入密码的要求<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">去除密码</span><br>openssl rsa -in server_private.key -out server_private.key<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">无密码证书秘钥</span><br>openssl genrsa -out server_private.key 2048<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成公钥</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">openssl rsa -<span class="hljs-keyword">in</span> server_private.key -pubout -out server_public.key</span><br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621223828285.png" alt="image-20230621223828285" style="zoom: 67%;"><p><strong>（2）运营商向CA申请证书文件</strong></p><p>模拟生成运营商 证书申请文件&#x2F;证书签名请求文件 <code>.req</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -new -key server_private.key -out server.req<br><span class="hljs-meta prompt_"># </span><span class="language-bash">会让输入Country Name 填 CN; Common Name 填 ip 也可以不填。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看server.req</span><br>openssl req -in server.req -text<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621224000406.png" alt="image-20230621224000406" style="zoom: 67%;"><p><strong>（3）CA机构要有自己的私钥，为运营商签发证书</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl genrsa -out ca_private.key 2048<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621224112637.png" alt="image-20230621224112637" style="zoom:67%;"><p><strong>（4）CA机构 也要向 更高级的CA机构 申请证书, 有了自己的证书 才能为运营商签发证书</strong></p><p> 生成 CA证书申请文件&#x2F;证书签名请求文件 <code>.req</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -new -key ca_private.key  -out ca_request.req<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看ca_request.req</span><br>openssl req -in ca_request.req -text<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621224223565.png" alt="image-20230621224223565" style="zoom:67%;"><p><strong>（5）CA机构获得证书</strong></p><p>创建CA证书，用来给运营商的证书签名。</p><p>这个证书，本来应由更高级的CA用它的private key对这个证书请求进行签发，</p><p>由于此时模拟的CA是 root CA，没有更高级的CA了，所以要进行自签发，用 自己的private key对 自己的证书请求 进行签发。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -req -in ca_request.req -signkey ca_private.key -days 365 -out ca.pem<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看证书</span><br>openssl x509 -in ca.pem -noout -text<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621224336866.png" alt="image-20230621224336866" style="zoom:67%;"><p><strong>（6）CA机构向运营商签发证书</strong></p><p>CA用自己的CA证书ca.pem 和 私钥ca_private.key 为 server.req运营商请求文件签名，生成运营商的证书:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -req -in server.req -CA ca.pem -CAkey ca_private.key -days 365 -CAcreateserial -out server.pem<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看证书</span><br>openssl x509 -in server.pem -noout -text<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看公钥</span><br>openssl x509 -in server.pem -noout -pubkey<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621225245969.png" alt="image-20230621225245969" style="zoom:67%;"><p><strong>（7）查看服务器证书的modulus和服务器私钥的modulus，应该一样：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -in server.pem -noout -modulus<br>openssl rsa -in server_private.key -noout -modulus<br></code></pre></td></tr></table></figure><p><strong>（8）用户访问https网站，服务器会用private key加密数据传输，同时会把证书传给用户，里面有public key信息，用于解密数据。</strong></p><p>用户使用公钥解密的时候，要确认此公钥是否是服务商的，是否是受信任的。</p><p>用户从服务商证书中发现，其证书是由某CA签发的，从CA官网下载他的证书，发现它由 更高级CA签发 或者 是root证书，自签发的。</p><p>这时就可以一级一级的验证证书的合法性，最终确认服务商的证书是否被信任。</p><p>验证后就可以使用公钥解密信息，进行通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl verify -CAfile ca.pem server.pem<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621225426965.png" alt="image-20230621225426965" style="zoom:67%;"><p><strong>（9）从证书导出公钥</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -in server.pem -noout -pubkey -out server_public.key<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621225505365.png" alt="image-20230621225505365" style="zoom:67%;"><p><strong>（10）使用公钥加密，私钥解密</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建测试文件</span><br>cat amx.txt<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621225609552.png" alt="image-20230621225609552" style="zoom: 67%;"><p>加解密</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加密</span><br>openssl rsautl -encrypt -in test.txt -inkey server_public.key -pubin -out test_encrypt.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解密</span><br>openssl rsautl -decrypt -in test_encrypt.txt -inkey server_private.key -out test_decrypt.txt<br></code></pre></td></tr></table></figure><img src="/2023/06/21/openssl%E6%A8%A1%E6%8B%9F%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/image-20230621225700280.png" alt="image-20230621225700280" style="zoom:67%;"><p>最终的文本解密成功…</p><p><strong>（11）查看证书内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打印出证书的内容：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -text</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印出证书的系列号：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -serial</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印出证书的拥有者名字：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -subject</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">以RFC2253规定的格式打印出证书的拥有者名字：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -subject -nameopt RFC2253</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印出证书的MD5特征参数：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -fingerprint</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印出证书有效期：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -dates</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印出证书公钥：openssl x509 -<span class="hljs-keyword">in</span> server.pem -noout -pubkey</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">验证证书的有效性：openssl verify -CAfile ca.pem server.pem</span><br></code></pre></td></tr></table></figure><p>⭐<strong>（12）证书秘钥要使用相同的编码格式</strong></p><p><strong>（13）证书格式转换</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">PEM转DER格式：openssl x509 -inform pem -<span class="hljs-keyword">in</span> server.pem -outform der -out server.der</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">DER转PEM格式：openssl x509 -inform der -<span class="hljs-keyword">in</span> server.der -outform pem -out server.pem0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓锁屏与FBE浅浅理解</title>
    <link href="/2023/06/18/%E5%AE%89%E5%8D%93%E9%94%81%E5%B1%8F%E4%B8%8EFBE%E6%B5%85%E6%B5%85%E7%90%86%E8%A7%A3/"/>
    <url>/2023/06/18/%E5%AE%89%E5%8D%93%E9%94%81%E5%B1%8F%E4%B8%8EFBE%E6%B5%85%E6%B5%85%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓锁屏与FBE浅浅理解"><a href="#安卓锁屏与FBE浅浅理解" class="headerlink" title="安卓锁屏与FBE浅浅理解"></a>安卓锁屏与FBE浅浅理解</h1><blockquote><p>🔴 <strong>注意</strong>：本文是基于Android 12(S)进行分析的，可能与Android 10(Q)有些出入。</p></blockquote><h2 id="1-LockscreenCredential对象"><a href="#1-LockscreenCredential对象" class="headerlink" title="1.LockscreenCredential对象"></a>1.LockscreenCredential对象</h2><img src="/2023/06/18/%E5%AE%89%E5%8D%93%E9%94%81%E5%B1%8F%E4%B8%8EFBE%E6%B5%85%E6%B5%85%E7%90%86%E8%A7%A3/image-20230618201829816.png" alt="image-20230618201829816" style="zoom:75%;"><p>从安卓文档可以看出，LockscreenCredential是一个锁屏凭证，可以是空密码，图案，密码，或者PIN码等。也就是说LockscreenCredential是一个锁屏凭证的抽象。我们可以通过<strong>LockscreenCredential.createPassword</strong>去构造一个credential对象。</p><blockquote><p>这里详细的可以先学习：<a href="https://blog.csdn.net/weixin_42135087/article/details/124565234">https://blog.csdn.net/weixin_42135087/article/details/124565234</a></p></blockquote><hr><h2 id="2-设置锁屏与FBE的关系"><a href="#2-设置锁屏与FBE的关系" class="headerlink" title="2.设置锁屏与FBE的关系"></a>2.设置锁屏与FBE的关系</h2><h3 id="2-1-addUserKeyAuth层层调用"><a href="#2-1-addUserKeyAuth层层调用" class="headerlink" title="2.1 addUserKeyAuth层层调用"></a>2.1 addUserKeyAuth层层调用</h3><p>⭐ 在Android系统重的设置密码、清除密码、修改密码，都是调用到LockSettingsService.java的setLockCredential函数进行的，而setLockCredential又调用了setLockCredentialInternal。【引用：<a href="https://blog.csdn.net/weixin_42135087/article/details/109726612?spm=1001.2014.3001.5506%E3%80%91">https://blog.csdn.net/weixin_42135087/article/details/109726612?spm=1001.2014.3001.5506】</a></p><blockquote><p>从<a href="https://blog.csdn.net/weixin_42135087">代码改变世界ctw</a>大哥的博客中可以知道，当我们创建了设置用户密码的时候会调用到setLockCredentialInternal ，下面的调用栈如下：</p><p>setLockCredentialInternal -&gt; setUserKeyProtection -&gt;  addUserKeyAuth</p><p>从addUserKeyAuth从和FBE扯上了关系</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\locksettings\LockSettingsService.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUserKeyAuth</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> mUserManager.getUserInfo(userId);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">callingId</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>    <span class="hljs-comment">// 调用SMS的addUserKeyAuth方法</span><br>    mStorageManager.addUserKeyAuth(userId, userInfo.serialNumber, token, secret);<br>&#125;<br><br><span class="hljs-comment">// ---------------------------------------------------------------</span><br><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\StorageManagerService.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUserKeyAuth</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">int</span> serialNumber, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret)</span> &#123;<br>    mVold.addUserKeyAuth(userId, serialNumber, encodeBytes(token), encodeBytes(secret));<br>&#125;<br><br><span class="hljs-comment">// ---------------------------------------------------------------</span><br><span class="hljs-comment">// system\vold\VoldNativeService.cpp</span><br>binder::Status VoldNativeService::addUserKeyAuth(int32_t userId, int32_t userSerial,<br>                                                 const std::string&amp; token,<br>                                                 const std::string&amp; secret) &#123;<br>    <span class="hljs-keyword">if</span> (!token_empty(token)) &#123;<br>        LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;Vold doesn&#x27;t use auth tokens, but non-empty token passed to addUserKeyAuth.&quot;</span>;<br>        <span class="hljs-keyword">return</span> binder::Status::fromServiceSpecificError(-EINVAL);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> translateBool(fscrypt_add_user_key_auth(userId, userSerial, secret));<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的注释可以看出，Vold服务是不需要AuthToken的，所以不需要向FBE传递。</p><h3 id="2-2-fscrypt-add-user-key-auth开始添加用户权限"><a href="#2-2-fscrypt-add-user-key-auth开始添加用户权限" class="headerlink" title="2.2 fscrypt_add_user_key_auth开始添加用户权限"></a>2.2 fscrypt_add_user_key_auth开始添加用户权限</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fscrypt_add_user_key_auth</span><span class="hljs-params">(<span class="hljs-type">userid_t</span> user_id, <span class="hljs-type">int</span> serial, <span class="hljs-type">const</span> std::string&amp; secret_hex)</span> </span>&#123;<br><span class="hljs-comment">// 判断是否支持文件级加密</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">fscrypt_is_native</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 还原锁屏码</span><br>    <span class="hljs-keyword">auto</span> auth = <span class="hljs-built_in">authentication_from_hex</span>(secret_hex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fscrypt_rewrap_user_key</span>(user_id, serial, kEmptyAuthentication, *auth);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用fscrypt_rewrap_user_key</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">fscrypt_rewrap_user_key</span><span class="hljs-params">(<span class="hljs-type">userid_t</span> user_id, <span class="hljs-type">int</span> serial,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> android::vold::KeyAuthentication&amp; retrieve_auth,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> android::vold::KeyAuthentication&amp; store_auth)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前用户的CE_KEY目录: /data/misc/vold/user_keys/ce/&lt;userid&gt;</span><br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> directory_path = <span class="hljs-built_in">get_ce_key_directory_path</span>(user_id);<br>    KeyBuffer ce_key;<br>    std::string ce_key_current_path = <span class="hljs-built_in">get_ce_key_current_path</span>(directory_path); <span class="hljs-comment">// /data/misc/vold/user_keys/ce/&lt;userid&gt;/current</span><br>    <span class="hljs-built_in">retrieveKey</span>(ce_key_current_path, kEmptyAuthentication, &amp;ce_key);<br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> paths = <span class="hljs-built_in">get_ce_key_paths</span>(directory_path);<br>    std::string ce_key_path;<br>    <span class="hljs-comment">// 新路径: /data/misc/vold/user_keys/ce/&lt;userid&gt;/current/cx%010u，例如/data/misc/vold/user_keys/ce/0/current/cx0000000000</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">get_ce_key_new_path</span>(directory_path, paths, &amp;ce_key_path)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// user_key_temp: /data/misc/vold/user_keys/temp</span><br>    <span class="hljs-comment">// 保存CE Key</span><br>    <span class="hljs-keyword">if</span> (!android::vold::<span class="hljs-built_in">storeKeyAtomically</span>(ce_key_path, user_key_temp, store_auth, ce_key))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用storeKeyAtomically保存当前用户的CE Key</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">storeKeyAtomically</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key_path, <span class="hljs-type">const</span> std::string&amp; tmp_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> KeyAuthentication&amp; auth, <span class="hljs-type">const</span> KeyBuffer&amp; key)</span> </span>&#123;<br>    <span class="hljs-comment">// 后面会将tmp_path换成Key_path，所以我直接改为key_path</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">storeKey</span>(key_path, auth, key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用storeKey【⭐ 这里所有的操作即使都是在&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;temp中处理的，只是后面会有RenameKeyDir和FsyncParentDirectory操作，只要操作成功了，就相当于<code>/data/misc/vold/user_keys/ce/&lt;userid&gt;/current</code>】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">storeKey</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; dir, <span class="hljs-type">const</span> KeyAuthentication&amp; auth, <span class="hljs-type">const</span> KeyBuffer&amp; key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">mkdir</span>(dir.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0700</span>)) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;key mkdir &quot;</span> &lt;&lt; dir;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 向/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/version中写入1</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kCurrentVersion, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_version)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 创建随机的secdiscardable_hash值</span><br>    std::string secdiscardable_hash;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">createSecdiscardable</span>(dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_secdiscardable, &amp;secdiscardable_hash)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 如果有锁屏密码，则stretching为none; 如果没有锁屏密码，则stretching为nopassword</span><br>    std::string stretching = <span class="hljs-built_in">getStretching</span>(auth);<br>    <span class="hljs-comment">// 向/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/stretching中写入stretching的值</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(stretching, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_stretching)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 生成appId，如果设置了锁屏密码，则为appId = hash + auth.secret；没有设置锁屏密码，则appId = hash</span><br>    std::string appId;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateAppId</span>(auth, stretching, secdiscardable_hash, &amp;appId)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::string encryptedKey;<br>    <span class="hljs-comment">// 如果没有设置锁屏密码，使用keymaster管理</span><br>    <span class="hljs-keyword">if</span> (auth.<span class="hljs-built_in">usesKeymaster</span>()) &#123;<br>        Keymaster keymaster;<br>        <span class="hljs-keyword">if</span> (!keymaster) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        std::string kmKey;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">generateKeyStorageKey</span>(keymaster, appId, &amp;kmKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(kmKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_keymaster_key_blob)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        km::AuthorizationSet keyParams = <span class="hljs-built_in">beginParams</span>(appId);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithKeymasterKey</span>(keymaster, dir, keyParams, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 设置了锁屏密码，不适用keymaster</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">encryptWithoutKeymaster</span>(appId, key, &amp;encryptedKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将加密后的CE key写入/data/misc/vold/user_keys/ce/&lt;userid&gt;/current/encrypted_key</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">writeStringToFile</span>(encryptedKey, dir + <span class="hljs-string">&quot;/&quot;</span> + kFn_encrypted_key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">FsyncDirectory</span>(dir)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>☃️ <strong>这里就揭示了锁屏密码与FBE的关系，当设置了锁屏密码的时候，最终会将锁屏元素中的secret生成appId，在加密ce key的时候要用到。</strong></p></blockquote><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><blockquote><p><a href="https://www.cnblogs.com/bobfly1984/p/14090078.html">https://www.cnblogs.com/bobfly1984/p/14090078.html</a></p></blockquote><ol><li>根据&#x2F;data&#x2F;unencrypted&#x2F;key和&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;de&#x2F;0&#x2F;路径是否存在判断首次开机还是非首次开机</li><li>system DE存储空间和user DE存储空间使用keymasterkey加解密，密钥元素secret和token为空</li><li><strong>不设置锁屏密码，user CE存储空间使用keymasterkey加解密，密钥元素secret和token为空</strong></li><li><strong>设置锁屏密码，user CE存储空间使用withoutkeymastery加解密，密钥元素secret为非空，token为空</strong></li><li>删除锁屏密码后，user CE 存储空间采用 不设置锁密码 加密策略</li><li>添加锁屏密码、修改锁屏密码、删除锁屏密码后在添加锁屏密码，传下来的secret值是一样的，确保不同场景下加密的文件都能解密</li><li>对user CE存储空间加解密的key，不管是设置锁屏密码还是不设置锁屏密码，这个key始终是一样的即首次开机生成的key。不同的只是加密元素和加密方式。</li><li>&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;current # cat stretching<br>nopassword &#x2F;&#x2F; 没有设置锁屏密码<br>none &#x2F;&#x2F; 设置锁屏密</li><li>&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;ce&#x2F;0&#x2F;current&#x2F;keymaster_key_blob &#x2F;&#x2F; 此文件存在意味keymaster加解密、否则使用withoutkeymastery加解密</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 12多用户机制中的连接与会话</title>
    <link href="/2023/06/06/Android-12%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BC%9A%E8%AF%9D/"/>
    <url>/2023/06/06/Android-12%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BC%9A%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-12多用户机制中的连接与会话"><a href="#Android-12多用户机制中的连接与会话" class="headerlink" title="Android 12多用户机制中的连接与会话"></a>Android 12多用户机制中的连接与会话</h1><img src="/2023/06/06/Android-12%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BC%9A%E8%AF%9D/image-20230606233821913.png" alt="image-20230606233821913" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓分区存储</title>
    <link href="/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/"/>
    <url>/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓分区存储"><a href="#安卓分区存储" class="headerlink" title="安卓分区存储"></a>安卓分区存储</h1><blockquote><p>版权声明：本文为CSDN博主「guolin」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/guolin_blog/article/details/105419420/">https://blog.csdn.net/guolin_blog/article/details/105419420/</a></p></blockquote><p>⭐<strong>分区存储的前提是解决SD卡存储的问题，也就是外部存储的问题，所以不涉及原本的安卓内部存储。</strong></p><h2 id="1-理解分区存储"><a href="#1-理解分区存储" class="headerlink" title="1.理解分区存储"></a>1.理解分区存储</h2><p>Android长久以来都支持外置存储空间这个功能，也就是我们常说的SD卡存储。这个功能使用得极其广泛，几乎所有的App都喜欢在SD卡的根目录下建立一个自己专属的目录，用来存放各类文件和数据。</p><p>那么这么做有什么好处吗？我想了一下，大概有两点吧。第一，存储在SD卡的文件不会计入到应用程序的占用空间当中，也就是说即使你在SD卡存放了1G的文件，你的应用程序在设置中显示的占用空间仍然可能只有几十K。第二，存储在SD卡的文件，即使应用程序被卸载了，这些文件仍然会被保留下来，这有助于实现一些需要数据被永久保留的功能。</p><p>然而，这些“好处”真的是好处吗？或 许对于开发者而言这算是好处吧，但对于用户而言，上述好处无异于一些流氓行为。因为这会将用户的SD卡空间搞得乱糟糟的，而且即使我卸载了一个完全不再使用的程序，它所产生的垃圾文件却可能会一直保留在我的手机上。</p><p>另外，存储在SD卡上的文件属于公有文件，所有的应用程序都有权随意访问，这也对数据的安全性带来了很大的挑战。</p><p>为了解决上述问题，Google在Android 10当中加入了作用域存储功能。</p><p>那么到底什么是作用域存储呢？简单来讲，就是Android系统对SD卡的使用做了很大的限制。**从Android 10开始，每个应用程序只能有权在自己的外置存储空间关联目录下读取和创建文件，获取该关联目录的代码是：context.getExternalFilesDir()**。关联目录对应的路径大致如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/storage/emulated/<span class="hljs-number">0</span>/Android/data/&lt;包名&gt;/files<br></code></pre></td></tr></table></figure><p>将数据存放到这个目录下，你将可以完全使用之前的写法来对文件进行读写，不需要做任何变更和适配。但同时，刚才提到的那两个“好处”也就不存在了。这个目录中的文件会被计入到应用程序的占用空间当中，同时也会随着应用程序的卸载而被删除。</p><p>那么有些朋友可能会问了，我就是需要访问其他目录该怎么办呢？比如读取手机相册中的图片，或者向手机相册中添加一张图片。为此，Android系统针对文件类型进行了分类，图片、音频、视频这三类文件将可以通过MediaStore API来进行访问，而其他类型的文件则需要使用系统的文件选择器来进行访问。</p><p>另外，<strong>我们的应用程序向媒体库贡献的图片、音频或视频，将会自动拥有其读写权限</strong>，不需要额外申请READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限。<strong>而如果你要读取其他应用程序向媒体库贡献的图片、音频或视频，则必须要申请READ_EXTERNAL_STORAGE权限才行</strong>。WRITE_EXTERNAL_STORAGE权限将会在未来的Android版本中废弃。</p><p>好了，关于作用域存储的理论知识就先讲到这里，相信你已经对它有了一个基本的了解了，那么接下来我们就开始上手操作吧。</p><hr><p>还有一部分帖子也有这种说法，<strong>外卡（外部存储卷）， 只能访问所谓的共享文件夹，或者说公共目录。而且只能访问这些目录的多媒体文件(图片，视频，音频)。非多媒体文件只能通过系统文件选择器访问，无法像MediaStore一样列举了。</strong></p><img src="/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/image-20230606225153789.png" alt="image-20230606225153789" style="zoom:67%;"><h2 id="2-我一定要升级吗"><a href="#2-我一定要升级吗" class="headerlink" title="2.我一定要升级吗"></a>2.我一定要升级吗</h2><p>一定会有很多朋友关心这个问题，因为每当适配升级面临着需要更改大量代码的时候，大多数人的第一想法都是能不升就不升，或者能晚升就晚升。而在作用域存储这个功能上面，恭喜大家，暂时确实是可以不用升级的。</p><p>目前Android 10系统对于作用域存储适配的要求还不是那么严格，毕竟之前传统外置存储空间的用法实在是太广泛了。如果你的项目指定的targetSdkVersion低于29，那么即使不做任何作用域存储方面的适配，你的项目也可以成功运行到Android 10手机上。</p><p>而如果你的targetSdkVersion已经指定成了29，也没有关系，假如你还不想进行作用域存储的适配，只需要在AndroidManifest.xml中加入如下配置即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span> &gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">android:requestLegacyExternalStorage</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">...</span>&gt;</span><br>    ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这段配置表示，即使在Android 10系统上，仍然允许使用之前遗留的外置存储空间的用法来运行程序，这样就不用对代码进行任何修改了。当然，这只是一种权宜之计，在未来的Android系统版本中，这段配置随时都可能会失效（Android 11中已强制启用作用域存储，这段配置在Android 11当中已不再有效）。因此，我们还是非常有必要现在就来学习一下，到底该如何对作用域存储进行适配。</p><p>另外，本篇文章中演示的所有示例，都可以到ScopedStorageDemo这个开源库中找到其对应的源码。</p><p>开源库地址是：<a href="https://github.com/guolindev/ScopedStorageDemo">https://github.com/guolindev/ScopedStorageDemo</a></p><h2 id="3-获取相册中的图片"><a href="#3-获取相册中的图片" class="headerlink" title="3.获取相册中的图片"></a>3.获取相册中的图片</h2><p>首先来学习一下如何在作用域存储当中获取手机相册里的图片。注意，虽然本篇文章中我是以图片来举例的，但是获取音频、视频的用法也是基本相同的。</p><p>不同于过去可以直接获取到相册中图片的绝对路径，在作用域存储当中，我们只能借助MediaStore API获取到图片的Uri，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">val</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;$&#123;MediaStore.MediaColumns.DATE_ADDED&#125; desc&quot;</span>)<br><span class="hljs-keyword">if</span> (cursor != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">while</span> (cursor.moveToNext()) &#123;<br>        <span class="hljs-type">val</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID))<br>        <span class="hljs-type">val</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id)<br>        println(<span class="hljs-string">&quot;image uri is $uri&quot;</span>)<br>    &#125;<br>cursor.close()<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们先是通过ContentResolver获取到了相册中所有图片的id，然后再借助ContentUris将id拼装成一个完整的Uri对象。一张图片的Uri格式大致如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">content:<span class="hljs-comment">//media/external/images/media/321</span><br></code></pre></td></tr></table></figure><p>那么有些朋友可能会问了，获取到了Uri之后，我又该怎样将这张图片显示出来呢？这就有很多种办法了，比如使用Glide来加载图片，它本身就支持传入Uri对象来作为图片路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Glide.with(context).load(uri).into(imageView)<br></code></pre></td></tr></table></figure><p>而如果你没有使用Glide或其他图片加载框架，想在不借助第三方库的情况下直接将一个Uri对象解析成图片，可以使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">val</span> <span class="hljs-variable">fd</span> <span class="hljs-operator">=</span> contentResolver.openFileDescriptor(uri, <span class="hljs-string">&quot;r&quot;</span>)<br><span class="hljs-keyword">if</span> (fd != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">val</span> <span class="hljs-variable">bitmap</span> <span class="hljs-operator">=</span> BitmapFactory.decodeFileDescriptor(fd.fileDescriptor)<br>fd.close()<br>    imageView.setImageBitmap(bitmap)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们调用了ContentResolver的openFileDescriptor()方法，并传入Uri对象来打开文件句柄，然后再调用BitmapFactory的decodeFileDescriptor()方法将文件句柄解析成Bitmap对象即可。</p><img src="/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/20200409205348955.gif" alt="img" style="zoom: 80%;"><h2 id="4-将图片添加到相册"><a href="#4-将图片添加到相册" class="headerlink" title="4.将图片添加到相册"></a>4.将图片添加到相册</h2><p>将一张图片添加到手机相册要相对稍微复杂一点，因为不同系统版本之间的处理方式是不太一样的。</p><p>我们还是通过一段代码示例来直观地学习一下，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addBitmapToAlbum</span><span class="hljs-params">(bitmap: <span class="hljs-type">Bitmap</span>, displayName: <span class="hljs-type">String</span>, mimeType: <span class="hljs-type">String</span>, compressFormat: <span class="hljs-type">Bitmap</span>.<span class="hljs-type">CompressFormat</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> values = ContentValues()<br>    values.put(MediaStore.MediaColumns.DISPLAY_NAME, displayName)<br>    values.put(MediaStore.MediaColumns.MIME_TYPE, mimeType)<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;<br>        values.put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DCIM)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        values.put(MediaStore.MediaColumns.DATA, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;Environment.getExternalStorageDirectory().path&#125;</span>/<span class="hljs-subst">$&#123;Environment.DIRECTORY_DCIM&#125;</span>/<span class="hljs-variable">$displayName</span>&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">val</span> uri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values)<br>    <span class="hljs-keyword">if</span> (uri != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">val</span> outputStream = contentResolver.openOutputStream(uri)<br>        <span class="hljs-keyword">if</span> (outputStream != <span class="hljs-literal">null</span>) &#123;<br>            bitmap.compress(compressFormat, <span class="hljs-number">100</span>, outputStream)<br>outputStream.close()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码演示了如何将一个Bitmap对象添加到手机相册当中，我来简单解释一下。</p><p>想要将一张图片添加到手机相册，我们需要构建一个ContentValues对象，然后向这个对象中添加三个重要的数据。一个是DISPLAY_NAME，也就是图片显示的名称，一个是MIME_TYPE，也就是图片的mime类型。还有一个是图片存储的路径，不过这个值在Android 10和之前的系统版本中的处理方式不一样。Android 10中新增了一个RELATIVE_PATH常量，表示文件存储的相对路径，可选值有DIRECTORY_DCIM、DIRECTORY_PICTURES、DIRECTORY_MOVIES、DIRECTORY_MUSIC等，分别表示相册、图片、电影、音乐等目录。而在之前的系统版本中并没有RELATIVE_PATH，所以我们要使用DATA常量（已在Android 10中废弃），并拼装出一个文件存储的绝对路径才行。</p><p>有了ContentValues对象之后，接下来调用ContentResolver的insert()方法即可获得插入图片的Uri。但仅仅获得Uri仍然是不够的，我们还需要向该Uri所对应的图片写入数据才行。调用ContentResolver的openOutputStream()方法获得文件的输出流，然后将Bitmap对象写入到该输出流当中即可。</p><p>以上代码即可实现将Bitmap对象存储到手机相册当中，那么有些朋友可能会问了，如果我要存储的图片并不是Bitmap对象，而是一张网络上的图片，或者是当前应用关联目录下的图片该怎么办呢？</p><p>其实方法都是相似的，因为不管是网络上的图片还是关联目录下的图片，我们都能获取到它的输入流，只要不断读取输入流中的数据，然后写入到相册图片所对应的输出流当中就可以了，示例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">writeInputStreamToAlbum</span><span class="hljs-params">(inputStream: <span class="hljs-type">InputStream</span>, displayName: <span class="hljs-type">String</span>, mimeType: <span class="hljs-type">String</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> values = ContentValues()<br>    values.put(MediaStore.MediaColumns.DISPLAY_NAME, displayName)<br>    values.put(MediaStore.MediaColumns.MIME_TYPE, mimeType)<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;<br>        values.put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DCIM)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        values.put(MediaStore.MediaColumns.DATA, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;Environment.getExternalStorageDirectory().path&#125;</span>/<span class="hljs-subst">$&#123;Environment.DIRECTORY_DCIM&#125;</span>/<span class="hljs-variable">$displayName</span>&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">val</span> bis = BufferedInputStream(inputStream)<br>    <span class="hljs-keyword">val</span> uri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values)<br>    <span class="hljs-keyword">if</span> (uri != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">val</span> outputStream = contentResolver.openOutputStream(uri)<br>        <span class="hljs-keyword">if</span> (outputStream != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">val</span> bos = BufferedOutputStream(outputStream)<br>            <span class="hljs-keyword">val</span> buffer = ByteArray(<span class="hljs-number">1024</span>)<br>            <span class="hljs-keyword">var</span> bytes = bis.read(buffer)<br>            <span class="hljs-keyword">while</span> (bytes &gt;= <span class="hljs-number">0</span>) &#123;<br>                bos.write(buffer, <span class="hljs-number">0</span> , bytes)<br>                bos.flush()<br>                bytes = bis.read(buffer)<br>            &#125;<br>            bos.close()<br>        &#125;<br>    &#125;<br>    bis.close()<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中只是将输入流和输出流的部分重新编写了一下，其他部分和之前存储Bitmap的代码是完全一致的，相信很好理解。</p><img src="/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/20200409205454790.gif" alt="img" style="zoom:80%;"><h2 id="5-下载文件到Download目录"><a href="#5-下载文件到Download目录" class="headerlink" title="5.下载文件到Download目录"></a>5.下载文件到Download目录</h2><p>执行文件下载操作是一个很常见的场景，比如说下载pdf、doc文件，或者下载APK安装包等等。在过去，这些文件我们通常都会下载到Download目录，这是一个专门用于存放下载文件的目录。而从Android 10开始，我们已经不能以绝对路径的方式访问外置存储空间了，所以文件下载功能也会受到影响。</p><p>那么该如何解决呢？主要有以下两种方式。</p><p>第一种同时也是最简单的一种方式，就是更改文件的下载目录。将文件下载到应用程序的关联目录下，这样不用修改任何代码就可以让程序在Android 10系统上正常工作。但使用这种方式，你需要知道，下载的文件会被计入到应用程序的占用空间当中，同时如果应用程序被卸载了，该文件也会一同被删除。另外，存放在关联目录下的文件只能被当前的应用程序所访问，其他程序是没有读取权限的。</p><p>以上几个限制条件如果不能满足你的需求，那么就只能使用第二种方式，对Android 10系统进行代码适配，仍然将文件下载到Download目录下。</p><p>其实将文件下载到Download目录，和向相册中添加一张图片的过程是差不多的，Android 10在MediaStore中新增了一种Downloads集合，专门用于执行文件下载操作。但由于每个项目下载功能的实现都各不相同，有些项目的下载实现还十分复杂，因此怎么将以下的示例代码融合到你的项目当中是你自己需要思考的问题。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">downloadFile</span><span class="hljs-params">(fileUrl: <span class="hljs-type">String</span>, fileName: <span class="hljs-type">String</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.Q) &#123;<br>        Toast.makeText(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;You must use device running Android 10 or higher&quot;</span>, Toast.LENGTH_SHORT).show()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    thread &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">val</span> url = URL(fileUrl)<br><span class="hljs-keyword">val</span> connection = url.openConnection() <span class="hljs-keyword">as</span> HttpURLConnection<br>connection.requestMethod = <span class="hljs-string">&quot;GET&quot;</span><br>connection.connectTimeout = <span class="hljs-number">8000</span><br>connection.readTimeout = <span class="hljs-number">8000</span><br><span class="hljs-keyword">val</span> inputStream = connection.inputStream<br><span class="hljs-keyword">val</span> bis = BufferedInputStream(inputStream)<br><span class="hljs-keyword">val</span> values = ContentValues()<br>values.put(MediaStore.MediaColumns.DISPLAY_NAME, fileName)<br>values.put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DOWNLOADS)<br><span class="hljs-keyword">val</span> uri = contentResolver.insert(MediaStore.Downloads.EXTERNAL_CONTENT_URI, values)<br><span class="hljs-keyword">if</span> (uri != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">val</span> outputStream = contentResolver.openOutputStream(uri)<br><span class="hljs-keyword">if</span> (outputStream != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">val</span> bos = BufferedOutputStream(outputStream)<br><span class="hljs-keyword">val</span> buffer = ByteArray(<span class="hljs-number">1024</span>)<br><span class="hljs-keyword">var</span> bytes = bis.read(buffer)<br><span class="hljs-keyword">while</span> (bytes &gt;= <span class="hljs-number">0</span>) &#123;<br>bos.write(buffer, <span class="hljs-number">0</span> , bytes)<br>bos.flush()<br>bytes = bis.read(buffer)<br>&#125;<br>bos.close()<br>&#125;<br>&#125;<br>bis.close()<br>&#125; <span class="hljs-keyword">catch</span>(e: Exception) &#123;<br>e.printStackTrace()<br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码总体来讲还是比较好理解的，主要就是添加了一些Http请求的代码，并将MediaStore.Images.Media改成了MediaStore.Downloads，其他部分几乎是没有变化的，我就不再多加解释了。</p><p>注意，上述代码只能在Android 10或更高的系统版本上运行，因为MediaStore.Downloads是Android 10中新增的API。至于Android 9及以下的系统版本，请你仍然使用之前的代码来进行文件下载。</p><img src="/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/20200409205714266.gif" alt="img" style="zoom:80%;"><h2 id="6-使用文件选择器"><a href="#6-使用文件选择器" class="headerlink" title="6.使用文件选择器"></a>6.使用文件选择器</h2><p>如果我们要读取SD卡上非图片、音频、视频类的文件，比如说打开一个PDF文件，这个时候就不能再使用MediaStore API了，而是要使用文件选择器。</p><p>但是，我们不能再像之前的写法那样，自己写一个文件浏览器，然后从中选取文件，而是必须要使用手机系统中内置的文件选择器。示例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> PICK_FILE = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pickFile</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT)<br>    intent.addCategory(Intent.CATEGORY_OPENABLE)<br>    intent.type = <span class="hljs-string">&quot;*/*&quot;</span><br>    startActivityForResult(intent, PICK_FILE)<br>&#125;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(requestCode: <span class="hljs-type">Int</span>, resultCode: <span class="hljs-type">Int</span>, <span class="hljs-keyword">data</span>: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="hljs-keyword">data</span>)<br>    <span class="hljs-keyword">when</span> (requestCode) &#123;<br>        PICK_FILE -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (resultCode == Activity.RESULT_OK &amp;&amp; <span class="hljs-keyword">data</span> != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">val</span> uri = <span class="hljs-keyword">data</span>.<span class="hljs-keyword">data</span><br>                <span class="hljs-keyword">if</span> (uri != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">val</span> inputStream = contentResolver.openInputStream(uri)<br><span class="hljs-comment">// 执行文件读取操作</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里在pickFile()方法当中通过Intent去启动系统的文件选择器，注意Intent的action和category都是固定不变的。而type属性可以用于对文件类型进行过滤，比如指定成image&#x2F;就可以只显示图片类型的文件，这里写成&#x2F;*表示显示所有类型的文件。注意type属性必须要指定，否则会产生崩溃。</p><p>然后在onActivityResult()方法当中，我们就可以获取到用户选中文件的Uri，之后通过ContentResolver打开文件输入流来进行读取就可以了。</p><img src="/2023/06/06/%E5%AE%89%E5%8D%93%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8/20200409205805627.gif" alt="img" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android加密之文件级加密</title>
    <link href="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/"/>
    <url>/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Android加密之文件级加密"><a href="#Android加密之文件级加密" class="headerlink" title="Android加密之文件级加密"></a>Android加密之文件级加密</h1><blockquote><p>声明：本文整理自</p><ul><li><a href="https://blog.csdn.net/myfriend0/article/details/77094890/?spm=1001.2014.3001.5506">https://blog.csdn.net/myfriend0/article/details/77094890/?spm=1001.2014.3001.5506</a></li><li><a href="https://blog.csdn.net/cs_tech/article/details/127579028">https://blog.csdn.net/cs_tech/article/details/127579028</a></li></ul><p>仅作为自己学习备忘使用，如有侵权，联系删除！再次感谢2位前辈精彩的博客！</p></blockquote><h2 id="1-什么是文件级加密"><a href="#1-什么是文件级加密" class="headerlink" title="1.什么是文件级加密"></a>1.什么是文件级加密</h2><p>Android 7.0 及更高版本支持文件级加密 (FBE)。采用文件级加密时，可以使用不同的密钥对不同的文件进行加密，并且可以对这些文件进行单独解密。</p><h2 id="2-全盘加密和文件级加密的区别"><a href="#2-全盘加密和文件级加密的区别" class="headerlink" title="2.全盘加密和文件级加密的区别"></a>2.全盘加密和文件级加密的区别</h2><p>借助文件级加密，Android 7.0 中引入了一项称为直接启动的新功能。该功能处于启用状态时，已加密设备在启动后将直接进入锁定屏幕。之前，在使用全盘加密 (FDE) 的已加密设备上，用户在访问任何数据之前都需要先提供凭据，从而导致手机无法执行除最基本操作之外的所有其他操作。例如，闹钟无法运行，无障碍服务不可用，手机无法接电话，而只能进行基本的紧急拨号操作。</p><h2 id="3-文件级加密概述"><a href="#3-文件级加密概述" class="headerlink" title="3.文件级加密概述"></a>3.文件级加密概述</h2><p>引入文件级加密 (FBE) 和新 API 后，便可以将应用设为加密感知型应用，这样一来，它们将能够在受限环境中运行。这些应用将可以在用户提供凭据之前运行，同时系统仍能保护私密用户信息。</p><p>在启用了 FBE 的设备上，每位用户均有两个可供应用使用的存储位置：</p><ul><li>🥇凭据加密 (CE) 存储空间：<strong>这是默认存储位置，只有在用户解锁设备后才可用。</strong></li><li>🥈设备加密 (DE) 存储空间：<strong>在直接启动模式期间以及用户解锁设备后均可用。</strong></li></ul><p>这种区分能够使工作资料更加安全，因为这样一来，加密不再只基于启动时密码，从而能够同时保护多位用户。</p><p>Direct Boot API 允许加密感知型应用访问上述每个区域。应用生命周期会发生一些变化，以便在用户的 CE 存储空间因用户在锁定屏幕上首次输入凭据而解锁时，或者在工作资料提供工作挑战时，通知应用。无论是否实现了 FBE，运行 Android 7.0 的设备都必须要支持这些新的 API 和生命周期。不过，如果没有 FBE，DE 和 CE 存储空间将始终处于解锁状态。</p><h3 id="3-1-启动文件级加密"><a href="#3-1-启动文件级加密" class="headerlink" title="3.1 启动文件级加密"></a>3.1 启动文件级加密</h3><p>如需在设备上启用文件级加密 (FBE)，就必须在内部存储设备 (userdata) 上启用 FBE。这也会自动为可合并的存储设备启用 FBE；但是，如有必要，可以覆盖可合并的存储设备的加密格式。内部存储设备通过将 fileencryption&#x3D;contents_encryption_mode[:filenames_encryption_mode[:flags]] 选项<strong>添加到 userdata 的 fstab 行 fs_mgr_flags 列，可启用 FBE</strong>。此选项用于定义内部存储设备的加密格式。它最多包含三个以英文冒号分隔的参数：</p><p>Android10：ext4 fileencryption&#x3D;ice,</p><p>Android11：f2fs fileencryption&#x3D;aes-256-xts:</p><ul><li>contents_encryption_mode 参数指定将哪种加密算法用于加密文件内容，可为 aes-256-xts 或 adiantum</li><li>filenames_encryption_mode 参数指定将哪种加密算法用于加密文件名，可为 aes-256-cts、aes-256-heh 或 adiantum。如果不指定，则当 contents_encryption_mode 为 aes-256-xts 时该参数默认为 aes-256-cts，当 contents_encryption_mode 为 adiantum 时该参数默认为 adiantum。</li><li>Android 11 中新增的 flags 参数是以 + 字符分隔的一个标记列表。支持以下标记：<ul><li>v1 标记用于选择第 1 版加密政策；v2 标记用于选择第 2 版加密政策。第 2 版加密政策使用更安全、更灵活的密钥派生函数。如果设备搭载的是 Android 11 或更高版本（由 ro.product.first_api_level 确定），则默认选择第 2 版；如果设备搭载的是 Android 10 或更低版本，则默认选择第 1 </li><li>inlinecrypt_optimized 标记用于选择针对无法高效处理大量密钥的内嵌加密硬件进行了优化的加密格式。其具体做法是仅为每个 CE 或 DE 密钥派生一个文件内容加密密钥，而不是为每个文件派生一个。IV（初始化向量）的生成也会相应地进行调整。</li><li>emmc_optimized 标记与 inlinecrypt_optimized 类似，但它还选择了将 IV 限制为 32 位的 IV 生成方法。此标记应仅在符合 JEDEC eMMC v5.2 规范的内嵌加密硬件上使用，因此仅支持 32 位 IV。在其他内嵌加密硬件上，请改用 inlinecrypt_optimized。此标记一律不得在基于 UFS 的存储设备上使用；UFS 规范允许使用 64 位 IV。</li><li>wrappedkey_v0 标记允许使用硬件封装的密钥。启用该标记后，FBE 密钥就不会由软件生成，而是由 Keymaster 使用 STORAGE_KEY 标签生成。然后，实际向内核提供的每个 FBE 密钥都是从 Keymaster 导出的 STORAGE_KEY 密钥，这会导致每次启动时都使用临时密钥对密钥进行封装。然后，内核会将封装的密钥直接提供给内嵌加密硬件。正确实现后，系统内存中永远不会显示解封的密钥，并且已破解的封装密钥在重新启动后将无法使用。此标记需要硬件支持、对 STORAGE_KEY 的 Keymaster 支持、内核驱动程序支持、inlinecrypt 装载选项以及 inlinecrypt_optimized 标记或 emmc_optimized 标记。</li></ul></li></ul><p>如果不使用内嵌加密硬件，则对于大多数设备推荐设置为 fileencryption&#x3D;aes-256-xts。如果使用内嵌加密硬件，则对于大多数设备推荐设置为 fileencryption&#x3D;aes-256-xts:aes-256-cts:inlinecrypt_optimized。在没有采用任何形式的 AES 加速的设备上，可以设置 fileencryption&#x3D;adiantum，从而用 Adiantum代替 AES。</p><p>在搭载 Android 10 或更低版本的设备上，也可以使用 fileencryption&#x3D;ice 来指定使用 FSCRYPT_MODE_PRIVATE 文件内容加密模式。Android 通用内核未实现该模式，但供应商可使用自定义内核补丁程序实现该模式。该模式生成的磁盘格式因供应商而异。在搭载 Android 11 或更高版本的设备上，不允许再使用该模式，而必须使用标准加密格式。</p><p>设备制造商还可以执行以下手动测试。在启用了 FBE 的设备上进行以下手动测试：</p><ul><li>检查 ro.crypto.state 是否存在<ul><li>确认 ro.crypto.state 是否已加密</li></ul></li><li>检查 ro.crypto.type 是否存在<ul><li>确认 ro.crypto.type 是否已设置为 file</li></ul></li></ul><h3 id="3-2-直接启动"><a href="#3-2-直接启动" class="headerlink" title="3.2 直接启动"></a>3.2 直接启动</h3><blockquote><p>安卓官网：<a href="https://developer.android.google.cn/training/articles/direct-boot?hl=zh-cn">https://developer.android.google.cn/training/articles/direct-boot?hl=zh-cn</a></p></blockquote><p>当设备已开机但用户尚未解锁设备时，Android 7.0 将在安全的“直接启动”模式下运行。为支持此模式，系统为数据提供了两个存储位置：</p><ul><li>凭据加密存储，这是默认存储位置，仅在用户解锁设备后可用。</li><li>设备加密存储，该存储位置在“直接启动”模式下和用户解锁设备后均可使用。</li></ul><p>默认情况下，应用不会在“直接启动”模式下运行。如果您的应用需要在“直接启动”模式下执行操作，您可以注册应在此模式下运行的应用组件。需要在“直接启动”模式下运行的一些常见应用用例包括：</p><ul><li>已安排通知的应用，如闹钟应用。</li><li>提供重要用户通知的应用，如短信应用。</li><li>提供无障碍服务的应用，如 Talkback。</li></ul><p>如果应用在“直接启动”模式下运行时需要访问数据，请使用DE设备加密存储。设备加密存储包含使用密钥加密的数据，该密钥只有在设备成功执行启动时验证后才可用。</p><p>对于应使用与用户凭据（如 PIN 码或密码）关联的密钥加密的数据，请使用CE凭据加密存储。凭据加密存储仅在用户成功解锁设备后可用，直到用户再次重启设备。如果用户在解锁设备后启用锁定屏幕，则不会锁定凭据加密存储。</p><p><strong>（1）请求在“直接启动”模式下运行</strong></p><p>应用必须先向系统注册其组件，然后才能在“直接启动”模式下运行或访问设备加密存储。应用通过将组件标记为加密感知来向系统注册。如需将您的组件标记为加密感知，请在清单中将 <code>android:directBootAware</code> 属性设为 true。</p><p>当设备重启后，加密感知组件可以注册以接收来自系统的 <code>ACTION_LOCKED_BOOT_COMPLETED</code> 广播消息。此时，设备加密存储可用，您的组件可以执行需要在“直接启动”模式下运行的任务，例如触发已设定的闹铃。</p><p>以下代码段示例说明了如何在应用清单中将 <code>BroadcastReceiver</code> 注册为加密感知并为 <code>ACTION_LOCKED_BOOT_COMPLETED</code> 添加 intent 过滤器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:directBootAware</span>=<span class="hljs-string">&quot;true&quot;</span> &gt;</span><br>    ...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.LOCKED_BOOT_COMPLETED&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br>    <br></code></pre></td></tr></table></figure><p>在用户解锁设备后，所有组件均可访问设备加密存储和凭据加密存储。</p><p><strong>（2）接收用户解锁通知</strong></p><p>当用户在重启后解锁设备时，应用可以切换至访问凭据加密CE存储，并使用依赖用户凭据的常规系统服务。</p><p>为了在重启后用户解锁设备时收到通知，请从正在运行的组件注册 <code>BroadcastReceiver</code> 以监听解锁通知消息。在用户重启后解锁设备时：</p><ul><li>如果应用具有需要立即获得通知的前台进程，请监听 <code>ACTION_USER_UNLOCKED</code> 消息。</li><li>如果应用仅使用可以对延迟通知执行操作的后台进程，请监听 <code>ACTION_BOOT_COMPLETED</code> 消息。</li></ul><p>您可以通过调用 <code>UserManager.isUserUnlocked()</code> 直接查询用户是否已解锁设备。</p><h3 id="3-3-设计概览"><a href="#3-3-设计概览" class="headerlink" title="3.3 设计概览"></a>3.3 设计概览</h3><blockquote><p>采用文件级加密时：</p><ul><li>可以使用不同的密钥对不同的文件进行加密，也可以对加密文件单独解密</li><li>可以有的放矢，没有安全要求的文件可以不加密</li><li>支持多用户，不同用户使用不同的密钥</li></ul></blockquote><p>基于这些特性，Google 对 Android 用户数据分区的目录做了安全等级划分，一些非用户隐私数据可以在设备启动后直接可以访问，解决了 FDE（Full Disk Encryption）的弊端。</p><p>在 FBE 的设计中，根据文件内容的私密性，Google 把用户数据分区的存储位置划分安全等级，包括下几类：</p><p>①. 不加密的存储位置</p><ul><li>Unencrypted</li></ul><p>②. 加密的存储位置 </p><ul><li>与用户无关的系统设备存储位置<ul><li>System Device Encrypted (DE) Storage ：一般存储一些设备相关，Framework 相关等用户无关的数据。</li></ul></li><li>与用户相关的存储位置 ：<ul><li>Device Encrypted (DE) Storage ：与用户相关的数据，安全性要求一般，在设备启动后以及用户解锁设备后都可以直接访问。</li><li>Credential Encrypted (CE) Storage ：与用户相关的数据，安全性等级高，如果用户设置了锁屏密码，必须在用户解锁设备后这些存储位置的数据才可用。</li></ul></li></ul><img src="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/image-20230604201431654.png" alt="image-20230604201431654" style="zoom: 67%;"><p>需要注意的点：</p><p>①. 从 User.x DE&#x2F;CE 以及对应文件夹的命名可知，FBE 天然支持多用户 ：</p><ul><li>每个用户都拥有2个单独的加密密钥： DE Master Key 和 CE Master Key。</li></ul><p>②. 当用户未设置锁屏密码时：</p><ul><li>DE 密钥和 CE 密钥安全等级一致，即开机过程中，APP 就可以直接访问 Device Encrypted (DE) Storage 和 Credential Encrypted (CE) Storage。</li></ul><p>③. 当用户设置锁屏密码时：</p><ul><li>只有校验用户密码成功后，用户的 CE 密钥才可用。即用户输入锁屏密码解锁设备后，APP 才可访问 Credential Encrypted (CE) Storage，同时访问到文件的明文数据。</li><li>用户 0 由于是特殊用户，必须先登录设备（设备启动后会自动登录用户0）；<br>不同存储位置的加解密顺序存在依赖关系：<ul><li>解密 System DE Storage 所需的密钥信息被存储在未加密目录 &#x2F;data&#x2F;unencrypted；</li><li>解密 User Device Encrypted (DE) Storage 和 User Credential Encrypted (CE) Storage 所需的密钥信息被存储在 System DE Storage 路径 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys；</li></ul></li></ul><p>🎈 这里再次重复磁盘数据加密解决的问题，对于后面理解 FBE 的设计很重要。</p><blockquote><p>解决设备被盗，丢失或者送修等机器不在用户手中的情况下，依然保护用户的隐私数据不被窃取。<strong>但是对于用户正常使用过程中，黑客通过提权等手段窃取数据的行为，这些技术基本无能为力，目前主要还是靠传统的 DAC（user、group、others） 和 MAC（selinux）</strong>。</p></blockquote><h3 id="3-4-秘钥管理"><a href="#3-4-秘钥管理" class="headerlink" title="3.4 秘钥管理"></a>3.4 秘钥管理</h3><p>①.对不同安全等级的加密存储位置，至少涉及 3 个密钥，包括：</p><ul><li>System DE key</li><li>User DE key for user 0</li><li>User CE key for user 0</li></ul><p>②. 密钥的安全管理，包括：</p><ul><li>在安全的内核密钥环（kernel keyring）和 ARM TZ 环境中管理密钥</li><li>密钥不允许出现在 HLOS</li><li>每个文件及其名称都应使用不同且唯一的密钥进行加密</li><li>根据 HLOS 请求，创建，更新和失效密钥等（支持远程擦除密钥）</li><li>……</li></ul><h3 id="3-5-密钥存储及其保护措施"><a href="#3-5-密钥存储及其保护措施" class="headerlink" title="3.5 密钥存储及其保护措施"></a>3.5 密钥存储及其保护措施</h3><blockquote><p>2023&#x2F;06&#x2F;19发现好文：<a href="https://blog.csdn.net/csdn_liqian/article/details/129362100">https://blog.csdn.net/csdn_liqian/article/details/129362100</a></p></blockquote><p>系统不会存储 per-boot key ，除此之外其他所有的 FBE key 将被<code>vold</code> 管理，并且存储在磁盘上。FBE key存储的位置如下表所示：</p><img src="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/image-20230619220158827.png" alt="image-20230619220158827" style="zoom: 80%;"><p>vold对所有的FBE key都有一层加密。</p><p>除了用于内部存储的 CE 密钥之外，每个密钥都由自己的 Keystore key（该密钥不在 TEE 外部公开）和 AES-256-GCM 算法来加密。这确保FBE key无法被解锁，除非可信操作系统已启动（就像开机校验强制执行，验证下一阶段的完整性和真实性）。</p><p>此外，Keystore key 需要设置抗回滚，以便 Keymaster 在支持抗回滚的设备上也能安全地删除 FBE 密钥。抗回滚：一旦使用 deleteKey 或者 deleteAllKeys 来删除密钥，安全硬件将保证该密钥不再可用，即删除的密钥无法恢复。</p><p>为了在抗回滚不可用时能够尽可能地回退，16384 个随机字节的 SHA-512 哈希值存储在与密钥一起存储的 secdiscardable 文件中，作为 Keystore key中的app ID tag。只有将这些字节全部恢复，才能恢复 FBE key。</p><p>用于内部存储的 CE key 将获得更高级别的保护，以确保在未获取用户的LSKF (LSKF：Lock Screen Knowledge Factor，即PIN 码 personal identification、图案pattern 或 口令password）、安全密码重置令牌（secure passcode reset token）或在重启恢复操作后的客户端密钥及服务器端密钥的情况下，CE key 无法被解锁。只允许为工作资料和完全受管设备（for work profiles and fully managed devices）创建密码重置令牌。</p><p>为此，vold 用AES-256-GCM算法加密用于内部存储的CE key，其加密密钥源自用户合成的口令。该合成口令是为每个用户随机生成的不可变的高级无序的（high-entropy，高熵）加密的密码。system_server 中的 LockSettingsService 用于管理合成口令及其保护方式。</p><p>用 LSKF 保护合成口令时，LockSettingsService 首先会扩展 LSKF（可以通过 scrypt 传递 LSKF，目标时间约为 25 毫秒且内存用量约为 2 MiB）。</p><p>由于 LSKF 通常较短，因此该步骤通常无法提供太多安全性。主要的安全保障是SE (SE： Secure Element安全元素) 或者由 TEE 强制执行的速率限制。</p><p><strong>（1）如果设备有SE， LockSettingsService 使用 Weaver HAL 将经过扩展的 LSKF 映射到存储在 SE 中的高级无序随机密码（secret）。</strong><br>然后，LockSettingsService 将对合成口令进行双重加密：</p><ul><li>第一次加密：使用扩展的 LSKF 和 Weaver secret派生软件密钥；</li><li>第二次加密：使用未经身份验证绑定(non-auth-bound)的 Keystore key。</li></ul><p>这样即可对 LSKF 猜测行为施加 SE 强制速率限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Weaver HAL代码路径: platform/hardware/interfaces/refs/heads/master/./weaver/<span class="hljs-number">1.0</span>/IWeaver.hal<br></code></pre></td></tr></table></figure><p><strong>（2）如果设备没有 SE，则 LockSettingsService 使用扩展的 LSKF 作为 Gatekeeper 口令。</strong></p><p>然后，LockSettingsService 将对合成口令进行双重加密：</p><ul><li>第一次加密：使用扩展的 LSKF 和 secdiscardable 文件的哈希值派生软件密钥；</li><li>第二次加密：使用经过身份验证绑定(auth-bound)到Gatekeeper的 Keystore key。</li></ul><p>这样即可对 LSKF 猜测行为施加 SE 强制速率限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Gatekeeper：<br><span class="hljs-built_in">TEE</span>(Trusted Execution Environment，可信执行环境)中，使用硬件支持的Keystore key通过HMAC注册并验证设备的图案或者口令（用TEE派生的共享密钥来进行身份验证）。<br>在连续数次验证失败时会限制验证尝试，拒绝为请求提供服务。<br></code></pre></td></tr></table></figure><p>当LSKF改变时，<code>LockSettingsService</code> 会删除所有旧的LSKF以及合成口令绑定的相关信息。在支持 Weaver 或者抗回滚的 Keystore key 的设备上，这样做可以保证安全地删除旧绑定。因此，即使用户没有设置 LSKF，系统也会进行上述保护措施。</p><h2 id="4-HLOS软件流程"><a href="#4-HLOS软件流程" class="headerlink" title="4.HLOS软件流程"></a>4.HLOS软件流程</h2><h3 id="4-1-Native软件流程"><a href="#4-1-Native软件流程" class="headerlink" title="4.1 Native软件流程"></a>4.1 Native软件流程</h3><p>Android 在 init rc 中 触发 FBE 软件流程：</p><blockquote><ul><li>在启动过程中，准备 FBE Master key，设置和校验各加密存储位置的加密策略（Encryption Policy）。</li><li>真正数据加密和解密是发生在文件 I&#x2F;O 时，而加密和解密所需的信息来源于文件的 Encryption Policy。Encryption Policy 包括：<ul><li>使用哪个 Master Key 加密；</li><li>文件数据的加密算法；</li><li>文件名的加密算法；</li></ul></li></ul></blockquote><img src="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/e09ee7d3490e49b1bd615011c7ecfc77.png" alt="img" style="zoom:80%;"><img src="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/450367269c4d4d3781406d3411f3e6e4.png" alt="img" style="zoom: 50%;"><p><strong>① installkey &#x2F;data</strong></p><p>软件流程进入 Vold 函数 fscrypt_initialize_systemwide_keys()。</p><p>设备第一次启动时：</p><ul><li>创建 System DE Master Key 和生成 System DE Encryption Policy；</li><li>把 System DE Encryption Policy 保存到文件  &#x2F;data&#x2F;unencrypted&#x2F;ref；</li></ul><p>后续每次启动时：</p><ul><li>加载 System DE Master Key；</li></ul><p><strong>② mkdir &lt;system de storage&gt;</strong></p><ul><li>如果 System DE Storage 不存在，创建并为文件夹设置 System DE Encryption Policy；</li><li>如果 System DE Storage 已经存在，则校验 System DE  Encryption Policy；<br>校验失败会强制设备启动到 recovery ，格式化 userdata 分区；</li></ul><p><strong>③ init_user0</strong></p><p>软件流程进入 Vold 函数 fscrypt_init_user0()。</p><p>设备第一次启动时：</p><ul><li>创建 User 0 DE Master Key 和生成 User 0 DE Encryption Policy；</li><li>创建 User 0 CE  Master Key 和生成 User 0 CE Encryption Policy；</li><li>创建 User 0 DE Storage，并为这些文件夹设置 User 0 DE Encryption Policy</li></ul><p>后续每次启动时：</p><ul><li>加载 User 0 DE Master Key；</li><li>准备 User 0 DE Storage，并校验文件夹 Encryption Policy；<ul><li>校验失败，不会强制格式化 userdata ，但是用户数据将无法使用，可能无法开机。</li></ul></li></ul><h3 id="4-2-Framework软件流程"><a href="#4-2-Framework软件流程" class="headerlink" title="4.2 Framework软件流程"></a>4.2 Framework软件流程</h3><p>可以发现在 Native 软件流程中， init_user0 中关于 User 0 CE 的流程相比 User 0 DE 存在缺失，主要包括：</p><p><strong>(1) 第一次启动时， User 0 CE Storage 是什么时候创建的呢？</strong></p><p>设备继续启动，由框架 UserController 通过 binder 触发 Vold 创建 User 0 CE Storage 和为相关文件夹设置 User 0 CE Encryption Policy</p><p><strong>(2) 后续每次启动时，加载 User 0 DE Master Key、准备 User 0 DE Storage 、校验 User 0 CE Encryption Policy 是什么时候发生？</strong></p><p>① 用户未设置锁屏密码时，设备启动 completed 后，ActivityManagerService 层层触发 Vold 完成这些任务；</p><img src="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/7227b1872aed453187f68be2bbd5c74e.png" alt="img" style="zoom:50%;"><p> <strong>②</strong> 用户设置锁屏密码时，用户输入密码并校验通过后，LockSettingsService 层层触发 Vold 完成这些任务；</p><img src="/2023/06/04/Android%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86/7575d136392e43b2be21ae3b9494fb43.png" alt="img" style="zoom: 50%;"><p>从图中可以看到，无论是设置用户密码，软件流程又回到了 Vold：</p><ul><li>fscrypt_unlock_user_key ： 加载 User 0 CE Master Key</li><li>fscrypt_prepare_user_storage：准备 User 0 CE Storage，并校验文件夹 Encryption Policy；</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓12多用户机制</title>
    <link href="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓12多用户机制"><a href="#安卓12多用户机制" class="headerlink" title="安卓12多用户机制"></a>安卓12多用户机制</h1><h2 id="1-CPP中的基类指针指向子类对象"><a href="#1-CPP中的基类指针指向子类对象" class="headerlink" title="1.CPP中的基类指针指向子类对象"></a>1.CPP中的基类指针指向子类对象</h2><p>☃️ 基类指针指向子类对象时：调用的是基类的函数，因为子类的函数被隐藏。 但是当基类函数有virtual关键字修饰的时候调用的是子类的函数【详细的可以了解一下<a href="https://zhuanlan.zhihu.com/p/98776075">虚函数表</a>】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> age) &#123;<br>        mAge = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printName</span><span class="hljs-params">(string name)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base -&gt; name = &quot;</span> &lt;&lt; name &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">doMount</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doMount</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> mAge;<br><br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Child</span>():<span class="hljs-built_in">Base</span>(<span class="hljs-number">24</span>)&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doMount</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;child do Mount&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> child = <span class="hljs-built_in">shared_ptr</span>&lt;Base&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Child</span>());<br><br>    child-&gt;<span class="hljs-built_in">printName</span>(<span class="hljs-string">&quot;amxixixi&quot;</span>);<br>    child-&gt;<span class="hljs-built_in">mount</span>();<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230607223135870.png" alt="image-20230607223135870" style="zoom:80%;"><h2 id="2-创建用户"><a href="#2-创建用户" class="headerlink" title="2.创建用户"></a>2.创建用户</h2><p>多用户的创建流程主要在UserManagerService.createUserInternalUnchecked()方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> UserInfo <span class="hljs-title function_">createUserInternalUnchecked</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String name,</span><br><span class="hljs-params">                                             <span class="hljs-meta">@NonNull</span> String userType, <span class="hljs-meta">@UserInfoFlag</span> <span class="hljs-type">int</span> flags, <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> parentId,</span><br><span class="hljs-params">                                             <span class="hljs-type">boolean</span> preCreate, <span class="hljs-meta">@Nullable</span> String[] disallowedPackages,</span><br><span class="hljs-params">                                             <span class="hljs-meta">@Nullable</span> Object token)</span> <span class="hljs-keyword">throws</span> UserManager.CheckedUserOperationException &#123;<br>    <span class="hljs-comment">// 获取下一个可用的用户ID，从10开始</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">nextProbableUserId</span> <span class="hljs-operator">=</span> getNextAvailableId();<br>    <span class="hljs-type">UserInfo</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        newUser = createUserInternalUncheckedNoTracing(name, userType, flags, parentId,<br>                                                       preCreate, disallowedPackages, t, token);<br>        <span class="hljs-keyword">return</span> newUser;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用createUserInternalUncheckedNoTracing</p><blockquote><p>🍃<strong>这里我们不讨论带有parentId类型的用户创建，离我本人的业务比较偏离</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// parentId: UserHandle.USER_NULL = -1000</span><br><span class="hljs-comment">// preCreate: false</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> UserInfo <span class="hljs-title">createUserInternalUncheckedNoTracing</span><span class="hljs-params">(@Nullable String name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                      @NonNull String userType, @UserInfoFlag <span class="hljs-type">int</span> flags, @UserIdInt <span class="hljs-type">int</span> parentId,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                      boolean preCreate, @Nullable String[] disallowedPackages,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                      @NonNull TimingsTraceAndSlog t, @Nullable Object token)</span></span><br><span class="hljs-function">    throws UserManager.CheckedUserOperationException </span>&#123;<br>    <br>    flags |= userTypeDetails.<span class="hljs-built_in">getDefaultUserInfoFlags</span>();<br><br>    <span class="hljs-built_in">synchronized</span> (mUsersLock) &#123;<br>        <span class="hljs-keyword">if</span> (mForceEphemeralUsers) &#123;<br>            flags |= UserInfo.FLAG_EPHEMERAL;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Try to use a pre-created user (if available).</span><br>    <span class="hljs-keyword">if</span> (!preCreate &amp;&amp; parentId &lt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">isUserTypeEligibleForPreCreation</span>(userTypeDetails)) &#123;<br>        <span class="hljs-keyword">final</span> UserInfo preCreatedUser = <span class="hljs-built_in">convertPreCreatedUserIfPossible</span>(userType, flags, name,token);<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> boolean isProfile = userTypeDetails.<span class="hljs-built_in">isProfile</span>();   <span class="hljs-comment">// 创建的用户是不是Profile</span><br>    <span class="hljs-keyword">final</span> boolean isGuest = UserManager.<span class="hljs-built_in">isUserTypeGuest</span>(userType);    <span class="hljs-comment">// 创建的是不是访客用户</span><br>    <span class="hljs-keyword">final</span> boolean isRestricted = UserManager.<span class="hljs-built_in">isUserTypeRestricted</span>(userType);  <span class="hljs-comment">// 创建的用户类型是不是被限制</span><br>    <span class="hljs-keyword">final</span> boolean isDemo = UserManager.<span class="hljs-built_in">isUserTypeDemo</span>(userType);  <span class="hljs-comment">// 创建的用户是不是一个Demo</span><br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ident = Binder.<span class="hljs-built_in">clearCallingIdentity</span>();<br>    UserInfo userInfo;<br>    UserData userData;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> userId;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">synchronized</span> (mPackagesLock) &#123;<br>            UserData parent = null;<br><br>            userId = <span class="hljs-built_in">getNextAvailableId</span>();  <span class="hljs-comment">// 获取下一个即将使用的UserId</span><br>            Environment.<span class="hljs-built_in">getUserSystemDirectory</span>(userId).<span class="hljs-built_in">mkdirs</span>();  <span class="hljs-comment">// 创建文件夹: /data/system/users/&lt;user_id&gt;</span><br><br>            <span class="hljs-built_in">synchronized</span> (mUsersLock) &#123;<br>                <span class="hljs-comment">// 实例化UserInfo并进行初始化赋值</span><br>                userInfo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">UserInfo</span>(userId, name, null, flags, userType);<br>                userInfo.serialNumber = mNextSerialNumber++; <span class="hljs-comment">// 串行号，根据经验来看等于UserId</span><br>                userInfo.creationTime = <span class="hljs-built_in">getCreationTime</span>();<br>                userInfo.partial = <span class="hljs-literal">true</span>;<br>                userInfo.preCreated = preCreate;<br>                userInfo.lastLoggedInFingerprint = Build.FINGERPRINT;<br>                userData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">UserData</span>();<br>                userData.info = userInfo;<br>                <span class="hljs-comment">// mUsers是SparseArray类型</span><br>                mUsers.<span class="hljs-built_in">put</span>(userId, userData);<br>            &#125;<br>            <span class="hljs-comment">// 详见2.2节</span><br>            <span class="hljs-built_in">writeUserLP</span>(userData);  <span class="hljs-comment">// 构造包含新用户信息的UserData，并固化到/data/system/users/&lt;user_id&gt;.xml</span><br>            <span class="hljs-built_in">writeUserListLP</span>();      <span class="hljs-comment">// 将新创建新UserId固化到 data/system/users/userlist.xml</span><br>        &#125;<br><br><br>        <span class="hljs-keyword">final</span> StorageManager storage = mContext.<span class="hljs-built_in">getSystemService</span>(StorageManager.<span class="hljs-keyword">class</span>);<br>        storage.<span class="hljs-built_in">createUserKey</span>(userId, userInfo.serialNumber, userInfo.<span class="hljs-built_in">isEphemeral</span>());<br><br>        mUserDataPreparer.<span class="hljs-built_in">prepareUserData</span>(userId, userInfo.serialNumber,<br>                                          StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE);<br><br>        <span class="hljs-comment">// 2.3节 获取当前用户类型需要安装的应用有哪些</span><br>        <span class="hljs-keyword">final</span> Set&lt;String&gt; userTypeInstallablePackages =<br>            mSystemPackageInstaller.<span class="hljs-built_in">getInstallablePackagesForUserType</span>(userType);<br><br>        <span class="hljs-comment">// 2.3节PMS安装新用户应用</span><br>        mPm.<span class="hljs-built_in">createNewUser</span>(userId, userTypeInstallablePackages, disallowedPackages);<br><br>        userInfo.partial = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">synchronized</span> (mPackagesLock) &#123;<br>            <span class="hljs-built_in">writeUserLP</span>(userData);  <span class="hljs-comment">// 再次调用2.2节中的方法</span><br>        &#125;<br>        <span class="hljs-built_in">updateUserIds</span>();<br><br>        Bundle restrictions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bundle</span>();<br>        <span class="hljs-keyword">if</span> (isGuest) &#123;<br><span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 添加默认的用户限制</span><br>            userTypeDetails.<span class="hljs-built_in">addDefaultRestrictionsTo</span>(restrictions);<br>        &#125;<br>        <span class="hljs-built_in">synchronized</span> (mRestrictionsLock) &#123;<br>            <span class="hljs-comment">// 更新RestrictionsSet.java中维护的mUserRestrictions的数据结构</span><br>            mBaseUserRestrictions.<span class="hljs-built_in">updateRestrictions</span>(userId, restrictions);<br>        &#125;<br><br>        mPm.<span class="hljs-built_in">onNewUserCreated</span>(userId, <span class="hljs-comment">/* convertedFromPreCreated= */</span> <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 设置用户默认的系统配置和安全配置</span><br>        <span class="hljs-built_in">applyDefaultUserSettings</span>(userTypeDetails, userId);<br>        <span class="hljs-built_in">setDefaultCrossProfileIntentFilters</span>(userId, userTypeDetails, restrictions, parentId);<br><br>        <span class="hljs-keyword">if</span> (preCreate) &#123;<br><span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">dispatchUserAdded</span>(userInfo, token);<br>        &#125;<br><br>    &#125; finally &#123;<br>        Binder.<span class="hljs-built_in">restoreCallingIdentity</span>(ident);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> userInfo;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-初始化用户信息"><a href="#2-1-初始化用户信息" class="headerlink" title="2.1 初始化用户信息"></a>2.1 初始化用户信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实例化UserInfo并进行初始化赋值</span><br>userInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserInfo</span>(userId, name, <span class="hljs-literal">null</span>, flags, userType);<br>userInfo.serialNumber = mNextSerialNumber++; <span class="hljs-comment">// 串行号，根据经验来看等于UserId</span><br>userInfo.creationTime = getCreationTime();<br>userInfo.partial = <span class="hljs-literal">true</span>;<br>userInfo.preCreated = preCreate;<br>userInfo.lastLoggedInFingerprint = Build.FINGERPRINT;<br>userData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserData</span>();<br>userData.info = userInfo;<br><span class="hljs-comment">// mUsers是SparseArray类型</span><br>mUsers.put(userId, userData);<br></code></pre></td></tr></table></figure><p>⭐ <strong>SparseArray</strong>并不像HashMap采用一维数组+单链表结构，而是采用两个一维数组，一个是存储key(int类型),一个是存在value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] mKeys;<br><span class="hljs-keyword">private</span> Object[] mValues;<br></code></pre></td></tr></table></figure><p>这里记住，UserManagerService维护了一个Key，Value的数据结构，Key为UserId，Value为UserData用户数据。</p><p>⭐ 我们平常使用<strong>dumpsys user</strong>打印的就是UserInfo类的ToString方法</p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230608232128458.png" alt="image-20230608232128458" style="zoom:67%;"><h3 id="2-2-保存新创建的用户信息"><a href="#2-2-保存新创建的用户信息" class="headerlink" title="2.2 保存新创建的用户信息"></a>2.2 保存新创建的用户信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">writeUserLP(userData);  <span class="hljs-comment">// 构造包含新用户信息的UserData，并固化到/data/system/users/&lt;user_id&gt;.xml</span><br>writeUserListLP();      <span class="hljs-comment">// 将新创建新UserId固化到 data/system/users/userlist.xml</span><br><br><span class="hljs-comment">// --------------------------------------------------</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeUserLP</span><span class="hljs-params">(UserData userData)</span> &#123;<br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 原子创建文件 /data/system/users/&lt;user_id&gt;.xml</span><br>    <span class="hljs-type">AtomicFile</span> <span class="hljs-variable">userFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(mUsersDir, userData.info.id + XML_SUFFIX));<br>    <span class="hljs-keyword">try</span> &#123;<br>        fos = userFile.startWrite();<br>        <span class="hljs-comment">// 将UserData中的消息写到/data/system/users/&lt;user_id&gt;.xml</span><br>        writeUserLP(userData, fos);<br>        userFile.finishWrite(fos);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ioe) &#123;<br>        Slog.e(LOG_TAG, <span class="hljs-string">&quot;Error writing user info &quot;</span> + userData.info.id, ioe);<br>        userFile.failWrite(fos);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// --------------------------------------------------</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeUserListLP</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 原子创建文件data/system/users/userlist.xml</span><br>    <span class="hljs-type">AtomicFile</span> <span class="hljs-variable">userListFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicFile</span>(mUserListFile);<br>    <span class="hljs-comment">// 写信息...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>⭐ <strong>原子类文件流操作</strong>：<a href="https://blog.csdn.net/FightFightFight/article/details/80069886">https://blog.csdn.net/FightFightFight/article/details/80069886</a></p><blockquote><p>AtomicFile是Android API17中引入的对文件进行原子操作的帮助类，所谓原子性，是指在对整个文件操作时，要么不操作，要么操作成功。如果操作失败，不会影响文件内容。</p><p>在获取该实例时，会在内部创建两个File对象，一个代表原文件，一个代表备份文件，通过这两个文件保证原文件的原子性！</p></blockquote><ul><li>构造包含新用户信息的UserData，并固化到 <code>/data/system/users/&lt;user_id&gt;.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">root@virgo:/ # cat data/system/users/10.xml<br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27; standalone=&#x27;yes&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">serialNumber</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">flags</span>=<span class="hljs-string">&quot;17&quot;</span> <span class="hljs-attr">created</span>=<span class="hljs-string">&quot;1561361447098&quot;</span> <span class="hljs-attr">lastLoggedIn</span>=<span class="hljs-string">&quot;1561460313625&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>security space<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">restrictions</span> <span class="hljs-attr">no_install_unknown_sources</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">no_usb_file_transfer</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">no_debugging_features</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>将新创建新UserId固化到 <code>data/system/users/userlist.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">root@virgo:/ # cat data/system/users/userlist.xml<br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27; standalone=&#x27;yes&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">users</span> <span class="hljs-attr">nextSerialNumber</span>=<span class="hljs-string">&quot;12&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">guestRestrictions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">restrictions</span> <span class="hljs-attr">no_config_wifi</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">no_outgoing_calls</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">no_sms</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">guestRestrictions</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;10&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;11&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">users</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-PMS安装新用户应用"><a href="#2-3-PMS安装新用户应用" class="headerlink" title="2.3 PMS安装新用户应用"></a>2.3 PMS安装新用户应用</h3><p><strong>（1）先获取要安装的包要有哪些</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span> Set&lt;String&gt; <span class="hljs-title function_">getInstallablePackagesForUserType</span><span class="hljs-params">(String userType)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">mode</span> <span class="hljs-operator">=</span> getWhitelistMode();  <span class="hljs-comment">// mode = 13，可以通过dumpsys user查看UserSystemPackageInstaller中的dump函数打印</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">implicitlyWhitelist</span> <span class="hljs-operator">=</span> isImplicitWhitelistMode(mode)<br>        || (isImplicitWhitelistSystemMode(mode) &amp;&amp; mUm.isUserTypeSubtypeOfSystem(userType));<br>    <span class="hljs-keyword">final</span> Set&lt;String&gt; whitelistedPackages = getWhitelistedPackagesForUserType(userType); <span class="hljs-comment">// 获取白名单安装包</span><br><br>    <span class="hljs-keyword">final</span> Set&lt;String&gt; installPackages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArraySet</span>&lt;&gt;();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">PackageManagerInternal</span> <span class="hljs-variable">pmInt</span> <span class="hljs-operator">=</span> LocalServices.getService(PackageManagerInternal.class);<br>    pmInt.forEachPackage(pkg -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (!pkg.isSystem()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (shouldInstallPackage(pkg, mWhitelistedPackagesForUserTypes,<br>                                 whitelistedPackages, implicitlyWhitelist)) &#123;<br>            <span class="hljs-comment">// Although the allowlist uses manifest names, this function returns packageNames.</span><br>            installPackages.add(pkg.getPackageName());<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> installPackages;<br>&#125;<br><span class="hljs-comment">// -------------------------------------------------------------</span><br><span class="hljs-meta">@NonNull</span> Set&lt;String&gt; <span class="hljs-title function_">getWhitelistedPackagesForUserType</span><span class="hljs-params">(String userType)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">userTypeMask</span> <span class="hljs-operator">=</span> getUserTypeMask(userType);  <span class="hljs-comment">//好获取当前用户类型的掩码</span><br>    <span class="hljs-keyword">final</span> Set&lt;String&gt; installablePkgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArraySet</span>&lt;&gt;(mWhitelistedPackagesForUserTypes.size());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mWhitelistedPackagesForUserTypes.size(); i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">pkgName</span> <span class="hljs-operator">=</span> mWhitelistedPackagesForUserTypes.keyAt(i);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">whitelistedUserTypes</span> <span class="hljs-operator">=</span> mWhitelistedPackagesForUserTypes.valueAt(i);<br>        <span class="hljs-comment">// 假设当前用户类型为GUEST，那么其掩码为 1 &lt;&lt; 1</span><br>        <span class="hljs-comment">// 又com.android.internal.display.cutout.emulation.corner位图的第2位为1，相&amp;之后不为0【具体见下图】</span><br>        <span class="hljs-comment">// 则这个包应该安装</span><br>        <span class="hljs-keyword">if</span> ((userTypeMask &amp; whitelistedUserTypes) != <span class="hljs-number">0</span>) &#123;<br>            installablePkgs.add(pkgName);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> installablePkgs;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>⭐ 下面说明一下<strong>mWhitelistedPackagesForUserTypes</strong>这个变量的存储方式，他是一个ArrayMap，键为包名，值为可以安装该应用对应的位图</p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230609203512256.png" alt="image-20230609203512256" style="zoom:67%;"><blockquote><p>下图为<strong>dumpsys user</strong>的打印结果</p></blockquote><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230609202459128.png" alt="image-20230609202459128" style="zoom:67%;"><p><strong>（2）安装应用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createNewUser</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-meta">@Nullable</span> Set&lt;String&gt; userTypeInstallablePackages,</span><br><span class="hljs-params">                   String[] disallowedPackages)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (mInstallLock) &#123;<br>        <span class="hljs-comment">// 在mSettintgs中调用PMS安装应用</span><br>        mSettings.createNewUserLI(<span class="hljs-built_in">this</span>, mInstaller, userId, userTypeInstallablePackages, disallowedPackages);<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        scheduleWritePackageRestrictionsLocked(userId);<br>        scheduleWritePackageListLocked(userId);<br>        mAppsFilter.onUsersChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-添加对用户的限制"><a href="#2-4-添加对用户的限制" class="headerlink" title="2.4 添加对用户的限制"></a>2.4 添加对用户的限制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">userTypeDetails.addDefaultRestrictionsTo(restrictions);<br><br><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\pm\UserTypeDetails.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addDefaultRestrictionsTo</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bundle currentRestrictions)</span> &#123;<br>    UserRestrictionsUtils.merge(currentRestrictions, mDefaultRestrictions);<br>&#125;<br></code></pre></td></tr></table></figure><p>⭐ 不同的用户类型在初始化<strong>UserTypeDetails</strong>的时候都会去设置限制，例如<strong>SecondaryUser</strong>类型的用户会添加2项限制：<code>no_outgoing_calls</code>和<code>no_sms</code></p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230609210435607.png" alt="image-20230609210435607" style="zoom:67%;"><p>我们可以再次通过<code>dumpsys user</code>查看一下：</p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230609211103672.png" alt="image-20230609211103672" style="zoom:67%;"><p>妈妈耶，对上了对上了！！</p><h2 id="3-切换用户"><a href="#3-切换用户" class="headerlink" title="3.切换用户"></a>3.切换用户</h2><p>先上实际操作的GIF，用眼睛看往往更加直观~</p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/切换用户.gif" style="zoom:50%;"><h3 id="3-1-开始切换用户"><a href="#3-1-开始切换用户" class="headerlink" title="3.1 开始切换用户"></a>3.1 开始切换用户</h3><p>Android多用户的切换函数入口ActivityManagerService.switchUser方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">switchUser</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> targetUserId)</span> &#123;<br>    <span class="hljs-keyword">return</span> mUserController.switchUser(targetUserId);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用UserController的switchUser方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\am\UserController.java</span><br><span class="hljs-function">boolean <span class="hljs-title">switchUser</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> targetUserId)</span> </span>&#123;<br>    <span class="hljs-type">int</span> currentUserId = <span class="hljs-built_in">getCurrentUserId</span>();  <span class="hljs-comment">// 获取当前用户的userId</span><br>    UserInfo targetUserInfo = <span class="hljs-built_in">getUserInfo</span>(targetUserId);  <span class="hljs-comment">// 获取即将切换用户的信息</span><br><br>    <span class="hljs-comment">// ...</span><br>    <br>    boolean userSwitchUiEnabled;<br>    <span class="hljs-built_in">synchronized</span> (mLock) &#123;<br>        mTargetUserId = targetUserId;<br>        userSwitchUiEnabled = mUserSwitchUiEnabled;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (userSwitchUiEnabled) &#123;<br>        UserInfo currentUserInfo = <span class="hljs-built_in">getUserInfo</span>(currentUserId);<br>        Pair&lt;UserInfo, UserInfo&gt; userNames = <span class="hljs-keyword">new</span> Pair&lt;&gt;(currentUserInfo, targetUserInfo);<br>        mUiHandler.<span class="hljs-built_in">removeMessages</span>(START_USER_SWITCH_UI_MSG);<br>        mUiHandler.<span class="hljs-built_in">sendMessage</span>(mUiHandler.<span class="hljs-built_in">obtainMessage</span>(START_USER_SWITCH_UI_MSG, userNames));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mHandler.<span class="hljs-built_in">removeMessages</span>(START_USER_SWITCH_FG_MSG);<br>        mHandler.<span class="hljs-built_in">sendMessage</span>(mHandler.<span class="hljs-built_in">obtainMessage</span>(START_USER_SWITCH_FG_MSG, targetUserId, <span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终会传递一个Handler消息<strong>START_USER_SWITCH_UI_MSG</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> START_USER_SWITCH_UI_MSG:<br><span class="hljs-comment">// 拿到Handler的参数</span><br>    <span class="hljs-keyword">final</span> Pair&lt;UserInfo, UserInfo&gt; fromToUserPair = (Pair&lt;UserInfo, UserInfo&gt;) msg.obj;<br>    showUserSwitchDialog(fromToUserPair);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>调用切换用户的对话框【在切换用户的时候，主界面会有一个UI显示】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showUserSwitchDialog</span><span class="hljs-params">(Pair&lt;UserInfo, UserInfo&gt; fromToUserPair)</span> &#123;<br>    mInjector.showUserSwitchingDialog(fromToUserPair.first, fromToUserPair.second,<br>                                      getSwitchingFromSystemUserMessage(), getSwitchingToSystemUserMessage());<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">showUserSwitchingDialog</span><span class="hljs-params">(UserInfo fromUser, UserInfo toUser,</span><br><span class="hljs-params">                             String switchingFromSystemUserMessage, String switchingToSystemUserMessage)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Dialog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserSwitchingDialog</span>(mService, mService.mContext, fromUser,<br>                                             toUser, <span class="hljs-literal">true</span> <span class="hljs-comment">/* above system */</span>, switchingFromSystemUserMessage,<br>                                             switchingToSystemUserMessage);<br>    d.show();<br>&#125;<br></code></pre></td></tr></table></figure><p>调用一个继承自Dialog的自定义对话框类UserSwitchingDialog，然后调用其show方法在主界面进行显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.show();<br>    mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_START_USER), WINDOW_SHOWN_TIMEOUT_MS);<br>&#125;<br></code></pre></td></tr></table></figure><p>又传递了一个Handler信息<strong>MSG_START_USER</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> MSG_START_USER:<br>    startUser();<br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-comment">// 调用UserSwitchingDialog的startUser</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">startUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!mStartedUser) &#123;<br>            mService.mUserController.startUserInForeground(mUserId);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Slog.i(TAG, <span class="hljs-string">&quot;user &quot;</span> + mUserId + <span class="hljs-string">&quot; already started&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>又重新调用到了UserController的startUserInForeground方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">startUserInForeground</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> targetUserId)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> startUser(targetUserId, <span class="hljs-comment">/* foreground */</span> <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startUser</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> foreground)</span> &#123;<br>    <span class="hljs-keyword">return</span> startUser(userId, foreground, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startUser</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> foreground, <span class="hljs-meta">@Nullable</span> IProgressListener unlockListener)</span> &#123;<br>    <span class="hljs-keyword">return</span> startUserNoChecks(userId, foreground, unlockListener);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startUserNoChecks</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> foreground,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@Nullable</span> IProgressListener unlockListener)</span> &#123;<br>    <span class="hljs-keyword">return</span> startUserInternal(userId, foreground, unlockListener, t);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终调用到了startUserInternal</p><h3 id="3-2-启动用户startUserInternal"><a href="#3-2-启动用户startUserInternal" class="headerlink" title="3.2 启动用户startUserInternal"></a>3.2 启动用户startUserInternal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从上面一路传下来的foreground为true</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startUserInternal</span><span class="hljs-params">(<span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId, <span class="hljs-type">boolean</span> foreground,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@Nullable</span> IProgressListener unlockListener, <span class="hljs-meta">@NonNull</span> TimingsTraceAndSlog t)</span> &#123;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">callingUid</span> <span class="hljs-operator">=</span> Binder.getCallingUid();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">callingPid</span> <span class="hljs-operator">=</span> Binder.getCallingPid();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ident</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">oldUserId</span> <span class="hljs-operator">=</span> getCurrentUserId();  <span class="hljs-comment">// 获取当前用户的userId</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> getUserInfo(userId); <span class="hljs-comment">// 获取当前用户的信息</span><br><br>        <span class="hljs-comment">// 1. 冻结输入事件</span><br>        <span class="hljs-comment">// 2. 强制结束所有动画</span><br>        <span class="hljs-comment">// 3. 截取当前屏幕并展示</span><br>        <span class="hljs-keyword">if</span> (foreground &amp;&amp; isUserSwitchUiEnabled()) &#123;<br>            mInjector.getWindowManager().startFreezingScreen(R.anim.screen_user_exit, R.anim.screen_user_enter);<br>        &#125;<br>        <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needStart</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">updateUmState</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        UserState uss;<br><br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            uss = mStartedUsers.get(userId);<br>            <span class="hljs-keyword">if</span> (uss == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 初始状态为STATE_BOOTING</span><br>                uss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserState</span>(UserHandle.of(userId));<br>                uss.mUnlockProgress.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserProgressListener</span>());<br>                <span class="hljs-comment">// mStartedUsers维护了用户id和用户状态</span><br>                mStartedUsers.put(userId, uss);<br>                updateStartedUserArrayLU();<br>                needStart = <span class="hljs-literal">true</span>;<br>                updateUmState = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (uss.state == UserState.STATE_SHUTDOWN &amp;&amp; !isCallingOnHandlerThread()) &#123;<br>               <span class="hljs-comment">// ...</span><br>            &#125;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">userIdInt</span> <span class="hljs-operator">=</span> userId;<br>            mUserLru.remove(userIdInt);<br>            mUserLru.add(userIdInt);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (foreground) &#123;<br>            mInjector.reportGlobalUsageEvent(UsageEvents.Event.SCREEN_NON_INTERACTIVE);<br>            <span class="hljs-type">boolean</span> userSwitchUiEnabled;<br>            <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>                mCurrentUserId = userId;<br>                mTargetUserId = UserHandle.USER_NULL;<br>                userSwitchUiEnabled = mUserSwitchUiEnabled;<br>            &#125;<br>            <span class="hljs-comment">// 从Setting Provider读取需要切换用户的字体、语言、地区等配置并更新</span><br>            <span class="hljs-comment">// 如果是初创用户，对于字体则使用默认配置，语言和地区使用当前用户的配置</span><br>            mInjector.updateUserConfiguration();<br>            <span class="hljs-comment">// 更新当前用户附属的ManageProfile</span><br>            updateCurrentProfileIds();<br>            <span class="hljs-comment">// 设置当前用户下所有window的可见性</span><br>            <span class="hljs-comment">// 设置切换用户的屏幕分辨率</span><br>            mInjector.getWindowManager().setCurrentUser(userId, getCurrentProfileIds());<br>            mInjector.reportCurWakefulnessUsageEvent();<br>            <span class="hljs-keyword">if</span> (userSwitchUiEnabled) &#123;<br>                <span class="hljs-comment">// 切换过程中关闭Keyguard的指纹监听</span><br>                mInjector.getWindowManager().setSwitchingUser(<span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 设置Keyguard锁屏(锁屏keyguard属于SystemUI)</span><br>                mInjector.getWindowManager().lockNow(<span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (uss.state == UserState.STATE_BOOTING) &#123;<br>            <span class="hljs-comment">// 设置新用户的权限，校验或准备新用户app存储</span><br>            mInjector.getUserManager().onBeforeStartUser(userId);<br>            <span class="hljs-comment">// 通知系统所有的服务新用户已经启动</span><br>            mHandler.sendMessage(mHandler.obtainMessage(USER_START_MSG, userId, <span class="hljs-number">0</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (foreground) &#123;<br>            <span class="hljs-comment">// 3.2.1 通知各服务切换用户</span><br>            mHandler.sendMessage(mHandler.obtainMessage(USER_CURRENT_MSG, userId, oldUserId));<br>        &#125;<br><br><br>        <span class="hljs-comment">// 详见3.2.2</span><br>        <span class="hljs-keyword">if</span> (foreground) &#123;<br>            moveUserToForeground(uss, oldUserId, userId);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            finishUserBoot(uss);<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Binder.restoreCallingIdentity(ident);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-2-1-通知各服务切换用户"><a href="#3-2-1-通知各服务切换用户" class="headerlink" title="3.2.1 通知各服务切换用户"></a>3.2.1 通知各服务切换用户</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">mHandler.sendMessage(mHandler.obtainMessage(USER_CURRENT_MSG, userId, oldUserId));<br><br><br>处理Handler消息:<br><span class="hljs-keyword">case</span> USER_CURRENT_MSG:<br>    mInjector.getSystemServiceManager().onUserSwitching(msg.arg2, msg.arg1);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>调用SystemServiceManager的onUserSwitching方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\SystemServiceManager.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUserSwitching</span><span class="hljs-params">(<span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> from, <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> to)</span> &#123;<br>    <span class="hljs-keyword">final</span> TargetUser curUser, prevUser;<br>    <span class="hljs-keyword">synchronized</span> (mTargetUsers) &#123;<br>        <span class="hljs-keyword">if</span> (mCurrentUser == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            prevUser = mCurrentUser;<br>        &#125;<br>        curUser = mCurrentUser = getTargetUser(to);<br>    &#125;<br>    onUser(TimingsTraceAndSlog.newAsyncLog(), USER_SWITCHING, prevUser, curUser);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用onUser方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUser</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String onWhat, <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId)</span> &#123;<br>    onUser(TimingsTraceAndSlog.newAsyncLog(), onWhat, <span class="hljs-comment">/* prevUser= */</span> <span class="hljs-literal">null</span>, getTargetUser(userId));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUser</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> TimingsTraceAndSlog t, <span class="hljs-meta">@NonNull</span> String onWhat,</span><br><span class="hljs-params">                    <span class="hljs-meta">@Nullable</span> TargetUser prevUser, <span class="hljs-meta">@NonNull</span> TargetUser curUser)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">curUserId</span> <span class="hljs-operator">=</span> curUser.getUserIdentifier();<br><span class="hljs-comment">// SMS管理的所有服务存储在mServices中</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">serviceLen</span> <span class="hljs-operator">=</span> mServices.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; serviceLen; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SystemService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> mServices.get(i);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> service.getClass().getName();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">switch</span> (onWhat) &#123;<br>                <span class="hljs-keyword">case</span> USER_SWITCHING:<br>                    service.onUserSwitching(prevUser, curUser);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br><span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>SystemServiceManager</strong>会通知其管理的所有服务调用其<strong>onUserSwitching</strong>方法，如StorageManagerService的onUserSwitching方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks\base\services\core\java\com\android\server\StorageManagerService.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUserSwitching</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TargetUser from, <span class="hljs-meta">@NonNull</span> TargetUser to)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">currentUserId</span> <span class="hljs-operator">=</span> to.getUserIdentifier();<br>    mStorageManagerService.mCurrentUserId = currentUserId;<br><br>    <span class="hljs-type">UserManagerInternal</span> <span class="hljs-variable">umInternal</span> <span class="hljs-operator">=</span> LocalServices.getService(UserManagerInternal.class);<br>    <span class="hljs-keyword">if</span> (umInternal.isUserUnlocked(currentUserId)) &#123;<br>        mStorageManagerService.maybeRemountVolumes(currentUserId);<br>        mStorageManagerService.mRemountCurrentUserVolumesOnUnlock = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mStorageManagerService.mRemountCurrentUserVolumesOnUnlock = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前用户已经解锁，那么直接重新挂载所有的卷。</p><h4 id="3-2-2-最后都会走到finishUserBoot"><a href="#3-2-2-最后都会走到finishUserBoot" class="headerlink" title="3.2.2 最后都会走到finishUserBoot"></a>3.2.2 最后都会走到finishUserBoot</h4><p>不同的是我们创建完，切换用户的时候是foregound，因此调用的是moveUserToForeground</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveUserToForeground</span><span class="hljs-params">(UserState uss, <span class="hljs-type">int</span> oldUserId, <span class="hljs-type">int</span> newUserId)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">homeInFront</span> <span class="hljs-operator">=</span> mInjector.taskSupervisorSwitchUser(newUserId, uss);<br>    <span class="hljs-keyword">if</span> (homeInFront) &#123;<br>        <span class="hljs-comment">// 如果之前没有前台应用，则启动HomeActivity</span><br>        mInjector.startHomeActivity(newUserId, <span class="hljs-string">&quot;moveUserToForeground&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果之前有前台应用，则resume该Activity</span><br>        mInjector.taskSupervisorResumeFocusedStackTopActivity();<br>    &#125;<br>    <span class="hljs-comment">// // 对于切换前的用户，发送ACTION_USER_BACKGROUND广播，对于切换后的用户，发送 ACTION_USER_FOREGROUND和ACTION_USER_SWITCHED广播</span><br>    sendUserSwitchBroadcasts(oldUserId, newUserId);<br>&#125;<br></code></pre></td></tr></table></figure><p>引用一下<a href="https://blog.csdn.net/qq_14978113/article/details/94654401?spm=1001.2014.3001.5506%E7%89%B9%E5%88%AB%E6%A3%92%E7%9A%84%E4%B8%80%E5%BC%A0%E4%BB%8EAMS%E5%88%B0finishUserBoot%E7%9A%84%E5%9B%BE%E7%89%87">https://blog.csdn.net/qq_14978113/article/details/94654401?spm=1001.2014.3001.5506特别棒的一张从AMS到finishUserBoot的图片</a></p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE0OTc4MTEz.png" alt="img" style="zoom: 60%;"><p>🐇 <strong>所以不管我们是前台切换还是后台切换，最终都会总到finishUserBoot</strong></p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230619224008130.png" alt="image-20230619224008130" style="zoom: 50%;"><h3 id="3-3-切换用户结束finishUserBoot-万物归宗"><a href="#3-3-切换用户结束finishUserBoot-万物归宗" class="headerlink" title="3.3 切换用户结束finishUserBoot(万物归宗)"></a>3.3 切换用户结束finishUserBoot(万物归宗)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishUserBoot</span><span class="hljs-params">(UserState uss)</span> &#123;<br>    finishUserBoot(uss, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishUserBoot</span><span class="hljs-params">(UserState uss, IIntentReceiver resultTo)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> uss.mHandle.getIdentifier();<br><br>    <span class="hljs-comment">// 设置用户状态，从booting设置为running_locked</span><br>    <span class="hljs-keyword">if</span> (uss.setState(STATE_BOOTING, STATE_RUNNING_LOCKED)) &#123;<br>        logUserLifecycleEvent(userId, USER_LIFECYCLE_EVENT_USER_RUNNING_LOCKED,<br>                              USER_LIFECYCLE_EVENT_STATE_NONE);<br>        <span class="hljs-comment">// UserManagerService维护的用户状态中添加userid,uss</span><br>        mInjector.getUserManagerInternal().setUserState(userId, uss.state);<br><br>        <span class="hljs-keyword">if</span> (!mInjector.getUserManager().isPreCreated(userId)) &#123;<br>            mHandler.sendMessage(mHandler.obtainMessage(REPORT_LOCKED_BOOT_COMPLETE_MSG,<br>                                                        userId, <span class="hljs-number">0</span>));<br>            <span class="hljs-keyword">if</span> (!(UserManager.isHeadlessSystemUserMode() &amp;&amp; uss.mHandle.isSystem())) &#123;<br>                sendLockedBootCompletedBroadcast(resultTo, userId);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 如果当前用户是profile类型</span><br>    <span class="hljs-keyword">if</span> (mInjector.getUserManager().isProfile(userId)) &#123;<br><span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        maybeUnlockUser(userId);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>调用maybeUnlockUser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">maybeUnlockUser</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId)</span> &#123;<br>    <span class="hljs-keyword">return</span> unlockUserCleared(userId, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">unlockUserCleared</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-meta">@UserIdInt</span> <span class="hljs-type">int</span> userId, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret, IProgressListener listener)</span> &#123;<br>    UserState uss;<br>    <span class="hljs-comment">// 如果用户没有解锁</span><br>    <span class="hljs-keyword">if</span> (!StorageManager.isUserKeyUnlocked(userId)) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> getUserInfo(userId);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">IStorageManager</span> <span class="hljs-variable">storageManager</span> <span class="hljs-operator">=</span> mInjector.getStorageManager();<br>        <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 调用SMS解锁CE Storage</span><br>            storageManager.unlockUserKey(userId, userInfo.serialNumber, token, secret);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException | RuntimeException e) &#123;<br>            Slogf.w(TAG, <span class="hljs-string">&quot;Failed to unlock: &quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">if</span> (!finishUserUnlocking(uss)) &#123;<br>        notifyFinished(userId, listener);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-1-解锁CE-Storage"><a href="#3-3-1-解锁CE-Storage" class="headerlink" title="3.3.1 解锁CE Storage"></a>3.3.1 解锁CE Storage</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlockUserKey</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, <span class="hljs-type">int</span> serialNumber, <span class="hljs-type">byte</span>[] token, <span class="hljs-type">byte</span>[] secret)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isFsEncrypted</span> <span class="hljs-operator">=</span> StorageManager.isFileEncryptedNativeOrEmulated();<br>    <span class="hljs-comment">// 判断用户是否已经解锁</span><br>    <span class="hljs-keyword">if</span> (isUserKeyUnlocked(userId)) &#123;<br>        Slog.d(TAG, <span class="hljs-string">&quot;User &quot;</span> + userId + <span class="hljs-string">&quot;&#x27;s CE storage is already unlocked&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>   <span class="hljs-comment">// 如果支持文件加密，则调用Vold的unlockUserKey方法</span><br>    <span class="hljs-keyword">if</span> (isFsEncrypted) &#123;<br>        mVold.unlockUserKey(userId, serialNumber, encodeBytes(token), encodeBytes(secret));<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        mLocalUnlockedUsers.append(userId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-结束解锁finishUserUnlocking"><a href="#3-3-2-结束解锁finishUserUnlocking" class="headerlink" title="3.3.2 结束解锁finishUserUnlocking"></a>3.3.2 结束解锁finishUserUnlocking</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">finishUserUnlocking</span><span class="hljs-params">(<span class="hljs-keyword">final</span> UserState uss)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> uss.mHandle.getIdentifier();<br>    <span class="hljs-keyword">if</span> (!StorageManager.isUserKeyUnlocked(userId)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    FgThread.getHandler().post(() -&gt; &#123;<br>        mInjector.getUserManager().onBeforeUnlockUser(userId);<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            <span class="hljs-keyword">if</span> (!uss.setState(STATE_RUNNING_LOCKED, STATE_RUNNING_UNLOCKING)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 设置用户状态</span><br>        mInjector.getUserManagerInternal().setUserState(userId, uss.state);<br><br>        <span class="hljs-comment">// 发送handler信息</span><br>        mHandler.obtainMessage(USER_UNLOCK_MSG, userId, <span class="hljs-number">0</span>, uss).sendToTarget();<br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理handler信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> USER_UNLOCK_MSG:<br>    finishUserUnlocked((UserState) msg.obj);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>调用finishUserUnlocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">finishUserUnlocked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> UserState uss)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> uss.mHandle.getIdentifier();<br><br>    mInjector.installEncryptionUnawareProviders(userId);<br><br>    <span class="hljs-keyword">if</span> (!mInjector.getUserManager().isPreCreated(userId)) &#123;<br>        <span class="hljs-comment">//发送ACTION_USER_UNLOCKED广播，并行广播</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">unlockedIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_USER_UNLOCKED);<br>        unlockedIntent.putExtra(Intent.EXTRA_USER_HANDLE, userId);<br>        unlockedIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);<br>        mInjector.broadcastIntent(unlockedIntent, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>,<br>                                  <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, AppOpsManager.OP_NONE, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, MY_PID, SYSTEM_UID,<br>                                  Binder.getCallingUid(), Binder.getCallingPid(), userId);<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> getUserInfo(userId);<br> <span class="hljs-comment">//用户fingerprint改变，则发送广播</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">UserInfo</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> getUserInfo(userId);<br>    <span class="hljs-keyword">if</span> (!Objects.equals(info.lastLoggedInFingerprint, Build.FINGERPRINT)<br>        || SystemProperties.getBoolean(<span class="hljs-string">&quot;persist.pm.mock-upgrade&quot;</span>, <span class="hljs-literal">false</span>)) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> quiet;<br>        <span class="hljs-keyword">if</span> (info.isManagedProfile()) &#123;<br><span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            quiet = <span class="hljs-literal">false</span>;<br>        &#125;<br>        mInjector.sendPreBootBroadcast(userId, quiet, () -&gt; finishUserUnlockedCompleted(uss));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        finishUserUnlockedCompleted(uss);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后的最后，我们结束整个的解锁finishUserUnlockedCompleted</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishUserUnlockedCompleted</span><span class="hljs-params">(UserState uss)</span> &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> uss.mHandle.getIdentifier();<br><br>      mInjector.getUserManager().onUserLoggedIn(userId);<br><br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">initializeUser</span> <span class="hljs-operator">=</span> () -&gt; mInjector.getUserManager().makeInitialized(userInfo.id);<br>      <span class="hljs-keyword">if</span> (!userInfo.isInitialized()) &#123;<br>          <span class="hljs-keyword">if</span> (userInfo.preCreated) &#123;<br>              <span class="hljs-comment">// ...</span><br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userId != UserHandle.USER_SYSTEM) &#123;<br>              <span class="hljs-comment">//发送ACTION_USER_INITIALIZE广播去给user初始化，，串行广播</span><br>              <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_USER_INITIALIZE);<br>              intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND<br>                      | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);<br>              mInjector.broadcastIntent(intent, <span class="hljs-literal">null</span>,<br>                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">IIntentReceiver</span>.Stub() &#123;<br>                          <span class="hljs-meta">@Override</span><br>                          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performReceive</span><span class="hljs-params">(Intent intent, <span class="hljs-type">int</span> resultCode,</span><br><span class="hljs-params">                                  String data, Bundle extras, <span class="hljs-type">boolean</span> ordered,</span><br><span class="hljs-params">                                  <span class="hljs-type">boolean</span> sticky, <span class="hljs-type">int</span> sendingUser)</span> &#123;<br>                              initializeUser.run();<br>                          &#125;<br>                      &#125;, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, AppOpsManager.OP_NONE,<br>                      <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, MY_PID, SYSTEM_UID, Binder.getCallingUid(),<br>                      Binder.getCallingPid(), userId);<br>          &#125;<br>      &#125;<br><br>      mInjector.startUserWidgets(userId);<br><br>      mHandler.obtainMessage(USER_UNLOCKED_MSG, userId, <span class="hljs-number">0</span>).sendToTarget();<br><br><span class="hljs-comment">//发送ACTION_BOOT_COMPLETED广播，串行广播</span><br>      <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">bootIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_BOOT_COMPLETED, <span class="hljs-literal">null</span>);<br>      bootIntent.putExtra(Intent.EXTRA_USER_HANDLE, userId);<br>      bootIntent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT<br>              | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND<br>              | Intent.FLAG_RECEIVER_OFFLOAD);<br><br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">callingUid</span> <span class="hljs-operator">=</span> Binder.getCallingUid();<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">callingPid</span> <span class="hljs-operator">=</span> Binder.getCallingPid();<br>      FgThread.getHandler().post(() -&gt; &#123;<br>          mInjector.broadcastIntent(bootIntent, <span class="hljs-literal">null</span>,<br>                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">IIntentReceiver</span>.Stub() &#123;<br>                      <span class="hljs-meta">@Override</span><br>                      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performReceive</span><span class="hljs-params">(Intent intent, <span class="hljs-type">int</span> resultCode, String data,</span><br><span class="hljs-params">                              Bundle extras, <span class="hljs-type">boolean</span> ordered, <span class="hljs-type">boolean</span> sticky, <span class="hljs-type">int</span> sendingUser)</span><br>                                      <span class="hljs-keyword">throws</span> RemoteException &#123;<br>                          mBootCompleted = <span class="hljs-literal">true</span>;<br>                      &#125;<br>                  &#125;, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,<br>                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;android.Manifest.permission.RECEIVE_BOOT_COMPLETED&#125;,<br>                  AppOpsManager.OP_NONE,<br>                  getTemporaryAppAllowlistBroadcastOptions(REASON_BOOT_COMPLETED).toBundle(),<br>                  <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, MY_PID, SYSTEM_UID, callingUid, callingPid, userId);<br>      &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="4-处理H-BOOT-COMPLETED消息"><a href="#4-处理H-BOOT-COMPLETED消息" class="headerlink" title="4.处理H_BOOT_COMPLETED消息"></a>4.处理H_BOOT_COMPLETED消息</h2><blockquote><p>参考：<a href="https://blog.csdn.net/geshifei/article/details/130194916">https://blog.csdn.net/geshifei/article/details/130194916</a></p></blockquote><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230626000521128.png" alt="image-20230626000521128" style="zoom:70%;"><p>当启动完成后，SystemServiceManager发送H_BOOT_COMPLETED消息。StorageManagerService收到开机广播消息H_BOOT_COMPLETED，按时间顺序完成以下4件事情：</p><ul><li>init用户目录的加密状态</li><li>reset external storage service</li><li>reset vold service</li><li>添加用户</li></ul><p>代码整体逻辑如下：</p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/cd5c71637c0b460f8aaae4a915c7f212.png" alt="img"><h3 id="4-1-init用户目录的加密状态"><a href="#4-1-init用户目录的加密状态" class="headerlink" title="4.1 init用户目录的加密状态"></a>4.1 init用户目录的加密状态</h3><p>代码路径：StorageManagerServiceHandler::handleMessage –&gt; handleBootCompleted –&gt; initIfBootedAndConnected</p><p>分两种情况：<br>1）用户目录采用硬件加解密（native encryption），此阶段什么事也不做，函数直接返回<br>2）用户目录采用软件加解密（enmulated encryption），执行lock  encryption key（用户目录已加密的情况）或者unlock encryption key（用户目录未加密的情况）</p><p>从安全性、性能角度看，硬件加解密更好。</p><p>现在的手机基本都是硬件加解密方式，通过<code>adb shell getprop ro.crypto.state</code>可查询手机用的是哪种加解密方式。</p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230625235902263.png" alt="image-20230625235902263" style="zoom: 67%;"><h2 id="5-拿捏小细节"><a href="#5-拿捏小细节" class="headerlink" title="5.拿捏小细节"></a>5.拿捏小细节</h2><h3 id="5-1-解锁用户"><a href="#5-1-解锁用户" class="headerlink" title="5.1 解锁用户"></a>5.1 解锁用户</h3><h4 id="5-1-1-存储了已解锁的用户"><a href="#5-1-1-存储了已解锁的用户" class="headerlink" title="5.1.1 存储了已解锁的用户"></a>5.1.1 存储了已解锁的用户</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// /frameworks/base/core/java/android/os/storage/StorageManager.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUserKeyUnlocked</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span> &#123;<br><br>    sStorageManager = IStorageManager.Stub.asInterface(ServiceManager.getService(<span class="hljs-string">&quot;mount&quot;</span>));<br>   <br>    <span class="hljs-keyword">return</span> sStorageManager.isUserKeyUnlocked(userId);<br>&#125;<br><br><span class="hljs-comment">// /frameworks/base/services/core/java/com/android/server/StorageManagerService.java</span><br><span class="hljs-comment">// WatchedLockedUsers中维护了列表，表示已经解锁的用户</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">WatchedLockedUsers</span> <span class="hljs-variable">mLocalUnlockedUsers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WatchedLockedUsers</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUserKeyUnlocked</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        <span class="hljs-keyword">return</span> mLocalUnlockedUsers.contains(userId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过dumpsys mount查看已解锁的用户</p><h4 id="5-1-2-数据结构mLocalUnlockedUsers"><a href="#5-1-2-数据结构mLocalUnlockedUsers" class="headerlink" title="5.1.2 数据结构mLocalUnlockedUsers"></a>5.1.2 数据结构mLocalUnlockedUsers</h4><p>我们调用SMS中的isUserKeyUnlocked，实际上就是查询mLocalUnlockedUsers是否包含了该用户Id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">WatchedLockedUsers</span> <span class="hljs-variable">mLocalUnlockedUsers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WatchedLockedUsers</span>();<br></code></pre></td></tr></table></figure><p>WatchedLockedUsers是一个类，内部维护了一个列表。因此我们在理解mLocalUnlockedUsers的时候，就可以直接理解成一个列表。</p><h4 id="5-1-3-向mLocalUnlockedUsers添加已解锁用户时机"><a href="#5-1-3-向mLocalUnlockedUsers添加已解锁用户时机" class="headerlink" title="5.1.3 向mLocalUnlockedUsers添加已解锁用户时机"></a>5.1.3 向mLocalUnlockedUsers添加已解锁用户时机</h4><p>当用户最后调用finishUserBoot后，依次调用：</p><p><strong>finishUserBoot -&gt; maybeUnlockUser -&gt; unlockUserCleared  -&gt; unlockUserKey</strong></p><img src="/2023/06/01/%E5%AE%89%E5%8D%9312%E5%A4%9A%E7%94%A8%E6%88%B7%E6%9C%BA%E5%88%B6/image-20230620215447143.png" alt="image-20230620215447143" style="zoom: 50%;"><p>也就是说调用Vold解锁CE Storage没有问题后，认为该用户解锁成功，那么将该用户添加到mLocalUnlockedUsers中</p><h4 id="5-1-4-删除未解锁用户【有问题】"><a href="#5-1-4-删除未解锁用户【有问题】" class="headerlink" title="5.1.4 删除未解锁用户【有问题】"></a>5.1.4 删除未解锁用户【有问题】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockUserKey</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用vold锁住用户</span><br>        mVold.lockUserKey(userId);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Slog.wtf(TAG, e);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// mLocalUnlockedUsers移除传进来的userId</span><br>    <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        mLocalUnlockedUsers.remove(userId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-用户类型managed-profile"><a href="#5-2-用户类型managed-profile" class="headerlink" title="5.2 用户类型managed profile"></a>5.2 用户类型managed profile</h3><p><a href="https://source.android.com/docs/devices/admin/multi-user?hl=zh-cn#user_types">https://source.android.com/docs/devices/admin/multi-user?hl=zh-cn#user_types</a></p><p>用户经常想在企业环境中使用他们的私人设备。这种情况可能让企业陷入困境。如果用户使用他们的私人设备，企业不得不担心在这个不受控制的设备上的机密信息（例如员工的电子邮件和通讯录）。</p><p>为了处理这种情况，Android 5.0（API 21）允许企业设置 managed profile。如果设备有 managed profile，这个 profile 的设置是在企业管理员的控制之下的。管理员可以选择在这个 profile 之下，什么应用程序可以运行，什么设备功能可以允许。</p><p>如果一个设备有 managed profile，那么，无论应用程序在哪个 profile 之下运行，都意味着：</p><ul><li><p>默认情况下，大部分的 intent 无法从一个 profile 跨越到另一个。如果在某个 profile 之下的一个应用程序创建了 intent，而这个 profile 无法响应，又因为 profile 的限制这个 intent 不允许跨越到其他 profile，那么，这个请求就失败了，应用程序可能意外关闭。</p></li><li><p>profile 管理员可以在 managed profile 中限制哪个系统应用程序可以运行。这个限制可能导致在 managed profile 中一些常见的 intent 无法处理。</p></li><li><p>因为 managed profile 和非 managed profile 有各自的存储区域，导致文件 URI 在一个 profile 中有效，但在其他 profile 中无效。在一个 profile 中创建的 intent 可能在其他 profile（取决于 profile 设置）中被响应，所以在 intent 中放置文件 URI 是不安全的。</p></li></ul><p><a href="https://www.w3cschool.cn/android_training_course/android_training_course-t3xv27in.html">https://www.w3cschool.cn/android_training_course/android_training_course-t3xv27in.html</a></p><h3 id="5-3-SMS维护用户状态的变化UserState-Uss"><a href="#5-3-SMS维护用户状态的变化UserState-Uss" class="headerlink" title="5.3 SMS维护用户状态的变化UserState(Uss)"></a>5.3 SMS维护用户状态的变化UserState(Uss)</h3>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓fuse文件系统</title>
    <link href="/2023/05/31/%E5%AE%89%E5%8D%93fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/05/31/%E5%AE%89%E5%8D%93fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓fuse文件系统"><a href="#安卓fuse文件系统" class="headerlink" title="安卓fuse文件系统"></a>安卓fuse文件系统</h1><p><a href="https://xie.infoq.cn/article/655c0893ed150ff65f2b7a16f">https://xie.infoq.cn/article/655c0893ed150ff65f2b7a16f</a></p><h2 id="1-Fuse是什么"><a href="#1-Fuse是什么" class="headerlink" title="1.Fuse是什么"></a>1.Fuse是什么</h2><p>Linux内核官方文档对 FUSE 的解释如下：</p><blockquote><p>What is FUSE?FUSE is a userspace filesystem framework. It consists of a kernel module (fuse.ko), a userspace library (libfuse.*) and a mount utility (fusermount).</p></blockquote><p><strong>划重点：FUSE 是一个用来实现用户态文件系统的框架</strong>，这套 FUSE 框架包含 3 个组件：</p><ol><li><strong>内核模块</strong> <code>fuse.ko</code> ：用来接收 vfs 传递下来的 IO 请求，并且把这个 IO 封装之后通过管道发送到用户态；</li><li><strong>用户态 lib 库</strong> <code>libfuse</code> ：解析内核态转发出来的协议包，拆解成常规的 IO 请求；</li><li><strong>mount 工具</strong> <code>fusermount</code> ；</li></ol><p>这就是 FUSE 框架的 3 大内容了，下面我们解释下。这 3 个组件只为了完成一件事：让 IO 在内核态和用户态之间自由穿梭。</p><p>一般我们认为 FUSE 是 Filesystem in Userspace 的缩写，也就是常说的用户态文件系统。</p><h2 id="2-Fuse原理"><a href="#2-Fuse原理" class="headerlink" title="2.Fuse原理"></a>2.Fuse原理</h2><p>接下来我们看下 IO 的路径，来理解下 FUSE 的原理。首先看一眼 wiki 上有对 FUSE 的 <code>ls -l /tmp/fuse</code> 命令的演示图：</p><img src="/2023/05/31/%E5%AE%89%E5%8D%93fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/b360be6f915a98e85780454c03160882-1686063758401-3.png" alt="img" style="zoom: 50%;"><p>这个图的意思是：</p><ol><li>背景：一个用户态文件系统，挂载点为 <code>/tmp/fuse</code> ，用户二进制程序文件为 <code>./hello</code> ；</li><li>当执行 <code>ls -l /tmp/fuse</code> 命令的时候，流程如下：</li><li>IO 请求先进内核，经 vfs 传递给内核 FUSE 文件系统模块；</li><li>内核 FUSE 模块把请求发给到用户态，由 <code>./hello</code> 程序接收并且处理。处理完成之后，响应原路返回；</li></ol><p>简化的 IO 动画示意图：</p><img src="/2023/05/31/%E5%AE%89%E5%8D%93fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/fuse1.gif" alt="img" style="zoom: 67%;"><p>通过这两张图，对 FUSE IO 的流程应该就清晰了，内核 FUSE 模块在内核态中间做协议包装和协议解析的工作。承接 vfs 下来的请求并按照 FUSE 协议转发到用户态，然后接收用户态的响应，回复给用户。</p><p>FUSE 在这条 IO 路径是是指做了一个透明中转站的作用，用户完全不感知这套框架。我们把中间的 FUSE 当作一个黑盒遮住，就更容易理解了。<img src="/2023/05/31/%E5%AE%89%E5%8D%93fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/daa6faab9efe0b3c4271bc9db2eba122.gif" alt="img" style="zoom: 67%;"></p><p><strong>思考问题：内核的 fuse.ko 模块，还有 libfuse 库。这两个角色是的作用？</strong></p><p>⭐ 划重点：这两个模块一个位于内核，一个位于用户态，是配套使用的，<strong>最核心的功能是协议封装和解析</strong>。</p><p>举给例子，内核 fuse.ko 用于承接 vfs 下来的 io 请求，然后封装成 FUSE 数据包，转发给用户态。这个时候，用户态文件系统收到这个 FUSE 数据包，它如果想要看懂这个数据包，就必须实现一套 FUSE 协议的代码，这套代码是公开透明的，属于 FUSE 框架的公共的代码，这种代码不能够让所有的用户文件系统都重复实现一遍，<strong>于是 libfuse 用户库就诞生了</strong>。</p><blockquote><p>🔴<strong>安卓对于libfuse的引入：</strong></p><ul><li>文件路径: external\libfuse</li><li>编译生成：libfuse.so</li></ul><p>顺便介绍一下安卓源码目录external: Android引入的第三方库，Google会把一些比较优秀的开源库纳入到源码里面，比如app开发常用的okhttp，zxing，sqlite等</p></blockquote><p>回到开篇的问题，FUSE 能做什么？</p><p>看到这里你应该就清晰了，FUSE 能够转运 vfs 下来的 io 请求到用户态，用户程序处理之后，经由 FUSE 框架回应给用户。<strong>从而就可以把文件系统的实现全部放到用户态实现了</strong>。</p><h2 id="3-Fuse协议格式"><a href="#3-Fuse协议格式" class="headerlink" title="3.Fuse协议格式"></a>3.Fuse协议格式</h2><p>我们分析一眼 FUSE 数据转运的数据格式（ fuse 协议的格式 ），请求包和响应包是什么样子的呢？好奇不？</p><h3 id="3-1-Fuse请求包"><a href="#3-1-Fuse请求包" class="headerlink" title="3.1 Fuse请求包"></a>3.1 Fuse请求包</h3><ul><li><code>Header</code> ： 这个是所有请求共用的，比如 <code>open</code> 请求，<code>read</code> 请求，<code>write</code> 请求，<code>getxattr</code> 请求，头部都至少有这个结构体，<code>Header</code> 结构体能描述整个 FUSE 请求，其中字段能区分请求类型；</li><li><code>Payload</code> ：这个东西是每个 IO 类型会是不同的，比如 <code>read</code> 请求就没这个，<code>write</code> 请求就有这个，因为 <code>write</code> 请求是携带数据的；</li></ul><p>数据包分为两部分：header，payload 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">type inHeader <span class="hljs-keyword">struct</span> &#123;<br>  Len    uint32<br>  Opcode uint32<br>  Unique uint64<br>  Nodeid uint64<br>  Uid    uint32<br>  Gid    uint32<br>  Pid    uint32<br>  _      uint32<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Len: 是整个请求的字节数长度（<code>Header</code> + <code>Payload</code>）</li><li>Opcode: 请求的类型，比如区分 open、read、write 等等；</li><li>Unique: 请求唯一标识（和响应中要对应）</li><li>Nodeid: 请求针对的文件 nodeid，目标文件或者文件夹的 nodeid；</li><li>Uid: 文件&#x2F;文件夹操作的进程的用户 ID</li><li>Gid: 文件&#x2F;文件夹操作的进程的用户组 ID</li><li>Pid: 文件&#x2F;文件夹操作的进程的进程 ID</li></ul><h3 id="3-2-Fuse响应包"><a href="#3-2-Fuse响应包" class="headerlink" title="3.2 Fuse响应包"></a>3.2 Fuse响应包</h3><p>FUSE 响应包也分为两部分：</p><ul><li><code>Header</code> ：这个结构体也是在数据头部的，所有 IO 类型的响应都至少有这个结构体。该结构体用于描述整个响应请求；</li><li><code>Payload</code> ：每个请求的类型可能不同，比如 <code>read</code> 请求就会有这个，因为要携带 <code>read</code> 出来的用户数据，<code>write</code> 请求就不会有；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">type outHeader <span class="hljs-keyword">struct</span> &#123;<br>  Len    uint32<br>  Error  int32<br>  Unique uint64<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Len: 整个响应的字节数长度（ <code>Header</code> + <code>Payload</code> ）；</li><li>Error: 响应错误码，成功返回 0，其他对应着系统的错误代码，负数；</li><li>Unique: 对应者请求的唯一标识，和请求对应；</li></ul><h2 id="4-内核态、用户态的纽带"><a href="#4-内核态、用户态的纽带" class="headerlink" title="4.内核态、用户态的纽带"></a>4.内核态、用户态的纽带</h2><p>现在对数据协议的格式，转发和转运的模块我们也知道了。现在还差一个关键的点：<strong>数据包的通道</strong>，也就是高速公路。</p><p>换句话说，内核模块的“包裹”发到哪里？用户程序又从哪里读取拿到这个“包裹”。</p><p><strong>答案是：</strong><code>/dev/fuse</code> <strong>，这个虚设备文件就是内核模块和用户程序的桥梁。</strong></p><p>一切都顺理成章了，内核在这个过程中相当于一个信使，用户的 io 通过正常的系统调用进来，走到内核文件系统 fuse ，fuse 文件系统把这个 io 请求封装起来，打包成特定的格式，通过 <code>/dev/fuse</code> 这个管道传递到用户态。在此之前有守护进程监听这个管道，看到有消息出来之后，立马读出来，然后利用 <code>libfuse</code> 库解析协议，之后就是用户文件系统的代码逻辑了。</p><p>示意图如下（省略了拆解包的步骤）：</p><img src="/2023/05/31/%E5%AE%89%E5%8D%93fuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/0b7beda12f1ffea18de8c62fbfc3c941.gif" alt="img" style="zoom: 67%;">]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓中的控制反转IOC</title>
    <link href="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/"/>
    <url>/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓中的控制反转IOC"><a href="#安卓中的控制反转IOC" class="headerlink" title="安卓中的控制反转IOC"></a>安卓中的控制反转IOC</h1><h2 id="1-IOC简介"><a href="#1-IOC简介" class="headerlink" title="1.IOC简介"></a>1.IOC简介</h2><h3 id="1-1-IOC是什么"><a href="#1-1-IOC是什么" class="headerlink" title="1.1 IOC是什么"></a>1.1 IOC是什么</h3><p><strong>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。</strong>在Java开发中，<strong>Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong>如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p><p> ● <strong>谁控制谁，控制什么：</strong>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；<strong>谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</strong></p><p> ● <strong>为何是反转，哪些方面反转了：</strong>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？<strong>因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</strong></p><p>用图例说明一下，传统程序设计如图，都是主动去创建相关对象然后再组合起来：</p><img src="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/image1.png" style="zoom: 80%;"><p>当有了IoC的容器后，在客户端类中不再主动去创建这些对象了，如图所示:</p><img src="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/image2.png" style="zoom: 80%;"><h3 id="1-2-IOC能做什么"><a href="#1-2-IOC能做什么" class="headerlink" title="1.2 IOC能做什么"></a>1.2 IOC能做什么</h3><p>IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p><p> 其实<strong>IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC&#x2F;DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</strong></p><p>IOC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><h3 id="1-3-SpringIOC创建容器"><a href="#1-3-SpringIOC创建容器" class="headerlink" title="1.3 SpringIOC创建容器"></a>1.3 SpringIOC创建容器</h3><h4 id="1-3-1-原生耦合方式"><a href="#1-3-1-原生耦合方式" class="headerlink" title="1.3.1 原生耦合方式"></a>1.3.1 原生耦合方式</h4><ol><li>创建接口Animal</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建具体实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一只小猫咪！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一只小狗狗！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>创建Service层，需要调用dao层的数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">getInfo</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getInfo</span><span class="hljs-params">()</span> &#123;<br>        animal.info();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>测试类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        userService.getInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/image3.png" style="zoom: 80%;"><p>分析：假设测试类是我们目前的用户（客户端），我们需要得到猫的信息，需要去Service层创建一个猫的实例出来；如果我们需要得到狗的信息，需要去Service层创建一个狗的实例出来！这样代码耦合性太高，用户的需求被耦合在源码中！</p><h4 id="1-3-2-SpringIOC创建容器"><a href="#1-3-2-SpringIOC创建容器" class="headerlink" title="1.3.2 SpringIOC创建容器"></a>1.3.2 SpringIOC创建容器</h4><ol><li>原来的实现类中构建set方法！</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br><br>    <span class="hljs-keyword">private</span> Animal animal;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAnimal</span><span class="hljs-params">(Animal animal)</span> &#123;<br>        <span class="hljs-built_in">this</span>.animal = animal;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getInfo</span><span class="hljs-params">()</span> &#123;<br>        animal.info();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建bean容器管理文件<code>beans.xml</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.amx.dao.Cat&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.amx.dao.Dog&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userservice&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.amx.service.UserServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;animal&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;cat&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>进入测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">// 通过类路径获取beans容器的上下文环境context</span><br>       <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>       <span class="hljs-comment">// 获取beans容器中的userservice对象</span><br>       <span class="hljs-type">UserService</span> <span class="hljs-variable">userservice</span> <span class="hljs-operator">=</span> (UserService) context.getBean(<span class="hljs-string">&quot;userservice&quot;</span>);<br>       userservice.getInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：如果我们想要获取Cat的信息，只要用户去beans.xml文件中修改一下即可！如果我们想要过去Dog的信息，只要用户去beans.xml文件中修改为dog就行了！所有的主动权交给了用户手中！需要什么我们去容器中拿就行了~</p><h3 id="1-4-IOC容器、控制反转、依赖注入"><a href="#1-4-IOC容器、控制反转、依赖注入" class="headerlink" title="1.4 IOC容器、控制反转、依赖注入"></a>1.4 IOC容器、控制反转、依赖注入</h3><img src="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/image-20230531000336367.png" alt="image-20230531000336367" style="zoom:80%;"><img src="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/image-20230531000351949.png" alt="image-20230531000351949" style="zoom:80%;"><img src="/2023/05/30/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC/image-20230531000408614.png" alt="image-20230531000408614" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓内部存储和外部存储</title>
    <link href="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/"/>
    <url>/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓内部存储和外部存储"><a href="#安卓内部存储和外部存储" class="headerlink" title="安卓内部存储和外部存储"></a>安卓内部存储和外部存储</h1><blockquote><p>声明：以下内容摘录自各大神的博客，用于自己学习备忘，十分感激！</p><ul><li><a href="https://www.jianshu.com/p/a39bc4b3a1a6">https://www.jianshu.com/p/a39bc4b3a1a6</a></li></ul></blockquote><h2 id="1-内部存储"><a href="#1-内部存储" class="headerlink" title="1.内部存储"></a>1.内部存储</h2><p>内部存储，其实是手机ROM上的一块存储区域，主要用于存储系统以及应用程序的数据。内部存储在Android系统对应的根目录是 &#x2F;data&#x2F;data&#x2F;，这个目录普通用户是无权访问的，用户需要root权限才可以查看。不过我们可以通过Android Studio的View—-Tool Windows—-Device File Explorer工具来查看该目录，内部存储目录的大致结构如下所示。</p><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/webp.webp" alt="img" style="zoom: 80%;"><p>从上图可以看到，&#x2F;data&#x2F;data目录是按照应用的包名来组织的，每个应用都是属于自己的内部存储目录，而且目录的名称就是该应用的包名，这个目录是在安装应用的时候自动创建的，当应用被卸载后，该目录也会被系统自动删除。所以，如果你将数据存储于内部存储中，其实就是把数据存储到自己应用包名对应的内部存储目录中。每个应用的内部存储目录都是私有的，也就是说内部存储目录下的文件只能被应用自己访问到，其他应用是没有权限访问的。应用访问自己的内部存储目录时不需要申请任何权限。</p><p>一个应用典型的内部存储目录结构如下所示。</p><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/webp-1685371597396-3.webp" alt="img" style="zoom:80%;"><p>相信很多人看到内部存储的目录结构，都有似曾相识的感觉，没错我们平常经常和内部存储打交道，只不过我们不知道罢了，下面我们来看下内部存储目录下各个子目录的作用。</p><ul><li><strong>app_webview</strong>：主要用于存储webview加载过程中的数据，例如Cookie，LocalStorage等。</li><li><strong>cache</strong>：主要用于存储使用应用过程中产生的缓存数据。</li><li><strong>databases</strong>：主要用于存储数据库类型的数据。我们平常创建的数据库文件就是存储在这里。</li><li><strong>files</strong>：可以在该目录下存储配置文件，敏感数据等。</li><li><strong>shared_prefs</strong>：用于存储SharedPreference文件。我们使用SharedPreference的时候只指定了文件名，并没有指定存储路径，其实SP的文件就是保存到了这个目录下。</li></ul><p>那么有哪些API可以获取到内部存储目录呢，我们主要是使用Context类提供的接口来访问内部存储目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>getDataDir()  <span class="hljs-comment">//获取的目录是/data/user/0/package_name，即应用内部存储的根目录</span><br><span class="hljs-number">2.</span>getFilesDir() <span class="hljs-comment">//获取的目录是/data/user/0/package_name/files，即应用内部存储的files目录</span><br><span class="hljs-number">3.</span>getCacheDir() <span class="hljs-comment">//获取的目录是/data/user/0/package_name/cache，即应用内部存储的cache目录</span><br><span class="hljs-number">4.</span>getDir(String name, <span class="hljs-type">int</span> mode) <span class="hljs-comment">//获取的目录是/data/user/0/package_name/app_name，如果该目录不存在，系统会自动创建该目录。</span><br></code></pre></td></tr></table></figure><p>获取到对应的目录后，我们就可以对目录下的文件进行读写。细心的同学可能会发现代码中获取的内部存储根目录是 &#x2F;data&#x2F;user&#x2F;0，并不是前面提到的&#x2F;data&#x2F;data，这是怎么回事呢？因为在Android4.2以后增加了多用户的功能，为了适应多用户的功能，原来的&#x2F;data&#x2F;data&#x2F;相当于直接链接到当前用户文件夹的，变成了&#x2F;data&#x2F;user&#x2F;0&#x2F;，所以我们代码中打印出来的路径是&#x2F;data&#x2F;user&#x2F;0，而不是&#x2F;data&#x2F;data，<strong>说白了&#x2F;data&#x2F;data和&#x2F;data&#x2F;user&#x2F;0&#x2F;是一个东西</strong>。</p><p>内部存储空间容量有限，如果内部存储空间被用完，系统会报内存不足。所以，不要把所有的数据都放到内部存储中。在开发应用过程中，我们可以把较敏感的应用数据放在内部存储中，而其他的数据可以放在外部存储中。那外部存储又是什么呢？下面我们接着来学习外部存储。</p><h2 id="2-外部存储"><a href="#2-外部存储" class="headerlink" title="2.外部存储"></a>2.外部存储</h2><p>我们知道内部存储中的数据对应用来说是私密的，用户和其他应用都没有访问权限，而外部存储中的数据是可以被其他应用或用户访问甚至删除的，用户可以通过USB方式和PC之间交互外部存储中的数据。我们平常在Android手机的文件管理工具下看到的目录其实就是外部存储。在Android4.4以前，外部存储就是指SD卡，手机自带的存储就是内部存储；但是在Android4.4以后，随着手机机身存储越来越大，手机的机身存储已经可以满足大多数用户的需求，所以很多手机都不需要再安装SD卡。此时外部存储和内部存储都位于手机机身存储上，他们只是同一个存储介质上的不同存储区域。但是很多手机还是保留了SD卡插槽，方便用户自行拓展。如果手机安装了SD卡，那么很显然SD卡目录也属于外部存储目录。这时手机都有了两个外部存储空间，一个位于手机机身存储上，一个位于SD卡上。但是随着机身存储越累越大，SD卡一般可能只适用于转移文件，对于一般应用来说应该也不会把数据写到外置的SD卡上了，所以这里主要以机身存储为例来分析外部存储。</p><h3 id="2-1-外部私有存储目录"><a href="#2-1-外部私有存储目录" class="headerlink" title="2.1 外部私有存储目录"></a>2.1 外部私有存储目录</h3><p>通常来说，应用涉及到的持久化数据一般分为两类：应用相关数据和应用无关数据。前者是指应用使用的数据信息，比如一些配置信息，调试信息，缓存文件等。当应用被卸载，这些信息也应该被随之删除，避免占用不必要的存储空间。例如下面两种场景。</p><ul><li>在用户使用应用过程中，产生的文件，图片，视频，音频等数据，这些数据不太敏感但是占用空间比较大，卸载App时不希望这些数据继续保留在用户手机中。</li><li>当应用发生闪退时，希望把一些闪退信息保存下来，让用户获取闪退信息文件后通过特定渠道发送给开发人员进行问题定位。同样的，这些信息在卸载App后也不希望继续留在用户手机中。</li></ul><p>对于问题一，我们可以直接把数据存储在内部存储中，但是考虑到内部存储空间有限，把这些数据存储到内部存储会浪费内部存储的空间。对于问题二，普通用户（指没有root权限的用户）无法直接查看其中的文件，把数据直接存储在内部存储中是行不通的。这些数据有一个共同点就是他们的生命周期和应用是一致的，而且不太适合于放在内部存储中。为了存储这种类型的数据，Android规定来一个专门的存储空间，这个空间被称为外部私有存储空间。外部私有存储空间属于外部存储，对于某个应用来说，外部私有存储的根目录（这里暂时不考虑SD卡）是 &#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;package_name，这个目录有点类似于内部存储目录，都是以包名来命名私有存储空间的。外部私有存储空间有以下特点</p><ul><li>内部私有存储中的数据会随着App的卸载一起删除</li><li>仅仅安装应用不会在&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;目录下生成该应用的外部私有存储目录，只有在应用中调用API访问外部私有存储目录时，才会创建以package_name命名的私有存储目录。</li><li>App在访问自己的外部私有存储目录时不需要任何权限</li><li>自 Android 7.0 开始，系统对外部存储目录中 应用私有目录的访问权限进一步限制。其他 App 无法通过 file:&#x2F;&#x2F; 这种形式的 Uri 直接读写其他应用的外部私有存储目录，而是需要通过 FileProvider 访问</li></ul><p>在代码中我们可以通过以下方式来获取外部私有存储目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>getExternalCacheDir() <br><span class="hljs-comment">/*获取到的目录是/storage/emulated/0/Android/data/package_name/cache，如果该目录不存在，调用这个方法会自动创建该目录。*/</span><br><span class="hljs-number">2.</span>getExternalFilesDir(String type) <br><span class="hljs-comment">/* 1.如果type为&quot;&quot;，那么获取到的目录是 /storage/emulated/0/Android/data/package_name/files</span><br><span class="hljs-comment">   2.如果type不为空，则会在/storage/emulated/0/Android/data/package_name/files目录下创建一个以传入的type值为名称的目录，例如你将type设为了test，那么就会创建/storage/emulated/0/Android/data/package_name/files/test目录，这个其实有点类似于内部存储getDir方法传入的name参数。但是android官方推荐使用以下的type类型</span><br><span class="hljs-comment">   public static String DIRECTORY_MUSIC = &quot;Music&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_PODCASTS = &quot;Podcasts&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_RINGTONES = &quot;Ringtones&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_ALARMS = &quot;Alarms&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_NOTIFICATIONS = &quot;Notifications&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_PICTURES = &quot;Pictures&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_MOVIES = &quot;Movies&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_DOWNLOADS = &quot;Download&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_DCIM = &quot;DCIM&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_DOCUMENTS = &quot;Documents&quot;;*/</span><br></code></pre></td></tr></table></figure><h3 id="2-2-外部共有存储目录"><a href="#2-2-外部共有存储目录" class="headerlink" title="2.2 外部共有存储目录"></a>2.2 外部共有存储目录</h3><p>外部存储目录还有一个存储空间就是外部共有存储目录，顾名思义，外部共有存储目录存储的数据无论对应用还是用户都是可见的应用只要有外部访问权限，就可以读取外部公共目录下的文件。外部公共目录主要存放和应用无关的数据，这些数据在卸载App的时候不会被删除。外部共有存储目录有以下特点。</p><ul><li>当卸载App时，共有存储目录下的文件不会被删除</li><li>应用在访问外部公有目录之前，首先要申请外部存储权限，在Android6.0以后，外部存储权限还要动态申请。</li><li>任何应用只要有外部存储权限，都可以访问共有存储目录下的数据。</li></ul><p>在代码中，我们可以通过以下方式来访问外部公共存储目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>Environment.getExternalStorageDirectory() <br><span class="hljs-comment">//获取到的目录是/storage/emulated/0,这个也是外部存储的根目录。</span><br><span class="hljs-number">2.</span>Environment.getExternalStoragePublicDirectory(String type) <br><span class="hljs-comment">/* 1.如果type为&quot;&quot;，那么获取到的目录是外部存储的根目录即  /storage/emulated/0</span><br><span class="hljs-comment">   2.如果type不为空，则会在/storage/emulated/0目录下创建一个以传入的type值为名称的目录，例如你将type设为了test，那么就在外部存储根目录下创建test目录，这个方法和getExternalFilesDir的用法一样。android官方推荐使用以下的type类型，我们在SK卡的根目录下也经常可以看到下面的某些目录。</span><br><span class="hljs-comment">   public static String DIRECTORY_MUSIC = &quot;Music&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_PODCASTS = &quot;Podcasts&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_RINGTONES = &quot;Ringtones&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_ALARMS = &quot;Alarms&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_NOTIFICATIONS = &quot;Notifications&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_PICTURES = &quot;Pictures&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_MOVIES = &quot;Movies&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_DOWNLOADS = &quot;Download&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_DCIM = &quot;DCIM&quot;;</span><br><span class="hljs-comment">   public static String DIRECTORY_DOCUMENTS = &quot;Documents&quot;;*/</span><br></code></pre></td></tr></table></figure><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/v2-76c6e06d688756944ccba4a85236dd7b_r.jpg" alt="img" style="zoom:67%;"><blockquote><p>图片来源：<a href="https://zhuanlan.zhihu.com/p/165140637%EF%BC%8C%E4%BD%9C%E8%80%85%EF%BC%9A[Bgwan](https://www.zhihu.com/people/qydq)">https://zhuanlan.zhihu.com/p/165140637，作者：[Bgwan](https://www.zhihu.com/people/qydq)</a></p></blockquote><h2 id="3-外部存储和内部存储对比"><a href="#3-外部存储和内部存储对比" class="headerlink" title="3.外部存储和内部存储对比"></a>3.外部存储和内部存储对比</h2><p>要区分外部存储和内部存储，我们最好从逻辑上来理解这两个概念，而不是从物理上。虽然在Android4.4以前，逻辑上和物理上是统一的，但是Android4.4以后，随着外置SD卡的使用越来越少，内部存储和外部存储和物理介质的内外就没有任何关系了。</p><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/webp-1685373896034-6.webp" alt="img" style="zoom:67%;"><h2 id="4-疑惑解答"><a href="#4-疑惑解答" class="headerlink" title="4.疑惑解答"></a>4.疑惑解答</h2><h3 id="4-1-内置的外部存储和SD卡有啥区别"><a href="#4-1-内置的外部存储和SD卡有啥区别" class="headerlink" title="4.1 内置的外部存储和SD卡有啥区别"></a>4.1 内置的外部存储和SD卡有啥区别</h3><p>在4.4以后的系统中，API提供了这样一个方法来遍历手机的外部存储路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">File[] files;<br><span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;<br>    files = getExternalFilesDirs(Environment.MEDIA_MOUNTED);<br>    <span class="hljs-keyword">for</span>(File file:files)&#123;<br>        Log.e(<span class="hljs-string">&quot;main&quot;</span>,file);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你的手机插了SD卡的话，那么它打印的路径就有两条了，例如我的华为荣耀7插了SD卡，它的结果如下：</p><ul><li>&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;packname&#x2F;files&#x2F;mounted</li><li>&#x2F;storage&#x2F;B3E4-1711&#x2F;Android&#x2F;data&#x2F;packname&#x2F;files&#x2F;mounted</li></ul><p>其中&#x2F;storage&#x2F;emulated&#x2F;0目录就是机身存储的外部存储路径，而&#x2F;storage&#x2F;B3E4-1711&#x2F;就是SD卡的路径，他们统称为外部存储</p><h3 id="4-2-主存储是什么"><a href="#4-2-主存储是什么" class="headerlink" title="4.2 主存储是什么"></a>4.2 主存储是什么</h3><blockquote><p>来源：<a href="https://fqzhanghao.github.io/post/android-cun-chu-wa-keng-ji/">https://fqzhanghao.github.io/post/android-cun-chu-wa-keng-ji/</a></p></blockquote><p>这个Primary和Secondary是怎么来的呢？实际上最开始Android也没有考虑这个区分，但是后来有一个情况发生了，就是上面所说到的：</p><p>后来部分手机开始将最初定义的“Internal Storage”，即内置存储，分成Internal和External两部分。</p><p>那么如果这个时候手机再插入sd卡，那不是有多个External Storage了吗？</p><p>这个时候，<strong>从Internal Storage里面分出来的那块“External Storage”我们称之为主存储(Primary Storage)，插入的外置储存称之为副存储(Secondary Storage)。</strong></p><p>主存储路径的获取方式非常简单，可以通过Environment.getExternalStorageDirectory()或者Context.getExternalFilesDir(null)来获取。</p><p>副存储路径在4.4及以上的Android系统中，可以使用Context.getExternalFilesDirs(null)(注意最后多了一个’s’)，它返回的是一个字符串数组。第0个就是主存储路径，第1个是副存储路径（如果有的话）。从4.1也可以证明！！！</p><h3 id="4-3-Adoptable-Storage"><a href="#4-3-Adoptable-Storage" class="headerlink" title="4.3 Adoptable Storage"></a>4.3 Adoptable Storage</h3><p>由于External Storage的缺点（有时不可用，存储内容没有被保护），在6.0之后多出了<code>Adoptable</code>存储方式。</p><p>当Android系统<code>Adopt</code>了一块External存储区域的时候，它会被视为Internal Storage，同时会被格式化与加密。格式化之后是GPT分区，存储上线为9ZB。</p><p>当你在一个支持<code>Adoptable Storage</code>的手机上插入一个sd卡，它会提示你是否将这个sd卡格式化并用作Internal Storage，或者正常作为External Storage使用。</p><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/731da63df8dcd100f5e720dd758b4710b8122f29.jpg" alt="img" style="zoom:67%;"><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/d7e7c1dcd100baa19d579f474010b912c9fc2e29.jpg" alt="img" style="zoom:67%;"><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/f27bf411728b4710ea542530c4cec3fdfd032329.jpg" alt="img" style="zoom:67%;"><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/85cb4b8b4710b9129cba2e02c4fdfc0393452229.jpg" alt="img" style="zoom:67%;"><img src="/2023/05/29/%E5%AE%89%E5%8D%93%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/3a517e10b912c8fc96882e31fb039245d7882129.jpg" alt="img" style="zoom: 67%;"><h3 id="4-4-私有卷PrivateVolume"><a href="#4-4-私有卷PrivateVolume" class="headerlink" title="4.4 私有卷PrivateVolume"></a>4.4 私有卷PrivateVolume</h3><p><a href="https://blog.csdn.net/woai110120130/article/details/107701932">https://blog.csdn.net/woai110120130/article/details/107701932</a></p><p>PrivateVolume分区用于将外置存储转为内置存储使用的，并且PrivateVolume是使用全盘加密的。所以PrivateVolume是和Android设备强相关的，把包含PrivateVolume的磁盘介质拿到其他手机上是无法解密挂载的。所以PrivateVolume必然是在Android设备上来进行格式化的。每个PrivateVolume还对应一个EmulatedVolume分区，这个EmulatedVolume可以作为主分区挂载。 <strong>对于&#x2F;data分区的挂载不由Vold服务来管理</strong>，所以MountService会主动添加一个PrivateVolume来对应&#x2F;data分区，Vold服务会主动添加一个EmulatedVolume来对应&#x2F;data这个PrivateVolume分区。</p><ul><li>当没有其他设备被格式化为PrivateVolume且要求使用Private分区来作为主存储的时候，就使用&#x2F;data分区对应的EmulatedVolume来作为主外置存储。</li><li>当我们格式化了一个PrivateVolume的时候，我们可以选择将主分区移动到新增的这个PrivateVolume对应的EmulatedVolume上。</li></ul><p>EmulatedVolume 为主分区的时才会被挂载，一个EmulatedVolume一般使用PrivateVolume挂载的根目录下的media目录，作为fuse的后端使用，使用fuse主要方便存储权限的管理，提供更灵活的权限管理机制。我们会在后面还分析fuse实现的存储目录。下面我们来分析下磁盘的格式化过程。</p>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑卷管理LVM</title>
    <link href="/2023/05/28/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86LVM/"/>
    <url>/2023/05/28/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86LVM/</url>
    
    <content type="html"><![CDATA[<h1 id="逻辑卷管理LVM"><a href="#逻辑卷管理LVM" class="headerlink" title="逻辑卷管理LVM"></a>逻辑卷管理LVM</h1><h2 id="1-为什么会出现逻辑卷"><a href="#1-为什么会出现逻辑卷" class="headerlink" title="1.为什么会出现逻辑卷"></a>1.为什么会出现逻辑卷</h2><p>每个Linux使用者在安装Linux时 都会遇到这样的困境：在为系统分区时，如何精确评估和分配各个硬盘分区的容量，因为系统管理员不但要考虑到当前某个分区需要的容量，还要预见该分区以后可能需要的容量的最大值。因为如果估计不准确，当遇到某个分区不够用时管理员可能甚至要备份整个系统、清除硬盘、重新对硬盘分区，然后恢复数据到新分区。</p><p>虽然现在有很多动态调整磁盘的工具可以使用，例如Partation Magic等等，但是它并不能完全解决问题，因为某个分区可能会再次被耗尽；另外一个方面这需要重新引导系统才能实现，对于很多关键的服务器，停机是不可接受的，而且对于添加新硬盘，希望一个能跨越多个硬盘驱动器的文件系统时，分区调整程序就不能解决问题。</p><p>因此完美的解决方法应该是在零停机前提下可以自如对文件系统的大小进行调整，可以方便实现文件系统跨越不同磁盘和分区。那么我们可以通过逻辑盘卷管理（LVM，Logical Volume Manager）的方式来非常完美的实现这一功能。</p><p>LVM是逻辑盘卷管理（Logical Volume Manager）的简称，他是磁盘管理的另一种工具，就目前基本上所有操作系统均支持，LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。通过LVM系统管理员可以轻松管理磁盘分区，如：将若干个磁盘分区连接为一个整块的卷组（volume group），形成一个存储池。管理员可以在卷组上随意创建逻辑卷组（logical volumes），并进一步在逻辑卷组上创建文件系统。管理员通过LVM可以方便的调整存储卷组的大小，并且可以对磁盘存储按照组的方式进行命名、管理和分配，例如按照使用用途进行定义：“DBdata”和“DBSoft”，而不是使用物理磁盘名“sda”和“sdb”或”hda”和”hdb”。而且当系统添加了新的磁盘，通过LVM管理员就不必将磁盘的文件移动到新的磁盘上以充分利用新的存储空间，而是直接扩展文件系统跨越磁盘即可，架构可以参考如下图：</p><img src="/2023/05/28/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86LVM/5f6824ed3294480aa7d2d13a293a3cdf.jpeg" alt="磁盘、分区、物理卷、卷组、逻辑卷关系" style="zoom:67%;"><h2 id="2-LVM基本结构"><a href="#2-LVM基本结构" class="headerlink" title="2.LVM基本结构"></a>2.LVM基本结构</h2><p><strong>物理存储介质（The physical media）</strong></p><p>这里指系统的存储设备：硬盘，如：&#x2F;dev&#x2F;hda、&#x2F;dev&#x2F;sda等等，是存储系统最低层的存储单元。</p><p><strong>物理卷（physicalvolume）</strong></p><p>物理卷就是指硬盘分区或从逻辑上与磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有与LVM相关的管理参数。</p><p><strong>卷组（Volume Group）</strong></p><p>LVM卷组类似于非LVM系统中的物理硬盘，其由物理卷组成。可以在卷组上创建一个或多个“LVM分区”（逻辑卷），LVM卷组由一个或多个物理卷组成。</p><p><strong>逻辑卷（logicalvolume）</strong></p><p>LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷之上可以建立文件系统(比如&#x2F;home或者&#x2F;usr等)。</p><p><strong>PE（physical extent）</strong></p><p>每一个物理卷被划分为称为PE(Physical Extents)的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是可配置的，默认为4MB。</p><p><strong>LE（logical extent）</strong></p><p>逻辑卷也被划分为被称为LE(Logical Extents) 的可被寻址的基本单位。在同一个卷组中，LE的大小和PE是相同的，并且一一对应。</p><img src="/2023/05/28/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86LVM/image-20230528220753173.png" alt="image-20230528220753173" style="zoom:67%;"><p>🤖<strong>注意：一个逻辑卷只能来自于一个卷组</strong></p><h2 id="3-LVM管理命令"><a href="#3-LVM管理命令" class="headerlink" title="3.LVM管理命令"></a>3.LVM管理命令</h2><img src="/2023/05/28/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86LVM/980b51f31966e6d9d5e5245f04c1cedcf46905.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom:67%;"><p><img src="https://dl-harmonyos.51cto.com/images/202101/980b51f31966e6d9d5e5245f04c1cedcf46905.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区"></p><p>主要命令的用法<br>（1）pvcreate 设备名<br>（2）vgcreate -s 8M 卷组名 物理卷名1 物理卷名2<br>（3）lvcreate -L 大小 -n 逻辑卷名 卷组名<br>（4）lvextend -L +大小 &#x2F;dev&#x2F;卷组名&#x2F;逻辑卷名<br>（5）lvreduce –L +大小 &#x2F;dev&#x2F;卷组名&#x2F;逻辑卷名</p><p>其余操作见：<a href="https://www.cnblogs.com/cloudos/p/9348315.html">https://www.cnblogs.com/cloudos/p/9348315.html</a></p><h2 id="4-LVM应用示例"><a href="#4-LVM应用示例" class="headerlink" title="4.LVM应用示例"></a>4.LVM应用示例</h2><p><strong>需求描述：</strong></p><blockquote><p>公司的邮件服务器由于用户数量众多，邮件存储需要大量的空间，考虑到动态扩容的需要，计划增加两块SCSI硬盘并构建LVM逻辑卷，挂载到“&#x2F;mail”目录专门用于存放邮件数</p></blockquote><p><strong>推荐步骤：</strong></p><blockquote><p>PV -&gt; VG -&gt; LV -&gt; 格式化-&gt;挂载使用文件系统</p></blockquote><img src="https://dl-harmonyos.51cto.com/images/202101/55f57c1699f0f7186137194b65b95fb109435f.png" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom:67%;"><p>第一步：转化物理卷<br>（1）使用fdisk命令规划两个分区，类型设置为“8e”：&#x2F;dev&#x2F;sdb1、&#x2F;dev&#x2F;sdc1<br>（2）使用pvcreate命令转换上述分区为物理卷</p><img src="/2023/05/28/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86LVM/04457b6915ed6816e27022c660e5ff0520395e.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom:67%;"><p>第二步：创建卷组<br>（1）使用vgcreate命令创建卷组mail_store（包括物卷：&#x2F;dec&#x2F;sdb1、&#x2F;dev&#x2F;sdc1）</p><img src="https://dl-harmonyos.51cto.com/images/202101/11476c03152237e8f1a533caa7b1aeaecaf618.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom: 67%;"><p>第三步：创建逻辑卷<br>（1）使用lvcreate命令创建逻辑卷mail， 从卷组mail_store上划出60GB空间<br>（2）使用mkfs命令创建ext4文件系统</p><img src="https://dl-harmonyos.51cto.com/images/202101/094608f00cd07bc6ae6632a3d6eec1b17f5b25.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom:67%;"><p>为逻辑卷扩容：<br>（1）使用lvextend命令为逻辑卷mail扩充容量， 从卷组mail_store上再划出10GB给逻辑卷mail<br>（2）使用resize2fs命令更新系统识别的文件系统大小</p><img src="https://dl-harmonyos.51cto.com/images/202101/838bfd311007d0d077f1443f83161fdc7833db.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom:67%;"><p>为逻辑卷缩减<br>（1）使用lvreduce命令为逻辑卷 mail缩减容量,必须先卸载， 从卷组 mail_store 上缩小逻辑卷mail到10G<br>（2）使用resize2fs命令更新系统识别的文件系统大小<br>（3）使用fsck 命令清理文件系统数据结构</p><img src="https://dl-harmonyos.51cto.com/images/202101/471b8156850e604a8f9098ea07c682d086fee4.jpg" alt="Linux学习笔记——逻辑卷管理（LVM）-开源基础软件社区" style="zoom:67%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>哈工大刘宏伟老师计算机组成原理</title>
    <link href="/2023/05/22/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%88%98%E5%AE%8F%E4%BC%9F%E8%80%81%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2023/05/22/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%88%98%E5%AE%8F%E4%BC%9F%E8%80%81%E5%B8%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="哈工大刘宏伟老师计算机组成原理"><a href="#哈工大刘宏伟老师计算机组成原理" class="headerlink" title="哈工大刘宏伟老师计算机组成原理"></a>哈工大刘宏伟老师计算机组成原理</h1><ul><li><a href="https://anmuxixixi.github.io/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/">计算机组成原理(一)计算机系统概论_</a></li><li><a href="https://anmuxixixi.github.io/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/">计算机组成原理(三)总线_</a></li><li><a href="https://anmuxixixi.github.io/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/">计算机组成原理(四)存储器</a></li><li><a href="https://anmuxixixi.github.io/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/">计算机组成原理(五)输入输出系统</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理(六)计算机的运算方法</title>
    <link href="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <url>/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-六-计算机的运算方法"><a href="#计算机组成原理-六-计算机的运算方法" class="headerlink" title="计算机组成原理(六)计算机的运算方法"></a>计算机组成原理(六)计算机的运算方法</h1><h2 id="1-无符号数和有符号数"><a href="#1-无符号数和有符号数" class="headerlink" title="1.无符号数和有符号数"></a>1.无符号数和有符号数</h2><p>在计算机中参与运算的数有两大类：<strong>无符号数、有符号数</strong></p><h3 id="1-1-无符号数"><a href="#1-1-无符号数" class="headerlink" title="1.1 无符号数"></a>1.1 无符号数</h3><p>计算机中的数均放在寄存器中,通常称寄存器的位数为机器字长。所谓无符号数,即没有符号的数,在寄存器中的每一位均可用来存放数值。当存放有符号数时,则需留出位置存放符号。因此,在机器字长相同时,无符号数与有符号数所对应的数值范围是不同的。以机器字长为16位为例,无符号数的表示范围为0 ~65535,而有符号数的表示范围为– 32768 ~ +32767。</p><h3 id="1-2-有符号数"><a href="#1-2-有符号数" class="headerlink" title="1.2 有符号数"></a>1.2 有符号数</h3><h4 id="1-2-1-机器数与真值"><a href="#1-2-1-机器数与真值" class="headerlink" title="1.2.1 机器数与真值"></a>1.2.1 机器数与真值</h4><p>对于有符号数而言，在计算机中用0-&gt;正，1-&gt;负，相当于符号被数字化了，并规定放在有效数字的前面，即组成了有符号数。</p><p>例如，<strong>有符号数的小数</strong>表示：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/20190814152551628.png" alt="在这里插入图片描述" style="zoom: 67%;"><p><strong>有符号数的整数</strong>表示：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/20190814152625574.png" alt="在这里插入图片描述" style="zoom:67%;"><p><strong>把符号数字化</strong>的数称为机器数，而把带”+”,”-“符号的数称为真值，一旦符号数字化后，符号的数值就形成了一种新的编码。</p><p><strong>在运算过程中，</strong><br>符号位能否和数值部分一起参加运算？<br>如果参加运算，符号位又需作哪些处理？<br>这些问题都与符号位和数值位所构成的编码有关，<strong>这些编码就是原码、反码、补码、移码。</strong></p><h4 id="1-2-2-原码"><a href="#1-2-2-原码" class="headerlink" title="1.2.2 原码"></a>1.2.2 原码</h4><p>原码表示法又称为<strong>带符号的绝对值表示</strong>，规定<strong>整数的符号位与数值之间用逗号隔开</strong>，<strong>小数的符号位与数值位之间用小数点隔开</strong>。</p><p>例如：<br>+0.1011 原码:0.1011<br>-0.1011 原码:1.1011<br>+1100 原码:0,1100<br>-1100 原码:1,1100</p><p><strong>整数原码的定义为：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA4Nzky,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom: 80%;"><p><strong>小数原码的定义为：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/20190814154044718.png" alt="在这里插入图片描述" style="zoom:80%;"><p><strong>举例说明：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/7d202230edd82e99eb5c7c0c0916473a.png" alt="image-20220508105918404" style="zoom:67%;"><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/23cdcb021ddac4aba19ef6bb50b35b20.png" alt="image-20220508110018469" style="zoom: 67%;"><p>原码表示简单明了,并易于和真值转换。但用原码进行加减运算时,却带来了许多麻烦。例如,当两个操作数符号不同且要作加法运算时,先要判断两数绝对值大小,然后将绝对值大的数减去绝对值小的数,结果的符号以绝对值大的数为准。运算步骤既复杂又费时,而且本来是加法运算却要用减法器实现。那么能否在计算机中只设加法器,只作加法操作呢?如果能找到一个与负数等价的正数来代替该负数,就可把减法操作用加法代替。而机器数采用补码时,就能满足此要求。</p><h4 id="1-2-3-补码"><a href="#1-2-3-补码" class="headerlink" title="1.2.3 补码"></a>1.2.3 补码</h4><p>在日常生活中，常会遇到“补数”的概念。例如，时钟指示6点，欲使它指示3点，既可按照顺时针方向将分钟转9圈，又可按照逆时针方向就分针转3圈，结果是一致。假设顺时针方向转为正，逆时针方向为负，则有</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/4b97c15569cc6ba39a00760b724a322e.png" alt="img" style="zoom: 50%;"><p>由于时钟的时针转一圈能指示12个小时,这“12”在时钟里是不被显示而自动丢失的,即15 -12&#x3D;3,故15点和3点均显示3点。这样-3和+9对时钟而言其作用是一致的。在数学上称12为模,写作mod 12,而称＋9是-3以12为模的补数,记作</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522225611392.png" alt="image-20230522225611392" style="zoom:67%;"><p>或者说，对模12而言，-3和+9是互为补数的。同理有：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522225718188.png" alt="image-20230522225718188" style="zoom: 67%;"><p>即对模12而言，+8和+7分为-4和-5的补数。可见，只要确定了“模”，就可找到一个与负数等价的正数（该正数即为负数的补数）来代替此负数，这样就可把减法运算用加法实现。例如：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA4Nzky,size_16,color_FFFFFF,t_70-1684767570485-15.png" alt="在这里插入图片描述" style="zoom:67%;"><ul><li>一个负数可用它的正补数来代替，而这个正补数可以用模加上负数本身求得</li><li>一个正数和一个负数互为补数时，它们绝对值之和即为模数</li><li>正数的补数即该补数本身。</li></ul><p>⭐<strong>补数的定义为：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/2800eed80de4eb89b325dd35c9a6991c.png" alt="img" style="zoom:40%;"><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/08a761ee8df15187290b436eac2f6fb6.png" alt="img" style="zoom: 40%;"><p>💟<strong>求补码的快捷方式</strong>【<strong>补码的模&#x3D;数值位数+1</strong>】</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522230946615.png" alt="image-20230522230946615" style="zoom:50%;"><blockquote><p>对于小数而言，就是符号位不变，后面的原码取反+1</p></blockquote><p>下面举几个例子：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522231029116.png" alt="image-20230522231029116" style="zoom: 48%;"><img src="https://img-blog.csdnimg.cn/img_convert/49174e17be37f264204c5e97f817887b.png" alt="img" style="zoom: 33%;"><h4 id="1-2-4-反码"><a href="#1-2-4-反码" class="headerlink" title="1.2.4 反码"></a>1.2.4 反码</h4><p><strong>正数的定义：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522234349056.png" alt="image-20230522234349056" style="zoom: 33%;"><p><strong>小数的定义：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522234404699.png" alt="image-20230522234404699" style="zoom:33%;"><p>举例：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/fb57719b0df2edf16e0b203e7e4db511.png" alt="img" style="zoom: 33%;"><blockquote><ul><li>对正数而言，反码是其本身</li><li>对负数而言，符号位不变，数值位每一位取反</li></ul></blockquote><p>实际上,反码也可看做是mod (2-2^(-n))(对于小数)或mod (2^(n+1)-1)(对于整数)的补码。<strong>与补码相比,仅在末位差1</strong>,因此有些书上称小数的补码为2的补码,而称小数的反码为1的补码。</p><h4 id="1-2-5-三种机器数的小结"><a href="#1-2-5-三种机器数的小结" class="headerlink" title="1.2.5 三种机器数的小结"></a>1.2.5 三种机器数的小结</h4><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522234915110.png" alt="image-20230522234915110" style="zoom:50%;"><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522234927867.png" alt="image-20230522234927867" style="zoom:50%;"><p><strong>下面这个规律要记住：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522234938601.png" alt="image-20230522234938601" style="zoom:50%;"><h4 id="1-2-6-移码"><a href="#1-2-6-移码" class="headerlink" title="1.2.6 移码"></a>1.2.6 移码</h4><p>补码通常你很难判断真值的带下，所以我们要把补码平移成都是从0开始，这样都就可以比较大小了。</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/e62a7bfd020380910a42d7f8faec3c2f.png" alt="image-20220510154451727" style="zoom: 67%;"><p>移码的定义如下：</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/b4bf63a93c2fefa9f650653801862921-1684770839332-39.png" alt="image-20220510161827115" style="zoom:33%;"><p>其实移码就是在真值上加一个常数2^n。在数轴上移码所表示的范围恰好对应于真值在数轴上的范围向轴的正方向移动2^n个单元,如上图所示,由此而得移码之称。</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA4Nzky,size_16,color_FFFFFF,t_70-1684770798778-36.png" alt="在这里插入图片描述" style="zoom:80%;"><p>进一步观察发现,<strong>同一个真值的移码和补码仅差一个符号位</strong>,若将补码的符号位由“0”改为“1”,或从“1”改为“O”,即可得该真值的移码。下表列出了真值、补码和移码的对应关系。</p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20230522235250588.png" alt="image-20230522235250588" style="zoom:50%;"><p><strong>移码的特点：</strong></p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/861c855d1c3690b159db2e1136862ac7.png" alt="image-20220510164307143" style="zoom: 50%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理(五)输入输出系统</title>
    <link href="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-五-输入输出系统"><a href="#计算机组成原理-五-输入输出系统" class="headerlink" title="计算机组成原理(五)输入输出系统"></a>计算机组成原理(五)输入输出系统</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1-发展概况"><a href="#1-1-发展概况" class="headerlink" title="1.1 发展概况"></a>1.1 发展概况</h3><p><strong>（1）早期阶段</strong></p><p>早期的I&#x2F;O设备种类较少，I&#x2F;O设备与主存交换信息都必须通过CPU：、</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/57eed5f957a849f9ac5ab2be50107f64.png" alt="在这里插入图片描述" style="zoom:67%;"><ul><li>每个I&#x2F;O设备都必须配有一套独立的逻辑电路与CPU相连，<strong>线路十分散乱、庞杂</strong>。</li><li>输入输出过程是穿插在CPU执行程序过程之中进行的，<strong>工作效率低</strong>。</li><li>每个I&#x2F;0设备的逻辑控制电路与CPU的控制器紧密构成一个不可分割的整体，<strong>可扩展性低</strong>。</li></ul><p><strong>（2）接口模块和DMA阶段</strong></p><p>这个阶段I&#x2F;O设备通过接口模块与主机连接，计算机系统采用了总线结构：</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/b1988599f220489cb0da4cc73805a1ea.png" alt="在这里插入图片描述" style="zoom:67%;"><ul><li>数据经过接口既起到缓冲作用，又可完成串并变换。</li><li>接口能满足中断请求处理的要求，使I&#x2F;O设备与CPU可按并行方式工作，大大地提高了CPU的工作效率。</li><li>接口技术还可以使多台I&#x2F;O设备分时占用总线，使多台I&#x2F;O设备互相之间也可实现并行工作方式，有利于整机工作效率的提高。</li></ul><p>为了进一步提高CPU的工作效率，又出现了直接存储器存取(Direct Memory Access,DMA)技术：</p><ul><li>I&#x2F;O设备与主存之间有一条直接数据通路；</li><li>I&#x2F;O设备可以与主存直接交换信息，使CPU在I&#x2F;O设备与主存交换信息时能继续完成自身的工作，故资源利用率得到了进一步提高。</li></ul><p><strong>（3）具有通道结构的阶段</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/d3f62d3e4e79426c9eefbd41ee0955af.png" alt="在这里插入图片描述" style="zoom:67%;"><ul><li>通道是用来负责管理I&#x2F;O设备以及实现主存与I&#x2F;O设备之间交换信息的部件。</li><li>通道有专用的通道指令，能独立地执行用通道指令所编写的输入输出程序，是从属于CPU的一个专用处理器。</li><li>依赖通道管理的I&#x2F;O设备在与主机交换信息时，CPU不直接参与管理，故提高了CPU的资源利用率。</li></ul><p><strong>（4）具有I&#x2F;O处理机的阶段</strong></p><p>输入输出系统发展到第四阶段，出现了I&#x2F;O处理机：</p><ul><li>I&#x2F;O处理机又称为外围处理机(Peripheral Processor)；</li><li>它基本独立于主机工作，既可完成I&#x2F;O通道要完成的I&#x2F;O控制，又可完成码制变换、格式处理、数据块检错、纠错等操作。</li><li>具有I&#x2F;O处理机的输入输出系统与CPU工作的并行性更高，这说明I&#x2F;O系统对主机来说具有更大的独立性。</li></ul><h3 id="1-2-输入输出系统的组成"><a href="#1-2-输入输出系统的组成" class="headerlink" title="1.2 输入输出系统的组成"></a>1.2 输入输出系统的组成</h3><p>输入输出系统：</p><ul><li>I&#x2F;O软件</li><li>I&#x2F;O硬件</li></ul><p><strong>（1）I&#x2F;O 软件</strong></p><p>输入输出系统软件的主要任务如下：</p><ul><li>将用户编制的程序（或数据）输入主机内。</li><li>将运算结果输送给用户。</li><li>实现输入输出系统与主机工作的协调等。</li></ul><p>组成：</p><ul><li>I&#x2F;O指令：机器指令的一类，其设备码相当于设备的地址，用于选择某台设备与主机交换信息。</li><li>通道指令：又称为通道控制字(Channel Control Word,CCW)，是通道自身的指令，用来执行I&#x2F;O操作，如读、写、磁带走带及磁盘找道等。</li></ul><p><strong>（2）I&#x2F;O 硬件</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/cff0204f4b7149fab529243358674241.png" alt="在这里插入图片描述" style="zoom: 50%;"><p>输入输出系统的硬件组成是多种多样的，在带有接口的I&#x2F;O系统中，一般包括：</p><ul><li>接口模块</li><li>I&#x2F;O设备</li></ul><p>如上图所示：</p><ul><li>具有通道的I&#x2F;O系统；</li><li>一个通道可以和一个以上的设备控制器相连，一个设备控制器又可以控制若干台同一类型的设备。</li></ul><h3 id="1-3-I-x2F-O设备与主机的联系方式"><a href="#1-3-I-x2F-O设备与主机的联系方式" class="headerlink" title="1.3 I&#x2F;O设备与主机的联系方式"></a>1.3 I&#x2F;O设备与主机的联系方式</h3><p>I&#x2F;O 设备与主机交换信息时，共有5种控制方式：</p><ul><li>程序查询方式：程序查询方式是由CPU通过程序不断查询I&#x2F;O设备是否已做好准备，从而控制I&#x2F;O设备与主机交换信息。</li><li>程序中断方式：当I&#x2F;O设备准备就绪并向 CPU发出中断请求后才予以响应。</li><li>直接存储器存取方式(DMA)：主存与I&#x2F;O设备之间有一条数据通路，主存与I&#x2F;0设备交换信息时，无须调用中断服务程序。</li><li>I&#x2F;O 通道方式；</li><li>I&#x2F;O处理机方式。</li></ul><h2 id="2-I-x2F-O设备"><a href="#2-I-x2F-O设备" class="headerlink" title="2.I&#x2F;O设备"></a>2.I&#x2F;O设备</h2><h3 id="2-1-I-x2F-O设备概述"><a href="#2-1-I-x2F-O设备概述" class="headerlink" title="2.1 I&#x2F;O设备概述"></a>2.1 I&#x2F;O设备概述</h3><p>I&#x2F;O设备大致可分为三类：</p><ul><li>人机交互设备：·实现操作者与计算机之间互相交流信息的设备。</li><li>计算机信息的存储设备：系统软件和各种计算机的有用信息，其信息量极大，需存储保留起来。</li><li>机——机通信设备：实现一台计算机与其他计算机或与其他系统之间完成通信任务的设备。</li></ul><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/dcc5b2d6616f4681ae293a882871ea68.png" alt="在这里插入图片描述" style="zoom: 40%;"><p>下面是《深入理解计算机系统》中的“一个典型系统的硬件组成”</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20230520203459094-1684586104268-1.png" alt="image-20230520203459094" style="zoom:80%;"><p>每一个I&#x2F;O涉笔都是通过一个控制器或适配器与I&#x2F;O总线连接起来耳朵。控制器和适配器的区别在于他们的组成方式。控制器是I&#x2F;O设备本身中或是系统的主印刷电路（通常称为主板）上的芯片组，而适配器则是一块插在主板插槽上的卡。无论如何，他们的功能否是在I&#x2F;O总线和I&#x2F;O设备之间传递信息。</p><blockquote><p>以图形适配器为例，说的其实就是显卡。显卡全称显示接口卡，又称显示适配器。</p></blockquote><p>我们再看一下杨一涛老师在操作系统课程讲解的图片</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/1684586383766-3.png" alt="img" style="zoom: 67%;"><h3 id="2-2-输入设备"><a href="#2-2-输入设备" class="headerlink" title="2.2 输入设备"></a>2.2 输入设备</h3><p>输入设备完成输入程序、数据和操作命令等功能：</p><ul><li>键盘：通过键盘上的各个键，按某种规范向主机输入各种信息，如汉字、外文、数字等。</li><li>鼠标：手持式的定位设备，由于它拖着一根长线与接口相连，外形有点像老鼠，故取名为鼠标。</li><li>触摸屏：是一种对物体的接触或靠近能产生反应的定位设备。按原理的不同，触摸屏大致可分为5类：电阻式、电容式、表面超声波式、扫描红外线式和压感式。</li><li>其他输人设备：<ul><li>光笔：外形与钢笔相似，头部装有一个透镜系统，能把进入的光会聚成一个光点。光笔的后端用导线连到计算机输入电路上。</li><li>画笔与图形板：画笔(Stylus)同样为笔状，但必须配合图形板(Tablet)使用。</li><li>图像输入设备：最直接的图像输入设备是摄像机(Camera)，它能被拍摄物经数字量化后变成数字图像存入磁带或磁盘。</li></ul></li></ul><h3 id="2-3-输出设备"><a href="#2-3-输出设备" class="headerlink" title="2.3 输出设备"></a>2.3 输出设备</h3><h4 id="2-3-1-显示设备"><a href="#2-3-1-显示设备" class="headerlink" title="2.3.1 显示设备"></a>2.3.1 显示设备</h4><hr><ul><li>字符显示器：<ul><li>显示存储器（刷新存储器）VRAM：显示存储器存放欲显示字符的ASCII码，其容量与显示屏能显示的字符个数有关。</li><li>字符发生器：将每个ASCII字符码转变为一组5×7或7×9的光点矩阵信息。</li><li>CRT控制器：可接收来自CPU的数据和控制信号，并给出访问显示存储器的地址和访问字符发生器的光栅地址，还能给出CRT所需的水平同步和垂直同步信号。</li></ul></li><li>图形显示器：图形显示器是用点、线（直线和曲线）、面（平面和曲面）组合成平面或立体图形的显示设备；</li><li>图像显示器：图形显示器所显示的图形是由计算机用一定的算法形成的点、线、面、阴影等，来自主观世界，故又称为主观图像或计算机图像。</li><li>IBM PC系列微型计算机的显示标准：<ul><li>MDA(Monochrome Display Adapter)标准： MDA是单色字符显示标准，采用9×14点阵的字符窗口，满屏显示80列、25行字符，对应分辨率为720×350像素。MDA不能兼容图形显示。</li><li>CGA(Color Graphics Adapter)标准： CGA是彩色图形&#x2F;字符显示标准，可兼容字符和图形两种显示方式。在字符方式下，字符窗口为8×8点阵，故字符质量不如MDA,但字符的背景可以选择颜色。</li><li>EGA(Enhanced Graphics Adapter)标准： EGA标准集中了MDA和CGA两个显示标准的优点，并有所增强。其字符窗口为8×14点阵，字符显示质量优于CGA而接近MDA。</li><li>VGA(Video Graphics Array)标准： VGA标准在字符方式下，字符窗口为9×16点阵，在图形方式下分辨率为640×480像素、 16种颜色，或320×200像素、256种颜色，还有720×400像素的文本模式。</li></ul></li></ul><h4 id="2-3-2-打印设备"><a href="#2-3-2-打印设备" class="headerlink" title="2.3.2 打印设备"></a>2.3.2 打印设备</h4><hr><ul><li>点阵针式打印机：结构简单、体积小、重量轻、价格低、字符种类不受限制、较易实现汉字打印，还可打印图形和图像。</li><li>激光打印机：采用了激光技术和照相技术，印字质量好，应用广泛。</li><li>喷墨打印机：是串行非击打式打印机，印字原理是将墨水喷射到普通打印纸上。若采用红、绿、蓝三色喷墨头，便可实现彩色打印。</li></ul><h2 id="3-I-x2F-O接口"><a href="#3-I-x2F-O接口" class="headerlink" title="3.I&#x2F;O接口"></a>3.I&#x2F;O接口</h2><h3 id="3-1-I-x2F-O接口概述"><a href="#3-1-I-x2F-O接口概述" class="headerlink" title="3.1 I&#x2F;O接口概述"></a>3.1 I&#x2F;O接口概述</h3><p>接口可以看做是两个系统或两个部件之间的交接部分，它<strong>既可以是两种硬设备之间的连接电路，也可以是两个软件之间的共同逻辑边界。</strong></p><p>设置接口理由如下：</p><ul><li>一台机器通常配有多台I&#x2F;O设备，它们各自有设备号（地址），通过接口可实现I&#x2F;0设备的选择。</li><li>I&#x2F;O设备种类繁多，速度不一，与CPU速度相差可能很大，通过接口可实现数据缓冲.</li><li>有些I&#x2F;O设备可能串行传送数据，而CPU一般为并行传送，通过接口可实现数据串——并格式的转换。</li><li>I&#x2F;O设备的输人输出电平可能与CPU的输入输出电平不同，通过接口可实现电平转换。</li><li>CPU启动I&#x2F;O设备工作，要向I&#x2F;O设备发各种控制信号，通过接口可传送控制命令。</li><li>I&#x2F;O设备需将其工作状态及时向CPU报告，通过接口可监视设备的工作状态，并可保存状态信息，供CPU查询。</li></ul><h3 id="3-2-接口的功能和组成"><a href="#3-2-接口的功能和组成" class="headerlink" title="3.2 接口的功能和组成"></a>3.2 接口的功能和组成</h3><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/fa24e287e4d14e29bc4f22bfb527a47a.png" alt="在这里插入图片描述" style="zoom:60%;"><p>如上图所示为总线结构的计算机，每一台I&#x2F;O设备都是通过I&#x2F;O接口挂到系统总线上的。图中的I&#x2F;O总线包括数据线、设备选择线、命令线和状态线。</p><p>根据上述设置接口的理由，可归纳出接口通常应具有以下几个功能以及相应的硬件配置：</p><ul><li>选址功能：当设备选择线上的设备码与本设备码相符时，应发出设备选中信号SEL；</li><li>传送命令的功能：通常在I&#x2F;O接口中设有存放命令的命令寄存器以及命令译码器，来对CPU的命令进行响应。</li><li>传送数据的功能：接口中通常设有数据缓冲寄存器(Data Buffer Register,DBR)，它用来暂存I&#x2F;O设备与主机准备交换的信息，与I&#x2F;O总线中的数据线是相连的。</li><li>反映I&#x2F;0设备工作状态的功能：为了使CPU能及时了解各I&#x2F;O设备的工作状态，接口内必须设置一些反映设备工作状态的触发器。</li></ul><h3 id="3-3-接口类型"><a href="#3-3-接口类型" class="headerlink" title="3.3 接口类型"></a>3.3 接口类型</h3><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/4439606cc51d4233a82533a8a4638525.png" alt="在这里插入图片描述" style="zoom: 50%;"><ul><li>按数据传送方式分类：<ul><li>并行接口：将一个字节（或一个字）的所有位同时传送；</li><li>串行接口：在设备与接口间一位一位传送，由于接口与主机之间是按字节或字并行传送，因此对串行接口而言，其内部还必须设有串——并转换装置。</li></ul></li><li>按功能选择的灵活性分类：<ul><li>可编程接口：其功能及操作方式可用程序来改变或选择；</li><li>不可编程接口：不能由程序来改变其功能，但可通过硬连线逻辑来实现不同的功能。</li></ul></li><li>按通用性分类：<ul><li>通用接口：可供多种I&#x2F;O设备使用；</li><li>专用接口：为某类外设或某种用途专门设计的。</li></ul></li><li>按数据传送的控制方式分类：<ul><li>程序型接口：用于连接速度较慢的I&#x2F;O设备，如显示终端、键盘、打印机等；</li><li>DMA型接口：用于连接高速I&#x2F;0设备，如磁盘、磁带等。</li></ul></li></ul><h2 id="4-程序中断方式"><a href="#4-程序中断方式" class="headerlink" title="4.程序中断方式"></a>4.程序中断方式</h2><h3 id="4-1-I-x2F-O中断的概念"><a href="#4-1-I-x2F-O中断的概念" class="headerlink" title="4.1 I&#x2F;O中断的概念"></a>4.1 I&#x2F;O中断的概念</h3><p><strong>中断</strong>：计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回到现行程序的间断处，继续执行原程序。</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/134f67493baa806ed044c2370cbfdd3d.png" alt="img" style="zoom:67%;"><h3 id="4-2-I-x2F-O中断的产生"><a href="#4-2-I-x2F-O中断的产生" class="headerlink" title="4.2 I&#x2F;O中断的产生"></a>4.2 I&#x2F;O中断的产生</h3><p>在I&#x2F;O设备与主机交换信息时，由于设备本身机电特性的影响，其工作速度较低，与CPU无法匹配，因此，CPU启动设备后，往往需要等待一段时间才能实现主机与I&#x2F;O设备之间的信息交换。</p><p>如果在设备准备的同时，CPU不作无谓的等待，而继续执行现行程序，<strong>只有当I&#x2F;O设备准备就绪向CPU提出请求后，再暂时中断CPU现行程序转入I&#x2F;O服务程序，这便产生了I&#x2F;O中断。</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/8c07a6229bc94849683b1ef307305055.png" alt="img" style="zoom:75%;"><h3 id="4-3-程序中断方式的接口电路"><a href="#4-3-程序中断方式的接口电路" class="headerlink" title="4.3 程序中断方式的接口电路"></a>4.3 程序中断方式的接口电路</h3><p>本文关于电路部分不做研究，故省略</p><h2 id="5-DMA方式"><a href="#5-DMA方式" class="headerlink" title="5.DMA方式"></a>5.DMA方式</h2><h3 id="5-1-DMA科普"><a href="#5-1-DMA科普" class="headerlink" title="5.1 DMA科普"></a>5.1 DMA科普</h3><p>首先我们要明确一点，<strong>MDA接口就是第3节中所说的I&#x2F;O接口中的一种</strong>。</p><p>有一种特殊的IO接口-DMA接口，它可以用DMA总线与主存直接相连，只要CPU告诉DMA接口要把数据存在主存中的哪个地址DMA接口就会根据地址把数据放进主存。</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20230521114406266.png" alt="image-20230521114406266" style="zoom:67%;"><p>对于DMA接口而言，CPU还需要告诉它主存地址，如果有多个DMA接口，CPU依旧会很忙碌。为了进一步解放CPU，<strong>通道</strong>可以接替CPU做一些基础操作。</p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20230521114538376.png" alt="image-20230521114538376" style="zoom:67%;"><p>它就像一个低级CPU，有自己的指令系统——<strong>通道指令</strong>，能够执行一些有限的操作。当它接收到CPU发出的IO指令后，可以按照要求启动IO设备，或者执行通道指令——就像CPU的小弟。</p><h3 id="5-2-DMA的特点"><a href="#5-2-DMA的特点" class="headerlink" title="5.2 DMA的特点"></a>5.2 DMA的特点</h3><img src="https://img-blog.csdnimg.cn/img_convert/fbff124410ee60a4d3b5fa33c1c8b7ed.png" alt="img" style="zoom: 75%;"><p>由图中可见，由于<strong>主存和DMA接口之间有一条数据通路</strong>，因此主存和设备交换信息时，不通过CPU，也不需要CPU暂停现行程序为设备服务，省去了保护现场和恢复现场，因此工作速度比程序中断方式的工作速度高。</p><p>在DMA方式中，由于DMA接口与CPU共享主存，这就有可能出现两者争用主存的冲突。为了有效地分时使用主存，通常DMA与主存交换数据时采用如下三种方法：</p><p><strong>（1）停止CPU访问主存</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/b50da7fe2155210fc105496e47127184.png" alt="img" style="zoom:67%;"><ul><li>方式：当外设要求传送一批数据时，由DMA接口向CPU发一个停止信号，要求CPU放弃地址线数据线和有关控制线的使用权。DMA接口获得总线控制权后，开始进行数据传送，在数据传送结束后，DMA接口通知CPU可以使用主存，并把总线控制权交回给CPU。</li><li>优点：控制简单，适用于数据传输率很高的I&#x2F;O设备实现成组数据的传送。</li><li>缺点：DMA接口在访问主存时，CPU基本上处于不工作状态或保持原状态。</li></ul><p><strong>（2）周期挪用（或周期窃取）</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/cf3ecee8377f2043ddbbde12a780665e.png" alt="img" style="zoom:67%;"><ul><li>方式：在这种方法中，每当I&#x2F;O设备发出DMA请求时，I&#x2F;O设备便挪用或窃取总线占用权一个或几个主存周期，而DMA不请求时，CPU仍继续访问主存。</li><li>优点：这种方式既实现了I&#x2F;O传送，又较好地发挥了主存与CPU的效率，是一种广泛采用的方法。</li><li>缺点：比较适合于I&#x2F;O设备的读&#x2F;写周期大于主存周期的情况，其他情况不推荐使用。</li></ul><p><strong>（3）DMA和CPU交替访问</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/90cdfcdc9f8fd6dd18da25ddd3c15f60.png" alt="img" style="zoom: 67%;"><ul><li>方式：不需要总线使用权的申请、建立和归还过程，总线使用权是通过C1和C2分别控制的。 CPU与DMA接口各自有独立的访存地址寄存器、数据寄存器和读&#x2F;写信号。</li><li>优点：CPU既不停止主程序的运行也不进入等待状态，即完成了 DMA的数据传送，效率较高。</li><li>缺点：相应的硬件逻辑复杂。</li></ul><h3 id="5-3-DMA接口的功能和组成"><a href="#5-3-DMA接口的功能和组成" class="headerlink" title="5.3 DMA接口的功能和组成"></a>5.3 DMA接口的功能和组成</h3><h4 id="5-3-1-DMA接口功能"><a href="#5-3-1-DMA接口功能" class="headerlink" title="5.3.1 DMA接口功能"></a>5.3.1 DMA接口功能</h4><p>利用DMA方式传送数据时，DMA接口应具有如下几个功能：</p><ul><li>向CPU申请DMA传送。</li><li>在CPU允许DMA工作时，处理总线控制权的转交，避免因进入DMA工作而影响CPU正常活动或引起总线竞争。</li><li>在DMA期间管理系统总线，控制数据传送。</li><li>确定数据传送的起始地址和数据长度，修正数据传送过程中的数据地址和数据长度。</li><li>在数据块传送结束时，给出DMA操作完成的信号。</li></ul><h4 id="5-3-2-DMA接口基本组成"><a href="#5-3-2-DMA接口基本组成" class="headerlink" title="5.3.2 DMA接口基本组成"></a>5.3.2 DMA接口基本组成</h4><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/daa49d98c2cb0b40b1e8ead9503f8cd0.png" alt="img" style="zoom:67%;"><ul><li>主存地址寄存器(AR) ：用于存放主存中需要交换数据的地址。</li><li>字计数器(WC) ：用于记录传送数据的总字数，通常以交换字数的补码值预置。</li><li>数据缓冲寄存器(BR) ：用于暂存每次传送的数据。</li><li>DMA控制逻辑： 负责管理DMA的传送过程，由控制电路、时序电路及命令状态控制寄存器等组成。</li><li>中断机构：当字计数器溢出（全“0”）时，表示一批数据交换完华，由“溢出信号”通过中断机构向CPU提出中断请求，请求CPU作DMA操作的后处理。</li><li>设备地址寄存器(DAR) ：存放I&#x2F;O设备的设备码或表示设备信息存储区的寻址信息，如磁盘数据所在的区号盘面号和柱面号。</li></ul><h3 id="5-4-DMA的工作过程"><a href="#5-4-DMA的工作过程" class="headerlink" title="5.4 DMA的工作过程"></a>5.4 DMA的工作过程</h3><p>DMA的数据传送过程分为三个阶段：</p><ul><li>预处理</li><li>数据传送</li><li>后处理</li></ul><h4 id="5-4-1-预处理"><a href="#5-4-1-预处理" class="headerlink" title="5.4.1 预处理"></a>5.4.1 预处理</h4><ul><li>给DMA控制逻辑指明数据传送方向是输入（写主存）还是输出（读主存）。</li><li>向DMA设备地址寄存器送入设备号，并启动设备。</li><li>向DMA主存地址寄存器送入交换数据的主存起始地址。</li><li>对字计数器赋予交换数据的个数。</li></ul><h4 id="5-4-2-数据传送"><a href="#5-4-2-数据传送" class="headerlink" title="5.4.2 数据传送"></a>5.4.2 数据传送</h4><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/a6000fe130974f4789bb1051dc38156c.png" alt="在这里插入图片描述" style="zoom: 50%;"><p><strong>以输入为例：</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20230521124247578.png" alt="image-20230521124247578" style="zoom: 25%;"><ol><li>IO设备将数据存储到数据存储寄存器BR</li><li>存入数据后，IO设备通过设备请求信号DREQ告诉DMA接口已经准备好了</li><li>DMA控制逻辑向CPU申请总线控制</li><li>CPU发出信号告诉DMA控制逻辑此时已经放弃了总线的占用和控制</li><li>此时进行数据传输，就要给出主存的地址。地址寄存器AR存放了要访问主存的地址，使得系统总线中的地址总线有效</li><li>DMA控制器给出设备应答信号，此时已经开始传输数据了</li><li>DMA控制器发出对内存的读写控制指令， 同时BR寄存器把数据通过传输线送到数据总线上</li><li>此过程AR+1，WC+1</li><li>….</li><li>当WC溢出，传输结束</li></ol><hr><p><strong>以输出为例：</strong></p><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/7ae608e212abd526ea9e3611cdbf51bb.png" alt="img" style="zoom:67%;"><ol><li>把BR中数据送到设备中</li><li>设备发出DREQ告诉DMA控制器此时BR已经空了，可以接收下一个数据了</li><li>DMA向CPU发出对总线和内存的控制请求</li><li>CPU向DMA控制器发出应答信号【此时系统总线和内存的控制权都转移到了DMA接口】</li><li>AR通过地址线告诉内存访问地址</li><li>DMA控制器向设备发出DACK应答信号，告诉设备已经开始新的数据传输了</li><li>主存中的数据通过数据线再次写入到BR中</li><li>同时修改AR+1，WC+1</li><li>…【判断传输是否结束，如果没有结束，继续循环执行】</li><li>WC溢出，传输结束</li></ol><hr><h4 id="5-4-3-后处理"><a href="#5-4-3-后处理" class="headerlink" title="5.4.3 后处理"></a>5.4.3 后处理</h4><p>当DMA的中断请求得到响应后，CPU停止原程序的执行，转去执行中断服务程序，执行DMA的结束工作：</p><ul><li>校验送入主存的数据是否正确；</li><li>决定是否继续用DMA传送其他数据块，若继续传送，则又要对DMA接口进行初始化，若不需要传送，则停止外设；</li><li>测试在传送过程中是否发生错误，若出错，则转错误诊断及处理错误程序。</li></ul><h3 id="5-5-DMA接口类型"><a href="#5-5-DMA接口类型" class="headerlink" title="5.5 DMA接口类型"></a>5.5 DMA接口类型</h3><h4 id="5-5-1-选择型DMA接口"><a href="#5-5-1-选择型DMA接口" class="headerlink" title="5.5.1 选择型DMA接口"></a>5.5.1 选择型DMA接口</h4><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/102fc43b2c1c4a7b9709c59811da028e.png" alt="在这里插入图片描述" style="zoom: 50%;"><p><strong>特点</strong>：</p><ul><li>在物理上可连接多个设备，在逻辑上只允许连接一个设备，即在某一段时间内，DMA接口只能为一个设备服务；</li><li>关键是在预处理时将所选设备的设备号送入设备地址寄存器。</li></ul><h4 id="5-5-2-多路型DMA接口"><a href="#5-5-2-多路型DMA接口" class="headerlink" title="5.5.2 多路型DMA接口"></a>5.5.2 多路型DMA接口</h4><img src="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%94-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/22f2e2f319714d9193b6c95807f6ab9d.png" alt="在这里插入图片描述" style="zoom: 50%;"><p><strong>特点</strong>：</p><ul><li>多路型DMA接口不仅在物理上可以连接多个设备，而且在逻辑上也允许多个设备同时工作，各个设备采用字节交叉的方式通过DMA接口进行数据传送。</li><li>这类接口特别适合于同时为多个数据传输率不十分高的设备服务。</li></ul><h3 id="5-6-DMA方式和程序中断方式比较"><a href="#5-6-DMA方式和程序中断方式比较" class="headerlink" title="5.6 DMA方式和程序中断方式比较"></a>5.6 DMA方式和程序中断方式比较</h3><table><thead><tr><th></th><th>中断方式</th><th>DMA方式</th></tr></thead><tbody><tr><td>数据传送</td><td>程序</td><td>硬件</td></tr><tr><td>响应时间</td><td>指令执行结束</td><td>存取周期结束</td></tr><tr><td>处理异常情况</td><td>能</td><td>不能</td></tr><tr><td>中断请求</td><td>传送数据</td><td>后处理</td></tr><tr><td>优先级</td><td>低</td><td>高</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机配置一本通</title>
    <link href="/2023/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%B8%80%E6%9C%AC%E9%80%9A/"/>
    <url>/2023/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%B8%80%E6%9C%AC%E9%80%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机配置一本通"><a href="#计算机配置一本通" class="headerlink" title="计算机配置一本通"></a>计算机配置一本通</h1><h2 id="1-CPU"><a href="#1-CPU" class="headerlink" title="1.CPU"></a>1.CPU</h2><ul><li><strong>Intel CPU后缀含义</strong></li></ul><h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2.内存"></a>2.内存</h2><ul><li>⭐<a href="https://www.bilibili.com/video/BV1vP411c7pt/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">探索主内存，以DDR5为例</a></li><li><a href="https://zhuanlan.zhihu.com/p/113187707">DDR4寻址原理</a></li><li><a href="https://www.bilibili.com/video/BV1Yg4y1E786/?spm_id_from=333.880.my_history.page.click&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">你的内存是马甲条吗？你知道马甲有什么作用吗？</a></li></ul><h2 id="3-主板"><a href="#3-主板" class="headerlink" title="3.主板"></a>3.主板</h2><ul><li><a href="https://www.douyin.com/user/self?modal_id=7085253674473180447&showTab=like">华硕主板怎么划分</a></li></ul><h2 id="4-硬盘"><a href="#4-硬盘" class="headerlink" title="4.硬盘"></a>4.硬盘</h2><ul><li><a href="https://www.douyin.com/video/7180506336273173792">机械硬盘的结构原理</a></li><li><a href="https://www.douyin.com/video/7180231042966506785">机械硬盘的工作原理</a></li><li><a href="https://www.douyin.com/video/7223806080290196792">机械硬盘是如何制造的</a></li><li><a href="https://www.douyin.com/user/self?modal_id=7163175761438919973&showTab=like">固态硬盘的工作原理</a></li><li>⭐<a href="https://www.bilibili.com/video/BV1Qv411t7ZL/?spm_id_from=333.999.0.0&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">硬盘的SATA M.2 NGFF NVME是什么意思，详解硬盘的总线协议与接口</a></li><li>【PCIe系列一】<a href="https://www.bilibili.com/video/BV1n4411m7HX/?spm_id_from=333.999.0.0&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">PCIe到底是个什么东西？他在电脑里是干什么的？</a></li><li>【PCIe系列二】<a href="https://www.bilibili.com/video/BV1cJ411K7HW/?spm_id_from=333.788&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">详解主板南桥芯片组的功能和作用</a></li></ul><h2 id="5-电源"><a href="#5-电源" class="headerlink" title="5.电源"></a>5.电源</h2><ul><li><a href="https://www.bilibili.com/video/BV1mD4y1D77y/?spm_id_from=333.999.0.0&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">什么是模组电源？他和普通电源有什么区别？模组电源定制线又是什么东西</a></li><li><a href="https://www.bilibili.com/video/BV1bT4y1E777/?spm_id_from=333.788&vd_source=0a2a531b678f5afe0a34f933b2fbdcb4">电源的金银铜牌指的是什么参数？金牌电源比铜牌好吗？详解电源80PLUS认证</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>硬盘的接口、协议、总线</title>
    <link href="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/"/>
    <url>/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="硬盘的接口、协议、总线"><a href="#硬盘的接口、协议、总线" class="headerlink" title="硬盘的接口、协议、总线"></a>硬盘的接口、协议、总线</h1><p>当我们购买固态硬盘的时候，常常会看到以下的内容：</p><img src="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/image-20230509225117077-1683643878529-1.png" alt="image-20230509225117077" style="zoom:67%;"><p>M.2固态硬盘 NVMe协议，PCIe4.0 ×4到底是什么？</p><img src="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/image-20230509225501897.png" alt="image-20230509225501897" style="zoom:80%;"><p>又或者自己在DIY电脑配置的时候硬盘会选择上述配置</p><h2 id="1-总线、协议、接口"><a href="#1-总线、协议、接口" class="headerlink" title="1.总线、协议、接口"></a>1.总线、协议、接口</h2><h3 id="1-1-总线"><a href="#1-1-总线" class="headerlink" title="1.1 总线"></a>1.1 总线</h3><p>总线是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束。总线是一种内部结构，它是CPU、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。</p><p>总线有一定的承载能力上限，我们把总线在单位时间内传输的数据量称为总线的带宽。常见的三种总线及其理论最大带宽如下表所示：</p><table><thead><tr><th>总线名称</th><th>应用场合</th><th>传输速率</th><th>说明</th></tr></thead><tbody><tr><td>SATA总线</td><td>民用</td><td>600MB&#x2F;s</td><td>目前SATA总线的版本为SATA3.0</td></tr><tr><td>PCIe总线</td><td>民用</td><td>见下表</td><td>目前PCIe总线的版本为PCIe3.0和PCIe4.0</td></tr><tr><td>SAS总线</td><td>服务器</td><td>1.2GB&#x2F;s</td><td>主要用于服务器硬盘，消费级市场不常见</td></tr></tbody></table><p>当前高端的M.2固态硬盘已经支持PCIe 5.0</p><img src="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/6b2e06dd569540b1ab30437a4581b00e.jpeg" alt="img" style="zoom:67%;"><h3 id="1-2-协议"><a href="#1-2-协议" class="headerlink" title="1.2 协议"></a>1.2 协议</h3><p>协议是物理设备之间进行通信时的“规则”，其内容主要包括设备间如何相互识别、如何建立链接、使用的讯号类型、数据的编码解码方式、数据传输的类型、数据传 输的方式以及物理层面上的电压、电流、保持时间和截止时间等。</p><p>只有当两个设备之间的协议相同或者相容时，才可以正常进行通讯。不同协议能够支持的最大传输速率也不同。</p><p>目前市场上硬盘所使用的的协议主要有四种，如下表所示：</p><table><thead><tr><th>协议名称</th><th>应用场合</th><th>说明</th></tr></thead><tbody><tr><td>IDE</td><td>民用</td><td>早期硬盘所使用的协议，目前基本见不到了</td></tr><tr><td>AHCI</td><td>民用</td><td>机械硬盘、SATA固态硬盘和极少数PCIe固态硬盘使用此协议</td></tr><tr><td>NVMe</td><td>民用</td><td>目前主流的PCIe固态硬盘使用此协议，也是消费级市场上最常见的</td></tr><tr><td>SCSI</td><td>服务器</td><td>常见于企业级固态硬盘，消费级市场不常见</td></tr></tbody></table><h3 id="1-3-接口"><a href="#1-3-接口" class="headerlink" title="1.3 接口"></a>1.3 接口</h3><p>相对于前面较难理解的总线与协议，接口顾名思义，就是硬盘与主板连接的物理接口。目前硬盘接口种类较多，在这里比较主要的三种分别为SATA接口、M.2接口和U.2接口，其他接口类型仅做了解即可。各种接口及其规格由下表给出：</p><table><thead><tr><th>物理接口</th><th>通信通道</th><th>传输数据协议</th><th>体积</th><th>描述</th></tr></thead><tbody><tr><td>SATA3</td><td>SATA</td><td>AHCI或者ATA</td><td>大</td><td>主流，速度6Gbps，不支持NVMe标准，体积也比较大，就是技术成熟，但是速度慢</td></tr><tr><td>mSATA（被淘汰）</td><td>SATA</td><td>AHCI或者ATA</td><td>小</td><td>就是为了SATA小型化，但是还是SATA通道，所以需要SATA主控<br>Tips：物理接口上和mini PCI-E接口一样</td></tr><tr><td>SATA - E (不咋地)</td><td>PCI-E x2</td><td>NVMe协议</td><td>大</td><td>为了解决上面mSATA的后继问题，就直接采用了PCI-E通道，但是用的很少</td></tr><tr><td>U.2</td><td>SATA + PCI-E x2, x4</td><td>NVMe协议</td><td>大</td><td>上面的SATA-E再升级，支持了NVMe协议，带宽也达到了32Gbps，但是由于现在很多主板上没有U.2接口，所以很多都是用的U.2转M.2的转接卡</td></tr><tr><td><strong>M.2</strong></td><td>SATA + PCI-E x2, x4</td><td>NVMe协议</td><td>小</td><td>取代mSATA，<strong>同时兼容SATA和PCI-E通道</strong>，非常的主流，现在全面转向PCIe 3.0 x4 通道，理论带宽达到了32Gbps</td></tr><tr><td>PCI-E</td><td>PCI-E x2, x4</td><td>NVMe协议</td><td>大</td><td>跟显卡类似，规格大小也有多种，目前直接走PCI-E接口的硬盘还不是很多，属于高端</td></tr></tbody></table><h2 id="2-M-2接口真实的样子"><a href="#2-M-2接口真实的样子" class="headerlink" title="2.M.2接口真实的样子"></a>2.M.2接口真实的样子</h2><p>现在的主板上一般M.2固态都散热片，需要我们拆开散热片</p><img src="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/image-20230509232115580.png" alt="image-20230509232115580" style="zoom: 33%;"><p>拆开散热片后，就可以看到真实的M.2接口了</p><img src="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/image-20230509232202877.png" alt="image-20230509232202877" style="zoom:50%;"><p>将M.2固态的金手指对准M.2接口，插入后即可：</p><img src="/2023/05/09/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%80%BB%E7%BA%BF/image-20230509232344100.png" alt="image-20230509232344100" style="zoom: 50%;">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理(四)存储器</title>
    <link href="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-四-存储器"><a href="#计算机组成原理-四-存储器" class="headerlink" title="计算机组成原理(四)存储器"></a>计算机组成原理(四)存储器</h1><blockquote><p>声明：本文大部分内容转载自<strong>不断前进的皮卡丘</strong>，感谢辛苦整理的成果</p><p>原文地址：<a href="https://blog.csdn.net/qq_52797170/article/details/124472835">https://blog.csdn.net/qq_52797170/article/details/124472835</a></p></blockquote><p>[TOC]</p><h3 id="1-1-存储器分类"><a href="#1-1-存储器分类" class="headerlink" title="1.1 存储器分类"></a>1.1 存储器分类</h3><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/3b068c358f4340b580f7f0727c2e0804.png" alt="在这里插入图片描述" style="zoom:67%;"><h4 id="1-1-1-按存储介质分类"><a href="#1-1-1-按存储介质分类" class="headerlink" title="1.1.1 按存储介质分类"></a>1.1.1 按存储介质分类</h4><ul><li>半导体存储器 TTL、MOS 易失</li><li>磁表面存储器 磁头、载磁体 非易失</li><li>磁芯存储器 硬磁材料、环状元件 非易失</li><li>光盘存储器 激光、磁光材料 非易失</li></ul><h4 id="1-1-2-按读取方式分类"><a href="#1-1-2-按读取方式分类" class="headerlink" title="1.1.2 按读取方式分类"></a>1.1.2 按读取方式分类</h4><p>①存取时间和存取单元位置无关(随机访问)</p><ul><li>随机存储器(RAM)<ul><li>存储器中任何存储单元的内容都能被随机存取，和存取时间和存储单元的物理位置无关，这种存储器叫做随机存储器</li><li>随机存储器在程序的执行过程中可读可写</li></ul></li><li>只读存储器(ROM)<ul><li>在程序的执行过程中只读</li></ul></li></ul><p>②存取时间和存取单元位置有关(串行访问)</p><ul><li>顺序存取存储器 磁带<ul><li>存储器只能按照某种顺序来存取，那么这种存储器就是顺序存取存储器，它的存取周期较长</li></ul></li><li>直接存取存储器 磁盘<ul><li>沿着磁道方向顺序存取，垂直半径方向随机存取</li></ul></li></ul><p>③按照在计算机中的作用分类<br><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/878f6fcb0db84f4890a7e594f3cb6786.png" alt="在这里插入图片描述" style="zoom: 50%;"></p><h3 id="1-2-存储器的层次结构"><a href="#1-2-存储器的层次结构" class="headerlink" title="1.2 存储器的层次结构"></a>1.2 存储器的层次结构</h3><h4 id="1-2-1-存储器的三个主要特性的关系"><a href="#1-2-1-存储器的三个主要特性的关系" class="headerlink" title="1.2.1 存储器的三个主要特性的关系"></a>1.2.1 存储器的三个主要特性的关系</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/340ca3c5d3554a91b7e48c5998e9cbe6.png" alt="在这里插入图片描述" style="zoom: 80%;"><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/332deb6cf51f4ad39270d8e96a1c18c3.png" alt="在这里插入图片描述" style="zoom:50%;"><h4 id="1-2-2-缓存-主存层次和主存-辅存层次"><a href="#1-2-2-缓存-主存层次和主存-辅存层次" class="headerlink" title="1.2.2 缓存-主存层次和主存-辅存层次"></a>1.2.2 缓存-主存层次和主存-辅存层次</h4><p>计算机的主机由CPU和主存储器构成<br>CPU可以从主存中读取信息，也可以把信息存到主存中，但是主存的容量是有限的，如果程序足够大的话，主存是存不下的，需要辅助存储器帮忙存储，不过程序的运行还是得通过主存</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/04816fd2fb45456baf26a7dafd1430dd.png" alt="在这里插入图片描述" style="zoom:50%;"><h2 id="2-主存储器"><a href="#2-主存储器" class="headerlink" title="2.主存储器"></a>2.主存储器</h2><h3 id="2-1-主存储器概述"><a href="#2-1-主存储器概述" class="headerlink" title="2.1 主存储器概述"></a>2.1 主存储器概述</h3><h4 id="2-1-1-主存的基本组成"><a href="#2-1-1-主存的基本组成" class="headerlink" title="2.1.1 主存的基本组成"></a>2.1.1 主存的基本组成</h4><p>从前面的只是来看，存储器的基本组成如下所示：</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230505235435737.png" alt="image-20230505235435737" style="zoom: 67%;"><ul><li>基本上主存由三部分组成 存储体 地址寄存器 数据寄存器</li><li>寄存器也是存储器 用来存放数据</li><li>一个读取操作就像是从菜鸟驿站拿快递一样，我需要提供取件码给店员（数据地址），然后从货架（存储体）中找到快递，放在柜台（数据寄存器中）我来取走</li><li>一个写入操作则和取快递稍微不同，我们需要先给地址寄存器一个地址，然后把数据给数据寄存器，这样主存就会帮我们把数据写入存储体。</li></ul><p>这一章节我们将详细介绍主存储器的结构：</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230506000027708.png" alt="image-20230506000027708" style="zoom: 40%;"><p>主存由存储体(程序，指令，数据都是存储在存储体中)，MAR，MDR构成。</p><p>MAR当中保存了我们要访问的那个存储单元的地址，必须要进行译码器译码以后，我们才可以选定指定的存储单元；MDR中保存了我们读出或者写入的数据，这个数据是读出还是写入需要通过读写电路和控制电路来控制</p><ul><li>如果是写入的话，则把数据从MDR送入指定的存储体的存储单元中</li><li>如果是读出的话，那么存储单元的内容就会被送到MDR中</li></ul><p>方向的控制是由读写电路来控制的。</p><h4 id="2-1-2-主存与CPU之间的关系"><a href="#2-1-2-主存与CPU之间的关系" class="headerlink" title="2.1.2 主存与CPU之间的关系"></a>2.1.2 主存与CPU之间的关系</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230506000218365.png" alt="image-20230506000218365" style="zoom: 40%;"><p>数据总线完成CPU和主存的信息传输<br>地址总线给出要访问的内存单元的地址</p><h4 id="2-1-3-主存中存储单元地址的分配"><a href="#2-1-3-主存中存储单元地址的分配" class="headerlink" title="2.1.3 主存中存储单元地址的分配"></a>2.1.3 主存中存储单元地址的分配</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/88abe0b5048349bdb560acdf4a42ff48.png" alt="在这里插入图片描述" style="zoom:80%;"><p>假设存储字长为32位(对存储器的某一个单元进行读或写的话，一次最多读或写32位0，1)，主存的编址单位是字节，每一个字节都有自己的地址。在这种情况下，一个存储字是32位，一个字节是八位，都有自己的地址。<br>那么12345678H这个数据怎么在主存储器中进行存储？</p><ul><li>一种方法是高位字节地址作为存储器的地址(字地址)，这种方式也叫大端方式</li><li>第二种方法是低位字节作为字地址，这种方式叫做小端方式</li></ul><h4 id="2-1-4-主存的技术指标"><a href="#2-1-4-主存的技术指标" class="headerlink" title="2.1.4 主存的技术指标"></a>2.1.4 主存的技术指标</h4><p>①存储容量：主存存放二进制代码的总位数<br>②存储速度</p><ul><li>存取时间(从存储器给出地址到获得稳定的输入输出) 存储器的访问时间<ul><li>读出时间 写入时间</li></ul></li><li>存取周期<ul><li>连续两次独立的存储器操作(读或写)所需的最小间隔时间</li><li>存取周期一般大于存取时间</li></ul></li></ul><p>③存储器带宽</p><ul><li>单位时间内存储器存取的信息量，用字&#x2F;秒、字节&#x2F;秒或位&#x2F;秒表示</li><li>衡量数据传输速率的重要指标，决定了以存储器为中心的计算机系统获得信息的速度，是改善机器性能瓶颈的一个关键因素</li></ul><h3 id="2-2-半导体存储芯片简介"><a href="#2-2-半导体存储芯片简介" class="headerlink" title="2.2 半导体存储芯片简介"></a>2.2 半导体存储芯片简介</h3><h4 id="2-2-1-半导体存储芯片的基本结构"><a href="#2-2-1-半导体存储芯片的基本结构" class="headerlink" title="2.2.1 半导体存储芯片的基本结构"></a>2.2.1 半导体存储芯片的基本结构</h4><ul><li>采用超大规模集成电路制造工艺，在一个芯片内集成具有记忆功能的存储矩阵、译码驱动电路和读&#x2F;写电路等</li><li>译码驱动：把地址总线送过来的地址信号翻译成对应存储单元的选择信号</li><li>读写电路：包括读写放大器和写入电路，用于完成读写操作</li></ul><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230507213936324.png" alt="image-20230507213936324" style="zoom:67%;"><p>存储芯片通过地址总线、数据总线和控制总线与外部连接</p><ul><li>地址线：单向输入，其位数与芯片容量有关</li><li>数据线：双向输入&#x2F;输出，其位数与芯片可一次读出或写入的数据有关</li></ul><blockquote><p>地址线和数据线的位宽，共同反应了存储芯片的容量。例如：地址线10根，数据线4根，则表示存储芯片的存储单元为2^10，每个单元的数据宽度为4位，则芯片的容量为2^10 * 4b &#x3D; 4Kb</p></blockquote><ul><li>控制线：主要有读写控制线和片选线2种：<ul><li>读写控制线：决定芯片进行读还是写，可以读写分开2根线，也可以合用一根</li><li>片选线：用来在存储矩阵中选择存储芯片，可能有多根线</li></ul></li></ul><h4 id="2-2-2-存储芯片片选线的作用"><a href="#2-2-2-存储芯片片选线的作用" class="headerlink" title="2.2.2 存储芯片片选线的作用"></a>2.2.2 存储芯片片选线的作用</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230507214503803.png" alt="image-20230507214503803" style="zoom:67%;"><p>半导体存储芯片它的片选线一般有2中标识方式，<br>$$<br>\overline{\text{CS}}、\overline{\text{CE}}<br>$$<br>上面的一横表示低电平有效，CS是芯片选择的缩写。</p><blockquote><p><strong>16K × 1位</strong>说明芯片的存储容量是16K，每一个存储单元保存1位信息。<br>如果我们用8个这样的芯片，对8个芯片同时进行读写，这8个芯片构成一组，这8个芯片就构成了16K × 8位的存储器<br>为了满足题目的需求，我们就应该布置4组这样的芯片。<br>每一组的8个芯片要同时进行工作<br>接下来对地址空间进行划分<br>第一组芯片: 0到16K-1<br>第二组芯片:16K到32K-1<br>第三组芯片:32K到48K-1<br>第四组芯片:48K到64K-1<br>如果我们要访问的地址是65535，也就是64K-1，按照我们划分的规则，它应该在第四组芯片，此8片的片选有效。片选信号看到这个地址后，就选择第四组芯片，其他三组芯片的片选信号是无效的，也就是高电平，最后一组对应的信号是低电平，也就是有效的。<br>片选信号的作用是让某个芯片或者某些芯片同时进行工作。</p></blockquote><h4 id="2-2-3-半导体存储芯片的译码驱动方式"><a href="#2-2-3-半导体存储芯片的译码驱动方式" class="headerlink" title="2.2.3 半导体存储芯片的译码驱动方式"></a>2.2.3 半导体存储芯片的译码驱动方式</h4><p>译码驱动方式就是说，给出存储单元的地址后，怎么找到指定的存储单元，可以有两种方式来找到指定的存储单元，</p><p><strong>（1）线选法</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/a2e5a6340fda4db982f1d4179089a578.png" alt="在这里插入图片描述" style="zoom:50%;"><p>给出A0到A3四位地址，说明有16个存储单元，每一个存储单元有多少位，就需要看数据线，数据线是从D0到D7，说明有8位，这个存储器是16×8</p><p>接下来看看工作过程：</p><p>如果给出的地址是全0，被译码后的信号只有0的这根线是有效的，其他的线是无效的。如果现在进行的是读操作，读信号会控制电路的通路打开，使数据可以从存储矩阵送到数据总线上，只有给定的单元才可以数据的输出</p><blockquote><p>这种方法对容量稍微大一点的芯片来说是不合适的</p></blockquote><p><strong>（2）重合法</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/db1d4fe8d41843e19a4d0ca6b8b53a79.png" alt="在这里插入图片描述" style="zoom:50%;"><p>线性法进行布局的时候，实际上是把它布局成线性数组，重合法进行布局的时候，实际上是把它布局成二维阵列</p><blockquote><p>行地址和列地址都只能有一条线是有效的，DDR4和DDR5的原理都是基于这个</p></blockquote><h3 id="2-3-随机存取存储器（RAM）"><a href="#2-3-随机存取存储器（RAM）" class="headerlink" title="2.3 随机存取存储器（RAM）"></a>2.3 随机存取存储器（RAM）</h3><p>RAM分为静态RAM(SRAM)和动态RAM(DRAM)：</p><ul><li>动态RAM是利用电容存储电荷的方式存储数据的；</li><li>静态RAM是利用触发器的稳态特性来存储数据的；</li></ul><hr><p>RAM 有点像“内存”，实际上涵盖了几种不同的类型。大多数人在讨论 RAM 或内存时，他们实际上谈论的内容在技术上是 DRAM（动态随机存取内存），或者更准确地说对于现代系统 <strong>SDRAM</strong>（同步动态随机存取内存）更为准确。除了技术性之外，术语并不重要，但知道这些术语通俗地说可以相互交换是有用的。</p><p>目前销售的最常见的 RAM 类型是 DDR4，尽管较旧的系统可能使用 DDR2 或 DDR3。这些简单地表示在特定系统中使用的 RAM 的生成，每个连续的系统通过更大的带宽提供更快的速度 – 更高的兆赫（MHz）等级。每代人都看到身体的变化，所以不能互换。</p><p>另一个常见术语，特别是在视频游戏领域是 VRAM 或视频 RAM。虽然 VRAM 本身就是一种技术，但它现在用于（技术上错误地）表示可用于图形芯片或内置于图形卡的内存。这实际上称为图形 DDR SDRAM，或更常见的 GDDR。大多数现代显卡都会使用 GDDR5，尽管有些使用更新的 GDDR5X 标准，而未来的几代甚至可能会搭配 GDDR6 内存。</p><p>一些小众图形卡采用称为高带宽内存（HBM 和 HBM2）的独特形式的内存 ，虽然它通常很昂贵，但供应问题意味着它没有被广泛采用，它具有一些独特的性能优势。</p><h3 id="2-4-只读存储器（ROM）"><a href="#2-4-只读存储器（ROM）" class="headerlink" title="2.4 只读存储器（ROM）"></a>2.4 只读存储器（ROM）</h3><p>ROM的发展历程：</p><ul><li>早期的只读存储器—–在厂家就写好了内容</li><li>改进1——–用户可以自己写，不过是一次性的，如果要修改程序就得重新买芯片，原有的芯片的数据不能够擦除</li><li>改进2——可以多次写——并且可以对信息进行擦除(早期的时候，那些可以擦除信息的芯片的设备要单独购买，不是很方便)</li><li>改进3——电可擦写—–需要特定设备</li><li>改进4——电可擦写——直接连接到计算机上</li></ul><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/bcf1404027e6445eb5a94b473f236bab.png" alt="在这里插入图片描述" style="zoom:100%;"><h4 id="2-4-1-掩膜ROM（MROM）——只可读"><a href="#2-4-1-掩膜ROM（MROM）——只可读" class="headerlink" title="2.4.1 掩膜ROM（MROM）——只可读"></a>2.4.1 掩膜ROM（MROM）——只可读</h4><p>这种ROM是由制造厂家利用一种掩膜技术写入程序的，掩膜ROM制成后，用户不能修改，根据制造工艺可以将它们分为MOS型和双极型两种。MOS型ROM功耗小、速度慢，适用于一般微机系统；而双极型则速度快、功耗大，适用于速度较高的计算机系统。</p><h4 id="2-4-2-PROM-一次性编程"><a href="#2-4-2-PROM-一次性编程" class="headerlink" title="2.4.2 PROM (一次性编程)"></a>2.4.2 PROM (一次性编程)</h4><p>可编程只读存储器 （英语：Programmable read-only memory），缩写为 PROM 或 FPROM，是一种电脑存储记忆晶片，它允许使用称为PROM编程器的硬件将数据写入设备中。在PROM被编程后，它就只能专用那些数据，并且不能被再编程，这种记忆体用作永久存放程式之用。通常会用于电子游戏机、或电子词典这类可翻译语言的产品之上。</p><p>采用破坏性编程，且只能编程一次，如果编程有错误，只能重新购买芯片。</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom:33%;"><h4 id="2-4-3-EPROM-多次性编程"><a href="#2-4-3-EPROM-多次性编程" class="headerlink" title="2.4.3 EPROM (多次性编程 )"></a>2.4.3 EPROM (多次性编程 )</h4><p>EPROM采用N型沟道浮动栅MOS电路，需要保存0，D端加正电压，形成浮动栅，需要保存1，D端不加正电压，不形成浮动栅。</p><p>编程完成后，EPROM只能用强紫外线照射来擦除。通过封装顶部能看见硅片的透明窗口，很容易识别EPROM，这个窗口同时用来进行紫外线擦除。可以将EPROM的玻璃窗对准阳光直射一段时间就可以擦除。</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70-1683468907249-13.png" alt="img" style="zoom: 33%;"><h4 id="2-4-4-EEPROM-多次性编程"><a href="#2-4-4-EEPROM-多次性编程" class="headerlink" title="2.4.4 EEPROM (多次性编程 )"></a>2.4.4 EEPROM (多次性编程 )</h4><p>EEPROM (Electrically Erasable Programmable read only memory)是指带电可擦可编程只读存储器。是一种掉电后数据不丢失的存储芯片。 EEPROM 可以在电脑上或专用设备上擦除已有信息，重新编程。一般用在即插即用。</p><p>常用在接口卡中，用来存放硬件设置数据。</p><p>也常用在防止软件非法拷贝的”硬件锁”上面。</p><p>EEPROM的特点：</p><ul><li>电可擦写</li><li>局部擦写</li><li>全部擦写</li></ul><h4 id="2-4-5-Flash-Memory-闪速型存储器"><a href="#2-4-5-Flash-Memory-闪速型存储器" class="headerlink" title="2.4.5 Flash Memory (闪速型存储器)"></a>2.4.5 Flash Memory (闪速型存储器)</h4><p>快闪存储器（英语：flash memory），是一种电子式可清除程序化只读存储器的形式，允许在操作中被多次擦或写的存储器。这种科技主要用于一般性数据存储，以及在计算机与其他数字产品间交换传输数据，如储存卡与U盘。</p><p>闪存是一种非易失性存储器，即断电数据也不会丢失。因为闪存不像RAM（随机存取存储器）一样以字节为单位改写数据，因此不能取代RAM。</p><p>闪存卡（Flash Card）是利用闪存（Flash Memory）技术达到存储电子信息的存储器，一般应用在数码相机，掌上电脑，MP3等小型数码产品中作为存储介质，所以样子小巧，有如一张卡片，所以称之为闪存卡。</p><h3 id="2-5-存储器与CPU的连接"><a href="#2-5-存储器与CPU的连接" class="headerlink" title="2.5 存储器与CPU的连接"></a>2.5 存储器与CPU的连接</h3><p>CPU执行的指令需要的数据都保存在主存储器中，运行的结果也保存在主存储器中，所以CPU和存储器要进行正确的连接，才能实现他们之间信息的交换</p><p>一般来说，CPU的地址线比较多，寻址范围也比较大。要构成主存储器，需要多个存储芯片共同组成。</p><h4 id="2-5-1-存储器容量的扩展"><a href="#2-5-1-存储器容量的扩展" class="headerlink" title="2.5.1 存储器容量的扩展"></a>2.5.1 存储器容量的扩展</h4><p>单片存储芯片的容量有限，需要将若干存储芯片连在一起组成具有足够容量的存储器，所需芯片数量的计算公式：</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/e17c0a8d820143eb953d6bf14339cffc.png" alt="在这里插入图片描述" style="zoom:50%;"><p>位扩展：增加存储器的横向容量<br>字扩展：增加存储器的纵向容量</p><p><strong>（1）位扩展(为了增加存储字长)</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230507230536721.png" alt="image-20230507230536721" style="zoom: 50%;"><p>用2片1K×4位的存储芯片组成1K×8位的存储器</p><p>两个芯片要能同时工作，也就是要把两个芯片的片选用相同信号连接</p><blockquote><p>地址线和控制线公用<br>数据线单独分开</p></blockquote><p><strong>（2）字扩展(增加存储字的数量)</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230507230753703.png" alt="image-20230507230753703" style="zoom:50%;"><blockquote><p>地址线和数据线公用<br>读写控制线公用<br>片选使能控制线独立，通过地址的高位字段进行译码决定</p></blockquote><p>对第一个芯片来说，它用的地址线是A0~A9，如果A10为0，我们就选择第一个芯片，A10如果为1.我们就选择第二个芯片，A10就是我们的片选信号</p><p>从00000000000 ~ 01111111111，这1K的存储空间分配给第一个芯片</p><p>从10000000000 ~ 11111111111 ，这1K的存储空间分配给第二个芯片</p><p><strong>（3）字、位扩展</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/fdfd8ac372a8451dade364a7eba263c9.png" alt="在这里插入图片描述" style="zoom: 67%;"><p>通过A10,A11来判断我们要访问的芯片是哪一组<br>00选择第一组芯片<br>01选择第二组芯片<br>10选择第三组芯片<br>11选择第四组芯片</p><h4 id="2-5-2-存储器与CPU的连接"><a href="#2-5-2-存储器与CPU的连接" class="headerlink" title="2.5.2 存储器与CPU的连接"></a>2.5.2 存储器与CPU的连接</h4><ul><li>存储芯片与CPU芯片相连，主要注意片与片之间的三种信号线的连接</li><li>地址线的连接<ul><li>CPU的地址线一般比存储芯片的地址线多</li><li>CPU地址线的低位线与存储芯片的地址线相连</li><li>CPU地址线的高位线或用于存储扩展，或用于片选等其他用途</li></ul></li><li>数据线的连接<ul><li>存储芯片的数据线应与CPU的数据线数量相同，若存储芯片数据线不够，需对其进行位扩展</li></ul></li><li>读写命令控制线的连接<ul><li>CPU的读写命令线一般可以直接连到存储芯片的读写控制器，通常高电平为读，低电平为写</li><li>若读写命令线分开，则分别连到对应的芯片控制端</li></ul></li><li>片选线的连接<ul><li>CPU与存储芯片正确工作的关键</li><li>片选有效信号与CPU的访存控制信号MREQ（低电平有效）有关，海域地址线（一般为高位线）有关</li><li>通常需要用到一些逻辑电路来产生片选信号，如译码器和门电路</li></ul></li><li>合理选择存储芯片<ul><li>存储芯片类型（RAM或ROM）和数量的选择</li><li>ROM：通常用于存放系统程序、标准函数库或各类常数等</li><li>RAM：用于用户程序使用，为用户编程而设置</li><li>考虑芯片数量时，应尽量使连线简单方便</li></ul></li><li>其他考虑，如时序配合、速度、负载等</li></ul><p>【<strong>例题1</strong>】</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/680eeb03576f492486b0aeddd407ada5.png" alt="在这里插入图片描述" style="zoom:90%;"><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/c4112880392d4101a60d444103db1470.png" alt="在这里插入图片描述" style="zoom:90%;"><p>①写出对应的二进制地址码【CPU低地址线对应存储器地址线】</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230508232722251.png" alt="image-20230508232722251" style="zoom: 50%;"><p>我们可以看成出A15到A11是固定的，A10到A0是连续的地址，从全0到全1，一共是2K×8位，这部分存放系统程序。</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230508232750023.png" alt="image-20230508232750023" style="zoom:50%;"><p>们可以看成出A15到A10是固定的，A9到A0是连续的地址，从全0到全1，一共是1K×8位，这部分存放用户程序，1K×8位我们可以用两个1K×4位的芯片。</p><p>②芯片的选择</p><ul><li>对应系统程序区，我们应该选择ROM,用1片2K×8</li><li>用户程序区要可读可写，选择RAM，用2片1K×4</li></ul><p>③分配地址线</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/1f00a8fe5b1b4e0db3a7d48a82f165f5.png" alt="在这里插入图片描述" style="zoom: 67%;"><p>④确定片选信号</p><p>根据74138译码逻辑关系，必须保证控制端G1为高电平，G2A和G2B为低电平，译码器才能正常工作</p><p>A15始终为低、A14始终为高，分别接G2A和G1；而MREQ低电平有效，接G2B<br>剩下A13、A12、A11，分别接译码器的输入端C、B、A译码结果为4（Y4有效），选中ROM；译码结果为5（Y5有效），与A10一起通过与门，都为低电平有效时，选中2片RAM。<br><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230508232909198.png" alt="image-20230508232909198" style="zoom: 67%;"></p><p>【<strong>例题2</strong>】</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/2ad6f7d4165b44b1b875a976a9977ca0.png" alt="在这里插入图片描述" style="zoom:67%;"><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/c8552a74c7cd4bedbb02d9d1e24f7400.png" alt="在这里插入图片描述" style="zoom: 67%;"><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/4d9d942d74874f0199486b4e71a2dad7.png" alt="在这里插入图片描述" style="zoom:67%;"><h3 id="2-6-存储器的校验"><a href="#2-6-存储器的校验" class="headerlink" title="2.6 存储器的校验"></a>2.6 存储器的校验</h3><p>编码的检测能力和纠错能力与任意两组合法代码之间二进制位的最少差异数有关</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/87a0b27134564de98358e5fa09ff5030.png" alt="在这里插入图片描述" style="zoom:80%;"><p>如果出错后的代码依然是合法代码，计算机压根检测不出出错的代码</p><blockquote><p>编码的最小距离就是指任意的两组合法代码之间二进制位数的最少差异</p><p>编码的纠错，校错能力和编码的最小距离有关</p></blockquote><h3 id="2-7-提高访存速度的措施"><a href="#2-7-提高访存速度的措施" class="headerlink" title="2.7 提高访存速度的措施"></a>2.7 提高访存速度的措施</h3><ul><li>采用高速器件，让内存速度更快</li><li>采用层次结构Cache-主存，把常用信息放在Cache中，Cache由静态RAM做的，速度快，集成度高，功耗低</li><li>调整主存结构</li><li>高性能存储芯片</li></ul><h4 id="2-7-1-调整主存结构"><a href="#2-7-1-调整主存结构" class="headerlink" title="2.7.1 调整主存结构"></a>2.7.1 调整主存结构</h4><p><strong>（1）单体多字系统</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/698fd0d23bc14441a2c0f2a3eb30bb8c.png" alt="在这里插入图片描述" style="zoom:67%;"><blockquote><p>关于存储字长，机器字长：<a href="https://blog.csdn.net/weixin_45609535/article/details/124323238">https://blog.csdn.net/weixin_45609535/article/details/124323238</a></p><ul><li>存储字长：一个存储单元中二进制代码的位数（通常和MDR位数相同）</li><li>机器字长：CPU进行一次整数运算所能处理的二进制数据的位数</li></ul><p>一般来说，单独说字或字长时，往往指的是 机器字，其字长即为计算机一次能直接处理的二进制数据的位数，这个主要取决于CPU内部数据总线的位宽，也就是说一次能传输多少数据到CPU中进行处理。比如8086的CPU内部数据总线的宽度为16位，即说明8086是16位机，所以其字长为16。同理，32位机其机器字长为32，64位机其机器字长为64.</p></blockquote><p>假设CPU是16位，存储器的存储字长是64位，CPU每一次访问存储器，都可以访问出4个机器字，这4个机器字，每一个都可以是一条机器指令，又或者是长度为16的数据。</p><p>CPU一次把这四个值取出放在数据寄存器中，下一次在用的时候，就可以直接把需要使用的指令或数据取走，用这种方法可以增加存储器的带宽。</p><p>但是这种方法也有问题，假设现在CPU要向存储器中某一共个存储单元写一共长度为16的字，它要先把字写到单字长寄存器中，然后再写入到4个字长的数据寄存器中，之后再写到存储器中。这样产生的问题就是，我们可能只需要写一个16位，但是其他的48位也会写到给定的存储单元中，这就会造成给定的存储字有48位被修改了，这个修改可能是错误的修改.</p><p>第二个问题，如果我们要取出的数据或指令不是连续的存放在相邻的指令中的，那么我们取出的指令可能就只有一条是有用的，其他的指令并没有用<br>出现这些问题的原因：虽然每一个存储单元包括四个机器字，但是这四个机器字存取的时候是以整体的方式进行存取的</p><p>为了解决这个问题，我们可以采用多体并行的方式</p><p><strong>（2）多体并行系统</strong> </p><ul><li>高位交叉 顺序编址</li></ul><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/3c693c78095844c6a4103cbada1d6208.png" alt="在这里插入图片描述" style="zoom:67%;"><p>高位交叉会造成一个问题，传进来的地址一直是连续的， 那么同一个存储体会很繁忙，其余的存储体会很闲。</p><ul><li>低位交叉 各个体轮流编址</li></ul><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/83d98363c63b4d0fb49bf0cb3832384f.png" alt="在这里插入图片描述" style="zoom:67%;"><p>低位交叉的特点：在不改变存取周期的前提下，增加存储器的带宽</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/d90eac5675564a52ba022f172125991e.png" alt="在这里插入图片描述" style="zoom: 50%;"><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/be5b2e83b30d4c498ed95023a22cfb4e.png" alt="在这里插入图片描述" style="zoom:67%;"><h4 id="2-7-2-高性能存储芯片"><a href="#2-7-2-高性能存储芯片" class="headerlink" title="2.7.2 高性能存储芯片"></a>2.7.2 高性能存储芯片</h4><p>（1）SDRAM（同步DRAM)</p><blockquote><p>在系统时钟的控制下进行读出和写入<br>CPU无需等待</p></blockquote><p>（2）RDRAM</p><blockquote><p>主要解决存储器带宽问题</p></blockquote><p>（3）带Cache的DRAM</p><blockquote><p>在DRAM的芯片内集成了一个由SRAM组成的Cache,有利于猝发式读取</p></blockquote><h2 id="3-高速缓冲存储器"><a href="#3-高速缓冲存储器" class="headerlink" title="3.高速缓冲存储器"></a>3.高速缓冲存储器</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><h4 id="3-1-1-使用的原因"><a href="#3-1-1-使用的原因" class="headerlink" title="3.1.1 使用的原因"></a>3.1.1 使用的原因</h4><p>Cache是为了避免CPU空等现象。</p><p>CPU空等现象：IO设备与cpu都需要访问内存，IO设备优先级较高，速度较慢，因此cpu需要等待IO访问内存从而出现空等现象。将热点数据缓存在Cache中可以有效避免cpu空等现象，直接从缓存中访问数据.</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/v2-56946c0f3d889d93bcf280f418abc75c_720w.webp" alt="img" style="zoom:67%;"><blockquote><p>CPU的频率也基本实现了每18个月翻一番，但是内存的速度一直都没怎么提高。下图曲线描述了20世纪后20年CPU速度和内存速度之间的“剪刀差”。</p></blockquote><h4 id="3-1-2-Cache的工作原理"><a href="#3-1-2-Cache的工作原理" class="headerlink" title="3.1.2 Cache的工作原理"></a>3.1.2 Cache的工作原理</h4><p><strong>(1)主存和缓存的编址</strong><br>我们把主存和Cache分成大小相等的块，主存有M块，Cache有C块。主存的容量远大于Cache的容量，即M&gt;&gt;C</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/a90bc042b0a24a77af0e8e842e189871.png" alt="在这里插入图片描述" style="zoom:80%;"><p>如果我们把主存和Cache分成若干块，那么CPU给出的内存地址就可以分成两个部分，一部分是块内偏移地址，它的位数决定块的大小，比如说一个块包含16个字节，并且内存的编址单位是字节，那么块内地址部分就是4位，剩余部分就是主存块号。<br>一个块在内存和Cache之间传送的时候，是整体进行传送，块内字节顺序不会发生变化。</p><p>所以，<strong>内存的块内地址部分和Cache的块内地址部分的值是完全相同的</strong>。</p><p>Cache中的标记，标记了主存块和Cache块之间的关系。如果一个主存块调入Cache块中，我们就可以把主存块号写到标记当中。将来CPU给出一个内存地址，它希望在Cache中访问到这个数据，它要首先确认这个块是否已经送到了Cache中，它就需要拿给出地址的主存块号和Cache中的标记进行比较。如果和某一个标记刚好相等，并且这个Cache块是有效的，这个块里面就保存了在内存中要访问的信息，它就可以直接从Cache中获取这些信息，它的速度就会大大提高</p><p>主存和缓存是按照块来存储的，<strong>块的大小相同</strong></p><p><strong>（2）命中和未命中</strong></p><p>缓存有C块，主存有M块，M&gt;&gt;C，主存中只能有部分块被缓存到了Cache中。</p><p>在CPU访问主存时，如果要访问的主存块已经调入缓存中，它的缓存能取到相应的数据，就说<strong>命中</strong><br>命中，就说明主存块和缓存块建立了对应关系，可以用标记记录与某缓存块建立了对应关系的主存块号</p><p>如果要访问的主存块没有调入缓存，那么就说未命中</p><p><strong>（3）Cache命中率</strong></p><p>命中率： 就是在Cache中访问到CPU要访问的字块的概率。设Nc表示访问Cache的总命中次数，Nm未访问主存的总次数，即未命中次数。命中率h&#x3D;Nc&#x2F;(Nc+Nm)<br>命中率与Cache的容量和块长有关。</p><p>一般每块可以取4~8个字<br>块长取一个存取周期内从主存调出的信息长度<br>Cache-主存系统的效率<br>效率e和命中率有关</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/b4e11ed8f331496d8c5dc3a04dcb1f4c.png" alt="在这里插入图片描述" style="zoom:67%;"><h4 id="3-1-3-Cache的基本结构"><a href="#3-1-3-Cache的基本结构" class="headerlink" title="3.1.3 Cache的基本结构"></a>3.1.3 Cache的基本结构</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/ffaf706f08dc479e9e20a0e117842888.png" alt="在这里插入图片描述" style="zoom:80%;"><p>CPU要访问内存的话，它要给出地址，包括块号和块内地址，由于Cache和主存之间是以块为基本单位传输数据的，所以主存的块内地址可以直接送到Cache的块内地址,或者形成Cache的块内地址</p><p>我们利用块号在Cache的地址映射变换机构中，去确认是否发生命中。如果发生命中的话，需要给出当前的内存块保存在哪一个Cache块中。如果没有命中，就需要查一下，Cache中是否还有空间可以存入主存块，如果有的话，就访问主存，把主存块装到Cache块中；如果没有空间的话，那么主存块装入的那些Cache块都是满的，我们就要启用Cache替换机构，由Cache的替换机构根据替换算法，来算出哪一些块要从Cache中退出，写回到主存，或者直接作废，并且把主存中要用的块写入到Cache块中，这就是Cache替换机构要做的</p><p><strong>地址映射:</strong></p><blockquote><p>主存中的一个块如果要放到Cache中，它可以被放到Cache的哪一个块或哪一些块中。</p></blockquote><p><strong>变换:</strong></p><blockquote><p>把主存的块号转变成相应的Cache块号，或者把主存的地址转变成相应的Cache的地址，然后在Cache中找到相应的主存块进行访问</p><p>在主存和Cache之间是有一条直接通路的，通过这条通路，可以完成主存和Cache之间的信息交换</p></blockquote><p>我们的信息<strong>以块为基本单位</strong>保存在Cache存储体中</p><h4 id="3-1-4-Cache的读写操作"><a href="#3-1-4-Cache的读写操作" class="headerlink" title="3.1.4 Cache的读写操作"></a>3.1.4 Cache的读写操作</h4><p><strong>（1）读操作</strong></p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/81fed2d01dfb457cbadd8f86bcff86cd.png" alt="在这里插入图片描述" style="zoom:67%;"><p>读操作是由CPU发出的，CPU发出这个访问地址，由Cache的地址映射和变换来确认是否发生命中。如果命中，就直接从Cache取出信息。若未命中，则需先判断，Cache是否已满，即是否可以直接将主存中对应的块装入Cache，若是，则访问主存，通过数据总线先将指令和数据传送给CPU，再通过直接通路，将指令和数据传送给Cache缓存。如果Cache已满，则需要通过Cache替换机构来访问主存并替换Cache中的某一个块。<br><strong>（2）写操作</strong></p><p>读操作是不会对内存中信息进行修改的，但是写操作可能造成<strong>主存和Cache中的信息不一致</strong>。</p><p>写操作需要解决Cache和主存的一致性问题，可以采用写直达法和写回法</p><ul><li>写直达法<ul><li>写操作时数据既写入Cache,又写入主存</li><li>写操作时间就是访问主存的时间,Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现</li></ul></li><li>写回法<ul><li>写操作时只把数据写入Cache而不写入主存</li><li>当Cache数据被替换出去时才写回主存</li></ul></li></ul><h4 id="3-1-5-Cache的改进"><a href="#3-1-5-Cache的改进" class="headerlink" title="3.1.5 Cache的改进"></a>3.1.5 Cache的改进</h4><ul><li>增加Cache的级数：离CPU比较近的在CPU内部集成L1缓，L2缓存，在主板上集成L3缓存</li><li>统一缓存和分立缓存：指令Cache和数据Cache分开</li></ul><h3 id="3-2-Cache-主存之间的地址映射"><a href="#3-2-Cache-主存之间的地址映射" class="headerlink" title="3.2 Cache-主存之间的地址映射"></a>3.2 Cache-主存之间的地址映射</h3><h4 id="3-2-1-什么是内存块"><a href="#3-2-1-什么是内存块" class="headerlink" title="3.2.1 什么是内存块"></a>3.2.1 什么是内存块</h4><p><strong>字</strong>：指存放在一个存储单元中的二进制代码组合</p><p><strong>字块：</strong>存储在连续的存储单元中而被看成一个单元的一组字</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514203908166.png" alt="image-20230514203908166" style="zoom: 33%;"><p>字的地址包含2个部分，前m位为指定字块的地址，后b位指定字在字块中的地址</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514204043280.png" alt="image-20230514204043280" style="zoom: 50%;">$$2^m = M，2^b = B$$<img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514204208280.png" alt="image-20230514204208280" style="zoom: 50%;"><p><strong>机器字长：</strong>CPU进行一次整数运算所能处理的二进制数据的位数。字长是由CPU的类型所决定，不同的计算机系统的字长是不同的，常见的有8位、16位、32位、64位等，字长越长，计算机一次处理的信息位就越多，精度就越高，</p><p><strong>存储字长：</strong>一个存储单元中二进制代码的位数（通常和MDR位数相同）</p><h4 id="3-2-2-直接映射"><a href="#3-2-2-直接映射" class="headerlink" title="3.2.2 直接映射"></a>3.2.2 直接映射</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514210212152.png" alt="image-20230514210212152" style="zoom: 50%;"><p>以<strong>字块</strong>为单位将内存和缓存分割为数组，内存向缓存形成多对一的直接映射关系，内存中的一个字块能够映射到缓存中的索引是确定的。如对于只有8个字块的缓存，21 号内存块内容在缓存块中的话，它一定在 5 号缓存块（21 mod 8 &#x3D; 5）中。</p><p>但是这种映射又重新带来一种问题，图中5,13,21,29都能映射到缓存5上，我们怎么确定我要21的时候拿到的不是其他呢？</p><p>通常我们会把缓存块的数量设置成 2 的 N 次方，那么内存的字块数量也一定是缓存的二次方倍，如8 个缓存字块，就是 2 的 3 次方，32个内存字块就是 2 的 5 次方，我们在通过内存地址的获取缓存数据时候，只需要拿到段地址的低三位，就能确定缓存索引，再根据字块中的偏移量就能拿到唯一对应的字节，道理就是这么个道理。</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514210350969.png" alt="image-20230514210350969" style="zoom:50%;"><p>那这个字是不是我们想要的，就需要引入另一个概念”组标记”</p><p>这个组标记会记录，当前缓存块内存储的数据对应的内存块，而缓存块本身的地址表示访问地址的低 N 位。就像上面的例子，21 的低 3 位 101，缓存块本身的地址已经涵盖了对应的信息、对应的组标记，我们只需要记录 21 剩余的高 2 位的信息，也就是 10 就可以了。</p><p>除了组标记信息之外，缓存块中还有两个数据。一个自然是从主内存中加载来的实际存放的数据，另一个是有效位用于存放缓存块中的数据是否有效的。如果有效位是 0，无论其中的组标记和 实际的数据内容是什么，CPU 都不会管这些数据，而要直接访问内存，重新加载数据。</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514210507419.png" alt="image-20230514210507419" style="zoom:50%;"><p><strong>重点来了，</strong>整体进行举例，比如一个64位的CPU，内存地址线宽度为40位，也就是说一个内存地址可以有40位，假设一个字块有64B，即64字节，内存大小为8G，缓存大小为8M。</p><p>由于内存大小为8G，即2的33次方字节，则最少需要33位地址可确定唯一字节。其中64B为一个字块，想要确定唯一字节需要6位地址，即2的6次方，所以偏移量需要6位；缓存大小是8M,即2的23次方字节，但是又因为一个字块是64B,所以缓存行数是2的23次方除以2的6次方，所以需要17位来确定唯一字块，即索引位数为17；缓存8M和内存8G相差2的10次方倍，所以组标记需要10位，高位补0。</p><p><strong>所以一个内存地址的访问，就会经历这样 4 个步骤：</strong></p><p><strong>1.根据内存地址中段地址(字块地址为段地址)的低位，计算在 缓存中的索引；</strong></p><p><strong>2.判断有效位，确认缓存中的数据是有效的；</strong></p><p><strong>3.对比内存访问地址的高位，和缓存中的组标记，确认缓存中的数据就是我们要访问的内存数据</strong></p><p><strong>4.根据内存地址的 偏移量，从字块中读取希望读取到的字节。</strong></p><p>如果在 2、3 这两个步骤中，CPU 发现，缓存中的数据并不是要访问的内存地址的数据，那 CPU 就会访问内存，并把对应的 内存中的数据字块更新到对应的缓存中，同时更新对应的有效位和组标记的数据。</p><h4 id="3-2-3-全相联映射"><a href="#3-2-3-全相联映射" class="headerlink" title="3.2.3 全相联映射"></a>3.2.3 全相联映射</h4><p>全相连映射方式比较灵活，主存的各块可以映射到缓存的任一块中，缓存的利用率高，字块冲突概率低，只要淘汰缓存中的某一块，即可调入主存的任一块。但是，由于缓存比较电路的设计和实现比较困难，这种方式只适合于小容量缓存采用。</p><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/image-20230514211224104.png" alt="image-20230514211224104" style="zoom:50%;"><h4 id="3-2-4-组相联映射"><a href="#3-2-4-组相联映射" class="headerlink" title="3.2.4 组相联映射"></a>3.2.4 组相联映射</h4><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/edc32409f52f4bb08f24ae66a214b1f4.png" alt="在这里插入图片描述" style="zoom: 67%;"><p>主存储器中的字块也进行分区，每个区的大小和Cache中的组数相同，Cache被分成几组，主存储器的每一个区就包含多少块</p><blockquote><p>例如主存中的字块0，可以存放到缓存中第0组的其他空余位置</p><p>例如字块2^(c-r)可以存放到缓存中第2^(c-r)-1组的其余空余位置</p></blockquote><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/9d7cf85354b64dd3bc0816759c0fb788.png" alt="在这里插入图片描述" style="zoom:67%;"><h3 id="3-3-置换算法"><a href="#3-3-置换算法" class="headerlink" title="3.3 置换算法"></a>3.3 置换算法</h3><img src="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%9B%9B-%E5%AD%98%E5%82%A8%E5%99%A8/2a1fc2de6ff347d5bdb50ab4a7603b13.png" alt="在这里插入图片描述">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理(三)总线</title>
    <link href="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/"/>
    <url>/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-三-总线"><a href="#计算机组成原理-三-总线" class="headerlink" title="计算机组成原理(三)总线"></a>计算机组成原理(三)总线</h1><h2 id="1-总线的基本概念"><a href="#1-总线的基本概念" class="headerlink" title="1.总线的基本概念"></a>1.总线的基本概念</h2><p>首先我们提出一个问题：那就是，我们为什么要使用总线？原因很简单，就是我们的计算机中有许多的设备，如果使用分散连接，也就是每两个设备之间互相连接，那样会造成大量的线路连接，而且还不利于添加删减设备。举个不恰当的例子，把我们的房子想成一个设备，公路想成线路，如果每家每户都一一连接，房子少的时候还好，但是一旦房子一多起来，就很麻烦了。所以我们设计出来了总线这样的方式，他就相当于一条靠近大家的大马路，每家每户通过这条马路去通信就好了，这样既简单，又便捷。</p><p>接下来我们来介绍一下有关总线的介绍：总线是连接多个部件的信息传输线，是各部件共享的传输介质，<u><strong>每一次只允许两个设备之间进行通信</strong></u>。而且在总线中，信息传递方式分为串行和并行两种，接下来我们会对其进行详细介绍。接下来我们来看一看一些总线结构。</p><p><strong>单总线</strong></p><p>顾名思义，就是只有一根总线。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/613fe30e19094fe4841a2557469a2846.png" alt="在这里插入图片描述" style="zoom: 67%;"><p><strong>双总线</strong></p><p>双总线呢，我们暂时展示两种，第一种是面向CPU，另外一种就是以寄存器为中心。我们一起来看看吧！</p><ul><li><strong>面向CPU</strong></li></ul><p>这种面向CPU的方式呢，虽然使得CPU与主存之间通信更快，但是还是有一个问题，就是设备与主存之间访问需要通过CPU，速度较慢，于是我们设计出来了以存储器为中心的结构。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/6354160da5894ff6acf183ababc24c79.png" alt="在这里插入图片描述" style="zoom: 67%;"><ul><li><strong>以存储器为中心</strong></li></ul><p>存储器为中心的结构是在单总线基础上又开辟出的一条 CPU 与主存之间的总线，称为存储总线。这组总线速度高，只供主存与 CPU 之间传输信息。这样既提高了传输效率，又减轻了系统总线的负担，还保留了 I&#x2F;0 设备与存储器交换信息时不经过 CPU 的特点</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/51fe1d5096414559a5b004cc6fb8ae7b.png" alt="在这里插入图片描述" style="zoom: 67%;"><h2 id="2-总线的分类"><a href="#2-总线的分类" class="headerlink" title="2.总线的分类"></a>2.总线的分类</h2><p>接下来我们来具体看一看总线的分类，当然了，根据不同的分类原则，也就能分成不同的种类，接下来我们是按照连接部件来进行分类的。</p><p><strong>片内总线</strong></p><p>这个比较好理解，片内总线是指芯片内部的总线，如在 CPU 芯片内部，寄存器与寄存器之间、寄存器与算逻单远 ALU 之间都由片内总线连接。</p><p><strong>系统总线</strong></p><p>系统总线是指 CPU 、主存、 I&#x2F;O 设备（通过 I&#x2F;O接口）各大部件之间的信息传输线。由于这些部件通常都安放在主板或各个插件板上，故又称板级总线或板间总线。按系统总线传输信息的不同，又可分为三类：数据总线、地址总线和控制总线。接下来我们来一一进行介绍。</p><p><strong>（1）数据总线</strong></p><p>顾名思义，数据总线就是用来传输数据的，并且它是双向传输总线，其位数与机器字长、存储字长有关。数据总线的位数称为数据总线宽度，它是衡量系统性能的一个重要参数。</p><p><strong>（2）地址总线</strong></p><p>地址总线主要用来指出数据总线上的源数据或目的数据在主存单元的地址或 I&#x2F;O 设备的地址。</p><p><strong>（3）控制总线</strong></p><p>由于数据总线、地址总线都是被挂在总线上的所有部件共享的，如何使各部件能在不同时刻占有总线使用权，需依靠控制总线来完成，因此控制总线是用来发出各种控制信号的传输线。通常对任一控制线而言，它的传输是单向的。而且控制信号既有输出，又有输入。常见的控制信号如：总线请求，中断请求等等。</p><p><strong>通信总线</strong></p><p>这类总线用于<strong>计算机系统之间</strong>或计算机系统与其他系统之间的通信。主要分为串行通信和并行通信。串行通信是指数据在单条位宽的传输线上，一位一位地按顺序分时传送。并行通信是指数据在多条并行位宽的传输线上，同时由源传送到目的地，适宜近距离的传输。</p><h2 id="3-总线特性及性能指标"><a href="#3-总线特性及性能指标" class="headerlink" title="3.总线特性及性能指标"></a>3.总线特性及性能指标</h2><p>接下来我们来介绍一下总线特性、性能指标和总线标准。</p><h3 id="3-1-总线特性"><a href="#3-1-总线特性" class="headerlink" title="3.1 总线特性"></a>3.1 总线特性</h3><p>我们现在将介绍一下关于总线的一些特性，首先我们来看一下总线的物理结构。</p><p>图中 CPU 、主存、 I&#x2F;O 这些插板（又称插卡）通过插头与水平方向总线插槽连接。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/773c1c371d2d4b739b9eb3114b54c52e.png" alt="在这里插入图片描述" style="zoom:80%;"><p><strong>机械特性</strong></p><blockquote><p>机械特性是指总线在机械连接方式上的一些性能，如插头与插座使用的标准，它们的<strong>几何尺寸</strong>、<strong>形状</strong>、<strong>管脚数</strong>以及<strong>排列的顺序</strong>，接头处的可靠接触等。</p></blockquote><p><strong>电气特性</strong></p><blockquote><p>电气特性主要是指总线的每一根传输线上信号的<strong>传递方向</strong>和<strong>有效的电平范围</strong>。</p></blockquote><p><strong>功能特性</strong></p><blockquote><p>功能特性是指总线中每根传输线的功能，主要包含<strong>数据、地址和控制总线</strong>等等。</p></blockquote><p><strong>时间特性</strong></p><blockquote><p>主要涉及的就是信号的时序关系，也可以说总线中的任一根线在什么时间内有效。</p></blockquote><p><strong>性能指标</strong></p><blockquote><p>性能指标的话，其实就是衡量总线能力的一个判断标准，具体我们就来看看吧！</p><ol><li>总线宽度：通常是指数据总线的根数。</li><li>总线带宽：总线带宽可理解为总线的数据传输速率，即单位时间内总线上传输数据的位数，通常用每秒传输信息的字节数来衡量，单位可用 MBps （兆字节每秒）表示。</li><li>时钟同步／异步：总线上的数据与时钟同步工作的总线称为同步总线，与时钟不同步工作 的总线称为异步总线。</li><li>总线复用：一条信号线上分时传送两种信号。</li><li>信号线数：地址总线、数据总线和控制总线三种总线数的总和。</li><li>总线控制方式：包括突发工作、自动配置、仲裁方式、逻辑方式、计数方式等。</li><li>其他指标：如负载能力、电源电压（是采用 5V 还是 3.3 V) 、总线宽度能否扩展等。</li></ol></blockquote><h3 id="3-2-总线标准"><a href="#3-2-总线标准" class="headerlink" title="3.2 总线标准"></a>3.2 总线标准</h3><p>总线标准的话，有许许多多标准，如：ISA 总线、 EISA 总线、 VESA总线、 PCI 总线、 AGP 总线、RS-232C 总线和USB 总线等等，我们呢，就不一一介绍，书上都有。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/image-20230503200015897.png" alt="image-20230503200015897" style="zoom:80%;"><h2 id="4-总线结构"><a href="#4-总线结构" class="headerlink" title="4.总线结构"></a>4.总线结构</h2><p><strong>单总线</strong></p><p>单总线是将 CPU 、主存、 I&#x2F;O 设备都挂在一组总线上，允许 I&#x2F;O 设备之间、 I&#x2F;O 设备与 CPU 之间或 I&#x2F;O 设备与主存之间直接交换信息。之前简单介绍过一下，在此就不再赘述了。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/613fe30e19094fe4841a2557469a2846.png" alt="在这里插入图片描述" style="zoom: 67%;"><p><strong>多总线</strong></p><p>对于多总线结构，主要包括双总线、三总线、四总线结构等等，我们来一一介绍吧！</p><ul><li><strong>双总线</strong></li></ul><p>双总线结构的特点是将速度较低的 I&#x2F;0 设备从单总线上分离出来，形成主存总线与 I&#x2F;0 线分开的结构。有点类似于面向CPU的双总线模式，但不是。通道可以说是具有特殊功能的处理器，由通道对I&#x2F;O统一管理。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/0202a9c954724fed9f996289f5a03aa3.png" alt="在这里插入图片描述" style="zoom: 67%;"><ul><li><strong>三总线</strong></li></ul><p>如果将速率不同的 I&#x2F;0 设备进行分类，然后将它们连接在不同的通道上，那么计算机系统的 工作效率将会更高，由此发展成多总线结构。接下来我们来介绍两种三总线模式。</p><p>这种就是将高速I&#x2F;O设备通过DMA挂接到主存上面，这样设备可以快速从主存里面获得数据。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/b4d4877086664979bd1a14f498780269.png" alt="在这里插入图片描述" style="zoom: 67%;"><p>另外一种结构就是通过一个Cache去保存CPU所需的数据。也可以达到高速存储的作用。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/e0ce68ecbb7f4051904205511ce2fb0c.png" alt="在这里插入图片描述" style="zoom: 67%;"><ul><li><strong>四总线</strong></li></ul><p>为了进一步提高 I&#x2F;0 设备的性能，使其更快地响应命令，又出现了四总线结构，这种结构对高速设备而言，其自身的工作可以很少依赖 CPU ，同时它们又比扩展总线上的设备更贴近 CPU ，可见对于高性能设备与 CPU 来说，各自的效率将获得更大的提高。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/8f75c6b3c9224a7abaf0609f512f52a3.png" alt="在这里插入图片描述" style="zoom:67%;"><h2 id="5-总线控制"><a href="#5-总线控制" class="headerlink" title="5.总线控制"></a>5.总线控制</h2><p>接下来我们介绍的就是关于总线控制的相关内容，主要包括判优控制和通信控制，而且这一部分内容就是我们的重难点，所以我也会着重进行讲解。</p><h3 id="5-1-总线判优控制"><a href="#5-1-总线判优控制" class="headerlink" title="5.1 总线判优控制"></a>5.1 总线判优控制</h3><p>首先我们根据设备是否对总线有控制权，我们把其分为主设备和从设备。主设备对总线有控制权，从设备只能响应从主设备发来的总线命令，对总线没有控制权。总线判优也分为集中式和分布式两种，接下来我们会一一进行介绍。</p><p><strong>（1）链式查询</strong></p><p>链式查询，顾名思义，就是跟一条链子一样，一个一个查询过去。控制总线中有3根线用于总线控制（BS 总线忙、 BR 总线请求、 BG 总线同意），其中总线同意信号 BG 是串行地从一个 I&#x2F;O 接口送到下 一个 I&#x2F;O 接口。</p><p>具体操作就是，BG一个一个去查询有没有设备发送总线请求BR，当发现了有之后，这个设备就会发送总线忙信号BS，这样就占有了总线，然后下一次也是如此循环。</p><p><strong>这样的话只需很少几根线就能按一定优先次序实现总线控制，并且很容易扩充设备，但对电路故障很敏感，且优先级别低的设备可能很难获得请求。</strong></p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/ab9830421e654f7e86135b64524d0819.png" alt="在这里插入图片描述" style="zoom:80%;"><p><strong>（2）计数器定时查询</strong></p><p>接下来介绍的是计数器定时查询，与链式查询相比，多了一组设备地址线，少了一根总线同意线 BG 。总线控制部件接到由 BR 送来的总线请求信号后，在总线未被使用 (BS&#x3D; 0) 的情况下，总线控制部件中的计数器开始计数，并通过设备地址线，向各设备发出一组地址信号。这样的好处是可以自己设定优先级，并且可以通过循环的方式去一一遍历设备（每此从中断点开始计数）。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/7ddaf3e0cf9c4b03b01f7c3dcfe28e65.png" alt="在这里插入图片描述" style="zoom:80%;"><p><strong>（3）独立请求方式</strong></p><p>独立请求方式就是每个设备都与总线控制部件相连，当设备要求使用总线时，便发出该设备的请求信号。总线控制部件中有一排队电路，可根据优先次序确定响应哪一台设备的请求。</p><p><strong>这种方式的特点是：响应速度快，优先次序控制灵活，但控制线数量多，总线控制更复杂</strong></p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/79ce24c525704529bfb267f452147ec7.png" alt="在这里插入图片描述" style="zoom:80%;"><h3 id="5-2-总线通信控制"><a href="#5-2-总线通信控制" class="headerlink" title="5.2 总线通信控制"></a>5.2 总线通信控制</h3><p>接下来我们要介绍的就是总线通信控制了，主要就是用来解决通信双方协调配合的问题的。一共分为4个阶段，<strong>申请分配、寻址、传输和结束</strong>阶段。通信方式也刚好是四种，分为同步、异步、半同步和分离式四种，好了，就让我们开始吧！</p><p><strong>同步通信</strong></p><p>通信双方由统一时标控制数据传送称为同步通信。时标通常由 CPU 的总线控制部件发出，送到总线上的所有部件；也可以由每个部件各自的时序发生器发出，但必须由总线控制部件发出的时钟信号对它们进行同步。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/1cba2e60495944e1bb4a6e3e8a5fc2a4.png" alt="在这里插入图片描述" style="zoom: 67%;"><p>对于读命令，其传输周期如下：</p><ol><li>T1主模块发地址。</li><li>T2主模块发读命令。</li><li>T3从模块提供数据。</li><li>T4主模块撤销读命令，从模块撤销数据。</li></ol><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/2e3ea8616cd84012ba6a804194bc61bb.png" alt="在这里插入图片描述" style="zoom: 67%;"><p>对于写命令，其传输周期如下：</p><ol><li>T1主模块发地址。</li><li>T1.5主模块发读命令。</li><li>T2从模块提供数据。</li><li>T4主模块撤销读命令，从模块撤销数据。</li></ol><p><strong>特点</strong></p><p>这种通信的优点是规定明确、统一，模块间的配合简单一致。其缺点是主、从模块时间配合属于强制性”同步”，必须在限定时间内完成规定的要求。并且对所有从模块都用同一限时，这就势必造成，对各不相同速度的部件而言，必须按最慢速度的部件来设计公共时钟，严重影响总线的工作效率，也给设计带来了局限性，缺乏灵活性。</p><p>所以同步通信一般用千总线长度较短、各部件存取时间比较一致的场合。而且，总线传输周期越短，数据线的位数越多，直接影响总线的数据传输率</p><p><strong>异步通信</strong></p><p>异步通信克服了同步通信的缺点，允许各模块速度的不一致性，给设计者充分的灵活性和选择余地。他是是采用应答方式（又称握手方式），即当主模块发出请求 (Request) 信号时，一直等待从模块反馈回来“响应 ”信号后才开始通信。应答方式可分为不互锁、半互锁和全互锁三种类型。</p><p>我们在这里采用出租车的例子去帮助大家理解这三种方式的区别，请大家想像自己在和出租车司机交流。</p><ul><li><strong>不互锁</strong></li></ul><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/7b92eb35ab61481b969a2ad6e55b5e91.png" alt="在这里插入图片描述" style="zoom:80%;"><p>这就是第一种情况，热情司机与高冷乘客，首先司机询问：你去哪啊？（请求信号）。但是乘客不回答，这个时候司机只能按照打车软件的地址将乘客安全送达，或者只能让他下车了。</p><ul><li><strong>半互锁</strong></li></ul><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/568e2b35a6504802b387c71e7fda1a3b.png" alt="在这里插入图片描述" style="zoom:80%;"><p>这个属于第二种情况，高冷司机与热情乘客，首先司机询问：你去哪啊？（请求信号）。乘客回答：机场（回答信号）。这个时候司机便不再回答。这种情况看起来不错，但是会照成一个情况，就是顾客怕司机没听清楚，便一直回答。</p><ul><li><strong>全互锁</strong></li></ul><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/c878e28825d349879bd6135713629034.png" alt="在这里插入图片描述" style="zoom: 80%;"><p>这个属于第三种情况，热情司机与热情乘客，首先司机询问：你去哪啊？（请求信号）。乘客回答：机场（回答信号）。这个时候司机便回答：好嘞。这种情况就比较完美了。</p><p><strong>半同步通信</strong></p><p>半同步通信既保留了同步通信的基本特点，如所有的地址、命令、数据信号的发出时间，都严格参照系统时钟的某个前沿开始，而接收方都采用系统时钟后沿时刻来进行判断识别；同时又像异步通信那样，允许不同速度的模块和谐地工作。</p><img src="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%89-%E6%80%BB%E7%BA%BF/c1283df227924e94a74ae78bd9062b45.png" alt="在这里插入图片描述" style="zoom:67%;"><p>其实就是加了一个等待信号，以便于不同速度的模块能一起工作。对于读命令，其传输周期如下：</p><ol><li>T1主模块发地址。</li><li>T2主模块发读命令。</li><li>TWAIT ~ TWAIT为低电平时，进入等待，八的宽度与 的宽度一致。</li><li>T3从模块提供数据。</li><li>T4主模块撤销读命令，从模块撤销数据。</li></ol><p>然后输出也是一样的，就不再赘述了。</p><p>我们总结一下上面三种通信的共同点，我们可以得到如下信息：</p><ul><li>主模块发地址、命令 占用总线</li><li>从模块准备数据 不占用总线</li><li>从模块向主模块发数据 占用总线</li></ul><p>于是在此基础上，我们设计出来了分离式通信。充分挖掘系统总线每个瞬间的潜力。</p><p><strong>分离式通信</strong></p><p>我们主要分为两个周期：</p><ul><li>主模块申请占用总线，使用完后既放弃总线的使用权。</li><li>从模块申请占用总线，将各类学习传输到总线上。</li></ul><p><strong>特点</strong></p><ol><li>各模块欲占用总线使用权都必须提出申请。</li><li>在得到总线使用权后，主模块在限定的时间内向对方传送信息，采用同步方式传送，不再等待对方的回答信号。</li><li>各模块在准备数据的过程中都不占用总线，使总线可接受其他模块的请求。</li><li>总线被占用时都在做有效工作，或者通过它发送命令，或者通过它传送数据，不存在空闲等待时间，充分地利用了总线的有效占用，从而实现了总线在多个主、从模块间进行信息交叉重叠并行式传送，这对大型计算机系统是极为重要的。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>车机MCU知识梳理</title>
    <link href="/2023/05/03/%E8%BD%A6%E6%9C%BAMCU%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <url>/2023/05/03/%E8%BD%A6%E6%9C%BAMCU%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="车机MCU知识梳理"><a href="#车机MCU知识梳理" class="headerlink" title="车机MCU知识梳理"></a>车机MCU知识梳理</h1><blockquote><p>声明：转载自<a href="https://www.eet-china.com/mp/a191448.html">https://www.eet-china.com/mp/a191448.html</a></p><p>仅做个人学习笔记使用</p></blockquote><p>一辆传统燃油车需要大约500到600颗芯片，轻混汽车大约需要1000颗，插电混动和纯电动汽车则需要至少2000颗芯片。这意味着，随着智能电动汽车的飞速发展，不但先进制程的芯片需求量越来越大，传统芯片的需求量也将继续提升。MCU就是这样，除了单车搭载的数量在不断增长，域控制器也带来了对高安全、高可靠、高算力MCU的新需求增长。</p><p>MCU，Microcontroller Unit，中文称单片微型计算机&#x2F;微控制器&#x2F;单片机，将CPU、存储器、外围功能整合在单一芯片上，形成具有控制功能的芯片级计算机，主要用于实现信号处理和控制，是智能控制系统的核心。</p><p>MCU与我们的生活工作息息相关，如汽车电子、工业、计算机与网络、消费电子、家电、物联网等，其中汽车电子是最大的市场，从全球角度看占比达到了33%。</p><h2 id="MCU结构"><a href="#MCU结构" class="headerlink" title="MCU结构"></a>MCU结构</h2><p>MCU主要由中央处理器CPU、存储器（ROM和RAM）、输入输出I&#x2F;O接口、串行口、计数器等构成。</p><img src="/2023/05/03/%E8%BD%A6%E6%9C%BAMCU%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/MBXY-CR-abdcd2d763896a6c675eba8495147cd2.png" alt="img" style="zoom: 60%;"><p><strong>CPU：</strong>Central Processing Unit，中央处理器，是 MCU 内部的核心部件，运算部件能完成数据的算术逻辑运算、位变量处理和数据传送操作，控制部件则按照一定时序协调工作，分析并执行指令。</p><p><strong>ROM：</strong>Read-Only Memory，是程序存储器，用来存放由制造厂家写好的程序，信息以非破坏方式读取，存储数据掉电后不消失，MCU按照事先编写好的程序执行。</p><p><strong>RAM：</strong>Random Access Memory，是数据存储器，与 CPU 直接进行数据交换，掉电后该数据不能保持。在程序运行过程中可以随时写入、读出，通常作为操作系统或其他正在运行中程序的临时数据存储介质。</p><p><strong>CPU和MCU的关系：</strong></p><p>CPU是运算控制的核心。MCU除了CPU之外，还包含ROM或RAM等，是芯片级芯片。常见的还有SoC（System on Chip），中文称片上系统，是系统级芯片，可存放并运行系统级别的代码，运行QNX、Linux 等操作系统，包含多个处理器单元（CPU+GPU+DSP+NPU+存储+接口单元）</p><h2 id="MCU的位数"><a href="#MCU的位数" class="headerlink" title="MCU的位数"></a>MCU的位数</h2><p>位数是指MCU每次处理数据的宽度，位数越高意味着MCU数据处理能力就越强，目前最主要的是8、16、32位三种，其中32位占比最多且增长迅速。</p><img src="/2023/05/03/%E8%BD%A6%E6%9C%BAMCU%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/MBXY-CR-705bbb7f06192297ec5f0fc5c931f0ae.png" alt="img" style="zoom:80%;"><p>在汽车电子应用中，8位MCU成本低、便于开发，目前主要应用在相对简单的控制领域，如照明、雨刷、车窗、座椅和车门等车身域控制。而对于相对复杂的领域，如仪表显示、车载娱乐信息系统、动力控制系统、底盘、驾驶辅助系统等，则以32位的为主，且随着汽车电动化、智能化、网联化的迭代进化，对MCU的运算能力要求也越来越高。</p><table><thead><tr><th>位数</th><th>车相关模块</th><th>时间</th><th>价格（美元）</th></tr></thead><tbody><tr><td>8位</td><td>低端控制功能：车体的各个次系统，如风扇控制、空调控制、雨刷、天窗、车窗升降、低阶仪表板、集线盒、座椅 控制、门控模块等低阶控制功能。</td><td>1980-1983年</td><td>&lt;1</td></tr><tr><td>16位</td><td>中端控制功能：① 动力传动系统，如引擎控制、齿轮与离合器控制，和电子式涡轮系统等；② 底盘机构，如悬吊系统、电子式动力方向盘、扭力分散控制、电子帮辅、电子刹车等</td><td>1983-80年代末</td><td>1 ~ 5</td></tr><tr><td>32位</td><td>高端控制功能：L1&#x2F;L2智能驾驶功能中扮演重要角色，如仪表盘控制、车身控制、多媒体信息系统、引擎控制，以及新兴的智能性和实时性的安全系统及动力系统（预碰撞、ACC、驾驶辅助系统、电子稳定程序、X-by-wire 等）</td><td>1990年代至今</td><td>5~10，部分&gt;10</td></tr></tbody></table><h2 id="MCU车规认证"><a href="#MCU车规认证" class="headerlink" title="MCU车规认证"></a>MCU车规认证</h2><p>MCU供应商在进入OEM的供应链体系前，一般需要完成三大认证：设计阶段要遵循功能安全标准 ISO 26262，流片和封装阶段要遵循AEC-Q001~004和IATF16949，以及在认证测试阶段要遵循AEC-Q100&#x2F;Q104。</p><p>其中，ISO 26262定义了ASIL四个安全等级，从低到高分别为A、B、C和D；AEC-Q100 分为四个可靠性等级，从低到高分别为 3、2、1和0。AEC-Q100 系列认证一般需要1-2年的时间，而ISO 26262的认证难度更大，周期更长。</p><h2 id="MCU在智能电动汽车产业的应用"><a href="#MCU在智能电动汽车产业的应用" class="headerlink" title="MCU在智能电动汽车产业的应用"></a>MCU在智能电动汽车产业的应用</h2><p>MCU在汽车产业中应用广泛，如前表，从车身附件、动力系统、底盘、车载信息娱乐到智能驾驶等板块都会用到。随着智能电动汽车时代的发展，MCU产品需求会越来越旺盛。</p><p><strong>电动化：</strong></p><p>1、电池管理系统BMS：BMS需要对充放电、温度、电池间均衡进行控制，主控板需要一颗MCU，每个从控板也需要一颗MCU；</p><p>2、整车控制器VCU：电动汽车能量管理需要增加一个整车控制器，同时需要配备32位高阶MCU，数量根据各厂的方案不同而不同；</p><p>3、引擎控制器&#x2F;变速箱控制器：存量替换，电动汽车逆变器控制MCU替代油车的引擎控制器，由于电机转速较高，需要经过减速器减速，其配备的MCU控制芯片替换了油车的变速箱控制器。</p><p><strong>智能化：</strong></p><p>1、目前国内汽车市场还是处于L2高速渗透的阶段，基于综合成本和性能的考量，OEM新增ADAS功能仍沿用分布式架构，随着装载率的提升，处理传感器信息的MCU随之增加。</p><p>2、由于座舱功能日益增多，更高新能的芯片作用越来越重要，对应的MCU地位有所下降。</p><h2 id="工艺制造"><a href="#工艺制造" class="headerlink" title="工艺制造"></a>工艺制造</h2><p>MCU本身对算力要求优先，对先进制程要求不高，同时其内置的嵌入式存储自身也限制了MCU制程的提升，因此当前车规MCU工艺节点主要是在40nm及以上的成熟制程，部分比较先进的车用MCU产品采用了28nm制程。车规芯片的规格主要是8英寸晶圆，部分厂商尤其IDM开始向12英寸平台迁移。</p><p><strong>目前28nm和40nm工艺是市场主流。</strong></p><h2 id="国内外典型车企"><a href="#国内外典型车企" class="headerlink" title="国内外典型车企"></a>国内外典型车企</h2><p>相较于消费和工业级MCU，车规级MCU对运行环境、可靠性和供货周期的要求较高，此外车规级MCU认证门槛比较高，认证时间长、进入难度大，所以整体看MCU市场格局较为集中，2021年世界前五名的MCU企业占比就达82%之多。</p><table><thead><tr><th>序号</th><th>企业</th><th>国别</th><th>2021年销售额（亿美元）</th><th>2021年市场份额</th></tr></thead><tbody><tr><td>1</td><td>NXP</td><td>荷兰</td><td>37.95</td><td>18.8%</td></tr><tr><td>2</td><td>微芯</td><td>美国</td><td>35.84</td><td>17.8%</td></tr><tr><td>3</td><td>瑞萨</td><td>日本</td><td>34.2</td><td>17%</td></tr><tr><td>4</td><td>ST</td><td>意大利</td><td>33.74</td><td>16.7%</td></tr><tr><td>5</td><td>英飞凌</td><td>德国</td><td>23.78</td><td>11.8%</td></tr></tbody></table><p>目前，中国车规级MCU还处在导入期，供应链本土化、国产替代化潜力巨大。</p><table><thead><tr><th>序号</th><th>企业</th><th>芯片</th><th>量产首款通过时间</th></tr></thead><tbody><tr><td>1</td><td>比亚迪半导体</td><td>车规级触控MCU、车规级通用MCU及电池管理MCU</td><td>2018年</td></tr><tr><td>2</td><td>杰发科技（四维图新子公司）</td><td>ABS、BMS等核心功能、车身控制</td><td>2018年</td></tr><tr><td>3</td><td>芯海科技</td><td>车身电子、智能座舱</td><td>2020年</td></tr><tr><td>4</td><td>航顺芯片</td><td>汽车前装</td><td>2019年</td></tr><tr><td>5</td><td>芯旺微电子</td><td>汽车照明、车窗控制、空调面板</td><td>2019年</td></tr><tr><td>6</td><td>国芯科技</td><td>车载T-BOX安全单元、车载诊断系统安全单元、C-V2X通信安全应用</td><td>2019年</td></tr><tr><td>7</td><td>芯驰科技</td><td>汽车显示类应用</td><td>2019年</td></tr><tr><td>8</td><td>赛腾微电子</td><td>尾灯流水灯、车载无线充电、车窗控制</td><td>2019年</td></tr></tbody></table><h2 id="SOC与MCU的区别"><a href="#SOC与MCU的区别" class="headerlink" title="SOC与MCU的区别"></a>SOC与MCU的区别</h2><ul><li><p>MCU</p></li><li><ul><li><p>&#x3D;Micro Control Unit&#x3D;&#x3D;Micro Controller&#x3D;Microcontroller&#x3D;Microcontroller Unit</p></li><li><p>特点</p></li><li><ul><li><p>复杂度</p></li><li><ul><li>比CPU高，比SoC低</li></ul></li><li><p>运行系统</p></li><li><ul><li>简单系统</li><li>一般不支持运行多任务的复杂系统（比如(嵌入式)Linux）</li></ul></li></ul></li></ul></li><li><p>SoC</p></li><li><ul><li><p>&#x3D;System On Chip&#x3D;System On a Chip&#x3D;系统级芯片&#x3D;片上系统</p></li><li><p>总结</p></li><li><ul><li><p>复杂度</p></li><li><ul><li>比CPU高，比MCU高</li></ul></li><li><p>运行系统</p></li><li><ul><li>能支持运行多任务的复杂系统（比如(嵌入式)Linux）</li></ul></li><li><p>总体复杂度&#x3D;集成功能的丰富程度</p></li><li><ul><li>CPU &lt; MCU &lt; SoC</li></ul></li><li><p>芯片平均价格</p></li><li><ul><li>CPU &lt; MCU &lt; SoC</li></ul></li></ul></li></ul></li></ul><blockquote><p>SOC是多了个简单的操作系统吗?</p></blockquote><p>如果仅仅是从 MCU和SoC所能支持的操作系统的角度来说，基本上说：是的。</p><ul><li><p>MCU：运行的往往是裸系统</p></li><li><ul><li><p>代码直接操作物理存储空间</p></li><li><ul><li>控制外部设备</li></ul></li></ul></li><li><p>SoC</p></li><li><ul><li><p>系统复杂度一般比较高</p></li><li><p>运行的典型如嵌入式Linux系统</p></li><li><ul><li>包括衍生出的Android系统等</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>车机扫盲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理(一)计算机系统概论</title>
    <link href="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    <url>/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理-一-计算机系统概论"><a href="#计算机组成原理-一-计算机系统概论" class="headerlink" title="计算机组成原理(一)计算机系统概论"></a>计算机组成原理(一)计算机系统概论</h1><h2 id="1-计算机系统简介"><a href="#1-计算机系统简介" class="headerlink" title="1.计算机系统简介"></a>1.计算机系统简介</h2><h2 id="2-计算机的基本组成"><a href="#2-计算机的基本组成" class="headerlink" title="2.计算机的基本组成"></a>2.计算机的基本组成</h2><h3 id="2-0-冯诺依曼计算机历史"><a href="#2-0-冯诺依曼计算机历史" class="headerlink" title="2.0 冯诺依曼计算机历史"></a>2.0 冯诺依曼计算机历史</h3><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/a825a9ed08e2a58a5d9d462c5d8de1a4.png" alt="img" style="zoom:80%;"><p>冯诺依曼计算机简称为EDVAC(Electronic Discrete Variable Automatic Computer)也叫普林斯顿体系结构（Princetionarchitecture），因为冯诺依曼是普林斯顿大学教授。</p><p>EDVAC是世界上第一台存储程序计算机(也有说法是电子数字式计算机)，成为所有现代计算机的原型和范本，它被建造于 1940年.。它是最早的大型二进制系统中央处理器计算机，而不是十进制系统。建造于19世纪40年代,EDVAC 设计于1944年,在这之前它被安装在美国军队的弹道学研究实验室，该实验室建造于1940年８月，位于马里兰州。</p><p>作为一个二进制序列的计算机，EDVAC用于加工数学的计算，连续的大致内存容量是5.5kb，EDVAC被用于作为数据的媒介存贮磁带，每天运行时间超过２&#x3D;０个小时，EDVAC 于1960年被BRLESC（Ballistic Research Laboratories Electronic Scientific Computer）替换成更大的内存和更快的响应时间。</p><p>冯·诺依曼体制的主要思想包括：<br> （1）采用二进制代码形式表示信息（数据、指令）；<br> （2）采用存储程序工作方式（冯·诺依曼思想最核心的概念）；<br> （3）计算机硬件系统由五大部件（运算器、控制器、存储器、输入设备和输出设备）组成。</p><blockquote><p>🪶按照冯诺依曼体质的思想，运算器是冯诺依曼计算机的核心，计算器就是用来进行复杂的计算，至于运行哪一种计算是加法、减法、乘法等等取决于控制器，告诉控制器要执行什么指令由它去进行控制。那么运算的中间结果，运算的初始值，运算的最终结果需要有一个容器进行盛放就是存储器。</p></blockquote><h3 id="2-1-冯诺依曼计算机的特点"><a href="#2-1-冯诺依曼计算机的特点" class="headerlink" title="2.1 冯诺依曼计算机的特点"></a>2.1 冯诺依曼计算机的特点</h3><ol><li>计算机由五大部件组成（存储器、运算器、控制器、输入设备、输出设备）</li><li>指令和数据以同等地位存于存储器，可按地址寻址</li><li>指令和数据用二进制表示</li><li>指令由操作码和地址码组成</li><li>存储程序</li><li>以运算器为核心</li></ol><h3 id="2-2-现代计算机硬件框图"><a href="#2-2-现代计算机硬件框图" class="headerlink" title="2.2 现代计算机硬件框图"></a>2.2 现代计算机硬件框图</h3><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501225515506.png" alt="image-20230501225515506" style="zoom: 80%;"><blockquote><p>内存也被称为主存，而辅存指的是计算机的外部存储、例如，硬盘、U盘、软盘以及光盘等等</p></blockquote><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501224841832.png" alt="image-20230501224841832" style="zoom:80%;"><p>对于像冯诺依曼体系这种复杂的系统，需要有一个系统复杂性管理的方法（3’Y）</p><ul><li>层次化（Hierachy）：将被设计的系统划分为多个模块或子模块</li><li>系统化（Modularity）：有明确定义的功能和接口</li><li>规则性（regularity）：模块更容易被重用</li></ul><blockquote><p>这边的思想远远不止用于设计冯诺依曼体系，对于日常工作中各种框架的理解和设计意义也是非凡的。</p></blockquote><h3 id="2-3-计算机的工作步骤"><a href="#2-3-计算机的工作步骤" class="headerlink" title="2.3 计算机的工作步骤"></a>2.3 计算机的工作步骤</h3><h4 id="2-3-1-编程举例"><a href="#2-3-1-编程举例" class="headerlink" title="2.3.1 编程举例"></a>2.3.1 编程举例</h4><p>计算：ax^2 + bx + c 的值</p><p><strong>第一种方案：直接计算</strong></p><blockquote><p>取 x 到运算器中</p><p>乘以 x 在运算器中</p><p>乘以 a 在运算器中</p><p>存 ax^2 到存储器中</p><p>取 b 到运算器中</p><p>乘以 x 在运算器中</p><p>加 ax^2 在运算器中</p><p>加 c 在运算器中</p></blockquote><p><strong>第二种方案：变形后计算</strong>   <strong>(ax+b)x+c</strong></p><blockquote><p>取 x 到运算器中</p><p>乘以 a 在运算器中</p><p>加 b 在运算器中</p><p>乘以 x 在运算器中</p><p>加 c 在运算器中</p></blockquote><p>对于同一台计算机而言，第一种方案需要8条指令，第二种方案只需要5条指令，显然第二种方案是更快的，对于存储空间的要求也是更少的。</p><h4 id="2-3-2-指令格式"><a href="#2-3-2-指令格式" class="headerlink" title="2.3.2 指令格式"></a>2.3.2 指令格式</h4><p>以取数指令为例：</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501232421591.png" alt="image-20230501232421591" style="zoom:80%;"><p>其他的指令如下：</p><table><thead><tr><th>操作</th><th>表示</th></tr></thead><tbody><tr><td>取数 α</td><td>[α] -&gt; ACC</td></tr><tr><td>存数 β</td><td>[ACC] -&gt; β</td></tr><tr><td>加 γ</td><td>[ACC] + [γ] -&gt; ACC</td></tr><tr><td>乘 δ</td><td>[ACC] × [δ] -&gt; ACC</td></tr><tr><td>打印 σ</td><td>[σ] -&gt; 打印机</td></tr></tbody></table><p>那么我们计算ax^2 + bx  + c 的程序清单为：</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501232836557.png" alt="image-20230501232836557" style="zoom:80%;"><h4 id="2-3-3-存储器的基本组成"><a href="#2-3-3-存储器的基本组成" class="headerlink" title="2.3.3 存储器的基本组成"></a>2.3.3 存储器的基本组成</h4><p>主存储器由 <u>存储体、MAR、MDR</u> 组成：</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501232931011.png" alt="image-20230501232931011" style="zoom:80%;"><p><strong>存储体</strong>的组成与生活例子对应如下：</p><p>存储体 — 存储单元 — 存储元件</p><p> 大楼   —  房间        — 床位</p><ul><li>存储单元：存放一串二进制代码</li><li>存储字：存储单元中二进制代码的组合</li><li>存储字长：存储单元中二进制代码的位数，每个存储单元赋予一个地址号</li></ul><p><strong>MAR：</strong>全称 memory data register，主存数据寄存器，MDR用来保存要被写入地址单元或者从地址单元读入的数据。</p><p><strong>MDR：</strong>全称memory address register，主存地址寄存器，MAR用来保存数据被传输到的位置的地址或者数据来源位置的地址。</p><h4 id="2-3-4-运算器的基本组成及操作过程"><a href="#2-3-4-运算器的基本组成及操作过程" class="headerlink" title="2.3.4 运算器的基本组成及操作过程"></a>2.3.4 运算器的基本组成及操作过程</h4><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501235216541.png" alt="image-20230501235216541" style="zoom:80%;"><p>①加法操作过程</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501235302879.png" alt="image-20230501235302879" style="zoom: 67%;"><p>②减法操作过程</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501235446223.png" alt="image-20230501235446223" style="zoom:67%;"><p>③乘法操作过程</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501235504985.png" alt="image-20230501235504985" style="zoom: 67%;"><blockquote><p>高位存放于ACC寄存器，低位存放于MQ寄存器</p></blockquote><p>④除法操作过程</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501235547197.png" alt="image-20230501235547197" style="zoom: 67%;"><h4 id="2-3-5-控制器的基本组成"><a href="#2-3-5-控制器的基本组成" class="headerlink" title="2.3.5 控制器的基本组成"></a>2.3.5 控制器的基本组成</h4><p>控制器CU主要由IR寄存器、PC寄存器组成；完成一条指令需要有三步：PC取指令、IR分析指令、CU控制单元执行指令。</p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230501235624624.png" alt="image-20230501235624624" style="zoom: 67%;"><h4 id="2-3-6-主机完成一条指令的过程"><a href="#2-3-6-主机完成一条指令的过程" class="headerlink" title="2.3.6 主机完成一条指令的过程"></a>2.3.6 主机完成一条指令的过程</h4><p><strong>（1）以取指令为例</strong></p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230503150830396.png" alt="image-20230503150830396" style="zoom: 67%;"><ul><li><p>先要做的是拿到取数指令，PC中存储了下一条要执行指令的地址</p><ul><li><p>PC将指令的地址送给MAR</p></li><li><p>MAR再送给存储体</p></li><li><p>存储体将具体的指令送到MDR中</p></li><li><p>将取出来的指令送到IR进行分析</p></li><li><p>将指令的操作码部分交给CU控制单元</p></li></ul></li><li><p>然后拿到具体的数值，所以传递具体数值的地址</p><ul><li>因为IR分析指令后，里面有操作码和地址码，操作码表明了是取数指令，已经告诉了CU。现在要把具体数值的取出来。IR吧数值的地址传递到MAR</li><li>MAR再传给存储体</li><li>存储体将具体的数值取出来放到MDR中</li><li>MDR将数值传到ACC寄存器中</li></ul></li></ul><p><strong>（2）以存数指令为例</strong></p><img src="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20230503151910628.png" alt="image-20230503151910628" style="zoom:67%;"><ul><li>PC中存储了下一条指令的地址<ul><li>PC将指令的地址传给MAR</li><li>MAR将地址传给存储体M</li><li>存储体M将具体的指令传给MDR</li><li>MDR将具体的指令传给IR进行分析</li><li>将指令的操作码部分交给CU控制单元</li></ul></li><li>然后就要存具体的数值了<ul><li>IR将要存的数值的具体地址传给MAR</li><li>MAR传给存储体</li><li>ACC寄存器将具体的数值传给MDR</li><li>MDR将数值传给存储体进行保存</li></ul></li></ul><p><strong>（3）ax^2+bx+c程序的运行过程</strong></p><ul><li>将程序通过输入设备送至计算机</li><li>程序首地址 -&gt; PC</li><li>启动程序运行</li><li>取指令 PC -&gt; MAR -&gt; M -&gt; MDR -&gt; IR， (PC)+1-&gt;PC</li><li>分析指令  OP(IR) -&gt; CU</li><li>执行指令  Ad(IR) -&gt; MAR -&gt; M -&gt; MDR -&gt; ACC</li><li>…</li><li>…</li><li>打印结果</li><li>停机</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DeviceMapper驱动</title>
    <link href="/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/"/>
    <url>/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="DeviceMapper驱动"><a href="#DeviceMapper驱动" class="headerlink" title="DeviceMapper驱动"></a>DeviceMapper驱动</h1><h2 id="1-驱动的ioctl接口"><a href="#1-驱动的ioctl接口" class="headerlink" title="1.驱动的ioctl接口"></a>1.驱动的ioctl接口</h2><h3 id="1-0-ioctl命令行扫盲"><a href="#1-0-ioctl命令行扫盲" class="headerlink" title="1.0 ioctl命令行扫盲"></a>1.0 ioctl命令行扫盲</h3><p>在进行ioctl时，我们会传递cmd，该cmd由32位组成：</p><blockquote><p>第一个分区：0-7，命令的编号，范围是0-255<br>第二个分区：8-15，命令的幻数<br>第三个分区：16-29，表示传递的数据的大小<br>第四分区：30-31，代表读写的方向</p><p>第一和第二分区，主要用来区分命令，不能有两个完全一样的“一+二”<br>第四分区：00：没有数据传递；10：用户从驱动读数据；01：用户向驱动写数据；11：先写数据到驱动再把数据读出来</p></blockquote><p>如果自己去组合这个cmd比较费事且容易搞错，所以Linux提供了相应的宏给我们去组合cmd：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">_IO(type,nr)   没有数据传递的命令<br>_IOR(type, nr, size)  从驱动中读取数据的命令<br>_IOW(type, nr, size)  向驱动中写入数据的命令<br>_IOWR(type, nr, size) 交换数据的命令<br><br>// type表示数据的幻数，8-15位<br>// nr命令的编号，0-7位<br>// size参数传递的大小，传递的是数据类型：如果传递4字节，可以写成int<br></code></pre></td></tr></table></figure><p>内核拿到这些cmd，首先要对组合后的cmd进行解析，才知道对应的动作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">_IOC_DIR(nr)   获得方向<br>_IOC_TYPE(nr)  获得幻数<br>_IOC_NR(nr)    获得编号<br>_IOC_SIZE(nr)  获得大小<br></code></pre></td></tr></table></figure><h3 id="1-1-内核空间ioctl空间定义"><a href="#1-1-内核空间ioctl空间定义" class="headerlink" title="1.1 内核空间ioctl空间定义"></a>1.1 内核空间ioctl空间定义</h3><p>先来看一下这个驱动的设备操作集</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> _<span class="hljs-title">ctl_fops</span> =</span> &#123;<br>.open = nonseekable_open,<br>.unlocked_ioctl = dm_ctl_ioctl,<br>.compat_ioctl = dm_compat_ctl_ioctl,<br>.owner = THIS_MODULE,<br>.llseek  = noop_llseek,<br>&#125;;<br></code></pre></td></tr></table></figure><p>用户空间调用ioctl接口，会调用驱动的<code>unlocked_ioctl</code>，对应的函数为<code>dm_ctl_ioctl</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dm_ctl_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, uint command, ulong u)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>)ctl_ioctl(command, (<span class="hljs-keyword">struct</span> dm_ioctl __user *)u);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctl_ioctl</span><span class="hljs-params">(uint command, <span class="hljs-keyword">struct</span> dm_ioctl __user *user)</span><br>&#123;<br>    <span class="hljs-comment">// 获得command的NR编号</span><br>    cmd = _IOC_NR(command);<br>    <br>fn = lookup_ioctl(cmd, &amp;ioctl_flags);<br>    <span class="hljs-comment">// 执行cmd对应的处理函数</span><br>    <span class="hljs-keyword">if</span> (!fn) &#123;<br>DMWARN(<span class="hljs-string">&quot;dm_ctl_ioctl: unknown command 0x%x&quot;</span>, command);<br><span class="hljs-keyword">return</span> -ENOTTY;<br>&#125;<br>&#125;<br><br><span class="hljs-type">static</span> ioctl_fn <span class="hljs-title function_">lookup_ioctl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">int</span> *ioctl_flags)</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> cmd;<br><span class="hljs-type">int</span> flags;<br>ioctl_fn fn;<br>&#125; _ioctls[] = &#123;<br>        <span class="hljs-comment">// ...</span><br>&#123;DM_DEV_CREATE_CMD, IOCTL_FLAGS_NO_PARAMS, dev_create&#125;,<br>&#123;DM_DEV_REMOVE_CMD, IOCTL_FLAGS_NO_PARAMS, dev_remove&#125;,<br>&#123;DM_DEV_RENAME_CMD, <span class="hljs-number">0</span>, dev_rename&#125;,<br>&#123;DM_DEV_SUSPEND_CMD, IOCTL_FLAGS_NO_PARAMS, dev_suspend&#125;,<br>&#123;DM_DEV_STATUS_CMD, IOCTL_FLAGS_NO_PARAMS, dev_status&#125;,<br>&#123;DM_DEV_WAIT_CMD, <span class="hljs-number">0</span>, dev_wait&#125;,<br><span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">return</span> _ioctls[cmd].fn;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会遍历ioctls里面定义的命令行，一个个进行查找对比，匹配到之后将对应的处理函数返回。例如匹配到 <strong>DM_DEV_CREATE_CMD</strong> 后，将<strong>dev_create</strong>返回，然后在 <strong>ctl_ioctl</strong> 执行 <strong>fn</strong> 也就是 <strong>dev_create</strong>。</p><h3 id="1-2-用户空间调用ioctl"><a href="#1-2-用户空间调用ioctl" class="headerlink" title="1.2 用户空间调用ioctl"></a>1.2 用户空间调用ioctl</h3><p>这是用户空间（init进程）向内核发送的创建设备的ioctl，其中cmd为DM_DEV_CREATE</p><img src="/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/image-20230425220018537.png" alt="image-20230425220018537" style="zoom:50%;"><p>我们研究一个这个DM_DEV_CREATE的组成：</p><img src="/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/image-20230425222337318.png" alt="image-20230425222337318" style="zoom: 67%;"><p>该cmd告诉内核我们是双向交互数据的，且NR号为3，传输数据的大小为struct dm_ioctl的大小。</p><h2 id="2-DeviceMapper中的数据结构"><a href="#2-DeviceMapper中的数据结构" class="headerlink" title="2.DeviceMapper中的数据结构"></a>2.DeviceMapper中的数据结构</h2><h3 id="2-1-hash-cell"><a href="#2-1-hash-cell" class="headerlink" title="2.1 hash_cell"></a>2.1 hash_cell</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// drivers\md\dm-ioctl.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash_cell</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">name_list</span>;</span>  <span class="hljs-comment">// 表示name的双向链表，同一个Hash值的形成一个双向链表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">uuid_list</span>;</span>  <span class="hljs-comment">// 表示uuid的双向链表，同一个Hash值的形成一个双向链表</span><br><br><span class="hljs-type">char</span> *name;   <span class="hljs-comment">// 当前mapped device的name</span><br><span class="hljs-type">char</span> *uuid;   <span class="hljs-comment">// 当前mapped device的uuid</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mapped_device</span> *<span class="hljs-title">md</span>;</span>  <span class="hljs-comment">// 具体的mapped_device</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dm_table</span> *<span class="hljs-title">new_map</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><img src="/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/image-20230425235406381.png" alt="image-20230425235406381" style="zoom:80%;"><h2 id="2-创建设备"><a href="#2-创建设备" class="headerlink" title="2.创建设备"></a>2.创建设备</h2><p>前面可以看到用户空间传递进来DM_DEV_CREATE想要创建dm设备，对应的处理函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dev_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dm_ioctl *param, <span class="hljs-type">size_t</span> param_size)</span><br>&#123;<br><span class="hljs-type">int</span> r, m = DM_ANY_MINOR;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mapped_device</span> *<span class="hljs-title">md</span>;</span><br><br>    <span class="hljs-comment">// 2.1节去检查传进来的参数中的name是否合法</span><br>r = check_name(param-&gt;name);<br>    <br>    <span class="hljs-comment">// 用户空间没有传递flag，所以m的值仍然是DM_ANY_MINOR</span><br>    <span class="hljs-comment">// 会影响到2.2.1节</span><br>    <span class="hljs-keyword">if</span> (param-&gt;flags &amp; DM_PERSISTENT_DEV_FLAG)<br>m = MINOR(huge_decode_dev(param-&gt;dev));<br><br>    <span class="hljs-comment">// 2.2节用来创建dm设备</span><br>r = dm_create(m, &amp;md);<br><span class="hljs-keyword">if</span> (r)<br><span class="hljs-keyword">return</span> r;<br><br>r = dm_hash_insert(param-&gt;name, *param-&gt;uuid ? param-&gt;uuid : <span class="hljs-literal">NULL</span>, md);<br><span class="hljs-keyword">if</span> (r) &#123;<br>dm_put(md);<br>dm_destroy(md);<br><span class="hljs-keyword">return</span> r;<br>&#125;<br><br>param-&gt;flags &amp;= ~DM_INACTIVE_PRESENT_FLAG;<br><br>__dev_status(md, param);<br><br>dm_put(md);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引用**<a href="https://blog.csdn.net/feelabclihu/article/details/120232172">内核工匠</a>**总结的图片：</p></blockquote><img src="/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/ec3e80a0f0a490eb7d77c6dbaa8f3df6.png" alt="img" style="zoom:80%;"><h3 id="2-1-checkname检查名字是否合法"><a href="#2-1-checkname检查名字是否合法" class="headerlink" title="2.1 checkname检查名字是否合法"></a>2.1 checkname检查名字是否合法</h3><p>首先我们确认一下param-&gt;name从何而来，在1.2中调用ioctl之前会初始化需要传递的数据，此时param-&gt;name也就是在初始化数据时的io-&gt;name，即类似system_a这种。</p><img src="/2023/04/25/DeviceMapper%E9%A9%B1%E5%8A%A8/image-20230425225647715.png" alt="image-20230425225647715" style="zoom: 50%;"><p>只要传进来的分区名不含有<code>/</code>，那么名字就是合法的！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_name</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strchr</span>(name, <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>DMWARN(<span class="hljs-string">&quot;invalid device name&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-dm-create创建dm设备"><a href="#2-2-dm-create创建dm设备" class="headerlink" title="2.2 dm_create创建dm设备"></a>2.2 dm_create创建dm设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dm_create</span><span class="hljs-params">(<span class="hljs-type">int</span> minor, <span class="hljs-keyword">struct</span> mapped_device **result)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mapped_device</span> *<span class="hljs-title">md</span>;</span><br><br>md = alloc_dev(minor);<br><span class="hljs-keyword">if</span> (!md)<br><span class="hljs-keyword">return</span> -ENXIO;<br><br>dm_sysfs_init(md);<br><br>*result = md;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-2-1-alloc-dev分配设备"><a href="#2-2-1-alloc-dev分配设备" class="headerlink" title="2.2.1 alloc_dev分配设备"></a>2.2.1 alloc_dev分配设备</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> mapped_device *<span class="hljs-title function_">alloc_dev</span><span class="hljs-params">(<span class="hljs-type">int</span> minor)</span><br>&#123;<br>    <span class="hljs-comment">// 用户空间没有传递param-&gt;flags所以</span><br>    <span class="hljs-comment">// 前面没有设置minor号，所以这里是DM_ANY_MINOR</span><br><span class="hljs-keyword">if</span> (minor == DM_ANY_MINOR)<br>        <span class="hljs-comment">// minor值会依次往下运行</span><br>        <span class="hljs-comment">// 在next_free_minor里面idr机制会分配给minor一个未占用的最小值</span><br>        <span class="hljs-comment">// 从0开始</span><br>r = next_free_minor(&amp;minor);<br><span class="hljs-keyword">else</span><br>r = specific_minor(minor);<br>   <br>    <span class="hljs-comment">// 此处初始化MapperDevice各种mutex和list</span><br>    <br>    <span class="hljs-comment">// 调用blk_queue_make_request注册mapped device对应的请求队列dm_make_request</span><br>    dm_init_md_queue(md);<br>    <br>    <span class="hljs-comment">// </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-dm-hash-insert插入哈希痛"><a href="#2-3-dm-hash-insert插入哈希痛" class="headerlink" title="2.3 dm_hash_insert插入哈希痛"></a>2.3 dm_hash_insert插入哈希痛</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dm_hash_insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *uuid, <span class="hljs-keyword">struct</span> mapped_device *md)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash_cell</span> *<span class="hljs-title">cell</span>, *<span class="hljs-title">hc</span>;</span><br><br>cell = alloc_cell(name, uuid, md);<br><br>down_write(&amp;_hash_lock);<br>hc = __get_name_cell(name);<br><span class="hljs-keyword">if</span> (hc) &#123;<br>dm_put(hc-&gt;md);<br><span class="hljs-keyword">goto</span> bad;<br>&#125;<br><br>list_add(&amp;cell-&gt;name_list, _name_buckets + hash_str(name));<br><br><span class="hljs-keyword">if</span> (uuid) &#123;<br>hc = __get_uuid_cell(uuid);<br><span class="hljs-keyword">if</span> (hc) &#123;<br>list_del(&amp;cell-&gt;name_list);<br>dm_put(hc-&gt;md);<br><span class="hljs-keyword">goto</span> bad;<br>&#125;<br>list_add(&amp;cell-&gt;uuid_list, _uuid_buckets + hash_str(uuid));<br>&#125;<br>dm_get(md);<br><br>dm_set_mdptr(md, cell);<br><br>up_write(&amp;_hash_lock);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux驱动——platform设备驱动实验</title>
    <link href="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux驱动——platform设备驱动实验"><a href="#Linux驱动——platform设备驱动实验" class="headerlink" title="Linux驱动——platform设备驱动实验"></a>Linux驱动——platform设备驱动实验</h1><blockquote><p>本文为学习正点原子驱动所做笔记，仅供本人复习查阅使用，请勿商用</p><p>侵权删除！</p></blockquote><h2 id="1-Linux驱动的分离与分层"><a href="#1-Linux驱动的分离与分层" class="headerlink" title="1.Linux驱动的分离与分层"></a>1.Linux驱动的分离与分层</h2><h3 id="1-1-驱动的分隔和分离"><a href="#1-1-驱动的分隔和分离" class="headerlink" title="1.1 驱动的分隔和分离"></a>1.1 驱动的分隔和分离</h3><p>对于 Linux 这样一个成熟、庞大、复杂的操作系统，代码的重用性非常重要，否则的话就会在 Linux 内核中存在大量无意义的重复代码。尤其是驱动程序，因为驱动程序占用了 Linux 内核代码量的大头，如果不对驱动程序加以管理，任由重复的代码肆意增加，那么用不了多久 Linux 内核的文件数量就庞大到无法接受的地步。 </p><p>假如现在有三个平台 A、B 和 C，这三个平台(这里的平台说的是 SOC)上都有 MPU6050 这个 I2C接口的六轴传感器，按照我们写裸机 I2C 驱动的时候的思路，每个平台都有一个 MPU6050 的驱动，因此编写出来的最简单的驱动框架如图所示：</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422181633524.png" alt="image-20230422181633524" style="zoom:80%;"><p>每种平台下都有一个主机驱动和设备驱动，主机驱动肯定是必须要的，毕竟不同的平台其 I2C 控制器不同。但是右侧的设备驱动就没必要每个平台都写一个， 因为不管对于那个 SOC 来说，MPU6050 都是一样，通过 I2C 接口读写数据就行了，只需要一个 MPU6050 的驱动程序即可。如果再来几个 I2C 设备，比如 AT24C02、FT5206(电容触摸屏) 等，如果按照上图的写法，那么设备端的驱动将会重复的编写好几次。显然在 Linux 驱动程序中这种写法是不推荐的，最好的做法就是每个平台的 I2C 控制器都提供一个统一的接口 (也叫做主机驱动)，每个设备的话也只提供一个驱动程序(设备驱动)，每个设备通过统一的 I2C 接口驱动来访问，这样就可以大大简化驱动文件，比如上图中三种平台下的 MPU6050 驱动 框架就可以简化为： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422181657643.png" alt="image-20230422181657643" style="zoom:80%;"><p>这个就是驱动的分隔，也就是将主机驱动和设备驱动分隔开来，比如 I2C、SPI 等等都会采用驱动分隔的方式来简化驱动的开发。在实际的驱动开发中，一般 I2C 主机控制器驱动已经由半导体厂家编写好了，而设备驱动一般也由设备器件的厂家编写好了，我们只需要提供设备信息即可，比如 I2C 设备的话提供设备连接到了哪个 I2C 接口上，I2C 的速度是多少等等。相当于将设备信息从设备驱动中剥离开来，驱动使用标准方法去获取到设备信息(比如从设备树中获取到设备信息)，然后根据获取到的设备信息来初始化设备。 这样就相当于驱动只负责驱动，设备只负责设备，想办法将两者进行匹配即可。这个就是 Linux 中的总线(bus)、驱动(driver)和设备(device)模型，也就是常说的驱动分离。总线就是驱动和设备信息的月老，负责给两者牵线搭桥，如图所示</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422181717547.png" alt="image-20230422181717547" style="zoom:80%;"><p>当我们向系统注册一个驱动的时候，总线就会在右侧的设备中查找，看看有没有与之匹配的设备，如果有的话就将两者联系起来。同样的，当向系统中注册一个设备的时候，总线就会在左侧的驱动中查找看有没有与之匹配的设备，有的话也联系起来。Linux 内核中大量的驱动程序都采用总线、驱动和设备模式，我们一会要重点讲解的 platform 驱动就是这一思想下的产物。</p><h3 id="1-2-驱动的分层"><a href="#1-2-驱动的分层" class="headerlink" title="1.2 驱动的分层"></a>1.2 驱动的分层</h3><p>上一小节讲了驱动的分隔与分离，本节我们来简单看一下驱动的分层，大家应该听说过网络的 7 层模型，不同的层负责不同的内容。同样的，Linux 下的驱动往往也是分层的，分层的目的也是为了在不同的层处理不同的内容。以其他书籍或者资料常常使用到的input(输入子系统，后面会有专门的章节详细的讲解)为例，简单介绍一下驱动的分层。input 子系统负责管理所有跟输入有关的驱动，包括键盘、鼠标、触摸等，最底层的就是设备原始驱动，负责获取输入设备的原始值，获取到的输入事件上报给 input 核心层。input 核心层会处理各种 IO 模型，并且提供 file_operations 操作集合。我们在编写输入设备驱动的时候只需要处理好输入事件的上报即可，至于如何处理这些上报的输入事件那是上层去考虑的，我们不用管。可以看出借助分层模型可以极大的简化我们的驱动编写，对于驱动编写来说非常的友好。</p><h2 id="2-platform平台驱动模型简介"><a href="#2-platform平台驱动模型简介" class="headerlink" title="2.platform平台驱动模型简介"></a>2.platform平台驱动模型简介</h2><p>前面我们讲了设备驱动的分离，并且引出了总线(bus)、驱动(driver)和设备(device)模型，比如 I2C、SPI、USB 等总线。但是在 SOC 中有些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型该怎么办呢？为了解决此问题，Linux 提出了 platform 这个虚拟总线，相应的就有platform_driver 和 platform_device。</p><h3 id="2-1-platform总线"><a href="#2-1-platform总线" class="headerlink" title="2.1 platform总线"></a>2.1 platform总线</h3><p>Linux系统内核使用bus_type 结构体表示总线，此结构体定义在文件 include&#x2F;linux&#x2F;device.h， bus_type 结构体内容如下：</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422181844577.png" alt="image-20230422181844577" style="zoom: 80%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422181859954.png" alt="image-20230422181859954" style="zoom:80%;"><p>第 10 行，match 函数，此函数很重要，单词 match 的意思就是“匹配、相配”，因此此函数就是完成设备和驱动之间匹配的，总线就是使用 match 函数来根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备，因此每一条总线都必须实现此函数。match 函数有两个参数：dev 和 drv，这两个参数分别为 device 和 device_driver 类型，也就是设备和驱动。 </p><p>platform 总线是 bus_type 的一个具体实例，定义在文件 drivers&#x2F;base&#x2F;platform.c，platform 总线定义如下：</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422181937298.png" alt="image-20230422181937298" style="zoom:80%;"><p>platform_bus_type 就是 platform 平台总线，其中 platform_match 就是匹配函数。我们来看一下驱动和设备是如何匹配的，platform_match 函数定义在文件 drivers&#x2F;base&#x2F;platform.c 中，函数内容如下所示： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182023491.png" alt="image-20230422182023491" style="zoom: 50%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182043518.png" alt="image-20230422182043518" style="zoom:50%;"><p>驱动和设备的匹配有四种方法，我们依次来看一下： </p><ol><li>第 11~12 行，第一种匹配方式， OF 类型的匹配，也就是设备树采用的匹配方式， of_driver_match_device 函数定义在文件 include&#x2F;linux&#x2F;of_device.h 中。device_driver 结构体(表示设备驱动)中有个名为of_match_table的成员变量，此成员变量保存着驱动的compatible匹配表，设备树中的每个设备节点的 compatible 属性会和 of_match_table 表中的所有成员比较，查看是否有相同的条目，如果有的话就表示设备和此驱动匹配，设备和驱动匹配成功以后 probe 函数 就会执行。</li><li>第 15~16 行，第二种匹配方式，ACPI 匹配方式</li><li>第 19~20 行，第三种匹配方式，id_table 匹配，每个 platform_driver 结构体有一个 id_table成员变量，顾名思义，保存了很多 id 信息。这些 id 信息存放着这个 platformd 驱动所支持的驱动类型。</li><li>第 23 行，第四种匹配方式，如果第三种匹配方式的 id_table 不存在的话就直接比较驱动和设备的 name 字段，看看是不是相等，如果相等的话就匹配成功</li></ol><p>对于支持设备树的 Linux 版本号，一般设备驱动为了兼容性都支持设备树和无设备树两种匹配方式。也就是第一种匹配方式一般都会存在，第三种和第四种只要存在一种就可以，一般用的最多的还是第四种，也就是直接比较驱动和设备的 name 字段，毕竟这种方式最简单了。 </p><h3 id="2-2-platform驱动"><a href="#2-2-platform驱动" class="headerlink" title="2.2 platform驱动"></a>2.2 platform驱动</h3><p>platform_driver 结构体表示 platform驱动，此结构体定义在文件include&#x2F;linux&#x2F;platform_device.h 中，内容如下： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182124773.png" alt="image-20230422182124773" style="zoom: 50%;"><p>第 2 行，probe 函数，当驱动与设备匹配成功以后 probe 函数就会执行，非常重要的函数！！ 一般驱动的提供者会编写，如果自己要编写一个全新的驱动，那么 probe 就需要自行实现。 </p><p>第 7 行，driver 成员，为 device_driver 结构体变量，Linux 内核里面大量使用到了面向对象的思维，device_driver 相当于基类，提供了最基础的驱动框架。plaform_driver 继承了这个基类，然后在此基础上又添加了一些特有的成员变量。</p><p>第 8 行，id_table 表，也就是我们上一小节讲解 platform 总线匹配驱动和设备的时候采用的 第三种方法，id_table 是个表( 也就是数组) ，每个元素的类型为 platform_device_id， platform_device_id 结构体内容如下：</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182200143.png" alt="image-20230422182200143" style="zoom:50%;"><p>device_driver 结构体定义在 include&#x2F;linux&#x2F;device.h，device_driver 结构体内容如下： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182225859.png" alt="image-20230422182225859" style="zoom: 67%;"><p>第 10 行，of_match_table 就是采用设备树的时候驱动使用的匹配表，同样是数组，每个匹配项都为 of_device_id 结构体类型，此结构体定义在文件 include&#x2F;linux&#x2F;mod_devicetable.h 中，内容如下：</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182255603.png" alt="image-20230422182255603" style="zoom: 67%;"><p>第 4 行的 compatible 非常重要，因为对于设备树而言，就是通过设备节点的 compatible 属性值和 of_match_table 中每个项目的 compatible 成员变量进行比较，如果有相等的就表示设备和此驱动匹配成功。 </p><p>在编写 platform 驱动的时候，首先定义一个 platform_driver 结构体变量，然后实现结构体中的各个成员变量，重点是实现匹配方法以及 probe 函数。当驱动和设备匹配成功以后 probe函数就会执行，具体的驱动程序在 probe 函数里面编写，比如字符设备驱动等等。 当我们定义并初始化好 platform_driver 结构体变量以后，需要在驱动入口函数里面调用 platform_driver_register 函数向 Linux 内核注册一个 platform 驱动，platform_driver_register 函数原型如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">platform_driver_register</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_driver *driver)</span><br></code></pre></td></tr></table></figure><p><strong>driver</strong>：要注册的 platform 驱动。 </p><p><strong>返回值：</strong>负数，失败；0，成功。 </p><p>还需要在驱动卸载函数中通过 platform_driver_unregister 函数卸载 platform 驱动，platform_driver_unregister 函数原型如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">platform_driver_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_driver *drv)</span><br></code></pre></td></tr></table></figure><p><strong>drv</strong>：要卸载的 platform 驱动。 </p><p><strong>返回值：</strong>无。 </p><p>platform 驱动框架如下所示： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182725425.png" alt="image-20230422182725425" style="zoom:67%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182655339.png" alt="image-20230422182655339" style="zoom: 67%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182746084.png" alt="image-20230422182746084" style="zoom:67%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182802093.png" alt="image-20230422182802093" style="zoom:67%;"><p>第 1~27 行，传统的字符设备驱动，所谓的 platform 驱动并不是独立于字符设备驱动、块设备驱动和网络设备驱动之外的其他种类的驱动。platform 只是为了驱动的分离与分层而提出来 的一种框架，其驱动的具体实现还是需要字符设备驱动、块设备驱动或网络设备驱动。</p><p>第 33~39 行，xxx_probe 函数，当驱动和设备匹配成功以后此函数就会执行，以前在驱动入口 init 函数里面编写的字符设备驱动程序就全部放到此 probe 函数里面。比如注册字符设备驱动、添加 cdev、创建类等等。 </p><p>第 41~47 行，xxx_remove 函数，platform_driver 结构体中的 remove 成员变量，当关闭 platform 设备驱动的时候此函数就会执行，以前在驱动卸载 exit 函数里面要做的事情就放到此函数中来。 比如，使用 iounmap 释放内存、删除 cdev，注销设备号等等。 </p><p>第 50~53 行，xxx_of_match 匹配表，如果使用设备树的话将通过此匹配表进行驱动和设备的匹配。第 51 行设置了一个匹配项，此匹配项的 compatible 值为“xxx-gpio”，因此当设备树中设备节点的 compatible 属性值为“xxx-gpio”的时候此设备就会与此驱动匹配。第 52 行是一个标记，of_device_id 表最后一个匹配项必须是空的。 </p><p>第 58 ~ 65 行，定义一个 platform_driver 结构体变量 xxx_driver，表示 platform 驱动，第 59 ~ 62行设置 paltform_driver 中的 device_driver 成员变量的 name 和 of_match_table 这两个属性。其中name 属性用于传统的驱动与设备匹配，也就是检查驱动和设备的 name 字段是不是相同。of_match_table 属性就是用于设备树下的驱动与设备检查。对于一个完整的驱动程序，必须提供有设备树和无设备树两种匹配方法。最后 63 和 64 这两行设置 probe 和 remove 这两成员变量。 </p><p>第68~71行，驱动入口函数，调用platform_driver_register函数向Linux内核注册一个platform驱动，也就是上面定义的 xxx_driver 结构体变量。 </p><p>第 74~77 行，驱动出口函数，调用 platform_driver_unregister 函数卸载前面注册的 platform驱动。</p><p>总体来说，platform 驱动还是传统的字符设备驱动、块设备驱动或网络设备驱动，只是套上了一张“platform”的皮，目的是为了使用总线、驱动和设备这个驱动模型来实现驱动的分离与分层。</p><h3 id="2-3-platform设备"><a href="#2-3-platform设备" class="headerlink" title="2.3 platform设备"></a>2.3 platform设备</h3><p>platform 驱动已经准备好了，我们还需要 platform 设备，否则的话单单一个驱动也做不了什么。platform_device 这个结构体表示 platform 设备，这里我们要注意，如果内核支持设备树的话就不要再使用 platform_device 来描述设备了，因为改用设备树去描述了。当然了，你如果 一定要用 platform_device 来描述设备信息的话也是可以的。platform_device 结构体定义在文件 include&#x2F;linux&#x2F;platform_device.h 中，结构体内容如下： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182845233.png" alt="image-20230422182845233" style="zoom:67%;"><p>第 23 行，name 表示设备名字，要和所使用的 platform 驱动的 name 字段相同，否则的话设备就无法匹配到对应的驱动。比如对应的 platform 驱动的 name 字段为“xxx-gpio”，那么此 name字段也要设置为“xxx-gpio”。 </p><p>第 27 行，num_resources 表示资源数量，一般为第 28 行 resource 资源的大小。 </p><p>第 28 行，resource 表示资源，也就是设备信息，比如外设寄存器等。Linux 内核使用 resource结构体表示资源，resource 结构体内容如下： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182902179.png" alt="image-20230422182902179" style="zoom:67%;"><p>start 和 end 分别表示资源的起始和终止信息，对于内存类的资源，就表示内存起始和终止地址，name 表示资源名字，flags 表示资源类型，可选的资源类型都定义在了文件include&#x2F;linux&#x2F;ioport.h 里面，如下所示： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422182933077.png" alt="image-20230422182933077" style="zoom:67%;"><p>在以前不支持设备树的Linux版本中，用户需要编写platform_device变量来描述设备信息， 然后使用 platform_device_register 函数将设备信息注册到 Linux 内核中，此函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">platform_device_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span> <br></code></pre></td></tr></table></figure><p><strong>pdev</strong>：要注册的 platform 设备。 </p><p><strong>返回值：</strong>负数，失败；0，成功</p><p>如果不再使用 platform 的话可以通过 platform_device_unregister 函数注销掉相应的 platform 设备，platform_device_unregister 函数原型如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">platform_device_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span><br></code></pre></td></tr></table></figure><p><strong>pdev</strong>：要注销的 platform 设备。 </p><p><strong>返回值：</strong>无。 </p><p>platform 设备信息框架如下所示： </p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422183014879.png" alt="image-20230422183014879" style="zoom:67%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422183030672.png" alt="image-20230422183030672" style="zoom:67%;"><p>第 7~18 行，数组 xxx_resources 表示设备资源，一共有两个资源，分别为设备外设 1 和外设 2 的寄存器信息。因此 flags 都为 IORESOURCE_MEM，表示资源为内存类型的。 </p><p>第 21~26 行，platform 设备结构体变量，注意 name 字段要和所使用的驱动中的 name 字段一致，否则驱动和设备无法匹配成功。num_resources 表示资源大小，其实就是数组 xxx_resources的元素数量，这里用 ARRAY_SIZE 来测量一个数组的元素个数。 </p><p>第 29~32 行，设备模块加载函数，在此函数中调用 platform_device_register 向 Linux 内核注册 platform 设备。</p><p>第 35~38 行，设备模块卸载函数，在此函数中调用 platform_device_unregister 从 Linux 内核中卸载 platform 设备。</p><p>示例代码主要是在不支持设备树的 Linux 版本中使用的，当 Linux 内核支持了设备树以后就不需要用户手动去注册 platform 设备了。因为设备信息都放到了设备树中去描述， Linux 内核启动的时候会从设备树中读取设备信息，然后将其组织成 platform_device 形式，至于设备树到 platform_device 的具体过程就不去详细的追究了，感兴趣的可以去看一下，网上也有很多博客详细的讲解了整个过程。</p><p>关于 platform 下的总线、驱动和设备就讲解到这里，我们接下来就使用 platform 驱动框架来编写一个 LED 灯驱动，本章我们不使用设备树来描述设备信息，我们采用自定义platform_device这种“古老”方式来编写LED的设备信息。下一章我们来编写设备树下的platform驱动，这样我们就掌握了无设备树和有设备树这两种 platform 驱动的开发方式。</p><h2 id="3-实验程序编写"><a href="#3-实验程序编写" class="headerlink" title="3.实验程序编写"></a>3.实验程序编写</h2><h3 id="3-1-无设备树的platform驱动编写"><a href="#3-1-无设备树的platform驱动编写" class="headerlink" title="3.1 无设备树的platform驱动编写"></a>3.1 无设备树的platform驱动编写</h3><p>新建名为 leddevice.c 和 leddriver.c 这两个文件，这两个文件分别为 LED 灯的 platform 设备文件和 LED 灯的 platform 的驱动文件</p><p><code>leddevice.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 寄存器地址定义</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CCM_CCGR1_BASE              (0X020C406C)        </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_MUX_GPIO1_IO03_BASE      (0X020E0068)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SW_PAD_GPIO1_IO03_BASE      (0X020E02F4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_DR_BASE               (0X0209C000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO1_GDIR_BASE             (0X0209C004)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REGISTER_LENGTH             4</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">led_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br>        printk(<span class="hljs-string">&quot;led device released!\r\n&quot;</span>);        <br>&#125;<br><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * 设备资源信息，也就是LED0所使用的所有寄存器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> <span class="hljs-title">led_resources</span>[] =</span> &#123;<br>        [<span class="hljs-number">0</span>] = &#123;<br>                .start         = CCM_CCGR1_BASE,<br>                .end         = (CCM_CCGR1_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<br>                .flags         = IORESOURCE_MEM,<br>        &#125;,        <br>        [<span class="hljs-number">1</span>] = &#123;<br>                .start        = SW_MUX_GPIO1_IO03_BASE,<br>                .end        = (SW_MUX_GPIO1_IO03_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<br>                .flags        = IORESOURCE_MEM,<br>        &#125;,<br>        [<span class="hljs-number">2</span>] = &#123;<br>                .start        = SW_PAD_GPIO1_IO03_BASE,<br>                .end        = (SW_PAD_GPIO1_IO03_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<br>                .flags        = IORESOURCE_MEM,<br>        &#125;,<br>        [<span class="hljs-number">3</span>] = &#123;<br>                .start        = GPIO1_DR_BASE,<br>                .end        = (GPIO1_DR_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<br>                .flags        = IORESOURCE_MEM,<br>        &#125;,<br>        [<span class="hljs-number">4</span>] = &#123;<br>                .start        = GPIO1_GDIR_BASE,<br>                .end        = (GPIO1_GDIR_BASE + REGISTER_LENGTH - <span class="hljs-number">1</span>),<br>                .flags        = IORESOURCE_MEM,<br>        &#125;,<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * platform设备结构体 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> <span class="hljs-title">leddevice</span> =</span> &#123;<br>        .name = <span class="hljs-string">&quot;imx6ul-amx-led&quot;</span>,<br>        .id = <span class="hljs-number">-1</span>,<br>        .dev = &#123;<br>                .release = &amp;led_release,<br>        &#125;,<br>        .num_resources = ARRAY_SIZE(led_resources),<br>        .resource = led_resources,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">leddevice_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-keyword">return</span> platform_device_register(&amp;leddevice);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">leddevice_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        platform_device_unregister(&amp;leddevice);<br>&#125;<br><br>module_init(leddevice_init);<br>module_exit(leddevice_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;anmuxixixi&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>leddriver.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_CNT      1           <span class="hljs-comment">/* 设备号长度         */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_NAME     <span class="hljs-string">&quot;platled&quot;</span>   <span class="hljs-comment">/* 设备名字         */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF          0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON           1</span><br><br><span class="hljs-comment">/* 寄存器名 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *IMX6U_CCM_CCGR1;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_MUX_GPIO1_IO03;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *SW_PAD_GPIO1_IO03;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_DR;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __iomem *GPIO1_GDIR;<br><br><span class="hljs-comment">/* leddev设备结构体 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span>&#123;</span><br>        <span class="hljs-type">dev_t</span> devid;                        <span class="hljs-comment">/* 设备号 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>                <span class="hljs-comment">/* cdev */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>        <span class="hljs-comment">/* 类 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>        <span class="hljs-comment">/* 设备 */</span><br>        <span class="hljs-type">int</span> major;                                <span class="hljs-comment">/* 主设备号 */</span>                <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span> <span class="hljs-title">leddev</span>;</span>         <span class="hljs-comment">/* led设备 */</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">led0_switch</span><span class="hljs-params">(u8 sta)</span><br>&#123;<br>        u32 val = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(sta == LEDON)&#123;<br>                val = readl(GPIO1_DR);<br>                val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);        <br>                writel(val, GPIO1_DR);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sta == LEDOFF)&#123;<br>                val = readl(GPIO1_DR);<br>                val|= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);        <br>                writel(val, GPIO1_DR);<br>        &#125;        <br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>        filp-&gt;private_data = &amp;leddev; <span class="hljs-comment">/* 设置私有数据  */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>&#123;<br>        <span class="hljs-type">int</span> retvalue;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ledstat;<br><br>        retvalue = copy_from_user(databuf, buf, cnt);<br>        <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> -EFAULT;<br>        &#125;<br><br>        ledstat = databuf[<span class="hljs-number">0</span>];                <span class="hljs-comment">/* 获取状态值 */</span><br>        <span class="hljs-keyword">if</span>(ledstat == LEDON) &#123;<br>                led0_switch(LEDON);                <span class="hljs-comment">/* 打开LED灯 */</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ledstat == LEDOFF) &#123;<br>                led0_switch(LEDOFF);        <span class="hljs-comment">/* 关闭LED灯 */</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">led_fops</span> =</span> &#123;<br>        .owner = THIS_MODULE,<br>        .open = led_open,<br>        .write = led_write,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span><br>&#123;        <br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ressize[<span class="hljs-number">5</span>];<br>        u32 val = <span class="hljs-number">0</span>;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">ledsource</span>[5];</span><br><br>        printk(<span class="hljs-string">&quot;led driver and device has matched!\r\n&quot;</span>);<br>        <span class="hljs-comment">/* 1、获取资源 */</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                ledsource[i] = platform_get_resource(dev, IORESOURCE_MEM, i); <span class="hljs-comment">/* 依次MEM类型资源 */</span><br>                <span class="hljs-keyword">if</span> (!ledsource[i]) &#123;<br>                        dev_err(&amp;dev-&gt;dev, <span class="hljs-string">&quot;No MEM resource for always on\n&quot;</span>);<br>                        <span class="hljs-keyword">return</span> -ENXIO;<br>                &#125;<br>                ressize[i] = resource_size(ledsource[i]);        <br>        &#125;        <br><br>        <span class="hljs-comment">/* 2、初始化LED */</span><br>        <span class="hljs-comment">/* 寄存器地址映射 */</span><br>         IMX6U_CCM_CCGR1 = ioremap(ledsource[<span class="hljs-number">0</span>]-&gt;start, ressize[<span class="hljs-number">0</span>]);<br>        SW_MUX_GPIO1_IO03 = ioremap(ledsource[<span class="hljs-number">1</span>]-&gt;start, ressize[<span class="hljs-number">1</span>]);<br>          SW_PAD_GPIO1_IO03 = ioremap(ledsource[<span class="hljs-number">2</span>]-&gt;start, ressize[<span class="hljs-number">2</span>]);<br>        GPIO1_DR = ioremap(ledsource[<span class="hljs-number">3</span>]-&gt;start, ressize[<span class="hljs-number">3</span>]);<br>        GPIO1_GDIR = ioremap(ledsource[<span class="hljs-number">4</span>]-&gt;start, ressize[<span class="hljs-number">4</span>]);<br>        <br>        val = readl(IMX6U_CCM_CCGR1);<br>        val &amp;= ~(<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);                                <span class="hljs-comment">/* 清除以前的设置 */</span><br>        val |= (<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">26</span>);                                <span class="hljs-comment">/* 设置新值 */</span><br>        writel(val, IMX6U_CCM_CCGR1);<br><br>        <span class="hljs-comment">/* 设置GPIO1_IO03复用功能，将其复用为GPIO1_IO03 */</span><br>        writel(<span class="hljs-number">5</span>, SW_MUX_GPIO1_IO03);<br>        writel(<span class="hljs-number">0x10B0</span>, SW_PAD_GPIO1_IO03);<br><br>        <span class="hljs-comment">/* 设置GPIO1_IO03为输出功能 */</span><br>        val = readl(GPIO1_GDIR);<br>        val &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);                        <span class="hljs-comment">/* 清除以前的设置 */</span><br>        val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);                        <span class="hljs-comment">/* 设置为输出 */</span><br>        writel(val, GPIO1_GDIR);<br><br>        <span class="hljs-comment">/* 默认关闭LED1 */</span><br>        val = readl(GPIO1_DR);<br>        val |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>) ;        <br>        writel(val, GPIO1_DR);<br>        <br>        <span class="hljs-comment">/* 注册字符设备驱动 */</span><br>        <span class="hljs-comment">/*1、创建设备号 */</span><br>        <span class="hljs-keyword">if</span> (leddev.major) &#123;                <span class="hljs-comment">/*  定义了设备号 */</span><br>                leddev.devid = MKDEV(leddev.major, <span class="hljs-number">0</span>);<br>                register_chrdev_region(leddev.devid, LEDDEV_CNT, LEDDEV_NAME);<br>        &#125; <span class="hljs-keyword">else</span> &#123;                                                <span class="hljs-comment">/* 没有定义设备号 */</span><br>                alloc_chrdev_region(&amp;leddev.devid, <span class="hljs-number">0</span>, LEDDEV_CNT, LEDDEV_NAME);        <span class="hljs-comment">/* 申请设备号 */</span><br>                leddev.major = MAJOR(leddev.devid);        <span class="hljs-comment">/* 获取分配号的主设备号 */</span><br>        &#125;<br>        <br>        <span class="hljs-comment">/* 2、初始化cdev */</span><br>        leddev.cdev.owner = THIS_MODULE;<br>        cdev_init(&amp;leddev.cdev, &amp;led_fops);<br>        <br>        <span class="hljs-comment">/* 3、添加一个cdev */</span><br>        cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);<br><br>        <span class="hljs-comment">/* 4、创建类 */</span><br>        leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);<br>        <span class="hljs-keyword">if</span> (IS_ERR(leddev.class)) &#123;<br>                <span class="hljs-keyword">return</span> PTR_ERR(leddev.class);<br>        &#125;<br><br>        <span class="hljs-comment">/* 5、创建设备 */</span><br>        leddev.device = device_create(leddev.class, <span class="hljs-literal">NULL</span>, leddev.devid, <span class="hljs-literal">NULL</span>, LEDDEV_NAME);<br>        <span class="hljs-keyword">if</span> (IS_ERR(leddev.device)) &#123;<br>                <span class="hljs-keyword">return</span> PTR_ERR(leddev.device);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span><br>&#123;<br>    <span class="hljs-comment">/* 取消虚拟地址映射 */</span><br>        iounmap(IMX6U_CCM_CCGR1);<br>        iounmap(SW_MUX_GPIO1_IO03);<br>        iounmap(SW_PAD_GPIO1_IO03);<br>        iounmap(GPIO1_DR);<br>        iounmap(GPIO1_GDIR);<br><br>        cdev_del(&amp;leddev.cdev); <span class="hljs-comment">/* 删除cdev */</span><br>        unregister_chrdev_region(leddev.devid, LEDDEV_CNT); <span class="hljs-comment">/* 注销设备号 */</span><br>        device_destroy(leddev.class, leddev.devid);<br>        class_destroy(leddev.class);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* platform驱动结构体 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">led_driver</span> =</span> &#123;<br>        .driver                = &#123;<br>                .name        = <span class="hljs-string">&quot;imx6ul-amx-led&quot;</span>,      <span class="hljs-comment">/* 驱动名字，用于和设备匹配 */</span><br>        &#125;,<br>        .probe                = led_probe,<br>        .remove                = led_remove,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">leddriver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-keyword">return</span> platform_driver_register(&amp;led_driver);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">leddriver_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        platform_driver_unregister(&amp;led_driver);<br>&#125;<br><br>module_init(leddriver_init);<br>module_exit(leddriver_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;anmuxixixi&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>platledAPP.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fcntl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF         0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON         1</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description          : main主程序</span><br><span class="hljs-comment"> * @param - argc         : argv数组元素个数</span><br><span class="hljs-comment"> * @param - argv         : 具体参数</span><br><span class="hljs-comment"> * @return               : 0 成功;其他 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>        <span class="hljs-type">int</span> fd, retvalue;<br>        <span class="hljs-type">char</span> *filename;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">2</span>];<br>        <br>        <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Usage!\r\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        filename = argv[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">/* 打开led驱动 */</span><br>        fd = open(filename, O_RDWR);<br>        <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file %s open failed!\r\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <br>        databuf[<span class="hljs-number">0</span>] = atoi(argv[<span class="hljs-number">2</span>]);        <span class="hljs-comment">/* 要执行的操作：打开或关闭 */</span><br>        retvalue = write(fd, databuf, <span class="hljs-keyword">sizeof</span>(databuf));<br>        <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LED Control Failed!\r\n&quot;</span>);<br>                close(fd);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        retvalue = close(fd); <span class="hljs-comment">/* 关闭文件 */</span><br>        <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file %s close failed!\r\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/f557da58-4767-47d8-8f40-51ff98a7debb.png" alt="image-20230422183030672" style="zoom:67%;"><h3 id="3-2-设备树下的platform驱动编写"><a href="#3-2-设备树下的platform驱动编写" class="headerlink" title="3.2 设备树下的platform驱动编写"></a>3.2 设备树下的platform驱动编写</h3><p><strong>1、在设备树中创建设备节点</strong></p><p>直接使用<code>7.4.1</code>中的设备树</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/267c8f85-c684-44e6-aacb-f3456432144d.png" alt="image-20230422183030672" style="zoom:67%;"><p>注意compatible 属性值为“fsl,gpioled”，因此一会在编写 platform 驱动的时候 of_match_table 属性表中要有“fsl,gpioled”。 </p><p><strong>2、编写 platform 驱动的时候要注意兼容属性</strong></p><p>上一章已经详细的讲解过了，在使用设备树的时候 platform 驱动会通过 of_match_table 来 保存兼容性值，也就是表明此驱动兼容哪些设备。所以，of_match_table 将会尤为重要，比如本例程的 platform 驱动中 platform_driver 就可以按照如下所示设置：</p><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422183516606.png" alt="image-20230422183516606" style="zoom:80%;"><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/image-20230422183536714.png" alt="image-20230422183536714" style="zoom:80%;"><p>第 1~4 行，of_device_id 表，也就是驱动的兼容表，是一个数组，每个数组元素为 of_device_id 类型。每个数组元素都是一个兼容属性，表示兼容的设备，一个驱动可以跟多个设备匹配。这里我们仅仅匹配了一个设备，那创建的 gpioled 这个设备。第 2 行的 compatible 值为“atkalpha-gpioled”，驱动中的 compatible 属性和设备中的 compatible 属性相匹配，因此驱动中对应的 probe 函数就会执行。注意第 3 行是一个空元素，在编写 of_device_id 的时候最后一个元素一定要为空！ </p><p>第 6 行，通过 MODULE_DEVICE_TABLE 声明一下 leds_of_match 这个设备匹配表。 </p><p>第 11 行，设置 platform_driver 中的 of_match_table 匹配表为上面创建的 leds_of_match，至此我们就设置好了 platform 驱动的匹配表了。</p><p><strong>3、编写 platform 驱动</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_CNT                 1               <span class="hljs-comment">/* 设备号长度 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDDEV_NAME                <span class="hljs-string">&quot;dtsplatled&quot;</span>    <span class="hljs-comment">/* 设备名字 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDOFF                     0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEDON                      1</span><br><br><span class="hljs-comment">/* leddev设备结构体 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span>&#123;</span><br>        <span class="hljs-type">dev_t</span> devid;                                <span class="hljs-comment">/* 设备号 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>                        <span class="hljs-comment">/* cdev */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>                <span class="hljs-comment">/* 类 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>                <span class="hljs-comment">/* 设备 */</span><br>        <span class="hljs-type">int</span> major;                                        <span class="hljs-comment">/* 主设备号 */</span>        <br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">node</span>;</span>        <span class="hljs-comment">/* LED设备节点 */</span><br>        <span class="hljs-type">int</span> led0;                                        <span class="hljs-comment">/* LED灯GPIO标号 */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">leddev_dev</span> <span class="hljs-title">leddev</span>;</span>                 <span class="hljs-comment">/* led设备 */</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">led0_switch</span><span class="hljs-params">(u8 sta)</span><br>&#123;<br>        <span class="hljs-keyword">if</span> (sta == LEDON )<br>        gpio_set_value(leddev.led0, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sta == LEDOFF)<br>                gpio_set_value(leddev.led0, <span class="hljs-number">1</span>);        <br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>        filp-&gt;private_data = &amp;leddev; <span class="hljs-comment">/* 设置私有数据  */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>&#123;<br>        <span class="hljs-type">int</span> retvalue;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> databuf[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ledstat;<br><br>        retvalue = copy_from_user(databuf, buf, cnt);<br>        <span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>) &#123;<br><br>                printk(<span class="hljs-string">&quot;kernel write failed!\r\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> -EFAULT;<br>        &#125;<br>        <br>        ledstat = databuf[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (ledstat == LEDON) &#123;<br>                led0_switch(LEDON);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ledstat == LEDOFF) &#123;<br>                led0_switch(LEDOFF);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">led_fops</span> =</span> &#123;<br>        .owner = THIS_MODULE,<br>        .open = led_open,<br>        .write = led_write,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span><br>&#123;        <br>        printk(<span class="hljs-string">&quot;led driver and device was matched!\r\n&quot;</span>);<br>        <span class="hljs-comment">/* 1、设置设备号 */</span><br>        <span class="hljs-keyword">if</span> (leddev.major) &#123;<br>                leddev.devid = MKDEV(leddev.major, <span class="hljs-number">0</span>);<br>                register_chrdev_region(leddev.devid, LEDDEV_CNT, LEDDEV_NAME);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                alloc_chrdev_region(&amp;leddev.devid, <span class="hljs-number">0</span>, LEDDEV_CNT, LEDDEV_NAME);<br>                leddev.major = MAJOR(leddev.devid);<br>        &#125;<br><br>        <span class="hljs-comment">/* 2、注册设备 */</span><br>        cdev_init(&amp;leddev.cdev, &amp;led_fops);<br>        cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);<br><br>        <span class="hljs-comment">/* 3、创建类 */</span><br>        leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);<br>        <span class="hljs-keyword">if</span> (IS_ERR(leddev.class)) &#123;<br>                <span class="hljs-keyword">return</span> PTR_ERR(leddev.class);<br>        &#125;<br><br>        <span class="hljs-comment">/* 4、创建设备 */</span><br>        leddev.device = device_create(leddev.class, <span class="hljs-literal">NULL</span>, leddev.devid, <span class="hljs-literal">NULL</span>, LEDDEV_NAME);<br>        <span class="hljs-keyword">if</span> (IS_ERR(leddev.device)) &#123;<br>                <span class="hljs-keyword">return</span> PTR_ERR(leddev.device);<br>        &#125;<br><br>        <span class="hljs-comment">/* 5、初始化IO */</span><br>        leddev.node = of_find_node_by_path(<span class="hljs-string">&quot;/gpioled&quot;</span>);<br>        <span class="hljs-keyword">if</span> (leddev.node == <span class="hljs-literal">NULL</span>)&#123;<br>                printk(<span class="hljs-string">&quot;gpioled node nost find!\r\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> -EINVAL;<br>        &#125; <br>        <br>        leddev.led0 = of_get_named_gpio(leddev.node, <span class="hljs-string">&quot;led-gpio&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (leddev.led0 &lt; <span class="hljs-number">0</span>) &#123;<br>                printk(<span class="hljs-string">&quot;can&#x27;t get led-gpio\r\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> -EINVAL;<br>        &#125;<br><br>        gpio_request(leddev.led0, <span class="hljs-string">&quot;led0&quot;</span>);<br>        gpio_direction_output(leddev.led0, <span class="hljs-number">1</span>); <span class="hljs-comment">/* led0 IO设置为输出，默认高电平        */</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *dev)</span><br>&#123;<br>        printk(<span class="hljs-string">&quot;led remove\r\n&quot;</span>);<br>        gpio_set_value(leddev.led0, <span class="hljs-number">1</span>);         <span class="hljs-comment">/* 卸载驱动的时候关闭LED */</span><br>        gpio_free(leddev.led0);                                <span class="hljs-comment">/* 释放IO */</span><br><br>        cdev_del(&amp;leddev.cdev);                                <span class="hljs-comment">/*  删除cdev */</span><br>        unregister_chrdev_region(leddev.devid, LEDDEV_CNT); <span class="hljs-comment">/* 注销设备号 */</span><br>        device_destroy(leddev.class, leddev.devid);<br>        class_destroy(leddev.class);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 匹配列表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">led_of_match</span>[] =</span> &#123;<br>        &#123; .compatible = <span class="hljs-string">&quot;fsl,gpioled&quot;</span>&#125;,<br>        &#123; <span class="hljs-comment">/* Sentinel */</span> &#125;,<br>&#125;;<br><br><span class="hljs-comment">/* platform驱动结构体 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">led_driver</span> =</span> &#123;<br>        .driver = &#123;<br>                .name = <span class="hljs-string">&quot;imx6ul-amx-led&quot;</span>,      <span class="hljs-comment">/* 驱动名字，用于和设备匹配 */</span><br>                .of_match_table = led_of_match, <span class="hljs-comment">/* 设备树匹配表 */</span><br>        &#125;,<br>        .probe = led_probe,<br>        .remove = led_remove,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">dtsleddriver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-keyword">return</span> platform_driver_register(&amp;led_driver);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">dtsleddriver_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        platform_driver_unregister(&amp;led_driver);<br>&#125;<br><br>module_init(dtsleddriver_init);<br>module_exit(dtsleddriver_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;anmuxixixi&quot;</span>);<br></code></pre></td></tr></table></figure><img src="/2023/04/22/Linux%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/fde6442f-8f21-42ad-9a4d-c5e7f2f9d54e.png" alt="image-20230422183030672" style="zoom:67%;">]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
      <category>linux驱动</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux设备模型之二:sysfs</title>
    <link href="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%BA%8C-sysfs/"/>
    <url>/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%BA%8C-sysfs/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux设备模型之二-sysfs"><a href="#Linux设备模型之二-sysfs" class="headerlink" title="Linux设备模型之二:sysfs"></a>Linux设备模型之二:sysfs</h1><blockquote><p>转载自：<a href="http://www.wowotech.net/device_model/dm_sysfs.html">http://www.wowotech.net/device_model/dm_sysfs.html</a></p><p>作为自己的学习笔记</p></blockquote><p><strong>Sysfs</strong> 是Linux 2.6所提供的一种虚拟文件系统。这个文件系统不仅可以把设备（devices）和驱动程序（drivers）的信息从内核输出到用户空间，也可以用来对设备和驱动程序做设置。</p><h2 id="1-初识sys-文件系统"><a href="#1-初识sys-文件系统" class="headerlink" title="1.初识sys 文件系统"></a>1.初识sys 文件系统</h2><p>简单的说，sysfs是一个基于内存的文件系统，它的作用是将内核信息以文件的方式提供给用户程序使用。</p><p>sysfs可以看成与proc,devfs和devpty同类别的文件系统，该文件系统是虚拟的文件系统，可以更方便对系统设备进行管理。它可以产生一个包含所有系统硬件层次视图，与提供进程和状态信息的proc文件系统十分类似。</p><p>sysfs把连接在系统上的设备和总线组织成为一个分级的文件，它们可以由用户空间存取，向用户空间导出内核的数据结构以及它们的属性。sysfs的一个目的就是展示设备驱动模型中各组件的层次关系，其顶级目录包括block,bus,drivers,class,power和firmware等.</p><p>sysfs提供一种机制，使得可以显式的描述内核对象、对象属性及对象间关系。sysfs有两组接口，一组针对内核，用于将设备映射到文件系统中，另一组针对用户程序，用于读取或操作这些设备。下表描述了内核中的sysfs要素及其在用户空间的表现：</p><img src="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%BA%8C-sysfs/image-20230416210112684.png" alt="image-20230416210112684" style="zoom:80%;"><h2 id="2-sysfs-与-x2F-sys"><a href="#2-sysfs-与-x2F-sys" class="headerlink" title="2.sysfs 与 &#x2F;sys"></a>2.sysfs 与 &#x2F;sys</h2><p>sysfs 文件系统总是被挂载在 &#x2F;sys 挂载点上。虽然在较早期的2.6内核系统上并没有规定 sysfs 的标准挂载位置，可以把 sysfs 挂载在任何位置，但较近的2.6内核修正了这一规则，要求 <strong>sysfs 总是挂载在 &#x2F;sys 目录</strong>上。</p><img src="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%BA%8C-sysfs/webp" alt="img" style="zoom:100%;"><h2 id="3-sysfs和Kobject的关系"><a href="#3-sysfs和Kobject的关系" class="headerlink" title="3.sysfs和Kobject的关系"></a>3.sysfs和Kobject的关系</h2><p>每一个Kobject，都会对应sysfs中的一个目录。因此在将Kobject添加到Kernel时，create_dir接口会调用sysfs文件系统的创建目录接口，创建和Kobject对应的目录，相关的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//lib/kobject.c </span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">create_dir</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobj)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span> *<span class="hljs-title">ktype</span> =</span> get_ktype(kobj);<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_ns_type_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">int</span> error;<br><br>error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj));<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br><br>error = populate_dir(kobj);<br><span class="hljs-keyword">if</span> (error) &#123;<br>sysfs_remove_dir(kobj);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br><br><span class="hljs-keyword">if</span> (ktype) &#123;<br>error = sysfs_create_groups(kobj, ktype-&gt;default_groups);<br><span class="hljs-keyword">if</span> (error) &#123;<br>sysfs_remove_dir(kobj);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @kobj-&gt;sd may be deleted by an ancestor going away.  Hold an</span><br><span class="hljs-comment"> * extra reference so that it stays until @kobj is gone.</span><br><span class="hljs-comment"> */</span><br>sysfs_get(kobj-&gt;sd);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If @kobj has ns_ops, its children need to be filtered based on</span><br><span class="hljs-comment"> * their namespace tags.  Enable namespace support on @kobj-&gt;sd.</span><br><span class="hljs-comment"> */</span><br>ops = kobj_child_ns_ops(kobj);<br><span class="hljs-keyword">if</span> (ops) &#123;<br>BUG_ON(ops-&gt;type &lt;= KOBJ_NS_TYPE_NONE);<br>BUG_ON(ops-&gt;type &gt;= KOBJ_NS_TYPES);<br>BUG_ON(!kobj_ns_type_registered(ops-&gt;type));<br><br>sysfs_enable_ns(kobj-&gt;sd);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-attribute"><a href="#4-attribute" class="headerlink" title="4.attribute"></a>4.attribute</h2><h3 id="4-1-attribute的功能概述"><a href="#4-1-attribute的功能概述" class="headerlink" title="4.1 attribute的功能概述"></a>4.1 attribute的功能概述</h3><p>在sysfs中，为什么会有attribute的概念呢？其实它是对应kobject而言的，指的是kobject的“属性”。我们知道，sysfs中的目录描述了kobject，而kobject是特定数据类型变量（如struct device）的体现。因此kobject的属性，就是这些变量的属性。它可以是任何东西，名称、一个内部变量、一个字符串等等。而attribute，在sysfs文件系统中是以文件的形式提供的，即：kobject的所有属性，都在它对应的sysfs目录下以文件的形式呈现。这些文件一般是可读、写的，而kernel中定义了这些属性的模块，会根据用户空间的读写操作，记录和返回这些attribute的值。</p><p><strong>总结一下：所谓的attibute，就是内核空间和用户空间进行信息交互的一种方法。例如某个driver定义了一个变量，却希望用户空间程序可以修改该变量，以控制driver的运行行为，那么就可以将该变量以sysfs attribute的形式开放出来。</strong></p><p>Linux内核中，attribute分为普通的attribute和二进制attribute，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//include/linux/sysfs.h </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;<br><span class="hljs-type">umode_t</span>mode;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="hljs-type">bool</span>ignore_lockdep:<span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span>*<span class="hljs-title">key</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span><span class="hljs-title">skey</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bin_attribute</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span><span class="hljs-title">attr</span>;</span><br><span class="hljs-type">size_t</span>size;<br><span class="hljs-type">void</span>*private;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *(*<span class="hljs-title">f_mapping</span>)(<span class="hljs-title">void</span>);</span><br><span class="hljs-type">ssize_t</span> (*read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> kobject *, <span class="hljs-keyword">struct</span> bin_attribute *,<br><span class="hljs-type">char</span> *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">size_t</span>);<br><span class="hljs-type">ssize_t</span> (*write)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> kobject *, <span class="hljs-keyword">struct</span> bin_attribute *,<br> <span class="hljs-type">char</span> *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">size_t</span>);<br><span class="hljs-type">int</span> (*mmap)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> kobject *, <span class="hljs-keyword">struct</span> bin_attribute *attr,<br>    <span class="hljs-keyword">struct</span> vm_area_struct *vma);<br>&#125;;<br></code></pre></td></tr></table></figure><p>struct attribute为普通的attribute，使用该attribute生成的sysfs文件，只能用字符串的形式读写（后面会说为什么）。而struct bin_attribute在struct attribute的基础上，增加了read、write等函数，因此它所生成的sysfs文件可以用任何方式读写。</p><p>说完基本概念，我们要问两个问题：</p><ul><li>Kernel怎么把attribute变成sysfs中的文件呢？</li><li>用户空间对sysfs的文件进行的读写操作，怎么传递给Kernel呢？</li></ul><p>下面来看看这个过程。</p><h3 id="4-2-attibute文件的创建"><a href="#4-2-attibute文件的创建" class="headerlink" title="4.2 attibute文件的创建"></a>4.2 attibute文件的创建</h3><p>在linux内核中，attibute文件的创建是由fs&#x2F;sysfs&#x2F;dir.c 中sysfs_create_dir_ns接口完成的，该接口的实现没有什么特殊之处，大多是文件系统相关的操作，和设备模型没有太多的关系，这里先略过不提。</p><h3 id="4-3-attibute文件的read和write"><a href="#4-3-attibute文件的read和write" class="headerlink" title="4.3 attibute文件的read和write"></a>4.3 attibute文件的read和write</h3><p>看到4.1章节struct attribute的原型时，也许我们会犯嘀咕，该结构很简单啊，name表示文件名称，mode表示文件模式，其它的字段都是内核用于debug Kernel Lock的，那文件操作的接口在哪里呢？</p><p>不着急，我们去fs&#x2F;sysfs目录下看看sysfs相关的代码逻辑。</p><p>所有的文件系统，都会定义一个struct file_operations变量，用于描述本文件系统的操作接口，sysfs也不例外：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* kernfs read callback for regular sysfs files with pre-alloc */</span><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sysfs_kf_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kernfs_open_file *of, <span class="hljs-type">char</span> *buf,</span><br><span class="hljs-params">     <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> pos)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span> *<span class="hljs-title">ops</span> =</span> sysfs_file_ops(of-&gt;kn);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> *<span class="hljs-title">kobj</span> =</span> of-&gt;kn-&gt;parent-&gt;priv;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If buf != of-&gt;prealloc_buf, we don&#x27;t know how</span><br><span class="hljs-comment"> * large it is, so cannot safely pass it to -&gt;show</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (pos || WARN_ON_ONCE(buf != of-&gt;prealloc_buf))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> ops-&gt;show(kobj, of-&gt;kn-&gt;priv, buf);<br>&#125;<br><br><span class="hljs-comment">/* kernfs write callback for regular sysfs files */</span><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sysfs_kf_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kernfs_open_file *of, <span class="hljs-type">char</span> *buf,</span><br><span class="hljs-params">      <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> pos)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span> *<span class="hljs-title">ops</span> =</span> sysfs_file_ops(of-&gt;kn);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> *<span class="hljs-title">kobj</span> =</span> of-&gt;kn-&gt;parent-&gt;priv;<br><br><span class="hljs-keyword">if</span> (!count)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span> ops-&gt;store(kobj, of-&gt;kn-&gt;priv, buf, count);<br>&#125;<br></code></pre></td></tr></table></figure><p>attribute文件的read操作，会由VFS转到sysfs_file_operations的read（也就是sysfs_read_file）接口上，让我们大概看一下该接口的处理逻辑。</p><h2 id="5-sysfs在设备模型中的应用总结"><a href="#5-sysfs在设备模型中的应用总结" class="headerlink" title="5.sysfs在设备模型中的应用总结"></a>5.sysfs在设备模型中的应用总结</h2><p>让我们通过设备模型class.c中有关sysfs的实现，来总结一下sysfs的应用方式。</p><p>首先，在class.c中，定义了Class所需的ktype以及sysfs_ops类型的变量，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//drivers/base/class.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span> <span class="hljs-title">class_sysfs_ops</span> =</span> &#123;<br>.show   = class_attr_show,<br>.store   = class_attr_store,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span> <span class="hljs-title">class_ktype</span> =</span> &#123;<br>.sysfs_ops= &amp;class_sysfs_ops,<br>.release= class_release,<br>.child_ns_type= class_child_ns_type,<br>&#125;;<br></code></pre></td></tr></table></figure><p>所有class_type的Kobject下面的attribute文件的读写操作，都会交给class_attr_show和class_attr_store两个接口处理。以class_attr_show为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//drivers/base/class.c </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> to_class_attr(_attr) container_of(_attr, struct class_attribute, attr)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">class_attr_show</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobj, <span class="hljs-keyword">struct</span> attribute *attr,</span><br><span class="hljs-params">       <span class="hljs-type">char</span> *buf)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">class_attribute</span> *<span class="hljs-title">class_attr</span> =</span> to_class_attr(attr);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subsys_private</span> *<span class="hljs-title">cp</span> =</span> to_subsys_private(kobj);<br><span class="hljs-type">ssize_t</span> ret = -EIO;<br><br><span class="hljs-keyword">if</span> (class_attr-&gt;show)<br>ret = class_attr-&gt;show(cp-&gt;class, class_attr, buf);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>该接口使用container_of从struct attribute类型的指针中取得一个class模块的自定义指针：struct class_attribute，该指针中包含了class模块自身的show和store接口。下面是struct class_attribute的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//include/linux/device/class.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">class_attribute</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> <span class="hljs-title">attr</span>;</span><br><span class="hljs-type">ssize_t</span> (*show)(<span class="hljs-keyword">struct</span> class *class, <span class="hljs-keyword">struct</span> class_attribute *attr,<br><span class="hljs-type">char</span> *buf);<br><span class="hljs-type">ssize_t</span> (*store)(<span class="hljs-keyword">struct</span> class *class, <span class="hljs-keyword">struct</span> class_attribute *attr,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> count);<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>因此，所有需要使用attribute的模块，都不会直接定义struct attribute变量，而是通过一个自定义的数据结构，该数据结构的一个成员是struct attribute类型的变量，并提供show和store回调函数。然后在该模块ktype所对应的struct sysfs_ops变量中，实现该本模块整体的show和store函数，并在被调用时，转接到自定义数据结构（struct class_attribute）中的show和store函数中。这样，每个atrribute文件，实际上对应到一个自定义数据结构变量中了。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux设备模型之一:Kobject</title>
    <link href="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%80-Kobject/"/>
    <url>/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%80-Kobject/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux设备模型之一-Kobject"><a href="#Linux设备模型之一-Kobject" class="headerlink" title="Linux设备模型之一:Kobject"></a>Linux设备模型之一:Kobject</h1><p>每一个kobject对象都会关联一个sysfs文件目录，本节重点关注如何将kobject对象与sysfs文件系统关联起来，关注kobject对象默认的属性文件操作接口</p><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h2><h3 id="1-1-kobject"><a href="#1-1-kobject" class="headerlink" title="1.1 kobject"></a>1.1 kobject</h3><ul><li>kobject代表内核对象，结构体本身不单独使用，而是嵌套在其他高层结构中，用于组织成拓扑关系；</li><li>sysfs文件系统中一个目录对应一个kobject</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/kobject.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;       <span class="hljs-comment">// 设备的名字</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">entry</span>;</span>   <span class="hljs-comment">// 用于链接目录</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span>*<span class="hljs-title">parent</span>;</span> <span class="hljs-comment">// 父亲节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span>*<span class="hljs-title">kset</span>;</span>       <span class="hljs-comment">// 所属的kset</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span>*<span class="hljs-title">ktype</span>;</span>  <span class="hljs-comment">// 对应的ktype操作</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kernfs_node</span>*<span class="hljs-title">sd</span>;</span>    <span class="hljs-comment">// 该kobject对象在sysfs文件系统中所对应的文件目录</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kref</span><span class="hljs-title">kref</span>;</span>       <span class="hljs-comment">// 引用计数</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">delayed_work</span><span class="hljs-title">release</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state_initialized:<span class="hljs-number">1</span>;   <span class="hljs-comment">// 是否初始化标志</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state_in_sysfs:<span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state_add_uevent_sent:<span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state_remove_uevent_sent:<span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uevent_suppress:<span class="hljs-number">1</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>kobject只是一个通用对象的表示（类似C++中的基类），它抽象出一些通用的属性（如引用计数）以及通用接口，它通常是被其他数据结构（结构体）所包含（继承kobject），而每个外围数据结构各自完成这些接口的内部实现，所以会表现出不同的属性，因此我们更关心kobject的外围数据接口。</p><h3 id="1-2-kset"><a href="#1-2-kset" class="headerlink" title="1.2 kset"></a>1.2 kset</h3><ul><li>kset是包含多个kobject的集合；</li><li>如果需要在sysfs的目录中包含多个子目录，那需要将它定义成一个kset；</li><li>kset结构体中包含struct kobject字段，可以使用该字段链接到更上一层的结构，用于构建更复杂的拓扑结构；</li><li>sysfs中的设备组织结构很大程度上根据kset组织的，&#x2F;sys&#x2F;bus目录就是一个kset对象，在Linux设备模型中，注册设备或驱动时就将kobject添加到对应的kset中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span> <span class="hljs-comment">//属于这个kset的kobject们的链表</span><br><span class="hljs-type">spinlock_t</span> list_lock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span> <span class="hljs-comment">//嵌入到该kset的kobject，该obj可以用于表示该kset对象</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset_uevent_ops</span> *<span class="hljs-title">uevent_ops</span>;</span> <span class="hljs-comment">//处理kobject的请求</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们想统一管理有些类似属性的kobjects时，可以将它们加入到一个集合中，方便进行管理，比如当热插拔事件发生时，可以同时通知到该集合中的所有kobjects；</p><hr><p>在linux系统中，当系统的环境发生变化时，如添加kset到系统，移动kobject都会从内核空间发送到用户控件，这个是热插拔事件，那么相应的处理程序会被调用，这个处理程序会调用加载驱动，创建设备节点等来响应。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset_uevent_ops</span> &#123;</span><br>    <span class="hljs-type">int</span> (* <span class="hljs-type">const</span> filter)(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *(* <span class="hljs-type">const</span> name)(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj);<br>    <span class="hljs-type">int</span> (* <span class="hljs-type">const</span> uevent)(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj,<br>         <span class="hljs-keyword">struct</span> kobj_uevent_env *env);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这三个函数有什么作用（优先级从高到低）</p><ol><li>filter:决定了是否会将热插拔事件传递到用户控件。返回0，不传递，返回1，传递</li><li>name:用于将字符串传递给用户控件的热插拔处理程序</li><li>uevent:将用户空间需要的参数添加到环境变量中。</li></ol><h3 id="1-3-ktype"><a href="#1-3-ktype" class="headerlink" title="1.3 ktype"></a>1.3 ktype</h3><ul><li>kobj_type用于表征kobject的类型，指定了删除kobject时要调用的函数，kobject结构体中有struct kref字段用于对kobject进行引用计数，<u>当计数值为0时，就会调用kobj_type中的release函数对kobject进行释放</u>，这个就有点类似于C++中的智能指针了；</li><li>kobj_type指定了通过sysfs显示或修改有关kobject的信息时要处理的操作，实际是调用show&#x2F;store函数；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*include/linux/kobject.h*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span> &#123;</span><br><span class="hljs-comment">/* 处理对象终结的回调函数。该接口应该由具体对象负责填充。 */</span><br><span class="hljs-type">void</span> (*release)(<span class="hljs-keyword">struct</span> kobject *kobj);<br><span class="hljs-comment">/* 该类型kobj的sysfs操作接口。 */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span> *<span class="hljs-title">sysfs_ops</span>;</span><br><span class="hljs-comment">/* 该类型kobj自带的缺省属性（文件），这些属性文件在注册kobj时，直接pop为该目录下的文件。 */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">default_groups</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_ns_type_operations</span> *(*<span class="hljs-title">child_ns_type</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> *<span class="hljs-title">kobj</span>);</span><br><span class="hljs-comment">/*child_ns_type/namespace 是 文件系统命名空间相关）略*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">void</span> *(*namespace)(<span class="hljs-keyword">struct</span> kobject *kobj);<br><span class="hljs-type">void</span> (*get_ownership)(<span class="hljs-keyword">struct</span> kobject *kobj, <span class="hljs-type">kuid_t</span> *uid, <span class="hljs-type">kgid_t</span> *gid);<br>&#125;;<br><br><span class="hljs-comment">/*include/linux/sysfs.h*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span> &#123;</span><br><span class="hljs-type">ssize_t</span>(*show)(<span class="hljs-keyword">struct</span> kobject *, <span class="hljs-keyword">struct</span> attribute *, <span class="hljs-type">char</span> *);<br><span class="hljs-type">ssize_t</span>(*store)(<span class="hljs-keyword">struct</span> kobject *, <span class="hljs-keyword">struct</span> attribute *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">size_t</span>);<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;<br><span class="hljs-type">umode_t</span>mode;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="hljs-type">bool</span>ignore_lockdep:<span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span>*<span class="hljs-title">key</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span><span class="hljs-title">skey</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-4-结构关系"><a href="#1-4-结构关系" class="headerlink" title="1.4 结构关系"></a>1.4 结构关系</h3><p>将上面的数据结构拿一张图来说明：</p><img src="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%80-Kobject/v2-be1ccc5fabbf8ff59e2838a48981f6ca_720w.webp" alt="img" style="zoom:100%;"><p>为了更形象的说明这几个结构体的关系，再来一张图：</p><img src="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%80-Kobject/490784b4d4adafe608af685e06803945519d316a.png@942w_596h_progressive.webp" alt="图片" style="zoom:80%;"><ul><li>kset既是kobject的集合，本身又是一个kobject，进而可以添加到其他的集合中，从而就可以构建成复杂的拓扑结构，满足&#x2F;sys文件夹下的文件组织需求；</li></ul><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h2><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/554838012">https://zhuanlan.zhihu.com/p/554838012</a></p></blockquote><h3 id="2-1-kobject示例"><a href="#2-1-kobject示例" class="headerlink" title="2.1 kobject示例"></a>2.1 kobject示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span>        <span class="hljs-comment">// module_init  module_exit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span>          <span class="hljs-comment">// __init   __exit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/string.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/sysfs.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/stat.h&gt;</span> </span><br><br><span class="hljs-comment">//MODULE_xxx这种宏作用是用来添加模块描述信息</span><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);                <span class="hljs-comment">// 描述模块的许可证</span><br>MODULE_AUTHOR(<span class="hljs-string">&quot;pp&quot;</span>);                  <span class="hljs-comment">// 描述模块的作者</span><br>MODULE_VERSION(<span class="hljs-string">&quot;0.1&quot;</span>);                <span class="hljs-comment">// 描述模块的版本</span><br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;module kobject&quot;</span>);   <span class="hljs-comment">// 描述模块的介绍信息</span><br>MODULE_ALIAS(<span class="hljs-string">&quot;alias kobject&quot;</span>);          <span class="hljs-comment">// 描述模块的别名信息</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">obj_test_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobject)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">kobj_test_show</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobject,<span class="hljs-keyword">struct</span> attribute *attr,<span class="hljs-type">char</span> *buf)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">kobj_test_store</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobject,<span class="hljs-keyword">struct</span> attribute *attr,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf,<span class="hljs-type">size_t</span> count)</span>;<br><br><br><span class="hljs-comment">//文件：文件名+文件权限</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> <span class="hljs-title">test_attr</span> =</span>&#123;<br>    .name = <span class="hljs-string">&quot;kobj_config&quot;</span>,<br>    .mode = S_IRWXUGO,<br>&#125;;<br><span class="hljs-comment">//属性(指针数组),一个指针代码一个文件，有几个代表几个文件</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> *<span class="hljs-title">def_attrs</span>[]=</span>&#123;<br>    &amp;test_attr,<br>    <span class="hljs-literal">NULL</span>,<br>&#125;;<br><br><span class="hljs-comment">//读写文件时会调用show/store方法</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span> <span class="hljs-title">obj_test_sysops</span> =</span> <br>&#123;<br>    .show = kobj_test_show,<br>    .store = kobj_test_store,<br>&#125;;<br><br><span class="hljs-comment">//important</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span> <span class="hljs-title">ktype</span> =</span><br>&#123;<br>    .release = obj_test_release,<br>    .sysfs_ops =&amp;obj_test_sysops,<br>    .default_attrs = def_attrs,<br>&#125;;<br><br><span class="hljs-comment">//release当计数为0时调用</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">obj_test_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobject)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;eric_test: release .\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//读</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">kobj_test_show</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobject,<span class="hljs-keyword">struct</span> attribute *attr,<span class="hljs-type">char</span> *buf)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;have show.\n&quot;</span>);<br>    printk(<span class="hljs-string">&quot;attrname:%s.\n&quot;</span>,attr-&gt;name);<br>    <span class="hljs-built_in">sprintf</span>(buf,<span class="hljs-string">&quot;%s\n&quot;</span>,attr-&gt;name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(attr-&gt;name)+<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//写</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">kobj_test_store</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobject,<span class="hljs-keyword">struct</span> attribute *attr,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf,<span class="hljs-type">size_t</span> count)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;have store\n&quot;</span>);<br>    printk(<span class="hljs-string">&quot;write:%s\n&quot;</span>,buf);<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">//</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  __init <span class="hljs-title function_">kobj_test_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;kobject test init.\n&quot;</span>);<br>    <span class="hljs-comment">//初始化kobect,并将其注册到linux系统</span><br>    <span class="hljs-comment">//ktype记录了kobject对象的属性和动作</span><br>    <span class="hljs-comment">//NULL表示在sys根目录创建一个目录，目录名为kobject_test</span><br>    kobject_init_and_add(&amp;kobj,&amp;ktype,<span class="hljs-literal">NULL</span>,<span class="hljs-string">&quot;kobject_test&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit  <span class="hljs-title function_">kobj_test_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;kobject test exit.\n&quot;</span>);<br>    kobject_del(&amp;kobj);<br>&#125;<br><br>module_init(kobj_test_init);<br>module_exit(kobj_test_exit);<br></code></pre></td></tr></table></figure><img src="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%80-Kobject/v2-7c44487b5c3c07dc7f2b0873c75836fc_720w.webp" alt="img" style="zoom: 100%;"><h3 id="2-2-kset示例"><a href="#2-2-kset示例" class="headerlink" title="2.2 kset示例"></a>2.2 kset示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span>        <span class="hljs-comment">// module_init  module_exit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span>          <span class="hljs-comment">// __init   __exit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/string.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/sysfs.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/stat.h&gt;</span> </span><br><br><span class="hljs-comment">//MODULE_xxx这种宏作用是用来添加模块描述信息</span><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);                <span class="hljs-comment">// 描述模块的许可证</span><br>MODULE_AUTHOR(<span class="hljs-string">&quot;pp&quot;</span>);                  <span class="hljs-comment">// 描述模块的作者</span><br>MODULE_VERSION(<span class="hljs-string">&quot;0.1&quot;</span>);                <span class="hljs-comment">// 描述模块的版本</span><br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;module kset&quot;</span>);   <span class="hljs-comment">// 描述模块的介绍信息</span><br>MODULE_ALIAS(<span class="hljs-string">&quot;alias kset&quot;</span>);          <span class="hljs-comment">// 描述模块的别名信息</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span> <span class="hljs-title">kset_p</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span> <span class="hljs-title">kset_c</span>;</span><br><br><span class="hljs-comment">//事件1：最先调用，若返回0则事件2,3不调用</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kset_filter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj)</span><br>&#123;<br>        printk(<span class="hljs-string">&quot;Filter: kobj %s.\n&quot;</span>,kobj-&gt;name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//事件2：返回buf到用户空间</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">kset_name</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj)</span><br>&#123;<br>        <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">20</span>];<br>        printk(<span class="hljs-string">&quot;Name: kobj %s.\n&quot;</span>,kobj-&gt;name);<br>        <span class="hljs-built_in">sprintf</span>(buf,<span class="hljs-string">&quot;%s&quot;</span>,<span class="hljs-string">&quot;kset_name&quot;</span>);<br>        <span class="hljs-keyword">return</span> buf;<br>&#125;<br><span class="hljs-comment">//事件3：返回事件到用户空间</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kset_uevent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj,<span class="hljs-keyword">struct</span> kobj_uevent_env *env)</span><br>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        printk(<span class="hljs-string">&quot;uevent: kobj %s.\n&quot;</span>,kobj-&gt;name);<br><br>        <span class="hljs-keyword">while</span>( i &lt; env-&gt;envp_idx)&#123;<br>                printk(<span class="hljs-string">&quot;%s.\n&quot;</span>,env-&gt;envp[i]);<br>                i++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//对基类目录进行绑定事件</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset_uevent_ops</span> <span class="hljs-title">uevent_ops</span> =</span> <br>&#123;<br>        .filter = kset_filter,<br>        .name   = kset_name,<br>        .uevent = kset_uevent,<br>&#125;;<br><br><span class="hljs-comment">////////////////////////</span><br><span class="hljs-comment">//基类目录创建、子目录创建</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kset_test_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        printk(<span class="hljs-string">&quot;kset test init.\n&quot;</span>);<br>        kobject_set_name(&amp;kset_p.kobj,<span class="hljs-string">&quot;kset_p&quot;</span>);<br>        <span class="hljs-comment">//该父目录添加事件ops，当在该目录下有操作时依次调用:filter、name、uevent</span><br>        kset_p.uevent_ops = &amp;uevent_ops; <br>        kset_register(&amp;kset_p);<br><br>        kobject_set_name(&amp;kset_c.kobj,<span class="hljs-string">&quot;kset_c&quot;</span>);<br>        <span class="hljs-comment">//核心:kset_c的目录是kset_p,该行为由于对父目录有结构的变化会触发热插拔事件</span><br>        kset_c.kobj.kset = &amp;kset_p;<br>        kset_register(&amp;kset_c);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kset_test_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>        <span class="hljs-title function_">printk</span><span class="hljs-params">(<span class="hljs-string">&quot;kset test exit.\n&quot;</span>)</span>;<br>        kset_unregister(&amp;kset_p);<br>        kset_unregister(&amp;kset_c);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>module_init(kset_test_init);<br>module_exit(kset_test_exit);<br></code></pre></td></tr></table></figure><img src="/2023/04/16/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%80-Kobject/v2-2d811337bd84748619c45bce0df52082_720w.webp" alt="img" style="zoom:100%;">]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kconfig学习笔记</title>
    <link href="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Kconfig学习笔记"><a href="#Kconfig学习笔记" class="headerlink" title="Kconfig学习笔记"></a>Kconfig学习笔记</h1><h2 id="1-menuconfig配置界面"><a href="#1-menuconfig配置界面" class="headerlink" title="1.menuconfig配置界面"></a>1.menuconfig配置界面</h2><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2021051320123770.png" alt="内核选项配置界面" style="zoom: 67%;"><p><strong>1、子菜单 —&gt;</strong></p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210513201339224.png" alt=" " style="zoom:80%;"><p>表示有子菜单，按下回车可以进入子菜单。</p><p><strong>2、中括号 []</strong></p><p>在每一个选项前都有个括号，有的是中括号，有的是尖括号，还有的是圆括号。</p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210513201528165.png" alt=" " style="zoom:80%;"><p>[] 表示该选项只有两种选项，中括号中要么是空，要么是“*”；</p><blockquote><p>使用 “空格” 键进行切换</p></blockquote><p><strong>3、尖括号 &lt;&gt;</strong></p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210513201546900.png" alt=" " style="zoom:80%;"><p>&lt;&gt;选择相应的配置时，有3种选择，它们代表的含义分别如下。</p><blockquote><ul><li>*：将该功能编译进内核。 </li><li>空：不将该功能编译进内核。 </li><li>M：将该功能编译成可以在需要时动态插入到内核中的模块。</li></ul></blockquote><blockquote><p> 使用 “空格” 键进行切换</p></blockquote><p><strong>4、模块配置圆括号 ()</strong></p><p>而圆括号的内容是要你在所提供的几个选项中选择一项。</p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210513202030189.png" alt=" " style="zoom:80%;"><h2 id="2-Kconfig语法"><a href="#2-Kconfig语法" class="headerlink" title="2.Kconfig语法"></a>2.Kconfig语法</h2><h3 id="2-1-Kconfig类型"><a href="#2-1-Kconfig类型" class="headerlink" title="2.1 Kconfig类型"></a>2.1 Kconfig类型</h3><p>配置选项的类型：”bool”&#x2F;“tristate”&#x2F;“string”&#x2F;“hex”&#x2F;“int”</p><p>每个config菜单项都要有类型定义</p><ul><li>bool：布尔类型</li><li>tristate三态：内建、模块、移除</li><li>string：字符串</li><li>hex：十六进制</li><li>int：整型</li></ul><h3 id="2-2-mainmenu"><a href="#2-2-mainmenu" class="headerlink" title="2.2 mainmenu"></a>2.2 mainmenu</h3><p>顾名思义 mainmenu 就是主菜单，也就是输入“make menuconfig”以后打开的默认界面，在顶层 Kconfig 中有如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">mainmenu <span class="hljs-string">&quot;Linux/$ARCH $KERNELVERSION Kernel Configuration&quot;</span><br></code></pre></td></tr></table></figure><p>上述代码就是定义了一个名为<code>Linux/$ARCH $KERNELVERSION Kernel Configuration</code>的主菜单，其中$ARCH为我们自己export或者写死在顶层Makefile中的为<code>arm</code>，$KERNELVERSION&#x3D;4.1.15，因此主菜单名为<code>Linux/arm 4.1.15 Kernel Configuration</code></p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230409165121922.png" alt="image-20230409165121922" style="zoom:80%;"><h3 id="2-3-调用其他目录下的Kconfig文件"><a href="#2-3-调用其他目录下的Kconfig文件" class="headerlink" title="2.3 调用其他目录下的Kconfig文件"></a>2.3 调用其他目录下的Kconfig文件</h3><p>和 makefile 一样，Kconfig 也可以调用其他子目录中的 Kconfig 文件，调用方法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">source <span class="hljs-string">&quot;xxx/Kconfig&quot;</span> //xxx 为具体的目录名，相对路径<br></code></pre></td></tr></table></figure><p>在顶层 Kconfig 中有如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">source <span class="hljs-string">&quot;drivers/amx_drivers/Kconfig&quot;</span><br><br>source <span class="hljs-string">&quot;arch/$SRCARCH/Kconfig&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-menu-x2F-endemenu条目"><a href="#2-4-menu-x2F-endemenu条目" class="headerlink" title="2.4 menu&#x2F;endemenu条目"></a>2.4 menu&#x2F;endemenu条目</h3><p>menu 用于生成菜单，endmenu 就是菜单结束标志，这两个一般是成对出现的。在顶层<code>init/Kconfig</code> 中有如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile">menu <span class="hljs-string">&quot;General setup&quot;</span><br><br>config BROKEN<br>bool<br><br>config BROKEN_ON_SMP<br>bool<br>depends on BROKEN || !SMP<br>default y<br><br><span class="hljs-comment"># ....</span><br><br>endmenu<br></code></pre></td></tr></table></figure><p>这个代码块就是一个子菜单，第1行的<code>menu &quot;General setup</code>表示自菜单<code>General Setup</code></p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230409165838486.png" alt="image-20230409165838486" style="zoom:80%;"><h3 id="2-5-config条目"><a href="#2-5-config条目" class="headerlink" title="2.5 config条目"></a>2.5 config条目</h3><p>在一些<code>menu/endmenu</code> 代码块中有大量的 <strong>config xxx</strong> 代码块，也就是config条目。</p><p>config基本结构为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">config option<br>    type <span class="hljs-string">&quot;xxx&quot;</span>       //简单描述<br>    depends on xxx //依赖选项，可选<br>    default xxx      //初始值<br>    help              //帮助信息<br>        xxxxxxxxxxxxxxx<br></code></pre></td></tr></table></figure><p>我们以下面的config为例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile">config LOCALVERSION<br>string <span class="hljs-string">&quot;Local version - append to kernel release&quot;</span><br>help<br>  Append an extra string to the end of your kernel version.<br>  This will show up when you type uname, for example.<br>  The string you set here will be appended after the contents <br>  of any files with a filename matching localversion* in your<br>  object and source tree, in that order.  Your total string <br>  can be a maximum of 64 characters.<br>  <br>config LOCALVERSION_AUTO<br>bool <span class="hljs-string">&quot;Automatically append version information to the version string&quot;</span><br>default y<br></code></pre></td></tr></table></figure><p>config后面跟着 <strong>LOCALVERSION</strong> 就是配置项名字。假如我们是能了LOCALVERSION 这个功能，那么就会在.config 文件中生成 LOCALVERSION。</p><p>config 关键字下面的这几行是配置项属性。属性里面描述了配置项的类型、输入提示、依赖关系、帮助信息和默认值等。</p><ul><li>第一行表示LOCALVERSION的变量类型为 string</li><li>第二行help表示帮助信息，告诉我们配置项的含义，当我们按下“h”或“?”弹出来的帮助界面就是 help 的内容。</li><li>LOCALVERSION_AUTO的第一行表示LOCALVERSION_AUTO是bool类型，可以通过空格键 <strong>使能</strong> 或 <strong>禁止</strong> LOCALVERSION_AUTO。</li><li>default y 表示 LOCALVERSION_AUTO的默认值为 <strong>y</strong>，所以上一行会默认选中</li></ul><h3 id="2-6-depends-on-和-select"><a href="#2-6-depends-on-和-select" class="headerlink" title="2.6 depends on 和 select"></a>2.6 depends on 和 select</h3><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs make">config USER_RETURN_NOTIFIER<br>bool<br>depends on HAVE_USER_RETURN_NOTIFIER<br><br>config GPIO_ALTERA<br>tristate <span class="hljs-string">&quot;Altera GPIO&quot;</span><br>depends on OF_GPIO<br>select GPIO_GENERIC<br>select GPIOLIB_IRQCHIP<br></code></pre></td></tr></table></figure><ul><li>depend on 说明 USER_RETURN_NOTIFIER 依赖于 HAVE_USER_RETURN_NOTIFIER。也就是说 HAVE_USER_RETURN_NOTIFIER选中以后 USER_RETURN_NOTIFIER 才能被选中</li><li>select 表示方向依赖，当选中 GPIO_ALTERA 以后，GPIO_GENERIC、GPIOLIB_IRQCHIP 这两个选中也会被选中</li></ul><h3 id="2-7-choice-x2F-endchoice"><a href="#2-7-choice-x2F-endchoice" class="headerlink" title="2.7 choice&#x2F;endchoice"></a>2.7 choice&#x2F;endchoice</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># arch\arm\Kconfig</span><br><br>choice<br>prompt <span class="hljs-string">&quot;ARM system type&quot;</span><br>default ARCH_VERSATILE if !MMU<br>default ARCH_MULTIPLATFORM if MMU<br><br>config ARCH_MULTIPLATFORM<br>bool <span class="hljs-string">&quot;Allow multiple platforms to be selected&quot;</span><br>depends on MMU<br>select ARCH_WANT_OPTIONAL_GPIOLIB<br>select ARM_HAS_SG_CHAIN<br><span class="hljs-comment"># ...</span><br><br>config ARCH_REALVIEW<br>bool <span class="hljs-string">&quot;ARM Ltd. RealView family&quot;</span><br>select ARCH_WANT_OPTIONAL_GPIOLIB<br>select PLAT_VERSATILE_SCHED_CLOCK<br><span class="hljs-comment"># ...</span><br>help<br>  This enables support for ARM Ltd RealView boards.<br>  <br>  <span class="hljs-comment">#.....</span><br>endchoice<br></code></pre></td></tr></table></figure><p>choice&#x2F;endchoice 代码段定义了一组可选择项，将多个类似的配置项组合在一起，供用户单选或者多选。上面的类型就是让用户选择处理器架构，可以从 ARCH_MULTIPLATFORM、ARCH_REALVIEW中进行选择。</p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230409172626588.png" alt="image-20230409172626588" style="zoom:80%;"><h3 id="2-8-menuconfig"><a href="#2-8-menuconfig" class="headerlink" title="2.8 menuconfig"></a>2.8 menuconfig</h3><p>menuconfig 和 menu 很类似，但是 menuconfig 是个带选项的菜单，其一般用法为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">menuconfig MODULES<br>bool <span class="hljs-string">&quot;菜单&quot;</span><br>if MODULEs<br>...<br><span class="hljs-keyword">endif</span> <span class="hljs-comment"># MODULES</span><br></code></pre></td></tr></table></figure><p>第 1 行，定义了一个可选的菜单 MODULES，只有选中了 MODULES 第 3~5 行 if 到 endif 之间的内容才会显示。在顶层 Kconfig 中有如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs makefile">menuconfig INPUT_TOUCHSCREEN<br>bool <span class="hljs-string">&quot;Touchscreens&quot;</span><br>help<br>  Say Y here, and a list of supported touchscreens will be &#x27;<br>  displayed.This option doesn&#x27;t affect the kernel.<br>  If unsure, say Y.<br><br>if INPUT_TOUCHSCREEN<br><br>config OF_TOUCHSCREEN<br>def_tristate INPUT<br>depends on INPUT &amp;&amp; OF<br><br>config TOUCHSCREEN_88PM860X<br>tristate <span class="hljs-string">&quot;Marvell 88PM860x touchscreen&quot;</span><br>depends on MFD_88PM860X<br>help<br>  Say Y here if you have a 88PM860x PMIC and want to enable<br>  support for the built-in touchscreen.<br><span class="hljs-comment"># ...</span><br><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230409173721763.png" alt="image-20230409173721763" style="zoom:80%;"><p>Touchscreens前面有[]，说明这个菜单是可选的，当选中这个菜单以后就可以进入到子选项中。</p><h3 id="2-6-comment"><a href="#2-6-comment" class="headerlink" title="2.6 comment"></a>2.6 comment</h3><p>comment用于注释，也就是在图形化界面中显示一行注释</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># arch\arm\Kconfig</span><br><br>comment <span class="hljs-string">&quot;CPU Core family selection&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到该注释独占一行</p><img src="/2023/04/09/Kconfig%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230409174046599.png" alt="image-20230409174046599" style="zoom:80%;"><h2 id="3-Kconfig键盘操作"><a href="#3-Kconfig键盘操作" class="headerlink" title="3.Kconfig键盘操作"></a>3.Kconfig键盘操作</h2><ol><li>两下 <code>ESC</code> 返回上一级</li><li>按<code>H</code> 或者 <code>?</code> 可以查看提示信息</li><li>按 <code>空格</code> 可以切换状态</li><li>按 <code>/</code> 可以快速搜索CONFIG宏</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核编译make defconfig</title>
    <link href="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/"/>
    <url>/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux内核编译make-defconfig"><a href="#Linux内核编译make-defconfig" class="headerlink" title="Linux内核编译make defconfig"></a>Linux内核编译make defconfig</h1><blockquote><p><strong>声明：</strong>本文部分内容引自正点原子，其资料完整，讲解清晰，非常感谢！</p></blockquote><p>在内核编译时，有各种配置方式可供进行选择，常见的有图形化界面<code>make menuconfig</code>，有<code>make XXX_defconfig</code>。今天以NXP官方的内核为例，记录一下编译默认配置文件<strong>make imx_v7_mfg_defconfig</strong></p><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/v2-28887f831d79f4d3abf8b153616528d0_720w.webp" alt="img" style="zoom:80%;"><h2 id="1-make-defconfig在Makefile匹配过程"><a href="#1-make-defconfig在Makefile匹配过程" class="headerlink" title="1.make defconfig在Makefile匹配过程"></a>1.make defconfig在Makefile匹配过程</h2><h3 id="1-1-顶层Makefile匹配"><a href="#1-1-顶层Makefile匹配" class="headerlink" title="1.1 顶层Makefile匹配"></a>1.1 顶层Makefile匹配</h3><p>当我们执行 <strong>make imx_v7_mfg_defconfig</strong> 时，对应于顶层makefile中的<code>%config</code>目标：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%config: scripts_basic outputmakefile FORCE</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=scripts/kconfig <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>“%config”依赖scripts_basic、outputmakefile 和 FORCE，“%config”真正有意义的依赖就只有 scripts_basic，</p><p>scripts_basic 的规则如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">scripts_basic:</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=scripts/basic<br><span class="hljs-variable">$(Q)</span>rm -f .tmp_quiet_recordmcount<br></code></pre></td></tr></table></figure><p>build 定义在文件 scripts&#x2F;Kbuild.include 中，值为 build :&#x3D; -f $(srctree)&#x2F;scripts&#x2F;Makefile.build obj，因此展开就是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">scripts_basic:</span><br>    @make -f ./scripts/Makefile.build obj=scripts/basic  //也可以没有@，视配置而定<br>    @rm -f . tmp_quiet_recordmcount //也可以没有@<br></code></pre></td></tr></table></figure><p>接着回到目标“%config”处，内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%config: scripts_basic outputmakefile FORCE</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=scripts/kconfig <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>将命令展开就是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">@make -f ./scripts/Makefile.build obj=scripts/kconfig imx_v7_mfg_defconfig<br></code></pre></td></tr></table></figure><h3 id="1-2-Makefile-build脚本解析"><a href="#1-2-Makefile-build脚本解析" class="headerlink" title="1.2 Makefile.build脚本解析"></a>1.2 Makefile.build脚本解析</h3><p>从上一小节可知，“make xxx_defconfig“配置 Linux 的时候如下两行命令会执行脚本scripts&#x2F;Makefile.build：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">@make -f ./scripts/Makefile.build obj=scripts/basic<br>@make -f ./scripts/Makefile.build obj=scripts/kconfig xxx_defconfig<br></code></pre></td></tr></table></figure><h4 id="1-2-1-scripts-basic"><a href="#1-2-1-scripts-basic" class="headerlink" title="1.2.1 scripts_basic"></a>1.2.1 scripts_basic</h4><p>scripts_basic 目标对应的命令为：@make -f .&#x2F;scripts&#x2F;Makefile.build obj&#x3D;scripts&#x2F;basic。打开文件 scripts&#x2F;Makefile.build，有如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># The filename Kbuild has precedence over Makefile</span><br>kbuild-dir := <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">filter</span> /%,<span class="hljs-variable">$(src)</span>)</span>,<span class="hljs-variable">$(src)</span>,<span class="hljs-variable">$(srctree)</span>/<span class="hljs-variable">$(src)</span>)<br>kbuild-file := <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">wildcard</span> $(kbuild-<span class="hljs-built_in">dir</span>)</span>/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)<br><span class="hljs-keyword">include</span> $(kbuild-file)<br></code></pre></td></tr></table></figure><p>将 kbuild-dir 展开后为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">kbuild-dir=./scripts/basic<br></code></pre></td></tr></table></figure><p>将 kbuild-file 展开后为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">kbuild-file= ./scripts/basic/Makefile<br></code></pre></td></tr></table></figure><p>最后一行展开：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">include</span> ./scripts/basic/Makefile<br></code></pre></td></tr></table></figure><p>继续分析 scripts&#x2F;Makefile.build，如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">__build: $(if <span class="hljs-variable">$(KBUILD_BUILTIN)</span>,$(builtin-target) $(lib-target) $(extra-y)) \</span><br> <span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(KBUILD_MODULES)</span>,$(obj-m)</span> $(modorder-target)) \<br> $(subdir-ym) <span class="hljs-variable">$(always)</span><br>@:<br></code></pre></td></tr></table></figure><p>__build 是默认目标，因为命令“@make -f .&#x2F;scripts&#x2F;Makefile.build obj&#x3D;scripts&#x2F;basic”没有指定目标，所以会使用到默认目标__build。在顶层 Makefile 中，KBUILD_BUILTIN 为 1，KBUILD_MODULES 为空，因此展开后目标__build 为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">__build:$(builtin-target) $(lib-target) $(extra-y)) $(subdir-ym) <span class="hljs-variable">$(always)</span></span><br>@:<br></code></pre></td></tr></table></figure><p>可以看出目标__build 有 5 个依赖：builtin-target、lib-target、extra-y、subdir-ym 和 always。这 5 个依赖的具体内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">builtin-target =<br>lib-target =<br>extra-y =<br>subdir-ym =<br>always = scripts/basic/fixdep scripts/basic/bin2c<br></code></pre></td></tr></table></figure><p>只有 always 有效，因此__build 最终为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">__build: scripts/basic/fixdep scripts/basic/bin2c</span><br>@<br></code></pre></td></tr></table></figure><p>__build 依赖于 scripts&#x2F;basic&#x2F;fixdep 和 scripts&#x2F;basic&#x2F;bin2c，所以要先将 scripts&#x2F;basic&#x2F;fixdep 和 scripts&#x2F;basic&#x2F;bin2c.c 这两个文件编译成 fixdep 和 bin2c。</p><p>🐘 综上所述，scripts_basic 目标的作用就是编译出 <strong>scripts&#x2F;basic&#x2F;fixdep</strong> 和 <strong>scripts&#x2F;basic&#x2F;bin2c</strong> 这两个软件。</p><h4 id="1-2-2-config"><a href="#1-2-2-config" class="headerlink" title="1.2.2 %config"></a>1.2.2 %config</h4><p>%config 目标 对应的命令为 ： @make -f .&#x2F;scripts&#x2F;Makefile.build obj&#x3D;scripts&#x2F;kconfig xxx_defconfig，此命令会使用到的各个变量值如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src= scripts/kconfig<br>kbuild-dir = ./scripts/kconfig<br>kbuild-file = ./scripts/kconfig/Makefile<br><span class="hljs-keyword">include</span> ./scripts/kconfig/Makefile<br></code></pre></td></tr></table></figure><p>可以看出，Makefile.build 会读取 scripts&#x2F;kconfig&#x2F;Makefile 中的内容，此文件有如下所示内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%_defconfig: <span class="hljs-variable">$(obj)</span>/conf</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(silent)</span> --defconfig=arch/<span class="hljs-variable">$(SRCARCH)</span>/configs/<span class="hljs-variable">$@</span> <span class="hljs-variable">$(Kconfig)</span><br></code></pre></td></tr></table></figure><p>目标%_defconfig 与 xxx_defconfig 匹配，所以会执行这条规则，将其展开就是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%_defconfig: scripts/kconfig/conf</span><br>@scripts/kconfig/conf --defconfig=arch/arm/configs/%_defconfig Kconfig<br></code></pre></td></tr></table></figure><p><code>%__defconfig</code> 会依赖于scripts&#x2F;kconfig&#x2F;conf，所以会先编译scripts&#x2F;kconfig&#x2F;conf，然后调用这个二进制，生成最终的<code>.config</code>文件，这就是第二章的内容。</p><h2 id="2-最终调用conf二进制，生成-config文件"><a href="#2-最终调用conf二进制，生成-config文件" class="headerlink" title="2.最终调用conf二进制，生成.config文件"></a>2.最终调用conf二进制，生成.config文件</h2><p>当执行<strong>make imx_v7_mfg_defconfig</strong>时，最后一步就是调用二进制conf，去生成.config文件</p><p>🎨 <strong>conf二进制是由conf.c编译而来</strong></p><blockquote><p>所以最终调用的命令为<code>scripts/kconfig/conf --defconfig=arch/../configs/imx_v7_mfg_defconfig Kconfig</code>，就是调用<strong>conf.c</strong>文件的main函数。我们可以发现传递给conf.c时的main函数的<strong>argv[0]&#x3D;scripts&#x2F;kconfig&#x2F;conf</strong>，<strong>argv[1]&#x3D;–defconfig&#x3D;arch&#x2F;arm&#x2F;configs&#x2F;imx_v7_mfg_defconfig</strong>，<strong>argv[2]&#x3D;Kconfig</strong>。</p></blockquote><p>因此，我们接下来分析一下conf.c的main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// scripts/kconfig/conf.c</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">option</span> <span class="hljs-title">long_opts</span>[] =</span> &#123;<br>&#123;<span class="hljs-string">&quot;oldaskconfig&quot;</span>,    no_argument,       <span class="hljs-literal">NULL</span>, oldaskconfig&#125;,<br>&#123;<span class="hljs-string">&quot;oldconfig&quot;</span>,       no_argument,       <span class="hljs-literal">NULL</span>, oldconfig&#125;,<br>&#123;<span class="hljs-string">&quot;silentoldconfig&quot;</span>, no_argument,       <span class="hljs-literal">NULL</span>, silentoldconfig&#125;,<br>&#123;<span class="hljs-string">&quot;defconfig&quot;</span>,       optional_argument, <span class="hljs-literal">NULL</span>, defconfig&#125;,<br>&#123;<span class="hljs-string">&quot;savedefconfig&quot;</span>,   required_argument, <span class="hljs-literal">NULL</span>, savedefconfig&#125;,<br>&#123;<span class="hljs-string">&quot;allnoconfig&quot;</span>,     no_argument,       <span class="hljs-literal">NULL</span>, allnoconfig&#125;,<br>&#123;<span class="hljs-string">&quot;allyesconfig&quot;</span>,    no_argument,       <span class="hljs-literal">NULL</span>, allyesconfig&#125;,<br>&#123;<span class="hljs-string">&quot;allmodconfig&quot;</span>,    no_argument,       <span class="hljs-literal">NULL</span>, allmodconfig&#125;,<br>&#123;<span class="hljs-string">&quot;alldefconfig&quot;</span>,    no_argument,       <span class="hljs-literal">NULL</span>, alldefconfig&#125;,<br>&#123;<span class="hljs-string">&quot;randconfig&quot;</span>,      no_argument,       <span class="hljs-literal">NULL</span>, randconfig&#125;,<br>&#123;<span class="hljs-string">&quot;listnewconfig&quot;</span>,   no_argument,       <span class="hljs-literal">NULL</span>, listnewconfig&#125;,<br>&#123;<span class="hljs-string">&quot;olddefconfig&quot;</span>,    no_argument,       <span class="hljs-literal">NULL</span>, olddefconfig&#125;,<br>&#123;<span class="hljs-string">&quot;oldnoconfig&quot;</span>,     no_argument,       <span class="hljs-literal">NULL</span>, olddefconfig&#125;,<br>&#123;<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>&#125;<br>&#125;;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> ac, <span class="hljs-type">char</span> **av)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *progname = av[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> opt;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, *defconfig_file = <span class="hljs-literal">NULL</span> <span class="hljs-comment">/* gcc uninit */</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">tmpstat</span>;</span><br><br>    <span class="hljs-comment">// 通过getopt_long去解析传进来的参数</span><br>    <span class="hljs-comment">// 传进来时有一个--defconfig，所以从option列表里面匹配到的是defconfig(枚举值为8)</span><br><span class="hljs-keyword">while</span> ((opt = getopt_long(ac, av, <span class="hljs-string">&quot;s&quot;</span>, long_opts, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">-1</span>) &#123;<br>input_mode = (<span class="hljs-keyword">enum</span> input_mode)opt;<br><span class="hljs-keyword">switch</span> (opt) &#123;<br>            <span class="hljs-keyword">case</span> defconfig:<br>            <span class="hljs-keyword">case</span> savedefconfig:<br>                defconfig_file = optarg;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>&#125;<br><br>name = av[optind];  <span class="hljs-comment">// 名字为Kconfig</span><br>conf_parse(name);  <span class="hljs-comment">// 解析Kconfig</span><br><br><span class="hljs-keyword">switch</span> (input_mode) &#123;<br>        <span class="hljs-keyword">case</span> defconfig:<br>            <span class="hljs-comment">// 前面在while循环解析参数时， defconfig_file为arch/arm/configs/imx_v7_mfg_defconfig</span><br>            <span class="hljs-keyword">if</span> (!defconfig_file)<br>                defconfig_file = conf_get_default_confname();<br>         <br>            <span class="hljs-keyword">if</span> (conf_read(defconfig_file)) &#123;<br>                <span class="hljs-built_in">printf</span>(_(<span class="hljs-string">&quot;***\n&quot;</span><br>                    <span class="hljs-string">&quot;*** Can&#x27;t find default configuration \&quot;%s\&quot;!\n&quot;</span><br>                    <span class="hljs-string">&quot;***\n&quot;</span>), defconfig_file);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">switch</span> (input_mode) &#123;<br>        <span class="hljs-keyword">case</span> defconfig:<br>            conf_set_all_new_symbols(def_default);<br>            <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (sync_kconfig) &#123;<br>        <span class="hljs-comment">// ....</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input_mode != listnewconfig) &#123;<br><span class="hljs-keyword">if</span> (conf_write(<span class="hljs-literal">NULL</span>)) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, _(<span class="hljs-string">&quot;\n*** Error during writing of the configuration.\n\n&quot;</span>));<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-conf-parse解析Kconfig"><a href="#2-1-conf-parse解析Kconfig" class="headerlink" title="2.1 conf_parse解析Kconfig"></a>2.1 conf_parse解析Kconfig</h3><p>调用<code>conf_parse(name)</code>从<code>$(srctree)</code>目录下依次查找名为<code>Kconfig</code>的文件，然后将取得的信息存放到链表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// scripts\kconfig\zconf.tab.c_shipped</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">conf_parse</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> *<span class="hljs-title">sym</span>;</span><br><span class="hljs-type">int</span> i;<br><br>zconf_initscan(name);<br><br>sym_init();<br>_menu_init();<br>rootmenu.prompt = menu_add_prompt(P_MENU, <span class="hljs-string">&quot;Linux Kernel Configuration&quot;</span>, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">if</span> (getenv(<span class="hljs-string">&quot;ZCONF_DEBUG&quot;</span>))<br>zconfdebug = <span class="hljs-number">1</span>;<br>zconfparse();<br><span class="hljs-keyword">if</span> (zconfnerrs)<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!modules_sym)<br>modules_sym = sym_find( <span class="hljs-string">&quot;n&quot;</span> );<br><br>rootmenu.prompt-&gt;text = _(rootmenu.prompt-&gt;text);<br>rootmenu.prompt-&gt;text = sym_expand_string_value(rootmenu.prompt-&gt;text);<br><br>menu_finalize(&amp;rootmenu);<br><br>sym_set_change_count(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-conf-read-defconfig-file-读取配置文件"><a href="#2-2-conf-read-defconfig-file-读取配置文件" class="headerlink" title="2.2 conf_read(defconfig_file)读取配置文件"></a>2.2 conf_read(defconfig_file)读取配置文件</h3><h3 id="2-3-conf-write往-config写配置"><a href="#2-3-conf-write往-config写配置" class="headerlink" title="2.3 conf_write往.config写配置"></a>2.3 conf_write往.config写配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">conf_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>FILE *out;<br>    <br>dirname[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (name &amp;&amp; name[<span class="hljs-number">0</span>]) &#123;<br><span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span><br>basename = conf_get_configname();<br><br><span class="hljs-built_in">sprintf</span>(newname, <span class="hljs-string">&quot;%s%s&quot;</span>, dirname, basename);  <span class="hljs-comment">// newname为.config</span><br>env = getenv(<span class="hljs-string">&quot;KCONFIG_OVERWRITECONFIG&quot;</span>);  <span class="hljs-comment">// 获取KCONFIG_OVERWRITECONFIG失败</span><br><span class="hljs-keyword">if</span> (!env || !*env) &#123;<br><span class="hljs-built_in">sprintf</span>(tmpname, <span class="hljs-string">&quot;%s.tmpconfig.%d&quot;</span>, dirname, (<span class="hljs-type">int</span>)getpid());  <span class="hljs-comment">// 临时文件为.tmpconfig.[@pid]</span><br>out = fopen(tmpname, <span class="hljs-string">&quot;w&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>*tmpname = <span class="hljs-number">0</span>;<br>out = fopen(newname, <span class="hljs-string">&quot;w&quot;</span>);<br>&#125;<br><br>    <span class="hljs-comment">// 2.3.1节</span><br>conf_write_heading(out, &amp;kconfig_printer_cb, <span class="hljs-literal">NULL</span>);<br><br><br>    <span class="hljs-comment">// 获取rootmenu首页的menu.list</span><br>    <span class="hljs-comment">// 就是我们make_menuconfig看到的首页所有项</span><br>menu = rootmenu.<span class="hljs-built_in">list</span>;<br><span class="hljs-keyword">while</span> (menu) &#123;<br>        <span class="hljs-comment">// sym就是解析后Symbol</span><br>sym = menu-&gt;sym;<br><span class="hljs-keyword">if</span> (!sym) &#123;<br><span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(sym-&gt;flags &amp; SYMBOL_CHOICE)) &#123;<br>sym_calc_value(sym);<br>sym-&gt;flags &amp;= ~SYMBOL_WRITE;<br><span class="hljs-comment">// 2.3.2节</span><br>conf_write_symbol(out, sym, &amp;kconfig_printer_cb, <span class="hljs-literal">NULL</span>);<br>&#125;<br>&#125;<br>fclose(out);<br><br>    <span class="hljs-comment">// 将tmpname重命名为.config</span><br>    <span class="hljs-comment">// 2.3.4节</span><br><span class="hljs-keyword">if</span> (*tmpname) &#123;<br><span class="hljs-built_in">strcat</span>(dirname, basename);<br><span class="hljs-built_in">strcat</span>(dirname, <span class="hljs-string">&quot;.old&quot;</span>);<br>rename(newname, dirname);<br><span class="hljs-keyword">if</span> (rename(tmpname, newname))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br>conf_message(_(<span class="hljs-string">&quot;configuration written to %s&quot;</span>), newname);  <span class="hljs-comment">// 在编译日志里面打印configuration written to .config</span><br><br>sym_set_change_count(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-0-真正发挥写文件的函数kconfig-printer-cb"><a href="#2-3-0-真正发挥写文件的函数kconfig-printer-cb" class="headerlink" title="2.3.0 真正发挥写文件的函数kconfig_printer_cb"></a>2.3.0 真正发挥写文件的函数kconfig_printer_cb</h4><p>kconfig_printer_cb中有两个成员变量，一个用来写注释，一个用来写配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">conf_printer</span> <span class="hljs-title">kconfig_printer_cb</span> =</span><br>&#123;<br>.print_symbol = kconfig_print_symbol,   <span class="hljs-comment">// 写配置的函数</span><br>.print_comment = kconfig_print_comment, <span class="hljs-comment">// 写注释的函数</span><br>&#125;;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">kconfig_print_symbol</span><span class="hljs-params">(FILE *fp, <span class="hljs-keyword">struct</span> symbol *sym, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *value, <span class="hljs-type">void</span> *arg)</span><br>&#123;<br><br><span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br><span class="hljs-keyword">case</span> S_BOOLEAN:<br><span class="hljs-keyword">case</span> S_TRISTATE:<br>        <span class="hljs-comment">// 如果值为n</span><br><span class="hljs-keyword">if</span> (*value == <span class="hljs-string">&#x27;n&#x27;</span>) &#123;<br><span class="hljs-type">bool</span> skip_unset = (arg != <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">// 往.config里面写# CONFIG_XXX is not set</span><br><span class="hljs-keyword">if</span> (!skip_unset)<br><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;# %s%s is not set\n&quot;</span>,<br>    CONFIG_, sym-&gt;name);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;%s%s=%s\n&quot;</span>, CONFIG_, sym-&gt;name, value);  <span class="hljs-comment">// 往.config中写配置，格式为CONFIG_XXX=XXX</span><br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">kconfig_print_comment</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *value, <span class="hljs-type">void</span> *arg)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = value;<br><span class="hljs-type">size_t</span> l;<br><br><span class="hljs-keyword">for</span> (;;) &#123;<br>l = <span class="hljs-built_in">strcspn</span>(p, <span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;#&quot;</span>);<br><span class="hljs-keyword">if</span> (l) &#123;<br><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot; &quot;</span>);<br>xfwrite(p, l, <span class="hljs-number">1</span>, fp);<br>p += l;<br>&#125;<br><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">if</span> (*p++ == <span class="hljs-string">&#x27;\0&#x27;</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409212854271.png" alt="image-20230409212854271" style="zoom:80%;"><p>我们举个例子：</p><p>假如我们在<strong>Kconfig</strong>中设置<code>AMX_FONT</code>为y，而在<strong>imx_v7_mfg_defconig</strong>设置为n</p><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409212629006.png" alt="image-20230409212629006" style="zoom:50%;"><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409212745735.png" alt="image-20230409212745735" style="zoom:50%;"><p>通过<code>make imx_v7_mfg_defconig</code>后在<code>.config</code>中最终为 <strong># CONFIG_AMX_FONT is not set</strong></p><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409212910588.png" alt="image-20230409212910588" style="zoom:67%;"><h4 id="2-3-1-conf-write-heading函数向-config写头部注释"><a href="#2-3-1-conf-write-heading函数向-config写头部注释" class="headerlink" title="2.3.1 conf_write_heading函数向.config写头部注释"></a>2.3.1 conf_write_heading函数向.config写头部注释</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">conf_write_heading:<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">conf_write_heading</span><span class="hljs-params">(FILE *fp, <span class="hljs-keyword">struct</span> conf_printer *printer, <span class="hljs-type">void</span> *printer_arg)</span><br>&#123;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>];<br><br><span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span>(buf),<br>    <span class="hljs-string">&quot;\n&quot;</span><br>    <span class="hljs-string">&quot;Automatically generated file; DO NOT EDIT.\n&quot;</span><br>    <span class="hljs-string">&quot;%s\n&quot;</span>,<br>    rootmenu.prompt-&gt;text);<br><br>printer-&gt;print_comment(fp, buf, printer_arg);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这边的rootmenu就是根目录下的<strong>Kconfig</strong>，其prompt值为<code>Linux/$ARCH $KERNELVERSION Kernel Configuration</code></p><p>因此最终写入的注释如下：</p><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409152128232.png" alt="image-20230409152128232" style="zoom: 67%;"><h4 id="2-3-2-conf-write-symbol函数向-config写配置项"><a href="#2-3-2-conf-write-symbol函数向-config写配置项" class="headerlink" title="2.3.2 conf_write_symbol函数向.config写配置项"></a>2.3.2 conf_write_symbol函数向.config写配置项</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">conf_write_symbol:<br>    <br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">conf_write_symbol</span><span class="hljs-params">(FILE *fp, <span class="hljs-keyword">struct</span> symbol *sym,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> conf_printer *printer, <span class="hljs-type">void</span> *printer_arg)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str;<br><br>    <span class="hljs-comment">// 判断写入的Symbol值</span><br><span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br><span class="hljs-keyword">case</span> S_OTHER:<br><span class="hljs-keyword">case</span> S_UNKNOWN:<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> S_STRING:<br>str = sym_get_string_value(sym);<br>str = sym_escape_string_value(str);<br>printer-&gt;print_symbol(fp, sym, str, printer_arg);<br><span class="hljs-built_in">free</span>((<span class="hljs-type">void</span> *)str);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>str = sym_get_string_value(sym);<br>        <span class="hljs-comment">// 按照2.3.0中的规则往.config中写内容</span><br>printer-&gt;print_symbol(fp, sym, str, printer_arg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果输入的是string类型，直接获取string类型的值，然后写入config中</li></ul><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409213953366.png" alt="image-20230409213953366" style="zoom:67%;"><img src="/2023/04/09/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91make-defconfig/image-20230409213825095.png" alt="image-20230409213825095" style="zoom: 50%;"><ul><li>如果是其他类型，比如bool类型和tristate，获取值然后写入.config</li></ul><h4 id="2-3-4-重命名-config"><a href="#2-3-4-重命名-config" class="headerlink" title="2.3.4 重命名.config"></a>2.3.4 重命名.config</h4><p>其实前面一直是往<code>.tmpconfig.[@pid]</code>里面写配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (*tmpname) &#123;<br>    <span class="hljs-built_in">strcat</span>(dirname, basename);<br>    <span class="hljs-built_in">strcat</span>(dirname, <span class="hljs-string">&quot;.old&quot;</span>);<br>    rename(newname, dirname);<br>    <span class="hljs-keyword">if</span> (rename(tmpname, newname))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>dirname为 <code>.config.old</code></p></li><li><p>将之前的 <strong>.config</strong> 文件重命名为 <strong>.config.old</strong></p></li><li><p>将<strong>tmpname</strong> 重命名为新的config为 <strong>.config</strong></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统——链接</title>
    <link href="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/"/>
    <url>/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解计算机系统——链接"><a href="#深入理解计算机系统——链接" class="headerlink" title="深入理解计算机系统——链接"></a>深入理解计算机系统——链接</h1><blockquote><p>声明：本文为学习计算机系统的笔记，供自己复习使用；按照<strong>yaaangmin</strong>的github声明，请勿进行商用</p><p>所有内容均整理自：<strong>yaaangmin</strong></p><p>其github地址为：<a href="https://github.com/yangminz/bcst_csapp">https://github.com/yangminz/bcst_csapp</a></p></blockquote><h2 id="1-可执行可链接格式"><a href="#1-可执行可链接格式" class="headerlink" title="1.可执行可链接格式"></a>1.可执行可链接格式</h2><p>首先，我们考虑什么是文件系统（File System)上的文件。我们知道，文件都是持久地储存在磁盘等设备上的，但它的实质仍然是二进制序列。只要我们对序列进行恰当的描述，我们就可以获得想要的全部信息。为了将某一文件的二进制串与其他文件的二进制串区别开，我们需要指定这一文件的类型与大小等信息，这些信息存放在文件二进制串的起始地址，也即首部（Header)。</p><h3 id="1-1-ELF-Header"><a href="#1-1-ELF-Header" class="headerlink" title="1.1 ELF Header"></a>1.1 ELF Header</h3><p>对于ELF，首部的信息包括文件类型、机器类型等信息。在Linux读取ELF文件时，Linux将ELF Header从Byte翻译为内存中的数据结构：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405210514169.png" alt="image-20230405210514169" style="zoom:80%;"><p>数据结构<strong>Elf64_Ehdr</strong>包含了很多信息，但对我们而言，我们只需要知道Header 是如何定位到节头表( Section Header Table,SHT)的。Header中的 Elf64_Ehdr.e_shoff 是SHT对ELF起始地址的Byte偏置，Elf64_Ehdr.e_shentsize描述SHT每一项的Byte大小，Elf64_Ehdr.e_shentnum 描述 SHT描述表项的数量，这样，我们就可以通过后两项计算出SHT的大小。Header中的Elf64_Ehdr.e_shstrndx则是SHT中一个特殊节<strong>字符串</strong>表的段索引，Header可以借此计算ELF中每一项的字符串。</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405210554302.png" alt="image-20230405210554302" style="zoom: 80%;"><p>我们举一个例子，使我们洞见ELF文件的数据结构，考虑如下的elf.c源文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> data1 = <span class="hljs-number">0xdddddddd11111111</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> data2 = <span class="hljs-number">0xdddddddd22222222</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span> &#123;&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><p>使用gcc编译得到它的ELF文件：<code>gcc -c elf.c -o elf.o</code>，其中-c的含义是仅编译源文件生成ELF文件，但不对ELF文件进行链接。生成ELF文件以后，利用hexdump查看ELF文件<code>elf.o</code>的内容。</p><p>hexdump获得elf.o的二进制内容后，按照Elf64_Ehdr的结构格式，我们可以解读ELF的Header。首先，我们可以计算得到sizeof(Elf64_Ehdr) &#x3D; 64Byte，因此Header占据ELF文件的低64Byte。这样我们就得到了elf.o的Header：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405211548347.png" alt="image-20230405211548347" style="zoom:80%;"><p>起始位置的16Bytes为 Magic Number,在这之后偏移2+2+4+8+8&#x3D;24Bytes,大小为8Bytes的数据为Elf64_Ehdr.e_shoff，也即SHT起始地址对ELF文件的偏移，数值为 0x00000000000002b0。在这之后，对Elf64_Ehdr.e_shoff偏移为4Bytes 的位置储存了ELF文件Header的大小：Elf64_Ehdr.e_ehsize &#x3D;0x0040。再之后2+2&#x3D;4 Bytes即 Elf64_Ehdr.e_shentsize，也即为SHT每一项的大小，数值为0x0040。最后两个2Bytes的数分别是 Elf64_Ehdr.e_shnum &#x3D; 0x000b以及Elf64_Ehdr.e_shstrndx &#x3D; 0x000a。</p><h3 id="1-2-节头表SHT"><a href="#1-2-节头表SHT" class="headerlink" title="1.2 节头表SHT"></a>1.2 节头表SHT</h3><p>SHT描述了ELF中不同的<strong>节(Section)<strong>，包括</strong>数据节(.data)<strong>、</strong>代码节(.text）</strong>等。这些Section中的数据是由编译器生成的，按照Section 的组织写入到磁盘上的ELF文件中。SHT的每一项可以被数据结构Elf64_Shdr所描：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405212130069.png" alt="image-20230405212130069" style="zoom: 80%;"><p>这样，我们可以通过SHT找到ELF内的任一Section，常见的Section有.text，.data，.rodata，.bss，.symtab，.rel.txt，.rel.data，.strtab，它们可以被Elf64_Shdr.sh_name确定：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405212311898.png" alt="image-20230405212311898" style="zoom:80%;"><p>在elf.o的Header中，我们可以发现SHT距离ELF文件的起始位置偏移为688Byte，并且每一项的大小为64Byte，共11项，那么我们可以找到SHT对应的二进制段。但由于这段代码太长了，因此只截取了.text和.data这两节：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405212446493.png" alt="image-20230405212446493"><p>和解析Header一样，对于SHT的每一个表项，按照结构Elf64_Shdr 逐个 Byte解析，我们就得到了.text对 ELF文件的偏移: .sh_offset &#x3D; 0x0000000000000040【.data对ELF文件的偏移为0x0000000000000050】。回忆起我们先前得知Header 的大小就是0x40，也即64 Bytes，因此.text所处的位置正是Header之后。并且，它的大小为.sh_size &#x3D;0x000000000000000e【实际上为了对齐，会进行补零】，就说明func1()与 func2()两个函数占据了14 Bytes(但目前我们并不知道每一个函数的真正位置)。对于.data，我们可以同样进行解析。readelf -s elf.o 会给我们相同的结论（我们省略了其他表项)。</p><p>值得一提的是，SHT中总存在[o]项，它被视为未定义的符号所在Section，SHN_UNDEF，也就是0。同时，这一SHT表项的值总是64 Bytes的0:</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405212718033.png" alt="image-20230405212718033" style="zoom:80%;"><h3 id="1-3-符号表"><a href="#1-3-符号表" class="headerlink" title="1.3 符号表"></a>1.3 符号表</h3><p>最后，我们要定位到每一个符号在ELF中所处的位置，这就需要一个特别的Section，<code>symtab</code>，也就是<strong>符号表</strong>(Symbol Table)。符号表被用来描述.c源文件中可以<strong>被其他ELF使用的符号</strong>。对于什么是符号Symbol，其实有必要先从编译器的角度去观察.c源文件。这部分工作主要是编译中语义分析(Semantic Analysis)的过程，通过语法中的环境(Environment)和范围(Scope)来进行管理。其中Environment映射在编译器中也被称为符号表，我们很快便能发现<strong>编译和链接语境下的符号表其实是含义相同的</strong>。</p><p>考虑赋值语句<code>int a = 0xaaaaaaaa</code>，在这里，终结符a就是我们通常所说的左值，其实它会被处理为一个字符串；终结符0xaaaaaaaa是我们所说的右值，被处理为数值。当我们在在.c源文件中引用终结符a时，其实做了两部映射(Two-Stage Mapping)；</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405192412069.png" alt="image-20230405192412069" style="zoom:67%;"><p>在C语言中，每一个对象（函数、变量）有它可见的Scope，也就是说在Scope内，这个对象是可以被引用的。而在不同的Scope内，Environment未必相同。我们仔细考虑C语言的语法，很容易发现源文件可以被区分为不同的**块(Block)**，它们通常被一组花括号<code>&#123;&#125;</code>所包围，天然地对应一颗有关Block的树（考虑最外层为根节点）。</p><p>假设当前有一个<code>.c</code>文件，其源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> g_var_init = <span class="hljs-number">0xffffffff</span>;<br><span class="hljs-type">int</span> g_var_uninit;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_undef</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func_def</span><span class="hljs-params">(<span class="hljs-type">int</span> func_param)</span><br>&#123;<br>    <span class="hljs-type">int</span> func_var = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> <br>    &#123;<br>        <span class="hljs-type">int</span> loop_var = <span class="hljs-number">1</span>;<br>        func_var += <span class="hljs-number">1</span>;<br>        g_var_init += <span class="hljs-number">1</span>;<br>        <br>        func_undef();<br>    &#125; <span class="hljs-keyword">while</span> (func_var &lt; func_param)<br>&#125;<br><br>voud <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    func_def();<br>&#125;<br></code></pre></td></tr></table></figure><p>相应的，考虑它的Block树，以及每一个Block内可见的对象：</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405193201163.png" alt="image-20230405193201163" style="zoom: 80%;"><p>我们可以发现，每当进入一个sub-block以前，sub-block会复制当前block的environment，同时，在sub-block以内，新定义的变量、传入函数的参数，也都会被视为在sub-block内新的映射。因此，我们在进入新的sub-block时，可以更新Environment，从而实现了对Environment的维护。</p><p>我们已知<strong>C语言不允许在函数内定义函数</strong>，这个简单的事实将整个.c源文件分为扁平的两层：<strong>函数内部（Internal）、函数外部（External）</strong>，如下图。我们已知函数Scope内的数据实在Run-Time Stack上分配的，因此函数内Scope的Enviroment映射到栈。而函数外部，也就是函数本身以及全局变量，他们的Environment需要我们额外维护，这也就是编译器在ELF文件中生成的符号表。</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405193923601.png" alt="image-20230405193923601" style="zoom:80%;"><p>因此,<strong>外部</strong>的函数与变量是<strong>对链接可见的</strong>，也因此它们能够被其他ELF文件所引用。这就是我们在链接时所说的符号——一个函数(Function)，一个全局变量(Global Variable)，或一个静态变量(Static Variable)。</p><p>根据我们对符号的理解，按照定义和引用，可以将符号分为以下三种类型。假定source1.c是我们当前可见的源文件，source2.c是被链接的ELF的源文件。</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405195017042.png" alt="image-20230405195017042" style="zoom:80%;"><p>其中被static修饰的，被称为局部符号(Local Symbol〉或静态符号(Static Symbol)，只对同一源文件中的函数可见。在本地有定义，但没有被static修饰的，是普通的全局符号(Global Symbol)，对链接中所有的源文件可见。被<strong>extern</strong>修饰的，说明在当前的源文件中没有定义，而只在 extern 处有声明，方便当前源文件中的函数对它进行引用。</p><p>全局符号  我们考察elf.o中的例子，data1与data2是作为变量的符号，func1与func2是作为函数的符号，它们是典型的全局符号。我们来观察全局符号是怎样在ELF被找到的。从ELF Header计算偏移量到Section Header Table，当我们读取到表项为<code>.symtab</code>时，就开始处理符号表，符号表表项的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include\uapi\linux\elf.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf64_sym</span> &#123;</span><br>  Elf64_Word st_name;<span class="hljs-comment">/* Symbol name, index in string tbl */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_info;<span class="hljs-comment">/* Type and binding attributes */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_other;<span class="hljs-comment">/* No defined meaning, 0 */</span><br>  Elf64_Half st_shndx;<span class="hljs-comment">/* Associated section index */</span><br>  Elf64_Addr st_value;<span class="hljs-comment">/* Value of the symbol */</span><br>  Elf64_Xword st_size;<span class="hljs-comment">/* Associated symbol size */</span><br>&#125; Elf64_Sym;<br></code></pre></td></tr></table></figure><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405195558160.png" alt="image-20230405195558160" style="zoom: 80%;"><p>查看SHT</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405195628645.png" alt="image-20230405195628645" style="zoom:60%;"><p><code>.symtab</code>时elf.o SHT中的 [8] 表项，它对于ELF文件的偏移为 0x000000e0，占据0x120Byte，并且.symtab中的每一个元素都有固定的大小，Elf64_Shdr.sh_entrsize &#x3D; 0x0000000000000018。</p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405195923966.png" alt="image-20230405195923966" style="zoom: 67%;"><p>这样，我们可以计算得到.symtab一共有12项。并且四项关于data1，data2，func1，func2：</p><p>通过<code>hexdump -C elf.o</code>后，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs shell">00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|<br>00000010  01 00 3e 00 01 00 00 00  00 00 00 00 00 00 00 00  |..&gt;.............|<br>00000020  00 00 00 00 00 00 00 00  a8 02 00 00 00 00 00 00  |................|<br>00000030  00 00 00 00 40 00 00 00  00 00 40 00 0b 00 0a 00  |....@.....@.....|<br>00000040  55 48 89 e5 90 5d c3 55  48 89 e5 90 5d c3 00 00  |UH...].UH...]...|<br>00000050  11 11 11 11 dd dd dd dd  22 22 22 22 dd dd dd dd  |........&quot;&quot;&quot;&quot;....|<br>00000060  00 47 43 43 3a 20 28 55  6f 73 20 38 2e 33 2e 30  |.GCC: (Uos 8.3.0|<br>00000070  2e 33 2d 33 2b 72 65 62  75 69 6c 64 29 20 38 2e  |.3-3+rebuild) 8.|<br>00000080  33 2e 30 00 00 00 00 00  14 00 00 00 00 00 00 00  |3.0.............|<br>00000090  01 7a 52 00 01 78 10 01  1b 0c 07 08 90 01 00 00  |.zR..x..........|<br>000000a0  1c 00 00 00 1c 00 00 00  00 00 00 00 07 00 00 00  |................|<br>000000b0  00 41 0e 10 86 02 43 0d  06 42 0c 07 08 00 00 00  |.A....C..B......|<br>000000c0  1c 00 00 00 3c 00 00 00  00 00 00 00 07 00 00 00  |....&lt;...........|<br>000000d0  00 41 0e 10 86 02 43 0d  06 42 0c 07 08 00 00 00  |.A....C..B......|<br>000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>000000f0  00 00 00 00 00 00 00 00  01 00 00 00 04 00 f1 ff  |................|<br>00000100  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000110  00 00 00 00 03 00 01 00  00 00 00 00 00 00 00 00  |................|<br>00000120  00 00 00 00 00 00 00 00  00 00 00 00 03 00 02 00  |................|<br>00000130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000140  00 00 00 00 03 00 03 00  00 00 00 00 00 00 00 00  |................|<br>00000150  00 00 00 00 00 00 00 00  00 00 00 00 03 00 05 00  |................|<br>00000160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000170  00 00 00 00 03 00 06 00  00 00 00 00 00 00 00 00  |................|<br>00000180  00 00 00 00 00 00 00 00  00 00 00 00 03 00 04 00  |................|<br>00000190  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>000001a0  07 00 00 00 11 00 02 00  00 00 00 00 00 00 00 00  |................|<br>000001b0  08 00 00 00 00 00 00 00  0d 00 00 00 11 00 02 00  |................|<br>000001c0  08 00 00 00 00 00 00 00  08 00 00 00 00 00 00 00  |................|<br>000001d0  13 00 00 00 12 00 01 00  00 00 00 00 00 00 00 00  |................|<br>000001e0  07 00 00 00 00 00 00 00  19 00 00 00 12 00 01 00  |................|<br>000001f0  07 00 00 00 00 00 00 00  07 00 00 00 00 00 00 00  |................|<br>00000200  00 65 6c 66 2e 63 00 64  61 74 61 31 00 64 61 74  |.elf.c.data1.dat|<br>00000210  61 32 00 66 75 6e 63 31  00 66 75 6e 63 32 00 00  |a2.func1.func2..|<br>00000220  20 00 00 00 00 00 00 00  02 00 00 00 02 00 00 00  | ...............|<br>00000230  00 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  |........@.......|<br>00000240  02 00 00 00 02 00 00 00  07 00 00 00 00 00 00 00  |................|<br>00000250  00 2e 73 79 6d 74 61 62  00 2e 73 74 72 74 61 62  |..symtab..strtab|<br>00000260  00 2e 73 68 73 74 72 74  61 62 00 2e 74 65 78 74  |..shstrtab..text|<br>00000270  00 2e 64 61 74 61 00 2e  62 73 73 00 2e 63 6f 6d  |..data..bss..com|<br>00000280  6d 65 6e 74 00 2e 6e 6f  74 65 2e 47 4e 55 2d 73  |ment..note.GNU-s|<br>00000290  74 61 63 6b 00 2e 72 65  6c 61 2e 65 68 5f 66 72  |tack..rela.eh_fr|<br>000002a0  61 6d 65 00 00 00 00 00  00 00 00 00 00 00 00 00  |ame.............|<br>000002b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>*<br>000002e0  00 00 00 00 00 00 00 00  1b 00 00 00 01 00 00 00  |................|<br>000002f0  06 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000300  40 00 00 00 00 00 00 00  0e 00 00 00 00 00 00 00  |@...............|<br>00000310  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>00000320  00 00 00 00 00 00 00 00  21 00 00 00 01 00 00 00  |........!.......|<br>00000330  03 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000340  50 00 00 00 00 00 00 00  10 00 00 00 00 00 00 00  |P...............|<br>00000350  00 00 00 00 00 00 00 00  08 00 00 00 00 00 00 00  |................|<br>00000360  00 00 00 00 00 00 00 00  27 00 00 00 08 00 00 00  |........&#x27;.......|<br>00000370  03 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000380  60 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |`...............|<br>00000390  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>000003a0  00 00 00 00 00 00 00 00  2c 00 00 00 01 00 00 00  |........,.......|<br>000003b0  30 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |0...............|<br>000003c0  60 00 00 00 00 00 00 00  24 00 00 00 00 00 00 00  |`.......$.......|<br>000003d0  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>000003e0  01 00 00 00 00 00 00 00  35 00 00 00 01 00 00 00  |........5.......|<br>000003f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000400  84 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000410  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>00000420  00 00 00 00 00 00 00 00  4a 00 00 00 01 00 00 00  |........J.......|<br>00000430  02 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000440  88 00 00 00 00 00 00 00  58 00 00 00 00 00 00 00  |........X.......|<br>00000450  00 00 00 00 00 00 00 00  08 00 00 00 00 00 00 00  |................|<br>00000460  00 00 00 00 00 00 00 00  45 00 00 00 04 00 00 00  |........E.......|<br>00000470  40 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |@...............|<br>00000480  20 02 00 00 00 00 00 00  30 00 00 00 00 00 00 00  | .......0.......|<br>00000490  08 00 00 00 06 00 00 00  08 00 00 00 00 00 00 00  |................|<br>000004a0  18 00 00 00 00 00 00 00  01 00 00 00 02 00 00 00  |................|<br>000004b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>000004c0  e0 00 00 00 00 00 00 00  20 01 00 00 00 00 00 00  |........ .......|<br>000004d0  09 00 00 00 08 00 00 00  08 00 00 00 00 00 00 00  |................|<br>000004e0  18 00 00 00 00 00 00 00  09 00 00 00 03 00 00 00  |................|<br>000004f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000500  00 02 00 00 00 00 00 00  1f 00 00 00 00 00 00 00  |................|<br>00000510  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>00000520  00 00 00 00 00 00 00 00  11 00 00 00 03 00 00 00  |................|<br>00000530  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000540  50 02 00 00 00 00 00 00  54 00 00 00 00 00 00 00  |P.......T.......|<br>00000550  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|<br>*<br>00000568<br></code></pre></td></tr></table></figure><p><strong>以data1为例，介绍其在符号表中的各种含义：</strong></p><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405200137407.png" alt="image-20230405200137407" style="zoom:80%;"><ul><li>根据Elf64_Sym.st_name可以查到符号在字符表中的名字，st_name&#x3D;0x7，从字符串表偏移0x7Byte，直到遇到第一个字符串终结符00(<code>\0</code>)，所得到的字符串为：<u>64 61 74 61 31 00</u>，转译为ASCII码的字符为’d’,’a’,’t’,’a’,’1’,’\0’。</li></ul><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405200642983.png" alt="image-20230405200642983" style="zoom:80%;"><ul><li>符号data1的Section索引为Elf64_Sym.st_index &#x3D; 0x2，那么在SHT中，编号为[2] 的表项是 <code>.data</code>节，因此我们确定了data1所在的Section。再根据Elf64_Sym.st_value&#x3D;0x0，我们知道data1对<code>.data</code>节的偏移为0，到此为止是Environment映射。由符号表，我们得到data1占据Elf64_Sym.st_size &#x3D; 0x8 Byte。至此，我们也完成了Type的映射，可以获得data1的数值了：【.data节的偏移量为0x50，且data1对.data偏移为0，data1数值占据8字节】</li></ul><img src="/2023/04/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/image-20230405201014924.png" alt="image-20230405201014924" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>操作系统,编译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux模块加载时的版本检查机制</title>
    <link href="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux模块加载时的版本检查机制"><a href="#Linux模块加载时的版本检查机制" class="headerlink" title="Linux模块加载时的版本检查机制"></a>Linux模块加载时的版本检查机制</h1><blockquote><p>参考：<a href="https://www.jb51.cc/python/3860648.html">https://www.jb51.cc/python/3860648.html</a></p></blockquote><p>Linux 的迅速发展致使相邻版本的内核之间亦存在较大的差异，即在版本补丁号（Patch Level，即内核版本号的第四位数）相邻的内核之间。为此 Linux 的开发者为了保证内核的稳定，Linux 在加载模块到内核时对模块采用了版本校验机制。当被期望加载模块的系统环境与模块的构建环境相左时，通常会出现如清单 1 所示的装载模块失败。</p><h2 id="1-模块加载校验失败"><a href="#1-模块加载校验失败" class="headerlink" title="1.模块加载校验失败"></a>1.模块加载校验失败</h2><p>首先，我们看一下当模块加载时候的报错信息：</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402204428316.png" alt="image-20230402204428316" style="zoom:100%;"><p>模块 hello.ko 构建时的环境与当前系统不一致，导致工具 insmod 在尝试装载模块 hello.ko 到内核时失败。hello.ko 是一个仅使用了函数 printk 的普通模块（。我们通过命令 dmesg获取模块装载失败的具体原因。从日志打印的<code>disagree about version of sysmbol module layout</code>可以看出，模块 hello.ko 装载失败是由于<strong>模块中 module_layout 的导出符号的版本信息与当前内核中的不符</strong>。</p><p>函数 module_layout 被定义在内核模块版本选项 MODVERSIONS（即内核可装载模块的版本校验选项）之后。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># kernel\module.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MODVERSIONS</span><br><span class="hljs-comment">/* Generate the signature for all relevant module structures here.</span><br><span class="hljs-comment"> * If these change, we don&#x27;t want to try to parse the module. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">module_layout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> module *mod,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> modversion_info *ver,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> kernel_param *kp,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> kernel_symbol *ks,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> tracepoint * <span class="hljs-type">const</span> *tp)</span><br>&#123;<br>&#125;<br>EXPORT_SYMBOL(module_layout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>那么我们如何比对内核的module_layout 和 外部模块的module_layout值呢？</p><h3 id="1-1-比对内核与模块module-layout的CRC"><a href="#1-1-比对内核与模块module-layout的CRC" class="headerlink" title="1.1 比对内核与模块module_layout的CRC"></a>1.1 比对内核与模块module_layout的CRC</h3><p>内核的<code>module_layout</code>的CRC值，我们可以通过内核编译的<code>Module.symvers</code>文件进行查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat Module.symvers | grep module_layout<br></code></pre></td></tr></table></figure><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402194808674.png" alt="image-20230402194808674" style="zoom:100%;"><p>外部模块<code>module_layout</code>的CRC值，我们可以通过modprode查看编译出的ko文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">modprobe --dump-versions xxx.ko | grep module_layout<br></code></pre></td></tr></table></figure><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402194909699.png" alt="image-20230402194909699" style="zoom:100%;"><blockquote><p>可以看到内核与外部模块的module_layout值是一样的，所以我们可以通过<strong>insmod或者modprobe加载chrdevbase.ko</strong></p></blockquote><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/8d71df88-4caa-436c-b5eb-72d2a53f2b31.png"><h3 id="1-2-Linux对于模块的两层检验"><a href="#1-2-Linux对于模块的两层检验" class="headerlink" title="1.2 Linux对于模块的两层检验"></a>1.2 Linux对于模块的两层检验</h3><p>inux 对可装载模块采取了两层验证：<strong>模块的 CRC 值校验</strong>和 <strong>vermagic 的检查</strong>。</p><p>其中模块 CRC 值校验针对模块（内核）导出符号，是一种简单的 ABI（即 Application Binary Interface）一致性检查，第一节开头的 hello.ko 加载失败的根本原因就是没有通过 CRC 值校验（即 module_layout 的 CRC 值与当前内核中的不符）。</p><p>而模块 vermagic（即 Version Magic String）则保存了模块编译时的内核版本以及 SMP 等配置信息，当模块 vermagic 与主机信息不相符时亦将终止模块的加载。</p><h2 id="2-模块的CRC值校验"><a href="#2-模块的CRC值校验" class="headerlink" title="2.模块的CRC值校验"></a>2.模块的CRC值校验</h2><p>首先我们了解一下CTC值校验在哪里添加，又是如何进行校验的</p><h3 id="2-1-添加模块的CRC值"><a href="#2-1-添加模块的CRC值" class="headerlink" title="2.1 添加模块的CRC值"></a>2.1 添加模块的CRC值</h3><p>当我们在编译内核模块时，会生成许多的中间文件：</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402205606535.png" alt="image-20230402205606535" style="zoom:80%;"><p>其中<strong>chrdevbase.mod.c</strong>是在模块源文件chrdevbase.c基础上进行的扩展，其内容如下：</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402205711705.png" alt="image-20230402205711705" style="zoom:67%;"><blockquote><p>🤺 <strong>注意</strong>：这里红色圈出来的就是各个符号，前面的16进制数字就是每个符号对应的CRC值。可以看到，module_layout对应的CRC值就是0xfa985410，与1.1节看到的是一样的！</p></blockquote><p>那么chrdevbase.mod.c在生成的过程中， 会调用modpost添加各种信息，其中有一步就是添加版本值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// scripts\mod\modpost.h</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">for</span> (mod = modules; mod; mod = mod-&gt;next) &#123;<br>err |= add_versions(&amp;buf, mod);<br>&#125;<br><br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add_versions</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buffer *b, <span class="hljs-keyword">struct</span> module *mod)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> *<span class="hljs-title">s</span>, *<span class="hljs-title">exp</span>;</span><br><span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (s = mod-&gt;unres; s; s = s-&gt;next) &#123;<br><span class="hljs-built_in">exp</span> = find_symbol(s-&gt;name);<br>s-&gt;module = <span class="hljs-built_in">exp</span>-&gt;module;<br>s-&gt;crc_valid = <span class="hljs-built_in">exp</span>-&gt;crc_valid;<br>s-&gt;crc = <span class="hljs-built_in">exp</span>-&gt;crc;<br>&#125;<br><br>buf_printf(b, <span class="hljs-string">&quot;\n&quot;</span>);<br>buf_printf(b, <span class="hljs-string">&quot;static const struct modversion_info ____versions[]\n&quot;</span>);<br>buf_printf(b, <span class="hljs-string">&quot;__used\n&quot;</span>);<br>buf_printf(b, <span class="hljs-string">&quot;__attribute__((section(\&quot;__versions\&quot;))) = &#123;\n&quot;</span>);<br><br><span class="hljs-keyword">for</span> (s = mod-&gt;unres; s; s = s-&gt;next) &#123;<br><span class="hljs-keyword">if</span> (!s-&gt;module)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (!s-&gt;crc_valid) &#123;<br>warn(<span class="hljs-string">&quot;\&quot;%s\&quot; [%s.ko] has no CRC!\n&quot;</span>,<br>s-&gt;name, mod-&gt;name);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>        <span class="hljs-comment">// 添加各个符号SYSBOL对应的CRC值</span><br>buf_printf(b, <span class="hljs-string">&quot;\t&#123; %#8x, __VMLINUX_SYMBOL_STR(%s) &#125;,\n&quot;</span>, s-&gt;crc, s-&gt;name);<br>&#125;<br><br>buf_printf(b, <span class="hljs-string">&quot;&#125;;\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>哇哦，从这里可以清晰的看到，最终生成的chrdevbase.mod.c【或chrdevbase.ko】是通过add_version添加的。</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402210324480.png" alt="image-20230402210324480" style="zoom:80%;"><h3 id="2-2-通过objdump反汇编后查看versions的值"><a href="#2-2-通过objdump反汇编后查看versions的值" class="headerlink" title="2.2 通过objdump反汇编后查看versions的值"></a>2.2 通过objdump反汇编后查看versions的值</h3><p>我们在上述<code>cat chrdevbase.mod.c</code>中可以看到几个section，如 .modinfo、.gnu.linkonce.this_module 和 __versions。<u>Linux 使用 GCC 中的声明函数属性 <code>__attribute__ </code>完成对模块的版本信息附加</u>。</p><p>通过<code>objdump --section=__versions -s chrdevbase.ko</code>的值查看当前模块的版本version值</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402211313240.png" alt="image-20230402211313240" style="zoom:50%;"><p>可以看到当前模块的module_layout也匹配上了，另外的几个值，如<code>__unregister_chrdev</code>也对应了上述的CRC值</p><h3 id="2-3-加载模块的过程中何时检验CRC"><a href="#2-3-加载模块的过程中何时检验CRC" class="headerlink" title="2.3 加载模块的过程中何时检验CRC"></a>2.3 加载模块的过程中何时检验CRC</h3><p>🥇🥈🥉 <strong>模块 CRC 值校验查看的是就是模块 __versions 小节的内容，模块的 CRC 校验过程在函数 setup_load_info 中完成</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel\module.c</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> module *<span class="hljs-title function_">setup_load_info</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> load_info *info, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-comment">/* Check module struct version now, before we try to use module. */</span><br><span class="hljs-keyword">if</span> (!check_modstruct_version(info-&gt;sechdrs, info-&gt;index.vers, mod))<br><span class="hljs-keyword">return</span> ERR_PTR(-ENOEXEC);<br><br><span class="hljs-keyword">return</span> mod;<br>&#125;<br><br><span class="hljs-comment">//--------------------------------------------------------</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_modstruct_version</span><span class="hljs-params">(Elf_Shdr *sechdrs, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> versindex, <span class="hljs-keyword">struct</span> module *mod)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *crc;<br><br><span class="hljs-keyword">if</span> (!find_symbol(VMLINUX_SYMBOL_STR(module_layout), <span class="hljs-literal">NULL</span>,&amp;crc, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>))<br>        BUG();<br><span class="hljs-keyword">return</span> check_version(sechdrs, versindex, VMLINUX_SYMBOL_STR(module_layout), mod, crc, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">//--------------------------------------------------------</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_version</span><span class="hljs-params">(Elf_Shdr *sechdrs, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> versindex, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *symname, <span class="hljs-keyword">struct</span> module *mod, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *crc, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> module *crc_owner)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i, num_versions;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">modversion_info</span> *<span class="hljs-title">versions</span>;</span><br><br><br>versions = (<span class="hljs-type">void</span> *) sechdrs[versindex].sh_addr;<br>num_versions = sechdrs[versindex].sh_size / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> modversion_info);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_versions; i++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(versions[i].name, symname) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-keyword">if</span> (versions[i].crc == maybe_relocated(*crc, crc_owner))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>pr_debug(<span class="hljs-string">&quot;Found checksum %lX vs module %lX\n&quot;</span>,<br>       maybe_relocated(*crc, crc_owner), versions[i].crc);<br><span class="hljs-keyword">goto</span> bad_version;<br>&#125;<br><br>pr_warn(<span class="hljs-string">&quot;%s: no symbol version for %s\n&quot;</span>, mod-&gt;name, symname);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>bad_version:<br>pr_warn(<span class="hljs-string">&quot;%s: disagrees about version of symbol %s\n&quot;</span>,<br>       mod-&gt;name, symname);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我的天，终于看到了第1节报错的报错的来源啦！</strong></p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230402213008474.png" alt="image-20230402213008474" style="zoom:80%;"><h3 id="2-4-为什么module-layout导出的符号会发生变化"><a href="#2-4-为什么module-layout导出的符号会发生变化" class="headerlink" title="2.4 为什么module_layout导出的符号会发生变化"></a>2.4 为什么module_layout导出的符号会发生变化</h3><p>根据附录2，我们知道了导出的符号如果是函数时，如果CRC值发生了改变，可能是<strong>参数变化</strong>或者<strong>返回值变化</strong>。</p><p>因此，我们将<strong>module_layout</strong>的参数进行变化，编译后查看其CRC值</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230405235046404.png" alt="image-20230405235046404" style="zoom: 50%;"><blockquote><p>我们在参数中添加了<code>int num</code>，发现值变化成了<code>0x5d01a2ac</code></p></blockquote><p>将<strong>module_layout</strong>的参数恢复成原样，重新编译</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230405235204648.png" alt="image-20230405235204648" style="zoom:50%;"><blockquote><p>可以看到又恢复成了原来的1.1节中的值</p></blockquote><h3 id="2-5-module-layout-完全一样的两份kernel代码，生成CRC值不一样？"><a href="#2-5-module-layout-完全一样的两份kernel代码，生成CRC值不一样？" class="headerlink" title="2.5 module_layout 完全一样的两份kernel代码，生成CRC值不一样？"></a>2.5 module_layout 完全一样的两份kernel代码，生成CRC值不一样？</h3><p>当我们在module.c中<code>EXPORT_SYMBOL(module_layout)</code>之后，在编译阶段，宏会被替换成下面的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include\linux\export.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __CRC_SYMBOL(sym, sec)\</span><br><span class="hljs-meta">extern __visible void *__crc_##sym __attribute__((weak));\</span><br><span class="hljs-meta">static const unsigned long __kcrctab_##sym\</span><br><span class="hljs-meta">__used\</span><br><span class="hljs-meta">__attribute__((section(<span class="hljs-string">&quot;___kcrctab&quot;</span> sec <span class="hljs-string">&quot;+&quot;</span> #sym), unused))\</span><br><span class="hljs-meta">= (unsigned long) &amp;__crc_##sym;</span><br><br><span class="hljs-comment">/* For every exported symbol, place a struct in the __ksymtab section */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __EXPORT_SYMBOL(sym, sec)\</span><br><span class="hljs-meta">extern typeof(sym) sym;\</span><br><span class="hljs-meta">__CRC_SYMBOL(sym, sec)\</span><br><span class="hljs-meta">static const char __kstrtab_##sym[]\</span><br><span class="hljs-meta">__attribute__((section(<span class="hljs-string">&quot;__ksymtab_strings&quot;</span>), aligned(1))) \</span><br><span class="hljs-meta">= VMLINUX_SYMBOL_STR(sym);\</span><br><span class="hljs-meta">extern const struct kernel_symbol __ksymtab_##sym;\</span><br><span class="hljs-meta">__visible const struct kernel_symbol __ksymtab_##sym\</span><br><span class="hljs-meta">__used\</span><br><span class="hljs-meta">__attribute__((section(<span class="hljs-string">&quot;___ksymtab&quot;</span> sec <span class="hljs-string">&quot;+&quot;</span> #sym), unused))\</span><br><span class="hljs-meta">= &#123; (unsigned long)&amp;sym, __kstrtab_##sym &#125;</span><br></code></pre></td></tr></table></figure><p>EXPORT_SYMBOL(sym)的这一段代码，其实就是针对模块版本校验机制，生成了某个符号相应的3个段的值。段<code>__ksymtab</code>保存了符号的地址和名字，段<code>__ksymtab_strings</code>是段名字的实际存储位置，段<code>__kcrctab</code>保存了符号crc值的地址。</p><p>可见EXPORT_SYMBOL(sym)宏声明以后，符号的地址名字和CRC值都有了，已经符合版本校验的需要了。可还有一个疑问，符号实际的crc值是怎么生成的呢？宏中引用了一个外部变量<code>extern void *__crc_##sym attribute((weak));</code>，<code>__crc##sym</code>是怎么来的？</p><p>__crc##sym是在编译.o时候做的，查看内核的makefile，makefile.build文件定义了.o的生成规则：<br><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230406225635425.png" alt="image-20230405235204648" style="zoom: 67%;"></p><p>而当CONFIG_MODVERSIONS&#x3D;y 时， cmd_cc_o_c 会将file.c 编译成.tmp_file.o而不是file.o 。cmd_modversions 会检查.tmp_file.o 是否包含<code>__ksymtab</code> ，也就是说file.c 是否包含EXPORT_SYMBOL(xxx)；如果没有__ksymtab ， cmd_modversions 会将.tmp_file.o 直接更名为file.o 。如果确实包含__ksymtab ， cmd_modversions 会通过genksyms 产生xxxx ( export symbol )的符号签名( checksum )，然后调用linker 重新把这些符号以及这些符号的checksum链接进file.o。</p><p>可见符号的CRC值_crc##sym，是在编译.o时，由genksyms脚本生成的。</p><p>通过readelf命令可以，查看内核中关于版本检查的三个段<code>__ksymtab</code>、<code>__ksymtab_strings</code>、<code>__kcrctab</code>：</p><p><img src="/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230406231443917.png" alt="image-20230406231443917"></p><p>如果module_layout在符号表中地址不同，则编译生成后期对应的CRC值是不同的！！</p><p>🤖 <strong>如果两份完全一样的module_layout代码，但是生成的CRC值不同</strong>  -&gt; 那么，必定是module_layout在符号表中的位置不同，也就是在module_layout之前肯定EXPORT_SYMBOL了其他的符号，导致module_layout在对应的符号表中位置不同</p><h2 id="3-模块的vermagic检验"><a href="#3-模块的vermagic检验" class="headerlink" title="3.模块的vermagic检验"></a>3.模块的vermagic检验</h2><h3 id="3-1-内核版本是如何生成的"><a href="#3-1-内核版本是如何生成的" class="headerlink" title="3.1 内核版本是如何生成的"></a>3.1 内核版本是如何生成的</h3><p>inux版本：在<code>include/generated/utsrelease.h</code>中定义，文件中的内容如下：**#define UTS_RELEASE “4.1.15”**，utsrelease.h是kernel编译后自动生成的，用户更改里面的内容不会有效果。</p><h3 id="3-2-模块的vermagic是如何生成的"><a href="#3-2-模块的vermagic是如何生成的" class="headerlink" title="3.2 模块的vermagic是如何生成的"></a>3.2 模块的vermagic是如何生成的</h3><p>在<code>include/linux/vermagic.h</code>中定义有VERMAGIC_STRING，VERMAGIC_STRING不仅包含内核版本号，还包含有 内核使用的gcc版本，SMP与PREEMPT等配置信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> VERMAGIC_STRING \</span><br><span class="hljs-meta">UTS_RELEASE <span class="hljs-string">&quot; &quot;</span>\</span><br><span class="hljs-meta">MODULE_VERMAGIC_SMP MODULE_VERMAGIC_PREEMPT \</span><br><span class="hljs-meta">MODULE_VERMAGIC_MODULE_UNLOAD MODULE_VERMAGIC_MODVERSIONS\</span><br><span class="hljs-meta">MODULE_ARCH_VERMAGIC</span><br></code></pre></td></tr></table></figure><p>模块在编译时，我们可以看到屏幕上会显示”MODPOST”。在此阶段，VERMAGIC_STRING会添加到模块的modinfo段。在内核源码目录下scripts\mod\modpost.c文件中可以看到模块后续处理部分的代码。</p><p>模块编译生成后，通过<code>modinfo xxx.ko</code>命令可以查看此模块的vermagic等信息。</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230406233259580.png" alt="image-20230406233259580" style="zoom: 80%;"><h3 id="3-3-如何校验模块的vermagic"><a href="#3-3-如何校验模块的vermagic" class="headerlink" title="3.3 如何校验模块的vermagic"></a>3.3 如何校验模块的vermagic</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* kernel/module.c */</span> <br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_modinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> module *mod,<span class="hljs-keyword">struct</span> load_info *info)</span> <br>&#123; <br> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *modmagic = get_modinfo(info,<span class="hljs-string">&quot;vermagic&quot;</span>); <br> ... <br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!same_magic(modmagic,vermagic,info-&gt;index.vers)) &#123; <br>   ... <br> &#125; <br> ... <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="附录1：module-symvers-文件的内容"><a href="#附录1：module-symvers-文件的内容" class="headerlink" title="附录1：module.symvers 文件的内容"></a>附录1：module.symvers 文件的内容</h2><p>如果打开该文件后看到的符号CRC值都是0x00000000，那是因为你在配置的时并没有设置 <code>CONFIG_MODVERSIONS</code>。一旦设置过这个配置选项，就意味着打开了内核的 <strong>Module versioning</strong>功能。Module versioning 功能应用在我们使用模块的场合。</p><p>如果Module versioning功能被打开的话，它会以每个导出符号的C原型声明作为输入，计算出对应的CRC校验值，保存在文件 Module.symvers 中。如此一来，内核在后面要加载使用模块的时候，会两相比较模块中的CRC值和保存下来的CRC值，如果发现不相等，内核就拒绝加载这个模块。</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230403230704333.png" alt="image-20230403230704333" style="zoom:100%;"><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230403231013373.png" alt="image-20230403231013373" style="zoom:100%;"><h2 id="附录2：CRC机制"><a href="#附录2：CRC机制" class="headerlink" title="附录2：CRC机制"></a>附录2：CRC机制</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/414290127?utm_id=0">https://zhuanlan.zhihu.com/p/414290127?utm_id=0</a></p></blockquote><p>内核模块符号CRC生成相关代码在scripts&#x2F;genksyms&#x2F;目录下面，注意其中除了c代码会进行解析之外，lex.l和parse.y也会进行初步的解析。CRC即cyclic redundancy check，用于错误检查。只有当内容保持不变的时候，CRC才会保持不变。内核模块主要对导出的符号（EXPORT_SYMBOL）做检查，要求保持两个一致性：</p><ol><li>接口一致：变量、函数参数、函数返回值类型名没有变化，若是结构体，其内部所有成员也没有变化；</li><li>语义一致：结构体成员变量名不能发生变化，函数参数名无需保持一致。</li></ol><h3 id="CRC基本函数"><a href="#CRC基本函数" class="headerlink" title="CRC基本函数"></a>CRC基本函数</h3><p>linux预先定义了256个（0xff）crctab，即用于异或操作的基，并以32位为单位来做CRC操作，相关内核源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">partial_crc32_one</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> crc)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> crctab32[(crc ^ c) &amp; <span class="hljs-number">0xff</span>] ^ (crc &gt;&gt; <span class="hljs-number">8</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">partial_crc32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> crc)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (*s)<br>        crc = partial_crc32_one(*s++, crc);<br>    <span class="hljs-keyword">return</span> crc;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">crc32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> partial_crc32(s, <span class="hljs-number">0xffffffff</span>) ^ <span class="hljs-number">0xffffffff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大致流程是从初始字符开始到最后一个字符，每个字符串都用相同的操作计算crc值，直到字符串结束，得到最终的CRC值。</p><p>对EXPORT_SYMBOL的符号进行crc调用并不由scripts&#x2F;genksyms&#x2F;中的c代码直接发起，而是在编译期的语法生成时由bison的semantic actions发起，相关生成规则如下（在scripts&#x2F;genksyms&#x2F;parse.y）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">export_definition:<br>    EXPORT_SYMBOL_KEYW <span class="hljs-string">&#x27;(&#x27;</span> IDENT <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span><br>        &#123; export_symbol((*$<span class="hljs-number">3</span>)-&gt;<span class="hljs-built_in">string</span>); $$ = $<span class="hljs-number">5</span>; &#125;<br>    ;<br></code></pre></td></tr></table></figure><p>即碰到EXPROT_SYMBOL关键词时，调用genksyms.c里的export_symbol，生成crc值。</p><h3 id="CRC计算举例"><a href="#CRC计算举例" class="headerlink" title="CRC计算举例"></a>CRC计算举例</h3><p><strong>基本类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> abcde;<br>EXPORT_SYMBOL(abcde);<br></code></pre></td></tr></table></figure><p>对于符号abcde，计算过程是：</p><ol><li>partial_crc32(“unsigned”, 0xffffffff) ⇒ 0xa9df1ba</li><li>partial_crc32_one(“ “, 0xa9df1ba) ⇒ 0x10d0e7ab</li><li>partial_crc32(“int”, 0x10d0e7ab) ⇒ 0xa9d106cd</li><li>partial_crc32_one(“ “, 0xa9d106cd) ⇒ 0xde124fc3</li><li>partial_crc32(“abcde”, 0xde124fc3) ⇒ 0x2e7e6a97</li><li>partial_crc32_one(“ “, 0x2e7e6a97) ⇒ 0x552b5845</li><li>0x552b5845 ^ 0xffffffff ⇒ 0xaad4a7ba</li></ol><p>最终，abcde的crc值即为0xaad4a7ba，可以通过Module.symvers查看得到。</p><p>可以发现，以上每步相当于把变量声明的每个符号依次计算了一遍crc32值，且每个符号计算后，都会与空格的crc哈希值做异或，最后将结果的值取0xffffffff的异或，即是最终符号的crc值，即如下过程：</p><img src="/2023/04/02/Linux%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/image-20230405234653884.png" alt="image-20230405234653884" style="zoom:80%;"><p>如果变量是个数组或者指针，则对于分号前的所有符号进行如上计算，包括数组大小等。</p><p>对于导出的基本类型，会产生CRC值不同的原因有：</p><ul><li>变量的类型发生改变</li><li>数组变量的大小发生改变</li></ul><p><strong>函数</strong></p><p>若定义如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">test_fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> b)</span>;<br>EXPORT_SYMBOL(test_fun);<br></code></pre></td></tr></table></figure><p>那么CRC计算如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> -&gt; test_fun -&gt; ( -&gt;<br>    <span class="hljs-type">int</span> -&gt; , -&gt;<br>    <span class="hljs-type">char</span> -&gt; , -&gt;<br>)<br></code></pre></td></tr></table></figure><p>此处变量类型使用基础变量以便理解，如果是符合变量，则需要按照需求展开。</p><p>对于导出的函数，会产生CRC值不同的原因有：</p><ul><li>函数的返回值类型发生变化；</li><li>参数的类型发生变化；</li><li>参数名字发生变化不影响CRC值。</li></ul><p><strong>结构体</strong></p><p>若定义如下复合结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_struct</span> &#123;</span><br>        <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> my_int;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_struct</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_struct</span> <span class="hljs-title">bb</span>;</span><br>        my_int cc;<br>&#125;;<br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_struct</span> *<span class="hljs-title">abcde</span>;</span><br></code></pre></td></tr></table></figure><p>对于abcde，其类型struct test_struct包含另一个结构体struct my_struct和typedef后的变量，则计算的时候，需要依次对如下变量进行计算：\</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> → <span class="hljs-title">test_struct</span> → &#123;</span> → <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> → <span class="hljs-title">my_struct</span> → &#123;</span> → <br>        <span class="hljs-type">int</span> → a → ; → <br>    &#125; → bb → ; → <br>        <span class="hljs-keyword">typedef</span> → <span class="hljs-type">int</span> → my_int → cc → ; → <br>&#125; → * → abcde<br></code></pre></td></tr></table></figure><p>也就是关于struct或者typedef后的类型，其不直接利用类型名来进行计算，而是递归展开该类型的定义，对定义中的所有元素进行再次计算，最后得出计算的结果。</p><p>需要注意的是，typedef计算与基本类型类似，但是struct计算时，其中的每个变量后的分号都纳入计算范围。</p><p>对于导出的结构体，会产生CRC值不同的原因有：</p><ul><li>结构体内变量发生变化，包括变量类型、变量名字；</li><li>结构体内成员的顺序发生改变</li><li>若有typedef，其对应的名字或者类型发生变化。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile中的include关键字</title>
    <link href="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile中的include关键字"><a href="#Makefile中的include关键字" class="headerlink" title="Makefile中的include关键字"></a>Makefile中的include关键字</h1><blockquote><p>🪶 <strong>摘录自</strong>：<a href="https://juejin.cn/post/7150700142817968158#heading-2">https://juejin.cn/post/7150700142817968158#heading-2</a></p></blockquote><h2 id="include-的概念"><a href="#include-的概念" class="headerlink" title="include 的概念"></a>include 的概念</h2><p>makefile 中可以使用 <code>include</code> 指令来包含另一个文件。 当 <code>make</code> 识别到 <code>include</code> 指令时，<u>会暂停读入当前的 makefile 文件</u>，并转而读入 <code>include</code> 指定的文件，之后再继续读取本文件的剩余内容。</p><h2 id="include的使用"><a href="#include的使用" class="headerlink" title="include的使用"></a>include的使用</h2><p>本小节实验涉及到的文件包括：</p><ul><li>inc_a</li><li>inc_b</li><li>makefile</li></ul><p><code>inc_a</code> 的内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#this is a include file for makefile</span><br><br>vari_c=<span class="hljs-string">&quot;vari_c from inc_a&quot;</span><br></code></pre></td></tr></table></figure><p><code>makefile</code> 文件的内容如下：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Make"><span class="hljs-comment"># this is a basic makefile</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:all clean</span><br><br>vari_a=<span class="hljs-string">&quot;original vari a&quot;</span><br>vari_b=<span class="hljs-string">&quot;original vari b&quot;</span><br><br><span class="hljs-keyword">include</span> inc_a<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(vari_a)</span><br>    @echo <span class="hljs-variable">$(vari_b)</span><br>    @echo <span class="hljs-variable">$(vari_c)</span><br><br><span class="hljs-section">clean:</span><br></code></pre></td></tr></table></figure><p>在 Terminal 中执行 <code>make</code> 命令并观察输出结果。</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330234842191.png" alt="image-20230330234842191" style="zoom:80%;"><p>从输出结果可以看出来 makefile 已经成功包含了 <code>inc_a</code> 文件，并且正确获取到了 <code>vari_c</code> 变量。 值得一提的是 <code>include</code> 指示符所指示的文件名可以是任何 shell 能够识别的文件名，这表明 <code>include</code> 还可以支持包含通配符的文件名。我们将在下面的实验中进行验证。</p><p><code>inc_b</code>，文件内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#this is a include file for makefile</span><br><br>vari_d=<span class="hljs-string">&quot;vari_d from inc_b&quot;</span><br></code></pre></td></tr></table></figure><p>修改 makefile，使用通配符同时包含 <code>inc_a</code> 和 <code>inc_b</code> 文件。 修改后的 makefile 内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># this is a basic makefile</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:all clean</span><br><br>vari_a=<span class="hljs-string">&quot;original vari a&quot;</span><br>vari_b=<span class="hljs-string">&quot;original vari b&quot;</span><br><br><span class="hljs-keyword">include</span> inc_*<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(vari_a)</span><br>    @echo <span class="hljs-variable">$(vari_b)</span><br>    @echo <span class="hljs-variable">$(vari_c)</span><br>    @echo <span class="hljs-variable">$(vari_d)</span><br><br><span class="hljs-section">clean:</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：makefile 中修改了两处，第一处是 <code>inc_a</code> 修改为了 <code>inc_*</code>，第二处是在 <code>all</code> 中新增了 <code>@echo $(vari_d)</code> 。因为在 <code>inc_b</code> 中我们定义了变量 <code>vari_d</code>，在 makefile 中我们需要对其值进行输出。</p></blockquote><p>执行 <code>make</code> 命令,输出结果如图：</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235057222.png" alt="image-20230330235057222" style="zoom:80%;"><p>由此说明 <code>inc_a</code> 与 <code>inc_b</code> 都被包含进了 makefile 文件中。</p><h2 id="include-文件的查找路径"><a href="#include-文件的查找路径" class="headerlink" title="include 文件的查找路径"></a>include 文件的查找路径</h2><p>当 include 指示符包含的文件不包含绝对路径，且在当前路径下也无法寻找到时，make 会按以下优先级寻找文件：</p><ol><li><code>-I</code> 指定的目录</li><li><code>/usr/gnu/include</code></li><li><code>/usr/local/include</code></li><li><code>/usr/include</code></li><li>指定 makefile 的 include 路径</li></ol><p>修改 <code>makefile</code>，不再指定 <code>inc_a</code> 和 <code>inc_b</code> 的相对路径，此时 makefile 文件的内容是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># this is a basic makefile</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:all clean</span><br><br>vari_a=<span class="hljs-string">&quot;original vari a&quot;</span><br>vari_b=<span class="hljs-string">&quot;original vari b&quot;</span><br><br><span class="hljs-keyword">include</span> inc_*<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(vari_a)</span><br>    @echo <span class="hljs-variable">$(vari_b)</span><br>    @echo <span class="hljs-variable">$(vari_c)</span><br>    @echo <span class="hljs-variable">$(vari_d)</span><br><span class="hljs-section">clean:</span><br></code></pre></td></tr></table></figure><p>当前目录结构为：</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235800533.png" alt="image-20230330235800533" style="zoom:80%;"><p>执行 <code>make</code> 命令，观察输出结果，如果发现有错误产生。</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235517959.png" alt="image-20230330235517959" style="zoom:80%;"><p>可以看到 makefile 无法找到 <code>inc_a</code> 和 <code>inc_b</code> 文件。</p><p>接下来使用 <code>make -I</code> 命令来指定搜寻路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -I ./include_demo/<br></code></pre></td></tr></table></figure><p>Terminal 输出结果如下图：</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235727451.png" alt="image-20230330235727451" style="zoom:80%;"><p>发现输出结果依然是错误的。因为从输出结果可以看出 <code>make</code> 是在查找名为 <code>inc_*</code> 的文件。现在我们修改 makefile 文件中的 <code>include</code> 行。</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs M">include inc_a inc_b<br></code></pre></td></tr></table></figure><p>Terminal 的输出结果如图所示：</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230330235905294.png" alt="image-20230330235905294" style="zoom:80%;"><p>说明程序得到了正确的执行。</p><blockquote><p>可见不使用通配符的情况下<code>include</code>配合<code>-I</code>选项才能得到预期效果。</p></blockquote><h2 id="include的处理细节"><a href="#include的处理细节" class="headerlink" title="include的处理细节"></a>include的处理细节</h2><p>前面提到 <code>make</code> 读入 makefile 时遇见 <code>include</code> 指示符会暂停读入当前文件，转而读入 <code>include</code> 指定的文件，之后才继续读入当前文件。</p><p>makefile 文件的内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#this makefile is test for include process</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:all clean</span><br><br>vari_a=<span class="hljs-string">&quot;vari_a @ 1st&quot;</span><br><br><span class="hljs-keyword">include</span> ./include_demo/c_inc<br><br>vari_a += <span class="hljs-string">&quot; @2nd ...&quot;</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(vari_a)</span><br><br><span class="hljs-section">clean:</span><br></code></pre></td></tr></table></figure><p>从 makefile 内容上可以看出 makefile 规则的执行过程是先定义变量 <code>vari_a</code>，然后再引入文件 <code>c_inc</code>，最后修改变量 <code>vari_a</code>。</p><p><code>c_inc</code> 文件的内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#this is a include file for include process</span><br><br>vari_a=<span class="hljs-string">&quot;vari_a from c_inc&quot;</span><br></code></pre></td></tr></table></figure><p>从中可以看出在 <code>c_inc</code> 文件中也对 <code>vari_a</code> 变量进行了定义。</p><p>执行 <code>make</code> 命令观察输出结果。</p><img src="/2023/03/30/Makefile%E4%B8%AD%E7%9A%84include%E5%85%B3%E9%94%AE%E5%AD%97/image-20230331000240966.png" alt="image-20230331000240966" style="zoom:80%;"><p>这说明 <code>vari_a</code> 在 <code>include</code> 过程中被修改了，并且在其后添加了字符串 <code>@2nd ...</code>，结果与预期中 <code>make</code> 处理 <code>include</code> 指示符的行为一致</p>]]></content>
    
    
    <categories>
      
      <category>Makefile学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile的执行顺序</title>
    <link href="/2023/03/30/Makefile%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2023/03/30/Makefile%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile的执行顺序"><a href="#Makefile的执行顺序" class="headerlink" title="Makefile的执行顺序"></a>Makefile的执行顺序</h1><blockquote><p>🪶 摘录自：<a href="https://blog.csdn.net/qq_35524916/article/details/77131555?spm=1001.2014.3001.5506">https://blog.csdn.net/qq_35524916/article/details/77131555?spm=1001.2014.3001.5506</a></p></blockquote><p><strong>在linux下，makefile的执行实际上分为两个阶段进行</strong></p><ul><li>第一阶段：读取所有的makefile文件（包括“MAKEFILES”变量指定的、指示符“include”指定的、以及命令行选项“-f（–file）”指定的makefile文件），内建的变量、明确规则和隐含规则，并建立所有目标和依赖之间的依赖关系结构链表。</li><li>第二阶段：根据第一阶段已经建立的依赖关系结构链表决定哪些目标需要更新，并使用对应的规则来重建这些目标。</li></ul><p><strong>make的执行过程如下：</strong></p><ol><li>依次读取变量“MAKEFILES”定义的makefile文件列表</li><li>读取工作目录下的makefile文件（缺省的是根据命名的查找顺序“GNUmakefile”，“makefile”，“Makefile”，首先找到那个就读取那个）</li><li>依次读取工作目录makefile文件中使用指示符“include”包含的文件</li><li>查找重建所有已读取的makefile文件的规则（如果存在一个目标是当前读取的某一个makefile文件，则执行此规则重建此makefile文件，完成以后从第一步开始重新执行）</li><li>初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支</li><li>根据“终极目标”以及其他目标的依赖关系建立依赖关系链表</li><li>执行除“终极目标”以外的所有的目标的规则（规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件）</li><li>执行“终极目标”所在的规则</li></ol>]]></content>
    
    
    <categories>
      
      <category>Makefile学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile中的shell函数</title>
    <link href="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/"/>
    <url>/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile中的shell函数"><a href="#Makefile中的shell函数" class="headerlink" title="Makefile中的shell函数"></a>Makefile中的shell函数</h1><p>shell函数不同于除“wildcard”函数之外的其它函数。make可以使用它来和外部通信。</p><p>函数功能：函数“shell”所实现的功能和shell中的引用（&#96;&#96;）相同，实现对命令的扩展。这就意味着需要一个shell 命令作为此函数的参数，函数的返回结果是此命令在shell中的执行结果。make仅仅对它的返回结果进行处理；make将函数返回结果中的所有换行符（“\n”）或者一对“\n\r”替换为单空格；并去掉末尾的回车符号（“\n”）或者“\n\r”。进行函数展开式时，它所调用的命令（它的参数）得到执行。除对它的引用出现在规则的命令行和递归变量的定义中以外，其它决大多数情况下，make是在读取解析Makefile时完成对函数shell的展开。</p><p>🤺 <strong>返回值</strong>：函数“shell”的参数（一个shell命令）在<strong>shell环境中的执行结果</strong>。</p><p>函数说明：注意，这个函数会新生成一个 Shell 程序来执行命令，所以你要注意其运行性能，如果你的 Makefile 中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是 Makefile 的隐晦的规则可能会让你的 shell 函数执行的次数比你想像的多得多。</p><p>🐼 <strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">contents := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> cat foo.txt)</span><br><span class="hljs-variable">$(info <span class="hljs-variable">$(contents)</span>)</span><br><span class="hljs-section">all:</span><br>@echo <span class="hljs-string">&quot;make all&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">foo.txt</span><br>hello amx!<br>I love codiing.<br></code></pre></td></tr></table></figure><img src="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/image-20230329222716788.png" alt="image-20230329222716788" style="zoom:80%;"><blockquote><p>将换行符当做空格进行连接</p></blockquote><p>🐼 <strong>示例2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">contents := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> echo *.c)</span><br><span class="hljs-variable">$(info <span class="hljs-variable">$(contents)</span>)</span><br><span class="hljs-section">all:</span><br>@echo <span class="hljs-string">&quot;make all&quot;</span><br></code></pre></td></tr></table></figure><img src="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/image-20230329222846872.png" alt="image-20230329222846872" style="zoom:90%;"><img src="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/image-20230329222921766.png" alt="image-20230329222921766" style="zoom:80%;"><p>🐼 <strong>示例3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">contents := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> sh test.sh hello)</span><br><span class="hljs-variable">$(info <span class="hljs-variable">$(contents)</span>)</span><br><span class="hljs-section">all:</span><br>@echo <span class="hljs-string">&quot;make all&quot;</span><br></code></pre></td></tr></table></figure><p>其中<code>test.sh</code>如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>name=&quot;amx&quot;<br>echo $&#123;name&#125;<br>echo $0<br>echo $1<br>echo &quot;ChatGpt4.0&quot;<br></code></pre></td></tr></table></figure><img src="/2023/03/29/Makefile%E4%B8%AD%E7%9A%84shell%E5%87%BD%E6%95%B0/image-20230329224038930.png" alt="image-20230329224038930" style="zoom:90%;">]]></content>
    
    
    <categories>
      
      <category>Makefile学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kernel中__attribute__属性</title>
    <link href="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/"/>
    <url>/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="kernel中-attribute-属性"><a href="#kernel中-attribute-属性" class="headerlink" title="kernel中__attribute__属性"></a>kernel中__attribute__属性</h1><blockquote><p>🐧 <strong>参考</strong>：<a href="https://www.eet-china.com/mp/a192020.html">https://www.eet-china.com/mp/a192020.html</a></p></blockquote><h2 id="1-实验程序"><a href="#1-实验程序" class="headerlink" title="1.实验程序"></a>1.实验程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __attribute__ ((constructor)) beforeMain(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before main...\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Main!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：<code>gcc test.c -o test</code></p><p>输出结果：</p><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328225545088.png" alt="image-20230328225545088" style="zoom:80%;"><blockquote><p>为什么最开始执行的不是main函数？怎么和我们刚开始学习C程序时说的不一样呢？从运行结果中，我们可以看出来beforeMain是在进入main函数之前被调用的，这对于C语言的初学者来说似乎有点难以理解。究竟是谁调用的beforeMain呢？怎么还没有进入main就可以有代码被执行呢？</p></blockquote><p>带着以上问题，我们先用-v参数来显示编译过程输出结果<code>gcc test.c -o test -v</code>：，其中输出部分如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/8/:/usr/lib/gcc/x86_64-linux-gnu/8/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/8/:/usr/lib/gcc/x86_64-linux-gnu/<br>LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/8/:/usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/8/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/8/../../../:/lib/:/usr/lib/<br>COLLECT_GCC_OPTIONS=&#x27;-o&#x27; &#x27;test&#x27; &#x27;-v&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=x86-64&#x27;<br> /usr/lib/gcc/x86_64-linux-gnu/8/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/8/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/8/lto-wrapper -plugin-opt=-fresolution=/tmp/ccxW7QBR.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o test /usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/8 -L/usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/8/../../.. /tmp/ccboZUZT.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/crtn.o<br>COLLECT_GCC_OPTIONS=&#x27;-o&#x27; &#x27;test&#x27; &#x27;-v&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=x86-64&#x27;<br></code></pre></td></tr></table></figure><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328225732402.png" alt="image-20230328225732402" style="zoom:100%;"><p>从输出结果可以看出，在链接生成最后的可执行文件时，有很多的C库二进制文件参与进来。而最终的可执行文件除了我们编写的这个简单的C代码以外，还有大量的C库文件参与了链接，并包含在了最终的可执行文件中。这个链接的过程，是由链接器ld的链接脚本来决定的。如果我们没有指定链接脚本，会默认使用ld的默认脚本。</p><p>通过<strong>ld -verbose</strong>命令来查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">using internal linker script:<br>==================================================<br>/* Script for -z combreloc -z separate-code: combine and sort reloc sections with separate code segment */<br>/* Copyright (C) 2014-2018 Free Software Foundation, Inc.<br>   Copying and distribution of this script, with or without modification,<br>   are permitted in any medium without royalty provided the copyright<br>   notice and this notice are preserved.  */<br>OUTPUT_FORMAT(&quot;elf64-x86-64&quot;, &quot;elf64-x86-64&quot;,<br>              &quot;elf64-x86-64&quot;)<br>OUTPUT_ARCH(i386:x86-64)<br>ENTRY(_start)<br>SEARCH_DIR(&quot;=/usr/local/lib/x86_64-linux-gnu&quot;); SEARCH_DIR(&quot;=/lib/x86_64-linux-gnu&quot;); SEARCH_DIR(&quot;=/usr/lib/x86_64-linux-gnu&quot;); SEARCH_DIR(&quot;=/usr/lib/x86_64-linux-gnu64&quot;); SEARCH_DIR(&quot;=/usr/local/lib64&quot;); SEARCH_DIR(&quot;=/lib64&quot;); SEARCH_DIR(&quot;=/usr/lib64&quot;); SEARCH_DIR(&quot;=/usr/local/lib&quot;); SEARCH_DIR(&quot;=/lib&quot;); SEARCH_DIR(&quot;=/usr/lib&quot;); SEARCH_DIR(&quot;=/usr/x86_64-linux-gnu/lib64&quot;); SEARCH_DIR(&quot;=/usr/x86_64-linux-gnu/lib&quot;);<br></code></pre></td></tr></table></figure><p>从上面输出可以看出这里定义了输出的文件格式、目标机器的类型，以及重要的信息和程序的入口ENTRY（_start）。</p><blockquote><p>我们的例子中beforeMain函数使用的gcc扩展属性<code>__attribute__（（constructor））</code>就是将函数对应的指令归属于.ctors section部分。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">.ctors          :<br>&#123;<br>  /* gcc uses crtbegin.o to find the start of<br>     the constructors, so we make sure it is<br>     first.  Because this is a wildcard, it<br>     doesn&#x27;t matter if the user does not<br>     actually link against crtbegin.o; the<br>     linker won&#x27;t look for a file to match a<br>     wildcard.  The wildcard also means that it<br>     doesn&#x27;t matter which directory crtbegin.o<br>     is in.  */<br>  KEEP (*crtbegin.o(.ctors))<br>  KEEP (*crtbegin?.o(.ctors))<br>  /* We don&#x27;t want to include the .ctor section from<br>     the crtend.o file until after the sorted ctors.<br>     The .ctor section from the crtend file contains the<br>     end of ctors marker and it must be last */<br>  KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))<br>  KEEP (*(SORT(.ctors.*)))<br>  KEEP (*(.ctors))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-attribute-constructor-属性"><a href="#2-attribute-constructor-属性" class="headerlink" title="2._attribute_((constructor))属性"></a>2._<em>attribute</em>_((constructor))属性</h2><blockquote><p>The constructor attribute causes the function to be called automatically before execution enters main (). 构造函数属性使函数在执行进入main（）之前自动被调用</p></blockquote><p>GNU C的一大特色就是<code>__attribute__</code>机制。<code>__attribute__</code>可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute ）。<code>__attribute__</code>写法是<code>__attribute__</code>前后都有两个下划线，并且后面会紧跟一对原括弧，括弧里面是相应的<code>__attribute__</code>参数。<code>__attribute__</code>格式为<code>__attribute__((attribute-list))</code></p><p>就是指在函数上方加上<code>__attribute__((constructor))</code>可以让这个函数在main函数执行前运行</p><p><strong>作用：<code>__attribute__((constructor))</code>可以提前初始化一些在main函数中用到的东西，便于我们做一些准备工作。</strong></p><p><strong>带有优先级的参数</strong></p><p>我们还可以给属性设置优先级，看下面示例代码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span><br><br>static void __attribute__ ((constructor(101))) beforeMain1(void)<br>&#123;<br>    printf(&quot;Before main...1\n&quot;);<br>&#125;<br>static void __attribute__ ((constructor(102))) beforeMain2(void)<br>&#123;<br>    printf(&quot;Before main...2\n&quot;);<br>&#125;<br>static void __attribute__ ((constructor(103))) beforeMain3(void)<br>&#123;<br>    printf(&quot;Before main...3\n&quot;);<br>&#125;<br><br>int main(void)<br>&#123;<br>    printf(&quot;Main!\n&quot;);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328230224517.png" alt="image-20230328230224517" style="zoom:100%;"><h2 id="3-attribute-destructor-属性"><a href="#3-attribute-destructor-属性" class="headerlink" title="3._attribute_((destructor))属性"></a>3._<em>attribute</em>_((destructor))属性</h2><p>查阅了GNU的文档你还会发现有提及这么一个写法<code>__attribute__((destructor))</code>，文档中关于这两个用法的说明如下:</p><blockquote><p>The constructor attribute causes the function to be called automatically before execution enters main (). Similarly, the destructor attribute causes the function to be called automatically after main () completes or exit () is called. Functions with these attributes are useful for initializing data that is used implicitly during the execution of the program.</p></blockquote><blockquote><p>同理, destructor让系统在main()函数退出或者调用了exit()之后,调用我们的函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __attribute__ ((constructor)) beforeMain(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before main...\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __attribute__ ((destructor)) afterMain(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After main...\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Main!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328230504826.png" alt="image-20230328230504826" style="zoom:100%;"><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>C程序中<code>__attribute__ ((constructor))</code>和<code>__attribute__ ((destructor))</code>类似于C++类中构造函数和析构函数。在main函数之前，执行一个函数，便于我们做一些准备工作；在main()函数退出或者调用了exit()之后调用。多个函数时，GCC为我们提供了一个参数叫优先级，constructor按从小到大，destructor函数相反<code> void __attribute__((constructor(5)) initFunction1(void); void __attribute__((constructor(10)) initFunction2(void);</code></p><h2 id="5-attribute用于加载动态库"><a href="#5-attribute用于加载动态库" class="headerlink" title="5.attribute用于加载动态库"></a>5.attribute用于加载动态库</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">Shared objects may <span class="hljs-keyword">export</span> functions using the<br><br>__attribute__((constructor)) and __attribute__((destructor))<br>function attributes.  Constructor functions are executed before<br>dlopen() returns, and destructor functions are executed before<br>dlclose() returns.  A shared object may <span class="hljs-keyword">export</span> multiple<br>constructors and destructors, and priorities can be associated<br>with each function to determine the order in which they are<br>executed.  See the gcc info pages (under <span class="hljs-string">&quot;Function attributes&quot;</span>)<br>for further information.<br></code></pre></td></tr></table></figure><p>函数设置__attribute__((constructor))属性，在dlopen时，会先调用该方法。</p><p>设置__attribute__((destructor))属性，在dlclose时会调用该方法。</p><p>实验程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br>__attribute__((constructor)) <span class="hljs-type">void</span> <span class="hljs-title function_">test_init</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>&#125;<br><br>__attribute__((destructor)) <span class="hljs-type">void</span> <span class="hljs-title function_">test_fini</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bye world\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -fPIC -shared test.c -o  libtest.so<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span><span class="hljs-params">(*testFunc)</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">void</span> *handle = dlopen(<span class="hljs-string">&quot;./libtest.so&quot;</span>, RTLD_LAZY);<br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;handle is null, %s\n&quot;</span>, dlerror());<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------\n&quot;</span>);<br>    testFunc f = (testFunc)dlsym(handle, <span class="hljs-string">&quot;test&quot;</span>);<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;f is null\n&quot;</span>);<br>    &#125;<br><br>    f();<br>    dlclose(handle);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc main.c -ldl -O0 -g -o main<br></code></pre></td></tr></table></figure><img src="/2023/03/28/kernel%E4%B8%AD-attribute-%E5%B1%9E%E6%80%A7/image-20230328234128499.png" alt="image-20230328234128499" style="zoom:100%;">]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓init进程系列(1)ctl.interface_start</title>
    <link href="/2023/03/24/%E5%AE%89%E5%8D%93init%E8%BF%9B%E7%A8%8B%E7%B3%BB%E5%88%97-1-ctl-interface-start/"/>
    <url>/2023/03/24/%E5%AE%89%E5%8D%93init%E8%BF%9B%E7%A8%8B%E7%B3%BB%E5%88%97-1-ctl-interface-start/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓init进程系列-1-ctl-interface-start"><a href="#安卓init进程系列-1-ctl-interface-start" class="headerlink" title="安卓init进程系列(1)ctl.interface_start"></a>安卓init进程系列(1)ctl.interface_start</h1><blockquote><p>🤖 <strong>背景</strong>：为什么会有ctl.interface_start这个属性，因为安卓有了动态HAL的概念，具体可以参见我的另外一篇<a href="https://anmuxixixi.github.io/2023/03/24/%E5%8A%A8%E6%80%81%E5%8F%AF%E7%94%A8%E7%9A%84-HAL/">博客</a></p></blockquote><h2 id="1-哪里会去调用ctl-interface-start"><a href="#1-哪里会去调用ctl-interface-start" class="headerlink" title="1.哪里会去调用ctl.interface_start"></a>1.哪里会去调用ctl.interface_start</h2><p>为什么一直强调背景的重要性，如果脱离的背景，看代码的实现是痛苦的，是梦游的，是无用功🐖</p><p>就好比这里，如果不知道ctl.interface_start出现的背景，就不知道哪里调用了<code>ctl.interface_start</code>，也不知道为什么在某一个Android版本里面突然出现了它。</p><p>好了，从背景来看是为了实现HAL的动态启动，比如WIFI我们不用的时候，WIFI相应的HAL需要自动关闭，这样就实现了一个HAL的动态启动，用的时候开，最大程度的节省系统资源。</p><blockquote><p>🎨 <strong>声明</strong>：那我们以CameraHAL为例，进行分析！【本人不是专业搞Camera的，故参考<a href="https://blog.csdn.net/liujun3512159/article/details/124702217%E3%80%91">https://blog.csdn.net/liujun3512159/article/details/124702217】</a></p><p>另外，关于HAL的启动流程，我也会写一篇详尽的博客供自己复习和大家参考！</p></blockquote><p>client需要获取hal服务，一般都会调用servicemanager去getservice</p><img src="/2023/03/24/%E5%AE%89%E5%8D%93init%E8%BF%9B%E7%A8%8B%E7%B3%BB%E5%88%97-1-ctl-interface-start/image-20230324225335198-1679669618537-1-1679669619970-3.png" alt="image-20230324225335198" style="zoom:80%;"><p>当client向hwservicemanager获取服务的时候，发现找不到该服务，那么会去调用<strong>tryStartService</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\hwservicemanager\ServiceManager.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">tryStartService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; fqName, <span class="hljs-type">const</span> std::string&amp; name)</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> ::android::base::SetProperty;<br><br>    <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Since &quot;</span> &lt;&lt; fqName &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; name<br>              &lt;&lt; <span class="hljs-string">&quot; is not registered, trying to start it as a lazy HAL.&quot;</span>;<br><br>    std::<span class="hljs-built_in">thread</span>([=] &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SetProperty</span>(<span class="hljs-string">&quot;ctl.interface_start&quot;</span>, fqName + <span class="hljs-string">&quot;/&quot;</span> + name)) &#123;<br>            <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Tried to start &quot;</span> &lt;&lt; fqName &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; name<br>                      &lt;&lt; <span class="hljs-string">&quot; as a lazy service, but was unable to. Usually this happens when a &quot;</span><br>                         <span class="hljs-string">&quot;service is not installed, but if the service is intended to be used as a &quot;</span><br>                         <span class="hljs-string">&quot;lazy service, then it may be configured incorrectly.&quot;</span>;<br>        &#125;<br>    &#125;).<span class="hljs-built_in">detach</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>设置属性值，key为<code>ctl.interface_start</code>，value为<code>fqName + &quot;/&quot; + name</code>，我们都知道init进行捕获到系统属性值变化以后会调用<strong>HandlePropertySet</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">HandlePropertySet</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> std::string&amp; value,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-type">const</span> std::string&amp; source_context, <span class="hljs-type">const</span> ucred&amp; cr,</span></span><br><span class="hljs-params"><span class="hljs-function">                           SocketConnection* socket, std::string* error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">StartsWith</span>(name, <span class="hljs-string">&quot;ctl.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SendControlMessage</span>(name.<span class="hljs-built_in">c_str</span>() + <span class="hljs-number">4</span>, value, cr.pid, socket, error);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当属性值以ctl.开头，调用SendControlMessage</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\property_service.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">SendControlMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg, <span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">pid_t</span> pid,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   SocketConnection* socket, std::string* error)</span> </span>&#123;<br>    <span class="hljs-comment">// 调用QueueControlMessage</span><br>    <span class="hljs-type">bool</span> queue_success = <span class="hljs-built_in">QueueControlMessage</span>(msg, name, pid, fd);<br><br>    <span class="hljs-keyword">return</span> PROP_SUCCESS;<br>&#125;<br><br><span class="hljs-comment">// system\core\init\init.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QueueControlMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message, <span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    pending_control_messages.<span class="hljs-built_in">push</span>(&#123;message, name, pid, fd&#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里往<code>pending_control_messages</code>放了<code>message, name, pid, fd</code>这些重要的信息！！！</p><p>按照init的设计思想，类似于rc文件中service的处理方式！既然向pending_control_messages放了一条信息待处理，那么必然有一个地方专门消费pending_control_messages中的信息，我理解这里运用了<strong>生产者-消费者</strong>设计模式，🐧答案在第3节！</p><h2 id="2-init进程启动后续"><a href="#2-init进程启动后续" class="headerlink" title="2.init进程启动后续"></a>2.init进程启动后续</h2><p>Android S从宏观来看，init进程总共分为3个阶段，最后一个阶段也就是<strong>SecondStageMain</strong>，当SecondStageMain所有代码执行结束，init进程基本就结束了，但不代表init进程啥也不干了，里面有一个关键的<u><strong>while循环</strong></u>，会一直监听是否收到ctlMsg信息！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\init.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SecondStageMain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsShuttingDown</span>()) &#123;<br>            <span class="hljs-built_in">HandleControlMessages</span>();<br>            <span class="hljs-built_in">SetUsbController</span>();<br>        &#125;<br>    &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们看看怎么处理CtlMsg信息的，这里我们暂时不用理会与ctl.interface_start的联系.</p><h2 id="3-HandleControlMessages-怎么处理CtlMsg"><a href="#3-HandleControlMessages-怎么处理CtlMsg" class="headerlink" title="3.HandleControlMessages:怎么处理CtlMsg"></a>3.HandleControlMessages:怎么处理CtlMsg</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\init.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">HandleControlMessages</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 当pending_control_messages不为空的时候</span><br>    <span class="hljs-keyword">if</span> (!pending_control_messages.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> control_message = pending_control_messages.<span class="hljs-built_in">front</span>();<br>        pending_control_messages.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 关键看这里，这里回去调用HandleControlMessage处理相关的信息</span><br>        <span class="hljs-type">bool</span> success = <span class="hljs-built_in">HandleControlMessage</span>(control_message.message, control_message.name,<br>                                            control_message.pid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最为关键的是HandleControlMessage，它负责处理每一条具体的CtlMsg</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">HandleControlMessage</span><span class="hljs-params">(std::string_view message, <span class="hljs-type">const</span> std::string&amp; name,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">pid_t</span> from_pid)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取进程的的cmdline_path，这里camerahal传进来的应该是hwservicemanager对应的pid</span><br>    <span class="hljs-comment">// 同时获取的cmdline_path就是hwservicemanger这个字符串</span><br>    std::string cmdline_path = <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;proc/%d/cmdline&quot;</span>, from_pid);<br>    std::string process_cmdline;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ReadFileToString</span>(cmdline_path, &amp;process_cmdline)) &#123;<br>        std::<span class="hljs-built_in">replace</span>(process_cmdline.<span class="hljs-built_in">begin</span>(), process_cmdline.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>);<br>        process_cmdline = <span class="hljs-built_in">Trim</span>(process_cmdline);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        process_cmdline = <span class="hljs-string">&quot;unknown process&quot;</span>;<br>    &#125;<br><br>    Service* service = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> action = message;<br>    <span class="hljs-comment">// 如果action以interface_开头，就去ServiceList中寻找</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ConsumePrefix</span>(&amp;action, <span class="hljs-string">&quot;interface_&quot;</span>)) &#123;<br>        service = ServiceList::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">FindInterface</span>(name);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        service = ServiceList::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">FindService</span>(name);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取我们要执行sigstop_on,oneshot_on,....,start,stop,...中的一种</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; map = <span class="hljs-built_in">GetControlMessageMap</span>();<br>    <span class="hljs-comment">// 显然这里找到的是start</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">find</span>(action);<br><span class="hljs-comment">// start对应的处理函数为DoControlStart</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; function = it-&gt;second;<br><br>    <span class="hljs-comment">// 调用DoControlStart执行这个服务</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">function</span>(service); !result.<span class="hljs-built_in">ok</span>()) &#123;<br>        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Control message: Could not ctl.&quot;</span> &lt;&lt; message &lt;&lt; <span class="hljs-string">&quot; for &#x27;&quot;</span> &lt;&lt; name<br>                   &lt;&lt; <span class="hljs-string">&quot;&#x27; from pid: &quot;</span> &lt;&lt; from_pid &lt;&lt; <span class="hljs-string">&quot; (&quot;</span> &lt;&lt; process_cmdline<br>                   &lt;&lt; <span class="hljs-string">&quot;): &quot;</span> &lt;&lt; result.<span class="hljs-built_in">error</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Control message: Processed ctl.&quot;</span> &lt;&lt; message &lt;&lt; <span class="hljs-string">&quot; for &#x27;&quot;</span> &lt;&lt; name<br>              &lt;&lt; <span class="hljs-string">&quot;&#x27; from pid: &quot;</span> &lt;&lt; from_pid &lt;&lt; <span class="hljs-string">&quot; (&quot;</span> &lt;&lt; process_cmdline &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> std::map&lt;std::string, ControlMessageFunction, std::less&lt;&gt;&gt;&amp; <span class="hljs-built_in">GetControlMessageMap</span>() &#123;<br>    <span class="hljs-comment">// clang-format off</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::map&lt;std::string, ControlMessageFunction, std::less&lt;&gt;&gt; control_message_functions = &#123;<br>        &#123;<span class="hljs-string">&quot;sigstop_on&quot;</span>,        [](<span class="hljs-keyword">auto</span>* service) &#123; service-&gt;<span class="hljs-built_in">set_sigstop</span>(<span class="hljs-literal">true</span>); <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-type">void</span>&gt;&#123;&#125;; &#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;sigstop_off&quot;</span>,       [](<span class="hljs-keyword">auto</span>* service) &#123; service-&gt;<span class="hljs-built_in">set_sigstop</span>(<span class="hljs-literal">false</span>); <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-type">void</span>&gt;&#123;&#125;; &#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;oneshot_on&quot;</span>,        [](<span class="hljs-keyword">auto</span>* service) &#123; service-&gt;<span class="hljs-built_in">set_oneshot</span>(<span class="hljs-literal">true</span>); <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-type">void</span>&gt;&#123;&#125;; &#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;oneshot_off&quot;</span>,       [](<span class="hljs-keyword">auto</span>* service) &#123; service-&gt;<span class="hljs-built_in">set_oneshot</span>(<span class="hljs-literal">false</span>); <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-type">void</span>&gt;&#123;&#125;; &#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;start&quot;</span>,             DoControlStart&#125;,<br>        &#123;<span class="hljs-string">&quot;stop&quot;</span>,              DoControlStop&#125;,<br>        &#123;<span class="hljs-string">&quot;restart&quot;</span>,           DoControlRestart&#125;,<br>    &#125;;<br>    <span class="hljs-comment">// clang-format on</span><br><br>    <span class="hljs-keyword">return</span> control_message_functions;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态可用的 HAL</title>
    <link href="/2023/03/24/%E5%8A%A8%E6%80%81%E5%8F%AF%E7%94%A8%E7%9A%84-HAL/"/>
    <url>/2023/03/24/%E5%8A%A8%E6%80%81%E5%8F%AF%E7%94%A8%E7%9A%84-HAL/</url>
    
    <content type="html"><![CDATA[<h1 id="动态可用的-HAL"><a href="#动态可用的-HAL" class="headerlink" title="动态可用的 HAL"></a>动态可用的 HAL</h1><blockquote><p>🤖 全部来自<a href="https://source.android.com/docs/core/architecture/hal/dynamic-lifecycle?hl=zh-cn">安卓官网</a></p></blockquote><p>Android 9 支持在不使用或不需要 Android 硬件子系统时动态关停这些子系统。例如，如果用户未使用 Wi-Fi，Wi-Fi 子系统就不应占用内存、耗用电量或使用其他系统资源。早期版本的 Android 中，在 Android 手机启动的整个期间，Android 设备上的 HAL&#x2F;驱动程序都会保持开启状态。</p><p>实现动态关停涉及连接数据流以及执行动态进程，下文对此进行了详细介绍。</p><h2 id="对-HAL-定义所做的更改"><a href="#对-HAL-定义所做的更改" class="headerlink" title="对 HAL 定义所做的更改"></a>对 HAL 定义所做的更改</h2><p>要实现动态关停，不仅需要有关于哪些进程为哪些 HAL 接口提供服务的信息（此类信息之后在其他情况中也可能很有用），还需要确保设备启动时不启动进程，而且在进程退出后，直到系统再次请求启动它们之前，都不重新启动它们。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># some init.rc script associated with the HAL</span><br>service vendor.some-service-name /vendor/bin/hw/some-binary-service<br>    <span class="hljs-comment"># init language extension, provides information of what service is served</span><br>    <span class="hljs-comment"># if multiple interfaces are served, they can be specified one on each line</span><br>    interface android.hardware.light@2.0::ILight default<br>    <span class="hljs-comment"># restarted if hwservicemanager dies</span><br>    <span class="hljs-comment"># would also cause the hal to start early during boot if disabled wasn&#x27;t set</span><br>    class hal<br>    <span class="hljs-comment"># will not be restarted if it exits until it is requested to be restarted</span><br>    oneshot<br>    <span class="hljs-comment"># will only be started when requested</span><br>    disabled<br>    <span class="hljs-comment"># ... other properties</span><br></code></pre></td></tr></table></figure><h2 id="对-init-和-hwservicemanager-所做的更改"><a href="#对-init-和-hwservicemanager-所做的更改" class="headerlink" title="对 init 和 hwservicemanager 所做的更改"></a>对 init 和 hwservicemanager 所做的更改</h2><p>为了实现动态关停，还需要让 <code>hwservicemanager</code> 告知 <code>init</code> 启动所请求的服务。在 Android 9 中，<code>init</code> 包含三个额外的控制消息（例如，<code>ctl.start</code>）：<code>ctl.interface_start</code>、<code>ctl.interface_stop</code> 和 <code>ctl.interface_restart</code>。这些消息可用于指示 <code>init</code> 打开或关闭特定硬件接口。如果系统请求使用某个服务但该服务未注册，<code>hwservicemanager</code> 会请求启动该服务。不过，动态 HAL 不需要使用以上任何消息。</p><h2 id="确定-HAL-退出"><a href="#确定-HAL-退出" class="headerlink" title="确定 HAL 退出"></a>确定 HAL 退出</h2><p>在 Android 9 中，必须手动确定 HAL 退出。对于 Android 10 及更高版本，还可以使用自动生命周期确定 HAL 退出。</p><p>为了实现动态关停，需要多个策略来决定何时启动和关停 HAL。如果 HAL 出于任何原因决定退出，当系统再次需要用到它时，它将使用以下信息和基础架构自动重新启动：HAL 定义中提供的信息，以及更改后的 <code>init</code> 和 <code>hwservicemanager</code> 提供的基础架构。这可能会涉及多个不同的策略，包括：</p><ul><li>如果有人对 HAL 调用关闭命令或类似的 API，则 HAL 可能会选择自行调用退出命令。此行为必须在相应的 HAL 接口中指定。</li><li>HAL 可在任务完成后关停（记录在 HAL 文件中）。</li></ul><h2 id="自动生命周期"><a href="#自动生命周期" class="headerlink" title="自动生命周期"></a>自动生命周期</h2><p>Android 10 为内核和 hwservicemanager 添加了更多支持，可让 HAL 在没有任何客户端时自动关停。如需使用此功能，请根据“对 HAL 定义所做的更改”这一部分完成其中所有步骤，并执行以下操作：</p><ul><li>使用 <code>LazyServiceRegistrar</code> 而不是成员函数 <code>registerAsService</code> 通过 C++ 注册服务，例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// only one instance of LazyServiceRegistrar per process</span><br>LazyServiceRegistrar registrar;<br>registrar.<span class="hljs-built_in">registerAsService</span>(myHidlService <span class="hljs-comment">/* , &quot;default&quot; */</span>);<br></code></pre></td></tr></table></figure><ul><li>验证 HAL 客户端是否仅在使用时保留对顶级 HAL（通过 <code>hwservicemanager</code> 注册的接口）的引用。为了避免出现延迟，如果该引用在继续执行的 hwbinder 线程上被丢弃，客户端还应该在丢弃引用后调用 <code>IPCThreadState::self()-&gt;flushCommands()</code>，以确保 binder 驱动程序在相关引用计数发生变化时收到通知。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习笔记</title>
    <link href="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="git学习笔记"><a href="#git学习笔记" class="headerlink" title="git学习笔记"></a>git学习笔记</h1><h2 id="git下载安装"><a href="#git下载安装" class="headerlink" title="git下载安装"></a>git下载安装</h2><p>下载地址：<a href="https://git-scm.com/download">Git - Downloads</a></p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1679585116661-4.png" alt="img"><p>以得到如下安装文件：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1679585140689-7.png" alt="img"><p>双击下载的安装文件来安装Git。安装完成后在电脑桌面（也可以是其他目录）点击右键，如果能够看</p><p>到如下两个菜单则说明Git安装成功</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230323232638131.png" alt="image-20230323232638131" style="zoom: 70%;"><p>备注：</p><ul><li>Git GUI：Git提供的图形界面工具</li><li>Git Bash：Git提供的命令行工具</li></ul><p>当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><h2 id="git三个区"><a href="#git三个区" class="headerlink" title="git三个区"></a>git三个区</h2><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/e38fd405-7e6a-4cc7-b576-a991af1d9cd5.png" alt="在这里插入图片描述"><ul><li><code>Workspace</code>：工作区，就是你平时存放项目代码的地方</li><li><code>Index / Stage</code>：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息,一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）</li><li><code>Repository</code>：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li><code>Remote</code>：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><hr><p><strong>命令如下：</strong></p><ol><li>clone（克隆）: 从远程仓库中克隆代码到本地仓库</li><li>checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订</li><li>add（添加）: 在提交前先将代码提交到暂存区</li><li>commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本</li><li>fetch (抓取) ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li><li>pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge</li><li>push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</li></ol><h2 id="git-config配置作者信息"><a href="#git-config配置作者信息" class="headerlink" title="git config配置作者信息"></a>git config配置作者信息</h2><blockquote><p>后盾人：<a href="https://www.bilibili.com/video/BV1WW4y1b78T">https://www.bilibili.com/video/BV1WW4y1b78T</a></p></blockquote><p>配置文件为<code>~/.gitconfig</code>，执行任何Git配置命令后文件将自动创建。</p><p>第一个要配置的是你个人的用户名称和电子邮件地址，这两条配置很重要，每次Git提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name “OneAmxixixi”<br>git config --global user.email “842629356@qq.com&quot;<br></code></pre></td></tr></table></figure><ul><li>如果我们要在特定的项目仓中修改提交人信息：</li></ul><p>当我们git init初始化本地仓库后，会出现.git文件，我们进入里面的配置文件<code>config</code>。</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325224813424.png" alt="image-20230325224813424" style="zoom:70%;"><p>此时config文件如下：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325224941049.png" alt="image-20230325224941049" style="zoom: 67%;"><p>修改当前仓库提交人信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">Administrator@WBX-20220621BRZ MINGW64 /g/git强化学习/android12 (master)<br>$ git config user.name <span class="hljs-string">&quot;baitaowulong&quot;</span><br></code></pre></td></tr></table></figure><p>此时当前仓库的<code>.git/config</code>就出现了新的提交人</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325225038843.png" alt="image-20230325225038843" style="zoom:67%;"><h2 id="gitignore添加文件至忽略列表"><a href="#gitignore添加文件至忽略列表" class="headerlink" title=".gitignore添加文件至忽略列表"></a>.gitignore添加文件至忽略列表</h2><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为<code>.gitignore</code> 的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略所有以.a结尾的文件</span><br>*.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略所有以.a结尾的文件，除了lib.a</span><br>!lib.a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅仅忽略当前目录下的TODO文件夹，但不忽略当前路径子文件的TODO文件夹，例如./subdir/TODO</span><br>/TODO<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略build/目录下所有文件</span><br>build/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略doc目录下以.txt结尾的文件，但不忽略doc子目录下以txt文件的文件，比如doc/server/arch.txt不会忽略</span><br>doc/*.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">忽略doc文件下所有以pdf结尾的文件，包括子目录</span><br>doc/**/*.pdf<br></code></pre></td></tr></table></figure><ol><li>我们创建了两个文件，一个以<code>.java</code>结尾，一个以<code>.c</code>结尾</li></ol><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325231753957.png" alt="image-20230325231753957" style="zoom:80%;"><ol start="2"><li>在<code>.gitignore</code>中设置被忽略的规则</li></ol><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325231903931.png" alt="image-20230325231903931" style="zoom:80%;"><ol start="3"><li>此时本地仓库就不会跟踪<code>.gitignore</code>中的内容</li></ol><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230325231922326.png" alt="image-20230325231922326" style="zoom: 80%;"><h2 id="git-rm删除文件"><a href="#git-rm删除文件" class="headerlink" title="git rm删除文件"></a>git rm删除文件</h2><h3 id="git-rm基本用法"><a href="#git-rm基本用法" class="headerlink" title="git rm基本用法"></a>git rm基本用法</h3><p><strong>作用：</strong>  <strong>同时从工作区和索引中删除文件</strong>。即本地的文件也被删除了。</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326104602205.png" alt="image-20230326104602205" style="zoom:80%;"><h3 id="git-rm-–cache后悔药"><a href="#git-rm-–cache后悔药" class="headerlink" title="git rm –cache后悔药"></a>git rm –cache后悔药</h3><blockquote><p>场景：假设我们手快了，将一些文件添加到了本地版本库里面，现在想删除它，但是又不希望本地的文件丢失。</p></blockquote><p><strong>作用：</strong> <strong>从索引中删除文件。但是本地文件还存在</strong>， 只是不希望这个文件被版本控制</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326105155871.png" alt="image-20230326105155871" style="zoom:80%;"><h2 id="git-mv修改文件名"><a href="#git-mv修改文件名" class="headerlink" title="git mv修改文件名"></a>git mv修改文件名</h2><blockquote><p>场景：发现版本库里面的文件需要修改，例如我们要将版本库里面的binder.c改成bind.c</p></blockquote><p><strong>作用：</strong></p><ul><li><p>git mv 命令用于移动或重命名一个文件、目录或软连接。</p></li><li><p>它会将内容从工作区和暂存区中重命名，手动重命名需要执行两步操作，git mv 一步即可</p></li></ul><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326110457377.png" alt="image-20230326110457377" style="zoom:80%;"><p>如果不采取git mv，需要两步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv led_t286.c led_q385.c<br>git add led_t286.c led_t286<br></code></pre></td></tr></table></figure><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326111013402.png" alt="image-20230326111013402" style="zoom:80%;"><h2 id="git-log查看版本变动信息"><a href="#git-log查看版本变动信息" class="headerlink" title="git log查看版本变动信息"></a>git log查看版本变动信息</h2><p><strong>作用：</strong>查看版本变动信息</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326112521485.png" alt="image-20230326112521485" style="zoom:80%;"><p>如果想看查看更加详细一点的信息可以使用<code>git log -p</code></p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326112631990.png" alt="image-20230326112631990" style="zoom:80%;"><p>如果想要日志以某种格式输出可以使用<code>git log --pretty=format</code></p><blockquote><p>详细可参考：<a href="https://blog.csdn.net/u011106915/article/details/105836289/">https://blog.csdn.net/u011106915/article/details/105836289/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --pretty=format:&quot;SHA-1:%h - 创建人:%an 时间:%ad 提交信息:%s&quot; --date=format:&quot;%y-%m-%d %H:%M:%S&quot; --shortstat --since=2.weeks &gt; log.txt<br></code></pre></td></tr></table></figure><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326112833997.png" alt="image-20230326112833997" style="zoom:67%;"><h2 id="git-amend修改最近一次提交"><a href="#git-amend修改最近一次提交" class="headerlink" title="git amend修改最近一次提交"></a>git amend修改最近一次提交</h2><blockquote><p>场景：假如刚刚有一笔提交，需要重新修改后提交，但是我们又不想生成新的commitId重新提交</p></blockquote><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326113641189.png" alt="image-20230326113641189" style="zoom:80%;"><h2 id="git命令创建别名"><a href="#git命令创建别名" class="headerlink" title="git命令创建别名"></a>git命令创建别名</h2><p>Linux：在home目录下，编辑<code>.gitconfig</code>文件</p><p>WIndow：在 <code>$HOME</code> 目录下（一般情况下是 <code>C:\Users\$USER</code> ）的 <code>.gitconfig</code> 文件</p><p>添加以下内容：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326210601688.png" alt="image-20230326210601688" style="zoom:80%;"><p>接下来我们就可以使用简短的命令表示以前繁琐的命令</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230326210430079.png" alt="image-20230326210430079" style="zoom: 80%;"><p>如果我们想更简短一点，在Linux下，编辑<code>~/.bashrc</code>【Window编辑<code>C:\Users\$USER\.bash_profile</code>】，添加以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias gs=&#x27;git status&#x27;<br>alias gss=&#x27;git status |grep modified&#x27;<br>alias gd=&#x27;git diff &#x27;<br>alias gds=&#x27;git diff --staged&#x27;<br>alias gsh=&#x27;git show &#x27;<br>alias ga=&#x27;git add .&#x27;<br>alias gcm=&#x27;git commit .&#x27;<br>alias gc=&#x27;git checkout -- &#x27;<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">alias</span> gl=<span class="hljs-string">&#x27;git log --pretty=oneline  --abbrev-commit&#x27;</span></span><br>alias gl=&#x27;git lg&#x27;<br>alias glh=&#x27;git lg --graph&#x27;<br>alias gls=&#x27;git lg --author=panfei&#x27;<br>alias gb=&#x27;git branch -v&#x27;<br></code></pre></td></tr></table></figure><p>就可以使用<code>gs</code>表示<code>git status</code>…</p><h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><blockquote><p>🐌 <strong>参考</strong>：<a href="https://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html">阮一峰博客</a></p></blockquote><p>对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。</p><p>这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（<code>git merge</code>）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>git cherry-pick</code>命令的作用，就是将指定的提交（commit）应用于其他分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick &lt;commitHash&gt;<br></code></pre></td></tr></table></figure><p>上面命令就会将指定的提交<code>commitHash</code>，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。</p><p>举例来说，代码仓库有<code>master</code>和<code>feature</code>两个分支。</p><blockquote><p>a - b - c - d   Master<br>     <br>       e - f - g Feature</p></blockquote><p>现在将提交<code>f</code>应用到<code>master</code>分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到 master 分支</span><br>$ git checkout master<br><br><span class="hljs-comment"># Cherry pick 操作</span><br>$ git cherry-pick f<br></code></pre></td></tr></table></figure><p>上面的操作完成以后，代码库就变成了下面的样子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">a - b - c - d - f   Master<br>     \<br>       e - f - g Feature<br></code></pre></td></tr></table></figure><p>从上面可以看到，<code>master</code>分支的末尾增加了一个提交<code>f</code>。</p><p><code>git cherry-pick</code>命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bas">$ git cherry-pick feature<br></code></pre></td></tr></table></figure><p>上面代码表示将<code>feature</code>分支的最近一次提交，转移到当前分支。</p><h3 id="转移多个提交"><a href="#转移多个提交" class="headerlink" title="转移多个提交"></a>转移多个提交</h3><p>Cherry pick 支持一次转移多个提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;<br></code></pre></td></tr></table></figure><p>上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。</p><p>如果想要转移一系列的连续提交，可以使用下面的简便语法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick A..B <br></code></pre></td></tr></table></figure><p>上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。</p><p>注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick A^..B <br></code></pre></td></tr></table></figure><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><p><code>git cherry-pick</code>命令的常用配置项如下。</p><p><strong>（1）<code>-e</code>，<code>--edit</code></strong></p><p>打开外部编辑器，编辑提交信息。</p><p><strong>（2）<code>-n</code>，<code>--no-commit</code></strong></p><p>只更新工作区和暂存区，不产生新的提交。</p><p><strong>（3）<code>-x</code></strong></p><p>在提交信息的末尾追加一行<code>(cherry picked from commit ...)</code>，方便以后查到这个提交是如何产生的。</p><p><strong>（4）<code>-s</code>，<code>--signoff</code></strong></p><p>在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</p><p><strong>（5）<code>-m parent-number</code>，<code>--mainline parent-number</code></strong></p><p>如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。</p><p><code>-m</code>配置项告诉 Git，应该采用哪个分支的变动。它的参数<code>parent-number</code>是一个从<code>1</code>开始的整数，代表原始提交的父分支编号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick -m 1 &lt;commitHash&gt;<br></code></pre></td></tr></table></figure><p>上面命令表示，Cherry pick 采用提交<code>commitHash</code>来自编号1的父分支的变动。</p><p>一般来说，1号父分支是接受变动的分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from）。</p><h3 id="代码冲突"><a href="#代码冲突" class="headerlink" title="代码冲突"></a>代码冲突</h3><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p><p><strong>（1）<code>--continue</code></strong></p><p>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（<code>git add .</code>），第二步使用下面的命令，让 Cherry pick 过程继续执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure><p><strong>（2）<code>--abort</code></strong></p><p>发生代码冲突后，放弃合并，回到操作前的样子。</p><p><strong>（3）<code>--quit</code></strong></p><p>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。</p><h3 id="转移到另一个代码库"><a href="#转移到另一个代码库" class="headerlink" title="转移到另一个代码库"></a>转移到另一个代码库</h3><p>Cherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add target git://gitUrl<br></code></pre></td></tr></table></figure><p>上面命令添加了一个远程仓库<code>target</code>。</p><p>然后，将远程代码抓取到本地。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bas">$ git fetch target<br></code></pre></td></tr></table></figure><p>上面命令将远程代码仓库抓取到本地。</p><p>接着，检查一下要从远程仓库转移的提交，获取它的哈希值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> target/master<br></code></pre></td></tr></table></figure><p>最后，使用<code>git cherry-pick</code>命令转移提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick &lt;commitHash&gt;<br></code></pre></td></tr></table></figure><h2 id="Git-中-HEAD、工作树和索引之间的区别"><a href="#Git-中-HEAD、工作树和索引之间的区别" class="headerlink" title="Git 中 HEAD、工作树和索引之间的区别"></a>Git 中 HEAD、工作树和索引之间的区别</h2><blockquote><p>参考：<a href="http://fanyouf.gitee.io/interview/git/02.html#%E7%AE%80%E7%89%88">http://fanyouf.gitee.io/interview/git/02.html#%E7%AE%80%E7%89%88</a></p></blockquote><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2de056a0-fa40-11eb-991d-334fd31f0201.png" alt="img" style="zoom:80%;"><p>在<code>git</code>中，可以存在很多分支，其本质上是一个指向<code>commit</code>对象的可变指针，而<code>Head</code>是一个特别的指针，是一个指向你正在工作中的本地分支的指针</p><p>简单来讲，就是你现在在哪儿，HEAD 就指向哪儿</p><p>例如当前我们处于<code>master</code>分支，所以<code>HEAD</code>这个指针指向了<code>master</code>分支指针</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/36cb0da0-fa40-11eb-991d-334fd31f0201.png" alt="img" style="zoom:80%;"><p>然后通过调用<code>git checkout test</code>切换到<code>test</code>分支，那么<code>HEAD</code>则指向<code>test</code>分支，如下图：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3e86ba80-fa40-11eb-991d-334fd31f0201.png" alt="img" style="zoom:80%;"><p>但我们在<code>test</code>分支再一次<code>commit</code>信息的时候，<code>HEAD</code>指针仍然指向了<code>test</code>分支指针，而<code>test</code>分支指针已经指向了最新创建的提交，如下图：</p><img src="/2023/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/439839b0-fa66-11eb-991d-334fd31f0201.png" alt="img" style="zoom: 50%;"><p>这个<code>HEAD</code>存储的位置就在<code>.git/HEAD</code>目录中，查看信息可以看到<code>HEAD</code>指向了另一个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> .git/HEAD</span><br>ref: refs/heads/master<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> .git/refs/heads/master</span><br>7406a10efcc169bbab17827aeda189aa20376f7f<br></code></pre></td></tr></table></figure><p>这个文件的内容是一串哈希码，而这个哈希码正是<code>master</code>分支上最新的提交所对应的哈希码</p><p>所以，当我们切换分支的时候，<code>HEAD</code>指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</p><p>所以，HEAD 指针 ——–&gt; 分支指针 ——–&gt; 最新提交</p><h3 id="工作树和索引"><a href="#工作树和索引" class="headerlink" title="工作树和索引"></a>工作树和索引</h3><p>在<code>Git</code>管理下，大家实际操作的目录被称为<strong>工作树</strong>，也就是<strong>工作区域</strong></p><p>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域</p><p><code>Git</code>在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库</p><p>因此，要提交文件，首先需要把文件加入到索引区域中。</p><p>所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交</p><blockquote><p>工作树就是工作区，索引就是暂存区，数据库就是本地仓库</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>从所在的位置来看：</p><ul><li>HEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</li><li>工作树是查看和编辑的（源）文件的实际内容</li><li>索引是放置你想要提交给 git 仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过 git commit 则将索引区域的文件提交到 git 仓库中</li></ul><h2 id="如何理解git-checkout-–-file和git-reset-HEAD-–-file"><a href="#如何理解git-checkout-–-file和git-reset-HEAD-–-file" class="headerlink" title="如何理解git checkout – file和git reset HEAD – file"></a>如何理解git checkout – file和git reset HEAD – file</h2><blockquote><p>参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897889638509536">https://www.liaoxuefeng.com/wiki/896043488029600/897889638509536</a></p></blockquote><p>git checkout – file：撤销对工作区修改；这个命令是以最新的存储时间节点（add和commit）为参照，覆盖工作区对应文件file；这个命令改变的是<strong>工作区</strong>【使用场景：当需要撤回工作区的内容到上一个版本，<strong>但是还没有</strong>git add添加到暂存区】</p><p>git reset HEAD – file：清空add命令向暂存区提交的关于file文件的修改（Ustage）；这个命令仅改变<strong>暂存区</strong>，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何改变【使用场景：当需要撤回工作区的内容到上一个版本，<strong>但是已经</strong>git add添加到暂存区】</p><p>🍭 <strong>总结：</strong></p><blockquote><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Git学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核编译</title>
    <link href="/2023/03/22/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"/>
    <url>/2023/03/22/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux内核编译"><a href="#Linux内核编译" class="headerlink" title="Linux内核编译"></a>Linux内核编译</h1><h2 id="1-linux内核中Makefile、Kconfig、-config的关系"><a href="#1-linux内核中Makefile、Kconfig、-config的关系" class="headerlink" title="1.linux内核中Makefile、Kconfig、.config的关系"></a>1.linux内核中Makefile、Kconfig、.config的关系</h2><p><strong>三者的作用：</strong></p><ul><li>Makefile：一个文本形式的文件，编译源文件的方法。</li><li>Kconfig：一个文本形式的文件，内核的配置菜单。</li><li>.config：编译所依据的配置</li></ul><p><strong>三者的关系：</strong></p><p>简单来说就是去饭店点菜：Kconfig是菜单，Makefile是做法，.config就是你点的菜。在运行make menuconfig后在配置界面中出现的就是Kconfig中的选项，在界面中看到的已经配置好的选项就是从.config中读取出来的，当配置完成后就会将配置重新保存到.config中，编译时makefile会读取.config中配置来对内核进行编译。</p><blockquote><ol><li>如果.config不存在，运行make config&#x2F;menuconfig时的缺省设置由固化在各个Kconfig文件中各项目的缺省值决定。</li><li>如果.config存在，运行make config&#x2F;menuconfig时的缺省设置即是当前.config的设置，若对设置进行了修改，<code>.config</code>将被更新。</li><li>arch&#x2F;arm&#x2F;defconfig是一个缺省的配置文件，make defconfig时会根据这个文件生成当前的.config。</li><li>arch&#x2F;arm&#x2F;configs文件夹中有许多命名为xxx_defconfig的配置文件，如果运行make xxx_defconfig，当前.config文件会由xxx_defconfig文件生成。</li></ol></blockquote><p>🐼 <strong>总结一下</strong></p><p>执行<code>make xxx_defconfig</code>生成.config文件</p><p>执行<code>make menuconfig</code>可以修改.config文件。</p><h2 id="2-模块编译时obj-y和obj-m的区别"><a href="#2-模块编译时obj-y和obj-m的区别" class="headerlink" title="2.模块编译时obj-y和obj-m的区别"></a>2.模块编译时obj-y和obj-m的区别</h2><p>在进行模块编译时，主要有两个选项，obj-m和obj-y，而与内核密切相关的是obj-y选项，下面对两者之间的区别简单总结一下。</p><p>以test.c文件为例：</p><p>obj-m +&#x3D; test.o</p><p>obj-y  +&#x3D; test.o</p><p>其中:</p><ul><li><p>obj-m表示把文件test.o作为”模块”进行编译，不会编译到内核，但是会生成一个独立的 “test.ko” 文件。</p></li><li><p>obj-y表示把test.o文件编译进内核</p></li></ul><h2 id="3-Kernel中Makefile的语法"><a href="#3-Kernel中Makefile的语法" class="headerlink" title="3.Kernel中Makefile的语法"></a>3.Kernel中Makefile的语法</h2><p>1）直接编译</p><p>obj-y &#x3D; led.o</p><p>2）条件编译</p><p>obj-$(CONFIG_RAPIDIO) +&#x3D; rapidio.o</p><p>3）编译目录：</p><p>obj-$(CONFIG_ISCSI_TARGET)  +&#x3D; iscsi&#x2F;</p><h2 id="4-Kernel中Kconfig的语法"><a href="#4-Kernel中Kconfig的语法" class="headerlink" title="4.Kernel中Kconfig的语法"></a>4.Kernel中Kconfig的语法</h2><blockquote><p> 参考：<a href="https://mp.weixin.qq.com/s/crXt-6EvKtWg9QX7SM90Sw">https://mp.weixin.qq.com/s/crXt-6EvKtWg9QX7SM90Sw</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android S创建逻辑分区</title>
    <link href="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/"/>
    <url>/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-S创建逻辑分区"><a href="#Android-S创建逻辑分区" class="headerlink" title="Android S创建逻辑分区"></a>Android S创建逻辑分区</h1><p>从安卓模拟器看来，super设备对应的真实块设备为<code>/dev/block/vda2</code></p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230318233940020.png" alt="image-20230318233940020" style="zoom:80%;"><p>从真实模拟器运行环境来看，super总共分为了四个分区system、vendor、product、system_ext【其中<strong>system</strong>分区由于<strong>system as root</strong>机制作为了rootfs进行挂载】</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230318234134317.png" alt="image-20230318234134317" style="zoom: 80%;"><p>另外从网上找到一份真实Android S启动日志：</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230322203850415.png" alt="image-20230322203850415" style="zoom:80%;"><p>🤖从真实启动日志来看，那么<strong>为什么这个dm设备怎么来的？为什么dm-0是system_a而不是vendor_a呢？</strong></p><p>我们要带着这些问题去思考，一步步阅读源码，解决自己的疑惑……</p><h2 id="1-整体认知——LpMetadata"><a href="#1-整体认知——LpMetadata" class="headerlink" title="1.整体认知——LpMetadata"></a>1.整体认知——LpMetadata</h2><blockquote><p>这里引用<strong>洛奇看世界</strong>大哥画的精美示意图：<a href="https://blog.csdn.net/guyongqiangx/article/details/123899602">https://blog.csdn.net/guyongqiangx/article/details/123899602</a></p></blockquote><ul><li>super整体分区布局示意图如下：</li></ul><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/086bef9593e0494a90d27eef2e071bae.png" alt="image-20230318234134317" style="zoom: 80%;"><ul><li>super分区中的metadata如下：</li></ul><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/4ff675e237df41ed9c7d4809bed4d758.png" alt="image-20230318234134317" style="zoom: 67%;"><p>metadata对应的数据结构为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\liblp\include\liblp\liblp.h</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadata</span> &#123;<br>    LpMetadataGeometry geometry;<br>    LpMetadataHeader header;<br>    std::vector&lt;LpMetadataPartition&gt; partitions;<br>    std::vector&lt;LpMetadataExtent&gt; extents;<br>    std::vector&lt;LpMetadataPartitionGroup&gt; groups;<br>    std::vector&lt;LpMetadataBlockDevice&gt; block_devices;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面配合具体从super分区中抓取的数据解析。</p><p>命令：<code>dd if=/dev/block/platform/soc/7824900.sdhci/by-name/super bs=4096 count=1048576 of=/data/super.data</code></p><blockquote><p>下面引用：<a href="https://blog.csdn.net/weixin_43899302/article/details/119343835?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_43899302/article/details/119343835?spm=1001.2014.3001.5506</a></p></blockquote><h3 id="1-1-LpMetadataGeometry"><a href="#1-1-LpMetadataGeometry" class="headerlink" title="1.1 LpMetadataGeometry"></a>1.1 LpMetadataGeometry</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\liblp\include\liblp\metadata_format.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataGeometry</span> &#123;<br>    <span class="hljs-type">uint32_t</span> magic;<br>    <span class="hljs-type">uint32_t</span> struct_size;<br>    <span class="hljs-type">uint8_t</span> checksum[<span class="hljs-number">32</span>];<br>    <span class="hljs-type">uint32_t</span> metadata_max_size;<br>    <span class="hljs-type">uint32_t</span> metadata_slot_count;<br>    <span class="hljs-type">uint32_t</span> logical_block_size;<br>&#125; __attribute__((packed)) LpMetadataGeometry;<br></code></pre></td></tr></table></figure><p>因为metadata.img前面预留了4KB（4096Byte），所以偏移位置为<strong>0x1000h</strong></p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/28872ef9b62844a5b49c0caa07658ff6.png" alt="在这里插入图片描述" style="zoom:100%;"><blockquote><p>前32位（4字节）为MetadataGeometry的Magic，在代码中会进行校验魔术字LP_METADATA_GEOMETRY_MAGIC</p><p>☃️<strong>一定注意：看镜像的16进制都是小端模式</strong></p><p>依次类推，后面0x0000034表示32位的变量struct_size</p><p>所以最终这些<strong>metadata.img</strong>中的数据都会一一按位读取到结构体LpMetadataGeometry</p></blockquote><p>在创建super分区的时候，会调用<strong>ParseGeometry</strong>去进行解析<strong>LpMetadataGeometry</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\liblp\include\liblp\metadata_format.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LP_METADATA_GEOMETRY_MAGIC 0x616c4467</span><br><br><span class="hljs-comment">// system\core\fs_mgr\liblp\reader.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParseGeometry</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* buffer, LpMetadataGeometry* geometry)</span> </span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(*geometry) &lt;= LP_METADATA_GEOMETRY_SIZE);<br>    <span class="hljs-built_in">memcpy</span>(geometry, buffer, <span class="hljs-built_in">sizeof</span>(*geometry));<br><br>    <span class="hljs-keyword">if</span> (geometry-&gt;magic != LP_METADATA_GEOMETRY_MAGIC) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has invalid geometry magic signature.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (geometry-&gt;struct_size &gt; <span class="hljs-built_in">sizeof</span>(LpMetadataGeometry)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has unrecognized fields.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    &#123;<br>        LpMetadataGeometry temp = *geometry;<br>        <span class="hljs-built_in">memset</span>(&amp;temp.checksum, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(temp.checksum));<br>        <span class="hljs-built_in">SHA256</span>(&amp;temp, temp.struct_size, temp.checksum);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(temp.checksum, geometry-&gt;checksum, <span class="hljs-built_in">sizeof</span>(temp.checksum)) != <span class="hljs-number">0</span>) &#123;<br>            LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has invalid geometry checksum.&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (geometry-&gt;struct_size != <span class="hljs-built_in">sizeof</span>(LpMetadataGeometry)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has invalid struct size.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (geometry-&gt;metadata_slot_count == <span class="hljs-number">0</span>) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Logical partition metadata has invalid slot count.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (geometry-&gt;metadata_max_size % LP_SECTOR_SIZE != <span class="hljs-number">0</span>) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Metadata max size is not sector-aligned.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-LpMetadataHeader"><a href="#1-2-LpMetadataHeader" class="headerlink" title="1.2 LpMetadataHeader"></a>1.2 LpMetadataHeader</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\liblp\include\liblp\metadata_format.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataHeader</span> &#123;<br>    <span class="hljs-type">uint32_t</span> magic;<br>    <span class="hljs-type">uint16_t</span> major_version;<br>    <span class="hljs-type">uint16_t</span> minor_version;<br>    <span class="hljs-type">uint32_t</span> header_size;<br>    <span class="hljs-type">uint8_t</span> header_checksum[<span class="hljs-number">32</span>];<br>    <span class="hljs-type">uint32_t</span> tables_size;<br>    <span class="hljs-type">uint8_t</span> tables_checksum[<span class="hljs-number">32</span>];<br>    LpMetadataTableDescriptor partitions;<br>    LpMetadataTableDescriptor extents;<br>    LpMetadataTableDescriptor groups;<br>    LpMetadataTableDescriptor block_devices;<br>&#125; __attribute__((packed)) LpMetadataHeader;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataTableDescriptor</span> &#123;<br>    <span class="hljs-type">uint32_t</span> offset;<br>    <span class="hljs-type">uint32_t</span> num_entries;<br>    <span class="hljs-type">uint32_t</span> entry_size;<br>&#125; __attribute__((packed)) LpMetadataTableDescriptor;<br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/fc1dd4f8828e4e279906e52bd4417f7a.png" alt="在这里插入图片描述" style="zoom:100%;"><h3 id="1-3-LpMetadataPartition"><a href="#1-3-LpMetadataPartition" class="headerlink" title="1.3 LpMetadataPartition"></a>1.3 LpMetadataPartition</h3><p>这个就是表示super中的一个个逻辑分区所有的字段，比如说name表示逻辑分区名，attributes表示逻辑分区属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataPartition</span> &#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">36</span>];                 <span class="hljs-comment">// 分区名字</span><br>    <span class="hljs-type">uint32_t</span> attributes;   <span class="hljs-comment">// 分区表属性</span><br>    <span class="hljs-type">uint32_t</span> first_extent_index;   <span class="hljs-comment">// 在1.4节中extents的第一个元素值索引【一般一个分区只会占用一个extents数组中的元素】</span><br>    <span class="hljs-type">uint32_t</span> num_extents;          <span class="hljs-comment">// 在1.4节中extents数组中占用了几个元素【一般只会占用一个，所以num_extents一般为0x01】</span><br>    <span class="hljs-type">uint32_t</span> group_index;          <span class="hljs-comment">// 在1.5节中的分组索引</span><br>&#125; __attribute__((packed)) LpMetadataPartition;<br><br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/e3b51aa1d6f94b66a78618b135853e75.png" alt="在这里插入图片描述" style="zoom:100%;"><p>我们来看一下前面的36字节表示的逻辑分区名，可以看到这里表示的是<strong>system</strong></p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230320234029590.png" alt="image-20230320234029590" style="zoom:80%;"><h3 id="1-4-LpMetadataExtent"><a href="#1-4-LpMetadataExtent" class="headerlink" title="1.4 LpMetadataExtent"></a>1.4 LpMetadataExtent</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataExtent</span> &#123;<br>    <span class="hljs-type">uint64_t</span> num_sectors;       <span class="hljs-comment">// 当前分区占用扇区数量，一个扇区大小为512Byte</span><br>    <span class="hljs-type">uint32_t</span> target_type;       <span class="hljs-comment">// 想要映射的类型，0表示线性Linear</span><br>    <span class="hljs-type">uint64_t</span> target_data;       <span class="hljs-comment">// 相对于super实际地址的偏移地址</span><br>    <span class="hljs-type">uint32_t</span> target_source;     <span class="hljs-comment">// 在1.6节中表示哪一个source，在安卓映射逻辑分区就是super，所以target_source一般为0x0【super在blockdevice位置】</span><br>&#125; __attribute__((packed)) LpMetadataExtent;<br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/02bdee1d427e444ab4e2d8b2416591fe.png" alt="在这里插入图片描述" style="zoom:100%;"><p>通过<code>lpdump super.img.raw</code>（未压缩的super.img）可以看到以下内容，</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230427230005157.png" alt="image-20230427230005157" style="zoom:80%;"><h3 id="1-5-LpMetadataPartitionGroup"><a href="#1-5-LpMetadataPartitionGroup" class="headerlink" title="1.5 LpMetadataPartitionGroup"></a>1.5 LpMetadataPartitionGroup</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataPartitionGroup</span> &#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">36</span>];<br>    <span class="hljs-type">uint32_t</span> flags;<br>    <span class="hljs-type">uint64_t</span> maximum_size;<br>&#125; __attribute__((packed)) LpMetadataPartitionGroup;<br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/0ea2cc17e450475396458ff4843f7a78.png" alt="在这里插入图片描述" style="zoom:100%;"><h3 id="1-6-LpMetadataBlockDevice"><a href="#1-6-LpMetadataBlockDevice" class="headerlink" title="1.6 LpMetadataBlockDevice"></a>1.6 LpMetadataBlockDevice</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LpMetadataBlockDevice</span> &#123;<br>    <span class="hljs-type">uint64_t</span> first_logical_sector;<br>    <span class="hljs-type">uint32_t</span> alignment;<br>    <span class="hljs-type">uint32_t</span> alignment_offset;<br>    <span class="hljs-type">uint64_t</span> size;<br>    <span class="hljs-type">char</span> partition_name[<span class="hljs-number">36</span>];<br>    <span class="hljs-type">uint32_t</span> flags;<br>&#125; __attribute__((packed)) LpMetadataBlockDevice;<br><br></code></pre></td></tr></table></figure><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/9d54d69d1fe943458fe819d4edfa5bb8.png" alt="在这里插入图片描述" style="zoom100%;"><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230426231255747.png" alt="image-20230426231255747" style="zoom:60%;"><h2 id="2-Device-Mapper机制简介"><a href="#2-Device-Mapper机制简介" class="headerlink" title="2.Device Mapper机制简介"></a>2.Device Mapper机制简介</h2><blockquote><p>参考<strong>内核工匠</strong>的<a href="https://blog.csdn.net/feelabclihu/article/details/106581248?spm=1001.2014.3001.5506">DeviceMapper架构及在android上的应用</a></p></blockquote><p>Device Mapper是Linux2.6 内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构。</p><p>Device Mapper将所有与策略相关的工作放到用户空间完成，内核中主要提供完成这些策略所需要的机制。用户空间部分责配置具体的策略和控制逻辑，比如逻辑设备和哪些物理设备建立映射，怎么建立这些映射关系等，而具体重定向 IO 请求的工作由内核中相关代码完成。</p><p>内核中相关代码在内核源码的 kernel&#x2F;driver&#x2F;md&#x2F; 目录中，其代码文件可以划分为实现device mapper 内核中基本架构的文件(例如：dm.c dm_table.c等)和实现具体映射工作的 target driver 插件文件(例如：dm-bow.c dm-crypt.c dm-linear.c等)两部分。</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/format.png" style="zoom:80%;"><p>它包含三个重要的对象概念，Mapped Device、Mapping Table、Target device。</p><ul><li><strong>Mapped Device</strong>：是一个抽象的逻辑设备，通过MappingTable描述的映射关系（Mapped Device 逻辑的起始地址、范围、和表示在 Target Device 所在物理设备的地址偏移量以及Target 类型等信息）和Target Device建立映射关系。</li><li><strong>Target Device</strong>：是Mapped Device所映射的物理空间段。</li><li><strong>Mapping Table</strong>：DeviceMapper在内核中通过一个一个模块化的 Target Driver 插件实现对 IO 请求的过滤或者重新定向等工作，当前已经实现的插件包括：dm-crypt、dm-linear、dm-verity、dm-bow、dm-raid等。</li></ul><p>Device mapper 中这三个对象和 target driver 插件一起构成了一个可迭代的设备树。该层次在理论上可以在 device mapper 架构下无限迭代下去。</p><h3 id="2-1-核心数据结构"><a href="#2-1-核心数据结构" class="headerlink" title="2.1 核心数据结构"></a>2.1 核心数据结构</h3><ul><li><strong>mapped_device</strong> ：在dm.c 文件中定义，该结构用于表示 mapped device，它主要包括该 mapped device 相关的锁，注册的请求队列和一些内存池以及指向它所对应映射表的指针等域。</li><li><strong>dm_table</strong>：在文件dm_table.c 文件中定义，该结构中包含一个 dm_target结构数组，dm_target 结构具体描述了 mapped_device 到它某个 target device 的映射关系。而在 dm_table 结构中将这些 dm_target 按照 B 树的方式组织起来方便 IO 请求映射时的查找操作。dm_target 结构具体记录该结构对应 target device 所映射的 mapped device 逻辑区域的开始地址和范围，同时还包含指向具体 target device 相关操作的 target_type 结构的指针。</li><li><strong>target_type</strong>：该结构主要包含了 target device 对应的 target driver 插件的名字、定义的构建和删除该类型target device的方法、该类target device对应的IO请求重映射和结束IO的方法等。而表示具体的target device的域是dm_target中的private域，该指针指向mapped device所映射的具体target device对应的结构。表示target device的具体结构由于不同的target 类型而不同。</li></ul><p>开发者可以定制device target部分，以实现自己所需要的需求功能。</p><h3 id="2-2-三步建立dm设备的过程"><a href="#2-2-三步建立dm设备的过程" class="headerlink" title="2.2 三步建立dm设备的过程"></a>2.2 <strong>三步建立dm设备的过程</strong></h3><p>通过下述的三个主要步骤，device mapper在内核中就建立一个可以提供给用户使用的mapped device逻辑块设备。</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/device-mapper.png"><h2 id="3-挂载阶段创建逻辑分区"><a href="#3-挂载阶段创建逻辑分区" class="headerlink" title="3.挂载阶段创建逻辑分区"></a>3.挂载阶段创建逻辑分区</h2><h3 id="3-1-开始挂载"><a href="#3-1-开始挂载" class="headerlink" title="3.1 开始挂载"></a>3.1 开始挂载</h3><p>🐼 关于第一阶段挂载的流程可以参考我之前写的<a href="https://blog.csdn.net/stephen_curry300/article/details/126110983?spm=1001.2014.3001.5501">CSDN博客</a></p><p>挂载的入口如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 路径: /system/core/init/first_stage_mount.cpp</span><br><span class="hljs-comment">// 在设备树中挂载由fstab文件指定的分区</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DoFirstStageMount</span><span class="hljs-params">(<span class="hljs-type">bool</span> create_devices)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> fsm = FirstStageMount::<span class="hljs-built_in">Create</span>();<br>    <span class="hljs-keyword">return</span> (*fsm)-&gt;<span class="hljs-built_in">DoFirstStageMount</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FirstStageMount::DoFirstStageMount</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">MountPartitions</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终与创建逻辑分区的代码走到 <strong>FirstStageMount::CreateLogicalPartitions</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\first_stage_mount.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FirstStageMount::CreateLogicalPartitions</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 遍历读取到的fstab中flag中是否含有logical</span><br>    <span class="hljs-comment">// 如果有，则支持DmLinear</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsDmLinearEnabled</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 对应3.2 读取元数据</span><br>    <span class="hljs-keyword">auto</span> metadata = android::fs_mgr::<span class="hljs-built_in">ReadCurrentMetadata</span>(super_path_);<br><br>    <span class="hljs-comment">// 对应3.3 创建逻辑分区</span><br>    <span class="hljs-keyword">return</span> android::fs_mgr::<span class="hljs-built_in">CreateLogicalPartitions</span>(*metadata.<span class="hljs-built_in">get</span>(), super_path_);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-读取元数据"><a href="#3-2-读取元数据" class="headerlink" title="3.2 读取元数据"></a>3.2 读取元数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\fs_mgr_dm_linear.cpp</span><br><span class="hljs-comment">// 传进来的block_device是super分区对应的真实的块设备（假设为/dev/block/vda2）</span><br><span class="hljs-function">std::unique_ptr&lt;LpMetadata&gt; <span class="hljs-title">ReadCurrentMetadata</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; block_device)</span> </span>&#123;<br>    <span class="hljs-comment">// fs_mgr_get_slot_suffix获取环境变量ro.boot.slot_suffix</span><br>    <span class="hljs-comment">// 如果当前启动分区为_a，则slot=0</span><br>    <span class="hljs-comment">// 如果当前启动分区为_b，则slot=1</span><br>    <span class="hljs-type">uint32_t</span> slot = <span class="hljs-built_in">SlotNumberForSlotSuffix</span>(<span class="hljs-built_in">fs_mgr_get_slot_suffix</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReadMetadata</span>(block_device.<span class="hljs-built_in">c_str</span>(), slot);<br>&#125;<br><br><span class="hljs-comment">// 传进来的super_partition是/dev/block/vda2</span><br><span class="hljs-comment">// 假设启动分区为_a，slot_number为0</span><br><span class="hljs-function">std::unique_ptr&lt;LpMetadata&gt; <span class="hljs-title">ReadMetadata</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; super_partition, <span class="hljs-type">uint32_t</span> slot_number)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReadMetadata</span>(<span class="hljs-built_in">PartitionOpener</span>(), super_partition, slot_number);<br>&#125;<br><br><span class="hljs-comment">// --------------------------------------------------------------</span><br><br><span class="hljs-comment">// system\core\fs_mgr\liblp\reader.cpp</span><br><span class="hljs-function">std::unique_ptr&lt;LpMetadata&gt; <span class="hljs-title">ReadMetadata</span><span class="hljs-params">(<span class="hljs-type">const</span> IPartitionOpener&amp; opener,</span></span><br><span class="hljs-params"><span class="hljs-function">                                         <span class="hljs-type">const</span> std::string&amp; super_partition, <span class="hljs-type">uint32_t</span> slot_number)</span> </span>&#123;<br>    android::base::unique_fd fd = opener.<span class="hljs-built_in">Open</span>(super_partition, O_RDONLY);<br><br>    LpMetadataGeometry geometry;<br>    <span class="hljs-comment">// 读取/dev/block/vda2中的元数据</span><br>    <span class="hljs-comment">// 读的是1.1节中的LpMetadataGeometry数据结构，将其保存到geometry</span><br>    <span class="hljs-comment">// 目的是直接赋值给下面即将创建的变量meta的成员变量geometry</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ReadLogicalPartitionGeometry</span>(fd, &amp;geometry)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    std::unique_ptr&lt;LpMetadata&gt; metadata;<br><br>    <span class="hljs-comment">// 读取/dev/block/mmcblk0p5中的所有的元数据</span><br>    <span class="hljs-comment">// 将其保存到metadata变量中，最后返回3.1中最初调用ReadCurrentMetadata的地方</span><br>    <span class="hljs-comment">// 所有的metadata结构都是按照1.整体认知——LpMetadata分布的</span><br>    metadata = <span class="hljs-built_in">ParseMetadata</span>(geometry, fd)<br>    <br>    <span class="hljs-keyword">return</span> metadata;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-创建逻辑分区"><a href="#3-3-创建逻辑分区" class="headerlink" title="3.3 创建逻辑分区"></a>3.3 创建逻辑分区</h3><p><strong>3.2节和3.3节是独立的，两节都是3.1的子篇，不要线性阅读</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateLogicalPartitions</span><span class="hljs-params">(<span class="hljs-type">const</span> LpMetadata&amp; metadata, <span class="hljs-type">const</span> std::string&amp; super_device)</span> </span>&#123;<br>    CreateLogicalPartitionParams params = &#123;<br>            .block_device = super_device,<br>            .metadata = &amp;metadata,<br>    &#125;;<br>    <span class="hljs-comment">// 这里的metadata.partitions是1.3节的LpMetadataPartition</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; partition : metadata.partitions) &#123;<br>        params.partition = &amp;partition;<br><br>        std::string ignore_path;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateLogicalPartition</span>(params, &amp;ignore_path)) &#123;<br>            LERROR &lt;&lt; <span class="hljs-string">&quot;Could not create logical partition: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetPartitionName</span>(partition);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会遍历metadata中存储的partitions成员变量，也就是metadata.img中存放的一个个逻辑分区信息，例如如果我们第一个存储的LpMetadataPartition是system的信息，那么首先调用CreateLogicalPartition去创建逻辑分区，第二个存储的LpMetadataPartition是vendor的信息，相应的调用CreateLogicalPartition去创建逻辑分。</p><p>🎈<strong>到这里解释了开头我们提到的为什么dm-1、dm-2创建的先后顺序，其与metadata.img中的分区顺序有关，换句话说，就是与生成super.img时指明的顺序有关。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateLogicalPartition</span><span class="hljs-params">(CreateLogicalPartitionParams params, std::string* path)</span> </span>&#123;<br>    CreateLogicalPartitionParams::OwnedData owned_data;<br>    <span class="hljs-comment">// 3.3.1：主要初始化params中的partition_name和device_name</span><br>    <span class="hljs-keyword">if</span> (!params.<span class="hljs-built_in">InitDefaults</span>(&amp;owned_data)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    DmTable table;<br>    <span class="hljs-comment">// 3.3.2：主要创建dmtable</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateDmTableInternal</span>(params, &amp;table)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    DeviceMapper&amp; dm = DeviceMapper::<span class="hljs-built_in">Instance</span>();<br>    <span class="hljs-comment">// 3.3.2：完成第2.2中所说的三步走</span><br>    <span class="hljs-keyword">if</span> (!dm.<span class="hljs-built_in">CreateDevice</span>(params.device_name, table, path, params.timeout_ms)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 文章开头的启动日志打印就是在这里</span><br>    LINFO &lt;&lt; <span class="hljs-string">&quot;Created logical partition &quot;</span> &lt;&lt; params.device_name &lt;&lt; <span class="hljs-string">&quot; on device &quot;</span> &lt;&lt; *path;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-1-InitDefaults初始化CreateLogicalPartitionParams"><a href="#3-3-1-InitDefaults初始化CreateLogicalPartitionParams" class="headerlink" title="3.3.1 InitDefaults初始化CreateLogicalPartitionParams"></a>3.3.1 InitDefaults初始化CreateLogicalPartitionParams</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateLogicalPartitionParams::InitDefaults</span><span class="hljs-params">(CreateLogicalPartitionParams::OwnedData* owned)</span> </span>&#123;<br>    <span class="hljs-comment">// 3.3节开头的CreateLogicalPartitionParams params的参数中还没有初始化partition_name</span><br>    <span class="hljs-keyword">if</span> (partition_name.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// partition_name为system_a</span><br>        partition_name = android::fs_mgr::<span class="hljs-built_in">GetPartitionName</span>(*partition);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (partition_name != android::fs_mgr::<span class="hljs-built_in">GetPartitionName</span>(*partition)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Inconsistent partition_name &quot;</span> &lt;&lt; partition_name &lt;&lt; <span class="hljs-string">&quot; with partition &quot;</span><br>               &lt;&lt; android::fs_mgr::<span class="hljs-built_in">GetPartitionName</span>(*partition);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (device_name.<span class="hljs-built_in">empty</span>()) &#123;<br>        device_name = partition_name;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// --------------------------------------------------------------</span><br><br><span class="hljs-comment">// system\core\fs_mgr\liblp\reader.cpp</span><br><span class="hljs-function">std::string <span class="hljs-title">GetPartitionName</span><span class="hljs-params">(<span class="hljs-type">const</span> LpMetadataPartition&amp; partition)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">NameFromFixedArray</span>(partition.name, <span class="hljs-built_in">sizeof</span>(partition.name));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">NameFromFixedArray</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">size_t</span> buffer_size)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (name[buffer_size - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(name);<br>    &#125;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(name, buffer_size);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-CreateDmTableInternal创建dm-linear设备table"><a href="#3-3-2-CreateDmTableInternal创建dm-linear设备table" class="headerlink" title="3.3.2 CreateDmTableInternal创建dm-linear设备table"></a>3.3.2 CreateDmTableInternal创建dm-linear设备table</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CreateDmTableInternal</span><span class="hljs-params">(<span class="hljs-type">const</span> CreateLogicalPartitionParams&amp; params, DmTable* table)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; super_device = params.block_device;<br><br>    <span class="hljs-type">uint64_t</span> sector = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; params.partition-&gt;num_extents; i++) &#123;<br>        <span class="hljs-comment">// 找到各个分区自己的extents内容，也就是1.4节</span><br>        <span class="hljs-comment">// 在partition中的first_extent_index字段会指明当前分区在extents哪个位置</span><br>        <span class="hljs-comment">// 99%的情况只会占用一个位置，所以 params.partition-&gt;num_extents一般都是1</span><br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; extent = params.metadata-&gt;extents[params.partition-&gt;first_extent_index + i];<br>        std::unique_ptr&lt;DmTarget&gt; target;<br>        <span class="hljs-comment">// 从1.4展示的type来看是数字0，正好对应了这里的LP_TARGET_TYPE_LINEAR，线性排布的DM设备</span><br>        <span class="hljs-keyword">switch</span> (extent.target_type) &#123;<br>            <span class="hljs-keyword">case</span> LP_TARGET_TYPE_ZERO:<br><span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">case</span> LP_TARGET_TYPE_LINEAR: &#123;<br>                <span class="hljs-comment">// 从1.4展示的target_source是0，也就是system_a对应的target_source是0，也就是指向了1.6节中super所在的位置【super的索引为0】</span><br>                <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; block_device = params.metadata-&gt;block_devices[extent.target_source];<br>                std::string dev_string;<br>                <span class="hljs-comment">// 获取super真实的物理地址，所以dev_string为/dev/block/vda2</span><br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetPhysicalPartitionDevicePath</span>(params, block_device, super_device,<br>                                                    &amp;dev_string)) &#123;<br>                    <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Unable to complete device-mapper table, unknown block device&quot;</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-comment">// 创建一个DmTargetLinear类型的指针，由target独占管理</span><br>                target = std::<span class="hljs-built_in">make_unique</span>&lt;DmTargetLinear&gt;(sector, extent.num_sectors, dev_string,<br>                                                          extent.target_data);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Unknown target type in metadata: &quot;</span> &lt;&lt; extent.target_type;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将target添加到table里面去，DmTable维护了一个列表_target</span><br>        <span class="hljs-comment">// DmTable::AddTarget也就是把target添加push到_target中</span><br>        <span class="hljs-keyword">if</span> (!table-&gt;<span class="hljs-built_in">AddTarget</span>(std::<span class="hljs-built_in">move</span>(target))) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        sector += extent.num_sectors;<br>    &#125;<br>    <span class="hljs-comment">// 如果1.3节中Attribute含有READ_ONLY属性，TABLE设置成只读的</span><br>    <span class="hljs-keyword">if</span> (params.partition-&gt;attributes &amp; LP_PARTITION_ATTR_READONLY) &#123;<br>        table-&gt;<span class="hljs-built_in">set_readonly</span>(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-comment">// 如果params设置了强制可写，TABLE设置成可读可写</span><br>    <span class="hljs-keyword">if</span> (params.force_writable) &#123;<br>        table-&gt;<span class="hljs-built_in">set_readonly</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-2-1-数据结构梳理"><a href="#3-3-2-1-数据结构梳理" class="headerlink" title="3.3.2.1 数据结构梳理"></a>3.3.2.1 数据结构梳理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DmTarget</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DmTarget</span>(<span class="hljs-type">uint64_t</span> start, <span class="hljs-type">uint64_t</span> length) : <span class="hljs-built_in">start_</span>(start), <span class="hljs-built_in">length_</span>(length) &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DmTargetLinear</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> DmTarget &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DmTargetLinear</span>(<span class="hljs-type">uint64_t</span> start, <span class="hljs-type">uint64_t</span> length, <span class="hljs-type">const</span> std::string&amp; block_device,<br>                   <span class="hljs-type">uint64_t</span> physical_sector)<br>        : <span class="hljs-built_in">DmTarget</span>(start, length), <span class="hljs-built_in">block_device_</span>(block_device), <span class="hljs-built_in">physical_sector_</span>(physical_sector) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-3-CreateDevice"><a href="#3-3-3-CreateDevice" class="headerlink" title="3.3.3 CreateDevice"></a>3.3.3 CreateDevice</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\libdm\dm.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeviceMapper::CreateDevice</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> DmTable&amp; table, std::string* path,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">const</span> std::chrono::milliseconds&amp; timeout_ms)</span> </span>&#123;<br>    <span class="hljs-comment">// 通过/dev/urandom生成随机UUID</span><br>    std::string uuid = <span class="hljs-built_in">GenerateUuid</span>();<br>    <span class="hljs-comment">// 3.3.3.1 调用ioctl创建设备</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateDevice</span>(name, uuid)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    std::string unique_path;<br>    <span class="hljs-comment">// 3.3.3.2 LoadTableAndActivate创建DM设备三步法</span><br>    <span class="hljs-comment">// 3.3.3.3 GetDeviceUniquePath获取获取dm设备的uuid，看dm设备是否创建成功了</span><br>    <span class="hljs-comment">// 3.3.3.4 GetDmDevicePathByName获取dm设备，看dm设备是否创建成功</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">LoadTableAndActivate</span>(name, table) || !<span class="hljs-built_in">GetDeviceUniquePath</span>(name, &amp;unique_path) ||<br>        !<span class="hljs-built_in">GetDmDevicePathByName</span>(name, path)) &#123;<br>        <span class="hljs-comment">// 如果设备没有创建成功，DeleteDevice会调用ioctl[DM_DEV_REMOVE]删除创建的dm设备</span><br>        <span class="hljs-built_in">DeleteDevice</span>(name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-3-1-CreateDevice调用ioctl创建设备"><a href="#3-3-3-1-CreateDevice调用ioctl创建设备" class="headerlink" title="3.3.3.1 CreateDevice调用ioctl创建设备"></a>3.3.3.1 CreateDevice调用ioctl创建设备</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">DeviceMapper::CreateDevice</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name, <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; uuid)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dm_ioctl</span> <span class="hljs-title">io</span>;</span><br>    InitIo(&amp;io, name);<br>    <span class="hljs-comment">// 上面生成了随机的UUID，所以这里肯定不为空</span><br>    <span class="hljs-keyword">if</span> (!uuid.empty()) &#123;<br>        <span class="hljs-built_in">snprintf</span>(io.uuid, <span class="hljs-keyword">sizeof</span>(io.uuid), <span class="hljs-string">&quot;%s&quot;</span>, uuid.c_str());<br>    &#125;<br><br>    <span class="hljs-comment">// 向DeviceMapper驱动发送DM_DEV_CRETE创建设备</span><br>    <span class="hljs-keyword">if</span> (ioctl(fd_, DM_DEV_CREATE, &amp;io)) &#123;<br>        PLOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;DM_DEV_CREATE failed for [&quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-3-2-LoadTableAndActivate传table数据下去"><a href="#3-3-3-2-LoadTableAndActivate传table数据下去" class="headerlink" title="3.3.3.2 LoadTableAndActivate传table数据下去"></a>3.3.3.2 LoadTableAndActivate传table数据下去</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这边传进来的table是3.3.2创建的dm-linear设备table</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">DeviceMapper::LoadTableAndActivate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name, <span class="hljs-type">const</span> DmTable&amp; table)</span> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">ioctl_buffer</span><span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> dm_ioctl), <span class="hljs-number">0</span>)</span>;<br>    ioctl_buffer += table.Serialize();<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dm_ioctl</span>* <span class="hljs-title">io</span> =</span> reinterpret_cast&lt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dm_ioctl</span>*&gt;</span>(&amp;ioctl_buffer[<span class="hljs-number">0</span>]);<br>    InitIo(io, name);<br>    io-&gt;data_size = ioctl_buffer.size();<br>    io-&gt;data_start = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> dm_ioctl);<br>    io-&gt;target_count = static_cast&lt;<span class="hljs-type">uint32_t</span>&gt;(table.num_targets());<br>    <span class="hljs-keyword">if</span> (table.readonly()) &#123;<br>        io-&gt;flags |= DM_READONLY_FLAG;<br>    &#125;<br>    <span class="hljs-comment">// 向DeviceMapper驱动发送DM_TABLE_LOAD下发MappingTable</span><br>    <span class="hljs-keyword">if</span> (ioctl(fd_, DM_TABLE_LOAD, io)) &#123;<br>        PLOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;DM_TABLE_LOAD failed&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    InitIo(io, name);<br>    <span class="hljs-comment">// 向DeviceMapper驱动发送DM_DEV_SUSPEND使能MappedDevice</span><br>    <span class="hljs-keyword">if</span> (ioctl(fd_, DM_DEV_SUSPEND, io)) &#123;<br>        PLOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;DM_TABLE_SUSPEND resume failed&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-3-3-GetDeviceUniquePath获取获取dm设备的uuid，看dm设备是否创建成功了"><a href="#3-3-3-3-GetDeviceUniquePath获取获取dm设备的uuid，看dm设备是否创建成功了" class="headerlink" title="3.3.3.3 GetDeviceUniquePath获取获取dm设备的uuid，看dm设备是否创建成功了"></a>3.3.3.3 GetDeviceUniquePath获取获取dm设备的uuid，看dm设备是否创建成功了</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">DeviceMapper::GetDeviceUniquePath</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* path)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dm_ioctl</span> <span class="hljs-title">io</span>;</span><br>    InitIo(&amp;io, name);<br>    <span class="hljs-comment">// 向DeviceMapper驱动发送DM_DEV_STATUS查询MappedDevice(system_a)的状态</span><br>    <span class="hljs-keyword">if</span> (ioctl(fd_, DM_DEV_STATUS, &amp;io) &lt; <span class="hljs-number">0</span>) &#123;<br>        PLOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to get device path: &quot;</span> &lt;&lt; name;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果内核没有对参数uuid进行赋值，说明没有创建成功</span><br>    <span class="hljs-keyword">if</span> (io.uuid[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;Device does not have a unique path: &quot;</span> &lt;&lt; name;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *path = <span class="hljs-string">&quot;/dev/block/mapper/by-uuid/&quot;</span>s + io.uuid;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-3-4-GetDmDevicePathByName获取dm设备，看dm设备是否创建成功"><a href="#3-3-3-4-GetDmDevicePathByName获取dm设备，看dm设备是否创建成功" class="headerlink" title="3.3.3.4 GetDmDevicePathByName获取dm设备，看dm设备是否创建成功"></a>3.3.3.4 GetDmDevicePathByName获取dm设备，看dm设备是否创建成功</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">DeviceMapper::GetDmDevicePathByName</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* path)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dm_ioctl</span> <span class="hljs-title">io</span>;</span><br>    InitIo(&amp;io, name);<br>    <span class="hljs-comment">// 向DeviceMapper驱动发送DM_DEV_STATUS查询MappedDevice(system_a)的状态</span><br>    <span class="hljs-keyword">if</span> (ioctl(fd_, DM_DEV_STATUS, &amp;io) &lt; <span class="hljs-number">0</span>) &#123;<br>        PLOG(WARNING) &lt;&lt; <span class="hljs-string">&quot;DM_DEV_STATUS failed for &quot;</span> &lt;&lt; name;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-comment">// 上面调用ioctl后会对io.dev进行赋值</span><br>    <span class="hljs-comment">// minor(io.dev)拿到mapped deivec对应的设备</span><br>    <span class="hljs-comment">// 例如system_a的dev_num为0</span><br>    <span class="hljs-type">uint32_t</span> dev_num = minor(io.dev);<br>    *path = <span class="hljs-string">&quot;/dev/block/dm-&quot;</span> + <span class="hljs-built_in">std</span>::to_string(dev_num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>最后画了一张图，完美闭关</p><img src="/2023/03/18/Android-S%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA/image-20230427231954102.png" alt="image-20230427231954102" style="zoom:1000%;"><h2 id="5-感谢"><a href="#5-感谢" class="headerlink" title="5.感谢"></a>5.感谢</h2><p>感谢 <a href="https://www.cnblogs.com/pyjetson/p/14872499.html%EF%BC%8C%E4%BB%8E%E5%AE%83%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%87%8C%E9%9D%A2%E5%AD%A6%E5%88%B0%E4%BA%86%E5%BE%88%E5%A4%9A%F0%9F%8E%97%EF%B8%8F">https://www.cnblogs.com/pyjetson/p/14872499.html，从它的博客里面学到了很多🎗️</a></p>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>展讯Android P System_as_root规范说明</title>
    <link href="/2023/03/16/%E5%B1%95%E8%AE%AFAndroid-P-System-as-root%E8%A7%84%E8%8C%83%E8%AF%B4%E6%98%8E/"/>
    <url>/2023/03/16/%E5%B1%95%E8%AE%AFAndroid-P-System-as-root%E8%A7%84%E8%8C%83%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="展讯Android-P-System-as-root规范说明"><a href="#展讯Android-P-System-as-root规范说明" class="headerlink" title="展讯Android P System_as_root规范说明"></a>展讯Android P System_as_root规范说明</h1><blockquote><p>作为个人学习笔记使用，<a href="https://bbs.16rd.com/thread-584995-1-1.html">https://bbs.16rd.com/thread-584995-1-1.html</a></p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Android 从 8.0 开始引入了 Treble 架构，目的是让 Android 设备制造商能够更快，更容易，更低成本的去升级 Android 版本。为实现这一目的，Google 设定了很多规则，设备商只有实现了这些规 则，才能满足 Treble 架构的要求。本文介绍的 system as root 就是 Google 在 AndroidP 上提出的一 项改动规则。</p><p>所谓 system as root，指的是 system 分区被挂载为 rootfs，android 可以通过 OTA 直接升级 rootfs，避免出现 system 升级之后，存储在 ramdisk（rootfs）中的 init&#x2F;init.rc 与新的 android 版本不匹配导致系统出问题。 在 A&#x2F;B 系统的 device 上，ramdisk 已经打包到 system.img 了，所以无需做什么适配。搭载Android 9.x 的所有新设备都必须使用 system-as-root（BOARD_BUILD_SYSTEM_ROOT_IMAGE必须为 true），它可以将 ramdisk.img 合并到 system.img，而后者会反过来再作为 rootfs 进行装载。对于要升级到 Android 9 的设备，使用 system-as-root 并非强制要求。</p><p>System as root 的改动部分可如下图所示：</p><img src="/2023/03/16/%E5%B1%95%E8%AE%AFAndroid-P-System-as-root%E8%A7%84%E8%8C%83%E8%AF%B4%E6%98%8E/173632rimzt33h8mi4ntif.jpg" alt="173632rimzt33h8mi4ntif" style="zoom:80%;"><h2 id="2-System-as-root-规范"><a href="#2-System-as-root-规范" class="headerlink" title="2.System as root 规范"></a>2.System as root 规范</h2><p>System as root 的核心在于 ramdisk 会被打包到 system.img，基于这种状况，设备厂商自行添加到 ramdisk 中的改动，必须转移到其它位置，否则 system.img 一更换（例如 GSI 版本），ramdisk中添加的内容就丢失了，导致系统启动可能出现问题。根据 Google 发布的 system as root 文档的要求，总结了下面这些需要调整的部分：</p><table><thead><tr><th>ID</th><th>修改内容</th><th>规范</th></tr></thead><tbody><tr><td>1</td><td>rc文件的调整</td><td>原来放置在device&#x2F;{board}&#x2F;路径中的rc文件，需要编译 到vendor&#x2F;etc&#x2F;init;另一方面如果修改了 &#x2F;system&#x2F;core&#x2F;rootdir&#x2F;T init.*.rc ,最好将修改移动到设备厂 商自行添加的rc文件中；rc文件中import的路径需要修改， 避免import路径错误导致rc文件没有被解析。</td></tr><tr><td>2</td><td>内核模块移岀ramdisk</td><td>内核模块驱动已经移到vendor分区。</td></tr><tr><td>3</td><td>fstab文件路径调整</td><td>fstab文件需要从ramdisk移动到vendor&#x2F;etc</td></tr><tr><td>4</td><td>ramdisk打包调整</td><td>ramdisk.img 需要打包到 system.img 中</td></tr><tr><td>5</td><td>dm-verify实现方案调整</td><td>AndroidP ± dm-verify必须开启,UNISOC版本已默认 开启 dm-verify</td></tr></tbody></table><h3 id="2-1-rc文件的调整"><a href="#2-1-rc文件的调整" class="headerlink" title="2.1 rc文件的调整"></a>2.1 rc文件的调整</h3><p>在 device&#x2F;{board}仓库中存在很多设备相关的 rc 文件，在 AndroidP 之前，这些 rc 文件是被编译到 ramdisk 的根路径的，但是按照 system as root 的要求，这些文件必须调整到其它路径，且文件 中 import rc 等语句所对应的路径需要做调整。具体改动如下：</p><ul><li>device&#x2F;{board} 路径的 rc 文件 copy 到 vendor 分区，例如： device&#x2F;{board}&#x2F;common&#x2F;DeviceCommon.mk</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">product_COPY_FILES += \<br><span class="hljs-variable">$(LOCAL_PATH)</span>/rootdir/root/init.common.rc:<span class="hljs-variable">$(TARGET_COPY_OUT_VENDOR)</span>/etc/init/hw/init.common .rc \<br><span class="hljs-variable">$(LOCAL_PATH)</span>/rootdir/root/init.ram.rc:<span class="hljs-variable">$(TARGET_COPY_OUT_VENDOR)</span>/etc/init/hw/init.ram.rc \<br></code></pre></td></tr></table></figure><ul><li>device&#x2F;{board} 路径的 rc 文件 import 路径需要做相应调整：例如 device&#x2F;{board}&#x2F;common&#x2F;rootdir&#x2F;root&#x2F;init.common.rc 文件原本 import 的都是根路径的 rc 文件，现在需要根据实际归档路径来调整。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">import /vendor/etc/init/hw/init.$&#123;ro.hardware&#125;.usb.rc<br>import /vendor/etc/init/hw/init.ram.rc<br>import /vendor/etc/init/hw/init.storage.rc<br></code></pre></td></tr></table></figure><h3 id="2-2-内核模块移出ramdisk"><a href="#2-2-内核模块移出ramdisk" class="headerlink" title="2.2  内核模块移出ramdisk"></a>2.2  内核模块移出ramdisk</h3><p>在 UNISOC 平台，部分 kernel modules 放到 ramdisk 的 lib 路径下，在开启了 <strong>system as root</strong>之后，遵循 Google 的建议，需要统一调整到&#x2F;vendor&#x2F;lib&#x2F;modules 中：</p><ul><li>在模块的 Android.mk(bp)中，将模块 bin 文件归档路径设定为&#x2F;vendor&#x2F;lib&#x2F;modules：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs make\">vendor/sprd/modules/wcn/fm/driver/Android.mk<br>1. LOCAL_MODULE := sprd_fm.ko<br>2. LOCAL_MODULE_CLASS := SHARED_LIBRARIES<br>3. LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/etc/modules<br></code></pre></td></tr></table></figure><h3 id="2-3-fstab-文件路径调整"><a href="#2-3-fstab-文件路径调整" class="headerlink" title="2.3 fstab 文件路径调整"></a>2.3 fstab 文件路径调整</h3><p>fstab 是用于定义文件系统 mount 信息的，这个文件与设备的存储强相关，所以也需要从 ramdisk移出，将 fstab 放在 vendor&#x2F;etc&#x2F;路径下。需要注意的是，recovery 模式所用的 ramdisk 与正常开机的不是一个， 所以 recovery 模式所用的 fstab 文件，路径不用修改。</p>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>User Data Checkpoint机制</title>
    <link href="/2023/03/15/User-Data-Checkpoint%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/03/15/User-Data-Checkpoint%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="User-Data-Checkpoint机制-UDC"><a href="#User-Data-Checkpoint机制-UDC" class="headerlink" title="User Data Checkpoint机制(UDC)"></a>User Data Checkpoint机制(UDC)</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>由于AB升级的回滚机制只支持到early_boot阶段，如果OTA升级的过程中，data分区被修改了，并且OTA升级失败了，则data分区是无法回滚到之前的状态的。UDC功能是为了解决OTA升级失败后，当data分区被修改后，不支持回滚data分区的问题。UDC同时支持绑定key版本以及防止key回滚的功能。</p><h2 id="2-实现UDC"><a href="#2-实现UDC" class="headerlink" title="2.实现UDC"></a>2.实现UDC</h2><blockquote><p>一定要参考安卓官网：<a href="https://source.android.com/docs/core/ota/user-data-checkpoint?hl=zh-cn">https://source.android.com/docs/core/ota/user-data-checkpoint?hl=zh-cn</a></p></blockquote><h3 id="2-1-设置"><a href="#2-1-设置" class="headerlink" title="2.1 设置"></a>2.1 设置</h3><p>在 <code>init.hardware.rc</code> 文件的 <code>on fs</code> 中，确保您具有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount_all /vendor/etc/fstab.$&#123;ro.boot.hardware.platform&#125; --early<br></code></pre></td></tr></table></figure><p>在 <code>init.hardware.rc</code> 文件的 <code>on late-fs</code> 中，确保您具有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount_all /vendor/etc/fstab.$&#123;ro.boot.hardware.platform&#125; --late<br></code></pre></td></tr></table></figure><p>在 <code>fstab.hardware</code> 文件中，确保将 <code>/data</code> 标记为 <code>latemount</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/dev/block/bootdevice/by-name/userdata              /data              f2fs<br>noatime,nosuid,nodev,discard,reserve_root=32768,resgid=1065,fsync_mode=nobarrier<br>latemount,wait,check,fileencryption=ice,keydirectory=/metadata/vold/metadata_encryption,quota,formattable,sysfs_path=/sys/devices/platform/soc/1d84000.ufshc,reservedsize=128M,checkpoint=fs<br></code></pre></td></tr></table></figure><h3 id="2-2-添加metadata分区"><a href="#2-2-添加metadata分区" class="headerlink" title="2.2 添加metadata分区"></a>2.2 添加metadata分区</h3><p>UDC 需要使用 metadata 分区来存储非引导加载程序重试计数和密钥。设置 metadata 分区并提前将其装载在 <code>/metadata</code> 中。</p><p>在 <code>fstab.hardware</code> 文件中，确保将 <code>/metadata</code> 标记为 <code>earlymount</code> 或 <code>first_stage_mount</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/dev/block/by-name/metadata           /metadata           ext4<br>noatime,nosuid,nodev,discard,sync<br>wait,formattable,first_stage_mount<br></code></pre></td></tr></table></figure><p>将分区初始化为全零。</p><p>将以下行添加到 <code>BoardConfig.mk</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">BOARD_USES_METADATA_PARTITION := true<br>BOARD_ROOT_EXTRA_FOLDERS := existing_folders metadata<br></code></pre></td></tr></table></figure><h3 id="2-3-更新系统"><a href="#2-3-更新系统" class="headerlink" title="2.3 更新系统"></a>2.3 更新系统</h3><p><strong>F2FS 系统</strong></p><ul><li><p>对于使用 F2FS 来格式化数据的系统，请确保您的 F2FS 版本支持检查点。</p></li><li><p>对于在 <code>/data</code> 装载的设备，请将 <code>checkpoint=fs</code> 标志添加到 fstab 的 <code>&lt;fs_mgr_flags&gt;</code> 部分。</p></li></ul><p><strong>非 F2FS 系统</strong></p><ul><li>对于非 F2FS 系统，必须在内核配置中启用 <code>dm-bow</code>。</li><li>对于在 <code>/data</code> 装载的设备，请将 <code>checkpoint=block</code> 标志添加到 fstab 的 <code>&lt;fs_mgr_flags&gt;</code> 部分。</li></ul><h2 id="3-f2fs挂载流程"><a href="#3-f2fs挂载流程" class="headerlink" title="3.f2fs挂载流程"></a>3.f2fs挂载流程</h2><p>既然上面提到了f2fs天然支持checkpoint，那我们分析一下它的挂载流程</p><h3 id="3-1开始挂载所有"><a href="#3-1开始挂载所有" class="headerlink" title="3.1开始挂载所有"></a>3.1开始挂载所有</h3><p>在rc中会调用mount_all来挂载所有fstab中的entry</p><p>在<code>device/softwinner/ceres-common/init.sun50iw10p1.rc</code>文件的on fs中有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount_all /vendor/etc/fstab.sun50iw10p1 --early<br></code></pre></td></tr></table></figure><p>在<code>device/softwinner/ceres-b3/fstab.sun50iw10p1.rc</code>文件的<code>data</code>分区中添加<code>latemount</code>和<code>checkpoint=fs</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/dev/block/by-name/UDISK      /data        f2fs     noatime,nosuid,nodev,discard wait,check,formattable,quota,reservedsize=33554432,fileencryption=aes-256-xts:aes-256-cts,latemount,checkpoint=fs<br></code></pre></td></tr></table></figure><p>此时会去解析mount_all对应的动作，然后将<code>/vendor/etc/fstab.sun50iw10p1</code>作为arg[0]，<code>--early</code>作为arg[1]传给mount_all对应的处理函数<code>do_mount_all</code></p><img src="/2023/03/15/User-Data-Checkpoint%E6%9C%BA%E5%88%B6/image-20230315202320251.png" alt="image-20230315202320251"><p>在<code>do_mount_all</code>中会调用fs_mgr_mount_all挂载所有<code>/vendor/etc/fstab.sun50iw10p1</code>中的项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\init\builtins.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> Result&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">do_mount_all</span><span class="hljs-params">(<span class="hljs-type">const</span> BuiltinArguments&amp; args)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    Fstab fstab;<br>    <span class="hljs-keyword">if</span> (mount_all-&gt;fstab_path.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ReadDefaultFstab</span>(&amp;fstab)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Error</span>() &lt;&lt; <span class="hljs-string">&quot;Could not read default fstab&quot;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 会将/vendor/etc/fstab.sun50iw10p1中的每一项解析好放在fstab数组中</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ReadFstabFromFile</span>(mount_all-&gt;fstab_path, &amp;fstab)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Error</span>() &lt;&lt; <span class="hljs-string">&quot;Could not read fstab&quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 调用fs_mgr_mount_all挂载所有解析出来的entry</span><br>    <span class="hljs-keyword">auto</span> mount_fstab_result = <span class="hljs-built_in">fs_mgr_mount_all</span>(&amp;fstab, mount_all-&gt;mode);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-fs-mgr-mount-all做好准备工作"><a href="#3-2-fs-mgr-mount-all做好准备工作" class="headerlink" title="3.2 fs_mgr_mount_all做好准备工作"></a>3.2 fs_mgr_mount_all做好准备工作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">MountAllResult <span class="hljs-title">fs_mgr_mount_all</span><span class="hljs-params">(Fstab* fstab, <span class="hljs-type">int</span> mount_mode)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(fstab-&gt;<span class="hljs-built_in">size</span>()); i++) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; current_entry = (*fstab)[i];<br>        <span class="hljs-comment">// 调用checkpoint_manager的Update方法</span><br>        <span class="hljs-keyword">if</span> (!checkpoint_manager.<span class="hljs-built_in">Update</span>(&amp;current_entry)) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// system\core\fs_mgr\fs_mgr.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Update</span><span class="hljs-params">(FstabEntry* entry, <span class="hljs-type">const</span> std::string&amp; block_device = std::string())</span> </span>&#123;<br>    <span class="hljs-comment">// fs_mgr_flags是否包含checkpoint=fs或checkpoint=blk</span><br>    <span class="hljs-comment">// 显然包含</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SupportsCheckpoint</span>(entry)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ***********************这里是最重要的***********************</span><br>    <span class="hljs-comment">// ***********************这里是最重要的***********************</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">NeedsCheckpoint</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">UpdateCheckpointPartition</span>(entry, block_device)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Could not set up checkpoint partition, skipping!&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-1-NeedsCheckpoint判断是否需要检查Checkpoint"><a href="#3-2-1-NeedsCheckpoint判断是否需要检查Checkpoint" class="headerlink" title="3.2.1 NeedsCheckpoint判断是否需要检查Checkpoint"></a>3.2.1 NeedsCheckpoint判断是否需要检查Checkpoint</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\core\fs_mgr\fs_mgr.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NeedsCheckpoint</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用vdc二进制，传入第一个参数checkpoint,第二个参数needsCheckpoint，最终回调的结果是needs_checkpoint_</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">call_vdc</span>(&#123;<span class="hljs-string">&quot;checkpoint&quot;</span>, <span class="hljs-string">&quot;needsCheckpoint&quot;</span>&#125;, &amp;needs_checkpoint_)) &#123;<br>        LERROR &lt;&lt; <span class="hljs-string">&quot;Failed to find if checkpointing is needed. Assuming no.&quot;</span>;<br>        needs_checkpoint_ = NO;<br>    &#125;<br>    <span class="hljs-keyword">return</span> needs_checkpoint_ == YES;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>vdc</strong>二进制编译完以后位于<code>out/target/product/[productName]</code>中</p><img src="/2023/03/15/User-Data-Checkpoint%E6%9C%BA%E5%88%B6/image-20230315204223717.png" alt="image-20230315204223717" style="zoom:50%;"><p>下面看一下它的main入口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// system\vold\vdc.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (xxx) &#123;<br>        <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;checkpoint&quot;</span> &amp;&amp; args[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;needsCheckpoint&quot;</span> &amp;&amp; args.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">bool</span> enabled = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 调用needsCheckpoint方法</span><br>        <span class="hljs-built_in">checkStatus</span>(args, vold-&gt;<span class="hljs-built_in">needsCheckpoint</span>(&amp;enabled));<br>        <span class="hljs-keyword">return</span> enabled ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">binder::Status <span class="hljs-title">VoldNativeService::needsCheckpoint</span><span class="hljs-params">(<span class="hljs-type">bool</span>* _aidl_return)</span> </span>&#123;<br>    *_aidl_return = <span class="hljs-built_in">cp_needsCheckpoint</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Ok</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cp_needsCheckpoint</span><span class="hljs-params">()</span> </span>&#123;<br><br>    sp&lt;IBootControl&gt; <span class="hljs-keyword">module</span> = IBootControl::<span class="hljs-built_in">getService</span>();<br><br>    <span class="hljs-keyword">if</span> (isCheckpointing) <span class="hljs-keyword">return</span> isCheckpointing;<br><br>    <span class="hljs-comment">// 调用bootctl的isSlotMarkedSuccessful方法</span><br>    <span class="hljs-comment">// 如果是第一次启动，那必然boot分区没有succ标记</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">module</span> &amp;&amp; <span class="hljs-keyword">module</span>-&gt;<span class="hljs-built_in">isSlotMarkedSuccessful</span>(<span class="hljs-keyword">module</span>-&gt;<span class="hljs-built_in">getCurrentSlot</span>()) == BoolResult::FALSE) &#123;<br>        isCheckpointing = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>如果是OTA升级阶段或者是第一次刷固件的时候（调用boot_ctrl判断当前slot是否已经Marked Successful了，如果没有，表明此时处于OTA升级阶段或者是第一次刷固件的时候，需要进行checkpoint），则返回true；正常情况就是false；</strong></p><h4 id="3-2-2-UpdateCheckpointPartition更新挂载opt选项"><a href="#3-2-2-UpdateCheckpointPartition更新挂载opt选项" class="headerlink" title="3.2.2 UpdateCheckpointPartition更新挂载opt选项"></a>3.2.2 UpdateCheckpointPartition更新挂载opt选项</h4><p>如果NeedsCheckpoint为True，调用UpdateCheckpointPartition</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UpdateCheckpointPartition</span><span class="hljs-params">(FstabEntry* entry, <span class="hljs-type">const</span> std::string&amp; block_device)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (entry-&gt;fs_mgr_flags.checkpoint_fs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_f2fs</span>(entry-&gt;fs_type)) &#123;<br>            <span class="hljs-comment">// 会在这里添加checkpoint=disable</span><br>            entry-&gt;fs_checkpoint_opts = <span class="hljs-string">&quot;,checkpoint=disable&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-mount-with-alternatives执行真正的挂载"><a href="#3-3-mount-with-alternatives执行真正的挂载" class="headerlink" title="3.3 mount_with_alternatives执行真正的挂载"></a>3.3 mount_with_alternatives执行真正的挂载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">mount_with_alternatives</span><span class="hljs-params">(<span class="hljs-type">const</span> Fstab&amp; fstab, <span class="hljs-type">int</span> start_idx, <span class="hljs-type">int</span>* end_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">int</span>* attempted_idx)</span> </span>&#123;<br>    <span class="hljs-comment">// 总共尝试2次</span><br> <span class="hljs-type">int</span> retry_count = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (retry_count-- &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 调用__mount开始真正的挂载</span><br>        <span class="hljs-keyword">if</span> (!__mount(fstab[i].blk_device, fstab[i].mount_point, fstab[i])) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><blockquote><p> 🍭 参考大神pyjeston：<a href="https://www.cnblogs.com/pyjetson/p/14682457.html">https://www.cnblogs.com/pyjetson/p/14682457.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手写一个简单的文件系统</title>
    <link href="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="动手写一个简单的文件系统"><a href="#动手写一个简单的文件系统" class="headerlink" title="动手写一个简单的文件系统"></a>动手写一个简单的文件系统</h1><blockquote><p>🍉 <strong>参考博客</strong>：<a href="https://www.jianshu.com/p/8966d121263b">https://www.jianshu.com/p/8966d121263b</a></p><p>🍒 <strong>项目地址</strong>：<a href="https://github.com/ZhangShurong/HUST_OS_fs_experiment">https://github.com/ZhangShurong/HUST_OS_fs_experiment</a></p><p>🍐 <strong>文件系统前置知识：</strong><a href="https://blog.csdn.net/u012489236/article/details/123834123?spm=1001.2014.3001.5506">https://blog.csdn.net/u012489236/article/details/123834123?spm=1001.2014.3001.5506</a></p></blockquote><h2 id="0-下载运行"><a href="#0-下载运行" class="headerlink" title="0.下载运行"></a>0.下载运行</h2><p>按照<code>Readme.md</code>执行以后，可以看到具有了一个基础文件系统的功能：</p><img src="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230311221220446.png" alt="image-20230311221220446" style="zoom: 67%;"><p>如果有编译报错，有关于timepesc类型转换的；解决方案如下：</p><img src="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230311224039035.png" alt="image-20230311224039035" style="zoom: 55%;"><h2 id="1-总体设计"><a href="#1-总体设计" class="headerlink" title="1.总体设计"></a>1.总体设计</h2><p>本文件系统的磁盘结构参考minix的文件系统实现。但是自举块（或称引导块）中没有数据。且不采用二级或者多级索引，其结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">|Dummy Block|Super Block|IMap|BMap|Inode Table|Data blocks|<br></code></pre></td></tr></table></figure><img src="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230312230337246.png" alt="image-20230312230337246" style="zoom:67%;"><p>其中每个块的大小定义为4096bytes，每个Inode含有10个块所以单个文件最大为40KB，支持的最小磁盘大小为24K。以下详细阐述文件系统中所需要的三个基本数据结构。</p><h3 id="1-1-超级块结构"><a href="#1-1-超级块结构" class="headerlink" title="1.1 超级块结构"></a>1.1 超级块结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_fs_super_block</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> version;<br>    <span class="hljs-type">uint64_t</span> magic;<br>    <span class="hljs-type">uint64_t</span> block_size;<br>    <span class="hljs-type">uint64_t</span> inodes_count;<br>    <span class="hljs-type">uint64_t</span> free_blocks;<br>    <span class="hljs-type">uint64_t</span> blocks_count;<br>    <span class="hljs-type">uint64_t</span> bmap_block;<br>    <span class="hljs-type">uint64_t</span> imap_block;<br>    <span class="hljs-type">uint64_t</span> inode_table_block;<br>    <span class="hljs-type">uint64_t</span> data_block_number;<br>    <span class="hljs-type">char</span> padding[<span class="hljs-number">4016</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>超级块中的padding数组，是为了使超级块的大小为4096bytes，以简化后期的工作；“Magic”为1314522；indoe_count记录文件系统所支持的inode个数，这个值在格式化时就已经计算并写入超级块了。Bmap_block记录着bmap开始的数据块索引,imap_block，inode_table_block和data_block_number同理，记录索引是为了简化文件块的定位操作。</p><h3 id="1-2-HUST-inode结构"><a href="#1-2-HUST-inode结构" class="headerlink" title="1.2 HUST_inode结构"></a>1.2 HUST_inode结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> &#123;</span>  <br>    <span class="hljs-type">mode_t</span> mode; <span class="hljs-comment">//sizeof(mode_t) is 4  </span><br>    <span class="hljs-type">uint64_t</span> inode_no;  <br>    <span class="hljs-type">uint64_t</span> blocks;  <br>    <span class="hljs-type">uint64_t</span> block[HUST_N_BLOCKS];  <br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>  <br>        <span class="hljs-type">uint64_t</span> file_size;  <br>        <span class="hljs-type">uint64_t</span> dir_children_count;  <br>    &#125;;  <br>    <span class="hljs-type">int32_t</span> i_uid;   <br>    <span class="hljs-type">int32_t</span> i_gid;  <br>    <span class="hljs-type">int32_t</span> i_nlink;  <br>    <span class="hljs-type">int64_t</span> i_atime;  <br>    <span class="hljs-type">int64_t</span> i_mtime;  <br>    <span class="hljs-type">int64_t</span> i_ctime;  <br>    <span class="hljs-type">char</span> padding[<span class="hljs-number">112</span>];  <br>&#125;;  <br></code></pre></td></tr></table></figure><p>HUST_inode对应着磁盘上的inode结构，在后文会描述它是如何转换为VFS中的inode的。在上述结构体中，mode代表该inode是文件还是目录，blocks代表该inode的大小（所占块的数目），i_uid和i_gid用于后面的多用户管理。Padding数组是为了让HUST_inode结构体能够被4096整除；宏HUST_N_BLOCK被定义为10，意味着每个文件（目录）最大的大小为10个块；block数组存储着每个块的索引，用于定位文件。</p><h3 id="1-3-文件系统的目录结构"><a href="#1-3-文件系统的目录结构" class="headerlink" title="1.3 文件系统的目录结构"></a>1.3 文件系统的目录结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_dir_record</span> &#123;</span>  <br>    <span class="hljs-type">char</span> filename[HUST_FILENAME_MAX_LEN];  <br>    <span class="hljs-type">uint64_t</span> inode_no;  <br>&#125;;<br></code></pre></td></tr></table></figure><p>文件记录是为了储存目录项，其中HUST_FILENAME_MAX_LEN定义为256也就是说，文件名最大长度256。<br> 编写文件系统除了设计文件系统的磁盘结构，定义文件系统支持的操作也是十分重要的，这个直接影响了文件系统的功能。本文件系统支持基本的文件的增删改查，多用户等功能，但是不支持文件的移动，软硬链接等操作。</p><h2 id="2-mkfs的实现"><a href="#2-mkfs的实现" class="headerlink" title="2.mkfs的实现"></a>2.mkfs的实现</h2><p>要使用这个文件系统，必须首先创建一个符合磁盘布局的映像文件，所以我们需要实现一个格式化程序，这个程序按照惯例叫做mkfs。本节详细描述mkfs的实现。</p><p>mkfs的作用是将一个文件改写成对应于我们文件系统的结构，其主要功能点为<strong>写入超级块，写入imap,bmap，写入inode table</strong>，以及创建一个根目录和测试文件。</p><p>超级块包含了文件系统的基本信息，其信息在上文中有详细描述。写入超级块信息，需要计算整个磁盘的大小，然后计算imap，bmap以及inode table的大小，这样才能确定各个区域在磁盘中的位置。这些工作都是在init_disk这个函数中完成的。基本逻辑为读取需要格式化的文件大小，计算出整个磁盘中的块的个数，简单的将块的个数与inode的个数等同起来；然后通过块数以及inode个数计算imap和bmap的大小。其中bmap的大小如下（imap大小计算公式与bmap一致）：<br>$$<br>bmapsize &#x3D; blockcount&#x2F; HUST_BLOCKSIZE * 8<br>$$<br>关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">init_disk</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span>  <br>&#123;  <br>    <span class="hljs-comment">//获取基本信息  </span><br>    <span class="hljs-comment">//... ...  </span><br>    <span class="hljs-comment">//计算bmap  </span><br>    bmap_size = super_block.blocks_count/(<span class="hljs-number">8</span>*HUST_BLOCKSIZE);  <br>    super_block.bmap_block = RESERVE_BLOCKS;  <br>  <br>    <span class="hljs-keyword">if</span> (super_block.blocks_count%(<span class="hljs-number">8</span>*HUST_BLOCKSIZE) != <span class="hljs-number">0</span>) &#123;  <br>        bmap_size += <span class="hljs-number">1</span>;  <br>    &#125;  <br>    bmap = (<span class="hljs-type">uint8_t</span> *)<span class="hljs-built_in">malloc</span>(bmap_size*HUST_BLOCKSIZE);  <span class="hljs-comment">// 单位是块</span><br>    <span class="hljs-built_in">memset</span>(bmap,<span class="hljs-number">0</span>,bmap_size*HUST_BLOCKSIZE);  <br>  <br>    <span class="hljs-comment">//计算imap  </span><br>    imap_size = super_block.inodes_count/(<span class="hljs-number">8</span>*HUST_BLOCKSIZE);  <span class="hljs-comment">// 单位是块</span><br>    super_block.imap_block = super_block.bmap_block + bmap_size;  <br> <br>    <span class="hljs-keyword">if</span>(super_block.inodes_count%(<span class="hljs-number">8</span>*HUST_BLOCKSIZE) != <span class="hljs-number">0</span>) &#123;  <br>        imap_size += <span class="hljs-number">1</span>;  <br>    &#125;  <br>    imap = (<span class="hljs-type">uint8_t</span> *)<span class="hljs-built_in">malloc</span>(imap_size*HUST_BLOCKSIZE);  <br>    <span class="hljs-built_in">memset</span>(imap,<span class="hljs-number">0</span>,imap_size*HUST_BLOCKSIZE);  <br>  <br>    <span class="hljs-comment">//计算inode_table  </span><br>    inode_table_size = super_block.inodes_count/(HUST_BLOCKSIZE/HUST_INODE_SIZE);  <br>    super_block.inode_table_block = super_block.imap_block + imap_size;  <br>    super_block.data_block_number = RESERVE_BLOCKS + bmap_size + imap_size + inode_table_size;  <br>    super_block.free_blocks = super_block.blocks_count - super_block.data_block_number - <span class="hljs-number">1</span>;  <br><br>    <span class="hljs-comment">// 设置bmap以及imap  </span><br>    <span class="hljs-comment">// ... ...  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，imap和bmap为uint8_t的全局数组。</p><p>计算完基本信息之后，我们需要将其写入文件并创建根目录和测试文件。文件创建的基本步骤如下：</p><ol><li>检测（获取）磁盘（文件）大小，确认是否有足够的空间</li><li>找的空闲的inode和block，并标记imap和bmap。</li><li>生成相应的数据，并写入对应的块中。对于根目录来讲，写入的数据为三个目录项，目录项的内容为文件（目录）名以及对应的inode编号。第一个目录项为当前目录和对应的inode编号0，第二个目录项为上一级目录和对应的inode编号0，第三个目录项为欢迎文件，内容为文件名“file”和对应的inode编号1。</li><li>设置对应的inode信息，如是文件还是目录（mode信息），创建时间修改时间(i_ctime和i_mtime)，用户id和组id信息（i_uid和i_gid）等。</li><li>更新超级块信息。</li></ol><p>在我们的文件系统写完之前，我们可以新建一个文件来测试我们的mkfs是否能正常运行，通过16进制编辑器来查看是否功能正常。具体步骤如下：</p><ul><li>运行下列命令创建文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">dd bs=4096 count=100 if=/dev/zero of=image <br><br>- if=文件名：输入文件名，默认为标准输入。即指定源文件。<br>- of=文件名：输出文件名，默认为标准输出。即指定目的文件。<br>- bs=bytes：同时设置读入/输出的块大小为bytes个字节。<br>- count=blocks：仅拷贝blocks个块，块大小等于bs指定的字节数。<br></code></pre></td></tr></table></figure><ul><li>编译mkfs.c</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc mkfs.c -o mkfs <br></code></pre></td></tr></table></figure><ul><li>格式化image文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./mkfs ./image<br></code></pre></td></tr></table></figure><ul><li>通过hexdump来查看文件的结构，结果如下图。通过检查，我们发现，image文件结构写入正确无误。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">amx@amxxxx:~/Desktop/simple_fs$ hexdump ./image <br><span class="hljs-number">0000000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0001000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0</span>eda <span class="hljs-number">0014</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>  <span class="hljs-comment">/* HUST_fs文件系统的magic为1314522 */</span><br><span class="hljs-number">0001010</span> <span class="hljs-number">1000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0064</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0001020</span> <span class="hljs-number">0059</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0064</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0001030</span> <span class="hljs-number">0002</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0003</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0001040</span> <span class="hljs-number">0004</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">000</span>a <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0001050</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0002000</span> <span class="hljs-number">07f</span>f <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0002010</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0003000</span> <span class="hljs-number">0003</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0003010</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0004000</span> <span class="hljs-number">4000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0004010</span> <span class="hljs-number">0001</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">000</span>a <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0004020</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>*<br><span class="hljs-number">0004040</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">24</span>ed <span class="hljs-number">4</span>c27 <span class="hljs-number">7f</span>f3 <span class="hljs-number">0000</span><br><span class="hljs-number">0004050</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">3760</span> <span class="hljs-number">4</span>c3b <span class="hljs-number">7f</span>f3 <span class="hljs-number">0000</span><br><span class="hljs-number">0004060</span> <span class="hljs-number">0</span>d68 <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0003</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0004070</span> <span class="hljs-number">03e8</span> <span class="hljs-number">0000</span> <span class="hljs-number">03e8</span> <span class="hljs-number">0000</span> <span class="hljs-number">0002</span> <span class="hljs-number">0000</span> <span class="hljs-number">7f</span>f3 <span class="hljs-number">0000</span><br><span class="hljs-number">0004080</span> <span class="hljs-number">8f</span>e7 <span class="hljs-number">640</span>c <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">8f</span>e7 <span class="hljs-number">640</span>c <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0004090</span> <span class="hljs-number">8f</span>e7 <span class="hljs-number">640</span>c <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">3848</span> <span class="hljs-number">4</span>c3b <span class="hljs-number">7f</span>f3 <span class="hljs-number">0000</span><br>...............................................<br>amx@amxxxx:~/Desktop/simple_fs$ <br></code></pre></td></tr></table></figure><h2 id="3-文件系统的实现"><a href="#3-文件系统的实现" class="headerlink" title="3.文件系统的实现"></a>3.文件系统的实现</h2><p>一个通常意义上的文件系统驱动可以单独被编译成模块动态加载，也可以被直接编译到内核中，为了调试的方便，本文中的文件系统采用动态加载的方式实现。实现一个文件系统必须遵照内核的一些“规则”，以下我将以递进的顺序阐述文件系统的实现过程。</p><h3 id="3-1-文件系统的加载与卸载"><a href="#3-1-文件系统的加载与卸载" class="headerlink" title="3.1 文件系统的加载与卸载"></a>3.1 文件系统的加载与卸载</h3><p>首先为了能够成功加载文件系统，文件系统需要提供文件系统的名字，超级块的加载和删除方法。这些东西反应在<code>file_system_type</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> <span class="hljs-title">HUST_fs_type</span> =</span> &#123;  <br>    .owner = THIS_MODULE,  <br>    .name = <span class="hljs-string">&quot;HUST_fs&quot;</span>,  <br>    .mount = HUST_fs_mount,  <br>    .kill_sb = HUST_fs_kill_superblock, <span class="hljs-comment">/* unmount */</span>  <br>&#125;;  <br></code></pre></td></tr></table></figure><p>文件系统作为一种块设备驱动，自然也需要实现module_init以及mocule_exit。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Called when the module is loaded. */</span>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_fs_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>    <span class="hljs-type">int</span> ret;  <br>    ret = register_filesystem(&amp;HUST_fs_type);  <br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)  <br>        printk(KERN_INFO <span class="hljs-string">&quot;Sucessfully registered HUST_fs\n&quot;</span>);  <br>    <span class="hljs-keyword">else</span>  <br>        printk(KERN_ERR <span class="hljs-string">&quot;Failed to register HUST_fs. Error: [%d]\n&quot;</span>, ret);  <br>    <span class="hljs-keyword">return</span> ret;  <br>&#125;  <br>  <br><span class="hljs-comment">/* Called when the module is unloaded. */</span>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">HUST_fs_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br><br>    <span class="hljs-type">int</span> ret;  <br>    ret = unregister_filesystem(&amp;HUST_fs_type);  <br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)  <br>        printk(KERN_INFO <span class="hljs-string">&quot;Sucessfully unregistered HUST_fs\n&quot;</span>);  <br>    <span class="hljs-keyword">else</span>  <br>        printk(KERN_ERR <span class="hljs-string">&quot;Failed to unregister HUST_fs. Error: [%d]\n&quot;</span>, ret);  <br>&#125;  <br>module_init(HUST_fs_init);  <br>module_exit(HUST_fs_exit);  <br>  <br>MODULE_LICENSE(<span class="hljs-string">&quot;MIT&quot;</span>);  <br>MODULE_AUTHOR(<span class="hljs-string">&quot;cv&quot;</span>); <br></code></pre></td></tr></table></figure><p>我们可以看到，设备驱动加载的时候，驱动向内核注册了文件系统，而驱动卸载的时候，文件系统的信息也被删除。文件系统加载时调用的函数为HUST_fs_mount，实际上，这个函数向内核注册了一个回调：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_fs_fill_super</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">void</span> *data, <span class="hljs-type">int</span> silent)</span>  <br></code></pre></td></tr></table></figure><p>这个函数是用来与VFS交互从而生成VFS超级块的。在HUST fs中，超级块在磁盘的第二个4096字节上，即块号为1。这个函数执行时会从磁盘中读取信息，填充到VFS提供的超级块结构体中，下列为部分关键代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_fs_fill_super</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-type">void</span> *data, <span class="hljs-type">int</span> silent)</span>  &#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> *<span class="hljs-title">bh</span>;</span>  <br>    bh = sb_bread(sb, <span class="hljs-number">1</span>);  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_fs_super_block</span> *<span class="hljs-title">sb_disk</span>;</span>  <br>    sb_disk = (<span class="hljs-keyword">struct</span> HUST_fs_super_block *)bh-&gt;b_data;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">root_inode</span>;</span>  <br>    <span class="hljs-keyword">if</span> (sb_disk-&gt;block_size != <span class="hljs-number">4096</span>) &#123;  <br>        printk(KERN_ERR <span class="hljs-string">&quot;HUST_fs expects a blocksize of %d\n&quot;</span>, <span class="hljs-number">4096</span>);  <br>        ret = -EFAULT;  <br>        <span class="hljs-keyword">goto</span> release;  <br>   &#125;  <br>   <span class="hljs-comment">//fill vfs super block  </span><br>    sb-&gt;s_magic = sb_disk-&gt;magic;  <br>    sb-&gt;s_fs_info = sb_disk;  <br>    sb-&gt;s_maxbytes = HUST_BLOCKSIZE * HUST_N_BLOCKS; <span class="hljs-comment">/* Max file size */</span>  <br>    sb-&gt;s_op = &amp;HUST_fs_super_ops;  <br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码可以看出，我们用sb_read来读取磁盘上的内容，然后填充super_block结构体。值得注意的是，有关超级块的操作函数即superblock_operations也是在此处赋值的。由于super_block* sb在文件系统卸载之前是一直存在于内存中的，所以我们可以使用s_fs_info来存储原始的超级块信息，避免后期交互时 再次读取磁盘。</p><p>文件系统卸载的时候超级块信息需要被删除，所以HUST_fs_kill_superblock的作用时释放该超级块，通知VFS该挂载点已经卸载。</p><p>实现基本函数后，可以对文件系统进行挂载操作，挂载操作的脚本内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">sudo umount ./test  <br>sudo rmmod HUST_fs  <br>dd bs=<span class="hljs-number">4096</span> count=<span class="hljs-number">100</span> <span class="hljs-keyword">if</span>=/dev/zero of=image  <br>./mkfs image  <br>insmod HUST_fs.ko  <br>mount -o loop -t HUST_fs image ./test  <br>dmesg<br></code></pre></td></tr></table></figure><p>我们从第0节可以看到挂载成功</p><h3 id="3-2-ls命令的实现"><a href="#3-2-ls命令的实现" class="headerlink" title="3.2  ls命令的实现"></a>3.2  ls命令的实现</h3><p>加载文件系统之后第一个要实现的功能是读取文件系统中的数据，所以选择实现文件夹读取操作，这一操作在2.x内核中是<code>.readdir</code>函数指针，在最新版本中是<code>.iterate</code>函数指针。这个指针在保存在file_operation中，如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">HUST_fs_dir_ops</span> =</span> &#123;  <br>    .owner = THIS_MODULE,  <br>    .iterate = HUST_fs_iterate,  <br>&#125;; <br></code></pre></td></tr></table></figure><p>HUST_fs_iterate函数主要功能逻辑是读取inode的块数据，并且将块数据中的inode和文件名通过dir_emit函数传输到VFS层。以根目录为例，根目录的包含三个数据项，分别是父目录，当前目录和欢迎文件，所以该函数会执行以下三个语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//参数分别表示上下文，文件/目录名，文件/目录名长度，inode号，文件类型  </span><br>dir_emit(ctx, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>, DT_DIR);  <br>dir_emit(ctx, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-number">2</span>,<span class="hljs-number">0</span>, DT_DIR);  <br>dir_emit(ctx, <span class="hljs-string">&quot;file&quot;</span>, <span class="hljs-number">4</span>,<span class="hljs-number">1</span>, DT_REG);<br></code></pre></td></tr></table></figure><p>完成该函数后，在填充根目录inode时将HUST_fs_dir_ops指针赋值，即可在挂在文件系统后执行ls命令。</p><img src="/2023/03/11/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230311223941193.png" alt="image-20230311223941193" style="zoom: 80%;"><p>如上图所示，我们成功看到了欢迎文件。但是此时我们不能对文件进行任何操作，因为还没有实现其他的接口。</p><h3 id="3-3-磁盘管理相关逻辑的实现"><a href="#3-3-磁盘管理相关逻辑的实现" class="headerlink" title="3.3 磁盘管理相关逻辑的实现"></a>3.3 磁盘管理相关逻辑的实现</h3><p>这个磁盘管理的内涵包括向磁盘写入和从磁盘取出读取inode，更新inode信息，维护imap，bmap，inode table等操作。为了使磁盘上的内容有序的组合起来，磁盘空间的管理十分的重要，后续的文件读写操作都与此相关。</p><p>写入和删除inode的操作存放在super_operations这个结构体中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_operations</span> <span class="hljs-title">HUST_fs_super_ops</span> =</span> &#123;  <br>    .evict_inode = HUST_evict_inode,  <br>    .write_inode = HUST_write_inode,  <br>&#125;;<br></code></pre></td></tr></table></figure><p>HUST_fs_super_ops需要在填充超级块时赋值到super_block的s_ops字段中。HUST_write_inode函数的功能是将内存中的inode保存在磁盘上。关键代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_write_inode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> writeback_control *wbc)</span>  <br>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> * <span class="hljs-title">bh</span>;</span>  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> * <span class="hljs-title">raw_inode</span> =</span> <span class="hljs-literal">NULL</span>;  <br>    HUST_fs_get_inode(inode-&gt;i_sb, inode-&gt;i_ino, raw_inode);  <br>    <span class="hljs-keyword">if</span> (!raw_inode)  <br>        <span class="hljs-keyword">return</span> -EFAULT;  <br>    raw_inode-&gt;mode = inode-&gt;i_mode;  <br>    raw_inode-&gt;i_uid = fs_high2lowuid(i_uid_read(inode));  <br>    raw_inode-&gt;i_gid = fs_high2lowgid(i_gid_read(inode));  <br>    raw_inode-&gt;i_nlink = inode-&gt;i_nlink;  <br>    raw_inode-&gt;file_size = inode-&gt;i_size;      <br>    raw_inode-&gt;i_atime = (inode-&gt;i_atime.tv_sec);  <br>    raw_inode-&gt;i_mtime = (inode-&gt;i_mtime.tv_sec);  <br>    raw_inode-&gt;i_ctime = (inode-&gt;i_ctime.tv_sec);  <br>    mark_buffer_dirty(bh);  <br>    brelse(bh);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>可以看到，该函数的将vfs inode中的相关信息存储到HUST_inode结构体中，然后写入磁盘。这个是单独的写入磁盘操作，事实上，当我们申请inode时，imap也是需要检查刷新的，需要把相应位置标记为1。同理，evict_inode函数的作用时删除inode，删除成功后，我们需要刷新imap的值，把相应位置标记为0。</p><p>设置和写入map的操作都在map.c中，以下以imap为例。对于imap来讲，申请inode的时候需要检查第一个空闲的inode编号，当inode被释放的时候也要及时清零对应的imap。与此相关的函数如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从磁盘中读取数据并存在imap数组中  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_imap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block* sb, <span class="hljs-type">uint8_t</span>* imap, <span class="hljs-type">ssize_t</span> imap_size)</span>;  <br><span class="hljs-comment">//在vaddr数组中找到第一个为0的bit，这个函数用于定位空inode或者block  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_find_first_zero_bit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *vaddr, <span class="hljs-type">unsigned</span> size)</span>;  <br><span class="hljs-comment">//将imap的某一位置0或者1，并保存在磁盘上  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">set_and_save_imap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> super_block* sb, <span class="hljs-type">uint64_t</span> inode_num, <span class="hljs-type">uint8_t</span> value)</span>;  <br><span class="hljs-comment">//定义的位操作宏如下  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> setbit(number,x) number |= 1UL &lt;&lt; x  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clearbit(number, x) number &amp;= ~(1UL &lt;&lt; x)  </span><br></code></pre></td></tr></table></figure><p>由于本文件系统并不是为了实际使用，所以上述的操作都没有考虑性能以及准确性问题。事实上，能够加上校验或者冗余备份是最好的。</p><h3 id="3-4-读写文件内容"><a href="#3-4-读写文件内容" class="headerlink" title="3.4 读写文件内容"></a>3.4 读写文件内容</h3><p>为了能够快速看到文件系统在正常工作，所以接下来需要实现文件的读写操作。文件读写操作按照一般处理，应该是实现在struct file_operations这个结构体中的。事实上，最开始我是实现在这个结构体中的read_iter函数指针中的。但是比较有趣的一点是，如果我们实现了struct address_space_operations结构体中的函数，那么struct file_operations结构体中的函数则可以交由VFS实现。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">HUST_fs_file_ops</span> =</span> &#123;  <br>    .owner = THIS_MODULE,  <br>    .llseek = generic_file_llseek,  <br>    .mmap = generic_file_mmap,  <br>    .fsync = generic_file_fsync,  <br>    .read_iter = generic_file_read_iter,  <br>    .write_iter = generic_file_write_iter,  <br>&#125;;  <br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>   <span class="hljs-title">address_space_operations</span> <span class="hljs-title">HUST_fs_aops</span> =</span> &#123;  <br>    .readpage = HUST_fs_readpage,  <br>    .writepage = HUST_fs_writepage,  <br>    .write_begin = HUST_fs_write_begin,  <br>    .write_end = generic_write_end,  <br>&#125;;<br></code></pre></td></tr></table></figure><p>上述的generic开头的函数是不需要我们手动实现的。上述的address_space_operations操作其实是实现了页高速缓存的一些操作。页高速缓存是linux内核实现的一种主要磁盘缓存，它主要用来减少对磁盘的IO操作，具体地讲，是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。这些接口一旦实现，那么对文件的操作就可以转移到内存中，这就是为什么可以使用generic开头的这些函数来代替手写。</p><p>HUST_fs_readpage, HUST_fs_writepage以及HUST_fs_write_begin都被注册回调到同一个函数HUST_fs_get_block。HUST_fs_get_block主要返回内核请求长度的数据。至于读写操作，内核调用__bwrite函数最终调用块设备驱动执行。因为在我没有采用二级或者多级索引，故而HUST_fs_get_block函数逻辑比较简单，部分代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">HUST_fs_get_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-type">sector_t</span> block,  </span><br><span class="hljs-params">              <span class="hljs-keyword">struct</span> buffer_head *bh, <span class="hljs-type">int</span> create)</span>  <br>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> inode-&gt;i_sb;  <br>    <span class="hljs-keyword">if</span> (block &gt; HUST_N_BLOCKS) <br>        <span class="hljs-keyword">return</span> -ENOSPC;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> <span class="hljs-title">H_inode</span>;</span>  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == HUST_fs_get_inode(sb, inode-&gt;i_ino, &amp;H_inode))  <br>        <span class="hljs-keyword">return</span> -EFAULT;  <br>    <span class="hljs-keyword">if</span> (H_inode.blocks == <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">if</span>(alloc_block_for_inode(sb, &amp;H_inode, <span class="hljs-number">1</span>)) <br>            <span class="hljs-keyword">return</span> -EFAULT;  <br>    map_bh(bh, sb, H_inode.block[block]);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，该函数判断传入的block的大小，并将磁盘内容映射到bh中。后续的读写操作将有VFS帮我们完成。</p><h3 id="3-5-inode操作"><a href="#3-5-inode操作" class="headerlink" title="3.5 inode操作"></a>3.5 inode操作</h3><p>Inode操作涉及文件(夹)的创建删除，将HUST_inode映射到VFS中的inode等操作。具体实现的函数如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span> <span class="hljs-title">HUST_fs_inode_ops</span> =</span> &#123;  <br>    .lookup = HUST_fs_lookup,  <br>    .mkdir = HUST_fs_mkdir,  <br>    .create = HUST_fs_create,  <br>    .unlink = HUST_fs_unlink,  <br>&#125;; <br></code></pre></td></tr></table></figure><p>HUST_fs_lookup是其中比较复杂的一个函数，它负责将一个目录下的inode信息交由VFS管理。首先，HUST_fs_lookup读取文件夹的内容，然后遍历文件夹下面的HUST_inode，找到我们想要的HUST_inode，根据不同的文件属性，申请vfs_inode；并对不同的vfs_inode设置不同的操作。假设vfs_inode对应的是一个文件，那么就设置vfs_inode-&gt;mapping-&gt;a_ops，如果vfs_inode对应的是文件夹，那么就设置vfs_inode-&gt;f_ops &#x3D; &amp;HUST_fs_dir_ops;最后将vfs_inode注册到VFS中。这部分的关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> dentry *<span class="hljs-title function_">HUST_fs_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *parent_inode,  </span><br><span class="hljs-params">                  <span class="hljs-keyword">struct</span> dentry *child_dentry, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span>  <br>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">sb</span> =</span> parent_inode-&gt;i_sb;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> <span class="hljs-title">H_inode</span>;</span>  <br><span class="hljs-comment">//省略代码  </span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; H_inode.dir_children_count; i++) &#123;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>  <br>            (child_dentry-&gt;d_name.name, dtptr[i].filename,  <br>             HUST_FILENAME_MAX_LEN) == <span class="hljs-number">0</span>)&#123;  <br>            inode = iget_locked(sb, dtptr[i].inode_no);  <br>            <span class="hljs-keyword">if</span> (inode-&gt;i_state &amp; I_NEW) &#123;  <br>                inode_init_owner(inode, parent_inode, <span class="hljs-number">0</span>);  <br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HUST_inode</span> <span class="hljs-title">H_child_inode</span>;</span>  <br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == HUST_fs_get_inode(sb, dtptr[i].inode_no, &amp;H_child_inode))  <br>                    <span class="hljs-keyword">return</span> ERR_PTR(-EFAULT);  <br>                HUST_fs_convert_inode(&amp;H_child_inode, inode);  <br>                inode-&gt;i_op = &amp;HUST_fs_inode_ops;  <br>                <span class="hljs-keyword">if</span> (S_ISDIR(H_child_inode.mode)) &#123;  <br>                    inode-&gt;i_fop = &amp;HUST_fs_dir_ops;  <br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISREG(H_child_inode.mode)) &#123;  <br>                    inode-&gt;i_fop = &amp;HUST_fs_file_ops;;  <br>                    inode-&gt;i_mapping-&gt;a_ops = &amp;HUST_fs_aops;  <br>                &#125;  <br>                inode-&gt;i_mode = H_child_inode.mode;  <br>                inode-&gt;i_size = H_child_inode.file_size;  <br>                insert_inode_hash(inode);  <br>                unlock_new_inode(inode);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br><span class="hljs-comment">//省略代码  </span><br>&#125; <br></code></pre></td></tr></table></figure><p>只有在这里注册了相关函数，系统调用才能正常执行。不然就会出现不支持的操作这种报错信息。</p><p>.create与.mkdir都是对应了inode的创建，只是inode的属性不能而已。.create创建普通文件而.mkdir创建文件夹。所以这两个函数的功能被函数HUST_fs_create_obj所处理。这个函数接受新建文件（夹）的请求，检查磁盘的大小，检查是否有空余的indoe，并且分配inode号，然后更新imap信息，最后更新超级块信息。由于该函数逻辑简单但是代码量比较大，故而不在此展示其具体实现。</p><p>在完成上述工作之后，我们的文件系统基本已经完成了，这个系统采用线性（区别于minixi二级索引用树来管理）的方式管理磁盘空间，支持基本的增删改查文件操作，支持文件权限，支持多用户。</p>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android HIDL服务实现</title>
    <link href="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-HIDL服务实现"><a href="#Android-HIDL服务实现" class="headerlink" title="Android HIDL服务实现"></a>Android HIDL服务实现</h1><blockquote><p><a href="https://www.jianshu.com/p/b75c4321ae0a">https://www.jianshu.com/p/b75c4321ae0a</a></p></blockquote><p><strong>Android O(8.0)</strong> 版本之后，底层实现有了比较大的变化，最显著的一个方面就是 <strong>HIDL</strong> 机制的全面实施。本文将从 <strong>HIDL的基本概念</strong>、<strong>HIDL服务模拟</strong>、<strong>framework层aidl服务</strong>、<strong>应用层程序</strong> 这四个方面来全面的阐述 <strong>HIDL</strong> 工作全过程，这对于理解系统源码中 <strong>Gnss</strong>、<strong>Usb</strong>、<strong>Camera</strong> 等模块的工作原理有极大帮助。</p><h2 id="1-HIDL设计目的"><a href="#1-HIDL设计目的" class="headerlink" title="1. HIDL设计目的"></a>1. HIDL设计目的</h2><p>在 <strong>Android O(8.0)</strong> 之前系统的升级牵扯多方协作，极为麻烦，<strong>HIDL</strong>机制的推出就是将 <strong>framework</strong> 与 <strong>hal</strong> 层分开，使得框架部分可以直接被覆盖、更新，而不需要重新对 HAL 进行编译，这样在系统升级时，<strong>OEM</strong> 厂商 跳过 <strong>SoC</strong> 厂商，先对 <strong>framework</strong> 进行升级。</p><h3 id="1-1-Android-8-0之前"><a href="#1-1-Android-8-0之前" class="headerlink" title="1.1 Android 8.0之前"></a>1.1 Android 8.0之前</h3><p><strong>framework</strong> 与 <strong>hal</strong> 紧紧耦合存在于 <strong>system.img</strong> 中，因此在版本升级时需要: <strong>OEM</strong> 厂商适配 <strong>framework</strong> ，<strong>SoC厂商</strong> 适配 <strong>hal</strong>， 之后将修改打包到 <strong>system.img</strong>，生成 OTA 升级包，推送到手机进行 OTA 升级</p><h3 id="1-2-Android-8-0之后"><a href="#1-2-Android-8-0之后" class="headerlink" title="1.2 Android 8.0之后"></a>1.2 Android 8.0之后</h3><p><strong>framework</strong> 与 <strong>hal</strong> 进行了解耦， <strong>framework</strong> 存在于 <strong>system.img</strong>，<strong>hal</strong> 存在于<strong>vendor.img</strong>，进行版本升级时，分为两次升级:</p><ul><li><strong>framework升级</strong> ： OEM 厂商适配 framework，将修改打包到 system.img， 生成OTA 升级包，推送到手机进行 OTA 升级(framework 发生改变，hal 层未变)。</li><li><strong>hal升级</strong> ：SoC 厂商适配 hal， 将修改打包到 vendor.img, 生成OTA 升级包，推送到手机进行OTA升级(framework发生改变，hal 层发生改变)。</li></ul><h2 id="2-HIDL机制演进"><a href="#2-HIDL机制演进" class="headerlink" title="2.HIDL机制演进"></a>2.HIDL机制演进</h2><h3 id="2-1-老版本-Framework-与-HAL-的通信框架"><a href="#2-1-老版本-Framework-与-HAL-的通信框架" class="headerlink" title="2.1 老版本 Framework 与 HAL 的通信框架"></a>2.1 老版本 Framework 与 HAL 的通信框架</h3><p>正如上述所言，旧版的系统架构中， Android Framework 层与 Hal 层是打包成一个 <strong>system.img</strong> 的，且 Framework 与 hal 层之间是紧密耦合的，通过链接的方式使用相应的硬件 <strong>so</strong> 库。它们之间的架构一般有如下两种方式：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-0fed2e7f185e551d.png" style="zoom:80%;"><h3 id="2-2-HIDL-类型介绍"><a href="#2-2-HIDL-类型介绍" class="headerlink" title="2.2  HIDL 类型介绍"></a>2.2  HIDL 类型介绍</h3><p>为了解决两者之间这种紧耦合所带来的弊端，google 引入 HIDL 来定义 Framework 与 HAL 之间的接口，可以用下图来描述：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-ea297e84897f8686.webp" style="zoom:80%;"><p>事实上虽然 google 推出了这种机制，但是很多厂商没有很快的跟上节奏，因此为了向前兼容， google 定义了三种类型：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-5b8123370101b01f.png" style="zoom: 67%;"><p>① 是 Treble Project 之前使用的实现架构，使用的是传统 HAL 和旧版 HAL</p><p>② 直通模式，passthrough mode。如图所示，Framework 和 HAL 层工作在同一个进程当中，下面的 HAL 是使用 HIDL 封装后的库，是直通式 HAL。这些库文件也可用于 ③ 绑定模式</p><p>③ 绑定模式，binderized mode。是直通式 HAL binder 化，变为绑定式 HAL。Framework 和 HAL 层工作在不同的进程，之间通过 Binder 进行 IPC</p><p>④ 纯绑定式。相对于 ③ 来说，绑定式 HAL 中并不包含直通式 HAL，因此称为纯绑定式</p><p><strong>上述可总结为</strong>：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-619180c0c7f8afc5.png" style="zoom: 67%;"><h2 id="3-Binderized-Mode（绑定式）简介"><a href="#3-Binderized-Mode（绑定式）简介" class="headerlink" title="3.Binderized Mode（绑定式）简介"></a>3.Binderized Mode（绑定式）简介</h2><p>们知道 <strong>绑定模式</strong> 是 google 为了向前兼容而定义的一种类型，且 Android 8.0 及后续版本的设备都必须只支持这种模式。这种模式下 Framework 与 Hal 分别位于不同的进程中，其实从具体实现来讲这种模式也更应该被称为 <strong>Binder 化的直通式</strong>。本文将通过这种方式实现一个 <strong>HIDL</strong> 服务。</p><h2 id="4-环境-x2F-工具准备"><a href="#4-环境-x2F-工具准备" class="headerlink" title="4.环境&#x2F;工具准备"></a>4.环境&#x2F;工具准备</h2><ul><li>Ubuntu 20.04 TLS</li><li>Android 源码：Android 9.0，编译烧录详见 <a href="https://www.jianshu.com/p/848414148272">Android源码编译烧录</a></li><li>hidl-gen 工具：Android 系统自带，需要配置一下环境变量</li></ul><h2 id="5-HIDL实现"><a href="#5-HIDL实现" class="headerlink" title="5.HIDL实现"></a>5.HIDL实现</h2><p>本文目的是实现一个具有 <strong>加减乘除</strong> 运算的 HIDL 服务,命名为 <strong>银河一号(GalaxyOne)<strong>。HIDL用起来非常简单，在系统源码中的 <strong>hardware&#x2F;interfaces</strong> 目录下有很多的 HIDL，我们仿照其他 HIDL 来创建自己的目录：</strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0</strong></p><h3 id="5-1-创建IGalaxyOne-hal-文件"><a href="#5-1-创建IGalaxyOne-hal-文件" class="headerlink" title="5.1 创建IGalaxyOne.hal 文件"></a>5.1 创建IGalaxyOne.hal 文件</h3><p><strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0&#x2F;IGalaxyOne.hal</strong></p><p>这里定义了四种基本的运算：加、减、乘、除，这是上层调用 HAL 的入口，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">package android.hardware.galaxy_one@<span class="hljs-number">1.0</span>;<br><br>interface IGalaxyOne&#123;<br><br>    <span class="hljs-comment">//加法</span><br>    add(<span class="hljs-type">uint32_t</span> a,<span class="hljs-type">uint32_t</span> b) generates (<span class="hljs-type">uint32_t</span> result);<br>    <span class="hljs-comment">//减法</span><br>    sub(<span class="hljs-type">uint32_t</span> a,<span class="hljs-type">uint32_t</span> b) generates (<span class="hljs-type">uint32_t</span> result);<br>    <span class="hljs-comment">//乘法</span><br>    mul(<span class="hljs-type">uint32_t</span> a,<span class="hljs-type">uint32_t</span> b) generates (<span class="hljs-type">uint32_t</span> result);<br>    <span class="hljs-comment">//除法</span><br>    div(<span class="hljs-type">uint32_t</span> a,<span class="hljs-type">uint32_t</span> b) generates (<span class="hljs-type">uint32_t</span> result);<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-2-hidl-gen生成HIDL框架"><a href="#5-2-hidl-gen生成HIDL框架" class="headerlink" title="5.2 hidl-gen生成HIDL框架"></a>5.2 hidl-gen生成HIDL框架</h3><p>在使用 hidl-gen 之前需要先做两件事：<br>1、hidl-gen 由 Android 提供，使用之前需要先配置一下系统路径，如我这里所做的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># vim ~/.bashrc</span><br>export PATH=/home/zsk/AOSP/out/soong/host/linux-x86/bin:$PATH<br></code></pre></td></tr></table></figure><p>2、Ubuntu 新的终端窗口必须先设定一些 Android 环境变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">source build/envsetup.sh<br>lunch aosp_sailfish-userdebug  <span class="hljs-comment">// lunch mode 根据需求修改</span><br>make hidl-gen<br></code></pre></td></tr></table></figure><p>配置完成之后在 <strong>源码根目录</strong> 下执行如下命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">PACKAGE=android.hardware.galaxy_one@<span class="hljs-number">1.0</span><br>LOC=hardware/interfaces/galaxy_one/<span class="hljs-number">1.0</span>/<span class="hljs-keyword">default</span>/<br>    <br>hidl-gen -o $LOC -Lc++-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE<br><br>hidl-gen -o $LOC -Landroidbp-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE<br></code></pre></td></tr></table></figure><p>命令执行成功之后会发现在 <strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0</strong> 目录下多了一个 <strong>default</strong> 目录，进入之后发现有如下文件：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-0096f7494b4dbff9.png" style="zoom: 80%;"><p>之后执行 <strong>update-makefiles.sh</strong> 脚本来为 HIDL 生成对应的 <strong>Android.bp</strong> 文件，此脚本位于 <strong>hardware&#x2F;interfaces</strong> 目录下，同样可在源码根目录下执行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">./hardware/interfaces/update-makefiles.sh<br></code></pre></td></tr></table></figure><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-5ea845283e2c2d58.png" style="zoom: 80%;"><p>接下来我们需要添加两个空文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">touch hardware/interfaces/galaxy_one/<span class="hljs-number">1.0</span>/<span class="hljs-keyword">default</span>/android.hardware.galaxy_one@<span class="hljs-number">1.0</span>-service.rc<br>touch hardware/interfaces/galaxy_one/<span class="hljs-number">1.0</span>/<span class="hljs-keyword">default</span>/service.cpp<br></code></pre></td></tr></table></figure><p>完成之后，整个工程结构如下所示：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-118902147dc61749.png" style="zoom: 80%;"><h3 id="5-3-调用流程"><a href="#5-3-调用流程" class="headerlink" title="5.3 调用流程"></a>5.3 调用流程</h3><p>上述过程已经将 HIDL 服务所需要的全本文件配置完成，虽然其中很多文件是空的，或者没有具体实现，我们现在先放在一边，先来对整体的调用流程及各个文件的功效略作说明。</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-865d0cf346cee965.png" style="zoom: 80%;"><ul><li>Application：指上层应用</li><li>JNI：指 framework 层，getService 获取 hal 层 service</li><li><a href="mailto:&#x61;&#x6e;&#100;&#114;&#x6f;&#105;&#100;&#46;&#x68;&#97;&#x72;&#x64;&#x77;&#x61;&#114;&#x65;&#x2e;&#x67;&#x61;&#108;&#x61;&#x78;&#121;&#x5f;&#x6f;&#110;&#x65;&#x40;&#49;&#46;&#x30;&#46;&#115;&#x6f;">&#x61;&#x6e;&#100;&#114;&#x6f;&#105;&#100;&#46;&#x68;&#97;&#x72;&#x64;&#x77;&#x61;&#114;&#x65;&#x2e;&#x67;&#x61;&#108;&#x61;&#x78;&#121;&#x5f;&#x6f;&#110;&#x65;&#x40;&#49;&#46;&#x30;&#46;&#115;&#x6f;</a>：由 IGalaxyOne.hal 生成的接口库，由 <strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0&#x2F;Android.bp</strong> 通过 <strong>IGalaxyOne.hal</strong> 生成，这样只要这个接口库不变，那么 framework 的更新和 hal 层就隔绝开了</li><li><a href="mailto:&#97;&#110;&#x64;&#114;&#x6f;&#x69;&#x64;&#46;&#104;&#x61;&#114;&#x64;&#x77;&#x61;&#114;&#x65;&#46;&#x67;&#97;&#108;&#97;&#120;&#x79;&#95;&#x6f;&#110;&#101;&#64;&#x31;&#46;&#x30;&#x2d;&#115;&#x65;&#114;&#x76;&#x69;&#x63;&#101;&#46;&#114;&#x63;">&#97;&#110;&#x64;&#114;&#x6f;&#x69;&#x64;&#46;&#104;&#x61;&#114;&#x64;&#x77;&#x61;&#114;&#x65;&#46;&#x67;&#97;&#108;&#97;&#120;&#x79;&#95;&#x6f;&#110;&#101;&#64;&#x31;&#46;&#x30;&#x2d;&#115;&#x65;&#114;&#x76;&#x69;&#x63;&#101;&#46;&#114;&#x63;</a>：设备开机时通过 <strong>rc</strong> 文件启动此服务</li><li>galaxy_hal_service：service的名，可通过 <strong>start galaxy_hal_service</strong> 启动服务，由service.cpp编译生成</li><li><a href="mailto:&#x61;&#x6e;&#100;&#x72;&#x6f;&#x69;&#100;&#46;&#x68;&#97;&#114;&#x64;&#x77;&#x61;&#114;&#x65;&#x2e;&#103;&#97;&#108;&#97;&#x78;&#121;&#x5f;&#x6f;&#110;&#101;&#x40;&#x31;&#46;&#48;&#45;&#x69;&#109;&#x70;&#108;&#46;&#x73;&#x6f;">&#x61;&#x6e;&#100;&#x72;&#x6f;&#x69;&#100;&#46;&#x68;&#97;&#114;&#x64;&#x77;&#x61;&#114;&#x65;&#x2e;&#103;&#97;&#108;&#97;&#x78;&#121;&#x5f;&#x6f;&#110;&#101;&#x40;&#x31;&#46;&#48;&#45;&#x69;&#109;&#x70;&#108;&#46;&#x73;&#x6f;</a>：实现库，上层应用的最终调用，由GalaxyOne.cpp编译生成</li></ul><p>关于 <strong>Application、JNI</strong> 这两层内容会在稍后用两个篇幅去分析，此处暂不理会。现在我们就着这个调用过程将需要的内容补充完成。明出处。</p><h4 id="5-3-1-接口库生成"><a href="#5-3-1-接口库生成" class="headerlink" title="5.3.1 接口库生成"></a>5.3.1 接口库生成</h4><p><a href="mailto:&#x61;&#110;&#x64;&#114;&#x6f;&#105;&#x64;&#46;&#x68;&#97;&#114;&#100;&#119;&#97;&#x72;&#101;&#x2e;&#x67;&#97;&#x6c;&#97;&#120;&#x79;&#x5f;&#111;&#110;&#101;&#x40;&#49;&#46;&#48;&#46;&#115;&#111;">&#x61;&#110;&#x64;&#114;&#x6f;&#105;&#x64;&#46;&#x68;&#97;&#114;&#100;&#119;&#97;&#x72;&#101;&#x2e;&#x67;&#97;&#x6c;&#97;&#120;&#x79;&#x5f;&#111;&#110;&#101;&#x40;&#49;&#46;&#48;&#46;&#115;&#111;</a>，由 <strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0&#x2F;Android.bp</strong> 通过 <strong>IGalaxyOne.hal</strong> 生成，Android.bp 文件是在上面一些列命令执行之后生成，而接口库是当我们最终执行编译模块时生成，可以说这个过程不需要我们手动参与，Android.bp 内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile">// This file is autogenerated by hidl-gen -Landroidbp.<br><br>hidl_interface &#123;<br>    name: <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0&quot;</span>,   //此处设置接口库的名字<br>    root: <span class="hljs-string">&quot;android.hardware&quot;</span>,<br>    vndk: &#123;<br>        enabled: true,<br>    &#125;,<br>    srcs: [<br>        <span class="hljs-string">&quot;IGalaxyOne.hal&quot;</span>,<br>    ],<br>    interfaces: [<br>        <span class="hljs-string">&quot;android.hidl.base@1.0&quot;</span>,<br>    ],<br>    gen_java: true,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-2-实现库生成"><a href="#5-3-2-实现库生成" class="headerlink" title="5.3.2 实现库生成"></a>5.3.2 实现库生成</h4><p><a href="mailto:&#97;&#x6e;&#100;&#114;&#111;&#105;&#x64;&#x2e;&#104;&#x61;&#114;&#x64;&#x77;&#x61;&#x72;&#101;&#46;&#x67;&#97;&#108;&#97;&#x78;&#x79;&#x5f;&#x6f;&#x6e;&#x65;&#x40;&#x31;&#x2e;&#48;&#x2d;&#x69;&#109;&#x70;&#x6c;&#x2e;&#x73;&#111;">&#97;&#x6e;&#100;&#114;&#111;&#105;&#x64;&#x2e;&#104;&#x61;&#114;&#x64;&#x77;&#x61;&#x72;&#101;&#46;&#x67;&#97;&#108;&#97;&#x78;&#x79;&#x5f;&#x6f;&#x6e;&#x65;&#x40;&#x31;&#x2e;&#48;&#x2d;&#x69;&#109;&#x70;&#x6c;&#x2e;&#x73;&#111;</a>，由 <strong>hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0&#x2F;default&#x2F;Android.bp</strong> 通过 <strong>GalaxyOne.cpp</strong> 生成，注意这个 Android.bp 文件是位于 <strong>default</strong> 目录下，同样的在最后模块编译时生成，原始内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cc_library_shared &#123;<br>    name: <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0-impl&quot;</span>,<br>    relative_install_path: <span class="hljs-string">&quot;hw&quot;</span>,<br>    proprietary: true,<br>    srcs: [<br>        <span class="hljs-string">&quot;GalaxyOne.cpp&quot;</span>,<br>    ],<br>    shared_libs: [    //这里可以添加我们需要的库<br>        <span class="hljs-string">&quot;liblog&quot;</span>,     <br>        <span class="hljs-string">&quot;libhidlbase&quot;</span>,<br>        <span class="hljs-string">&quot;libhidltransport&quot;</span>,<br>        <span class="hljs-string">&quot;libhwbinder&quot;</span>,<br>        <span class="hljs-string">&quot;libutils&quot;</span>,<br>        <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0&quot;</span>,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-3-GalaxyOne-cpp实现"><a href="#5-3-3-GalaxyOne-cpp实现" class="headerlink" title="5.3.3 GalaxyOne.cpp实现"></a>5.3.3 GalaxyOne.cpp实现</h4><p>在 <strong>5.3.2</strong> 中，实现库是由 <strong>GalaxyOne.cpp</strong> 编译而成，现在我们来将此文件补充完成：</p><p><strong>GalaxyOne.h:</strong><br> Binder化直通式，同样需要将 HIDL_FETCH_XXX 打开，至于原因我们在后面会提及</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ANDROID_HARDWARE_GALAXY_ONE_V1_0_GALAXYONE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANDROID_HARDWARE_GALAXY_ONE_V1_0_GALAXYONE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hardware/galaxy_one/1.0/IGalaxyOne.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/MQDescriptor.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/Status.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;log/log.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> android &#123;<br><span class="hljs-keyword">namespace</span> hardware &#123;<br><span class="hljs-keyword">namespace</span> galaxy_one &#123;<br><span class="hljs-keyword">namespace</span> V1_0 &#123;<br><span class="hljs-keyword">namespace</span> implementation &#123;<br><br><span class="hljs-keyword">using</span> ::android::hardware::hidl_array;<br><span class="hljs-keyword">using</span> ::android::hardware::hidl_memory;<br><span class="hljs-keyword">using</span> ::android::hardware::hidl_string;<br><span class="hljs-keyword">using</span> ::android::hardware::hidl_vec;<br><span class="hljs-keyword">using</span> ::android::hardware::Return;<br><span class="hljs-keyword">using</span> ::android::hardware::Void;<br><span class="hljs-keyword">using</span> ::android::sp;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GalaxyOne</span> : <span class="hljs-keyword">public</span> IGalaxyOne &#123;<br>    <span class="hljs-comment">// Methods from ::android::hardware::galaxy_one::V1_0::IGalaxyOne follow.</span><br>    <span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> <span class="hljs-keyword">override</span></span>;<br><br>    <span class="hljs-comment">// Methods from ::android::hidl::base::V1_0::IBase follow.</span><br><br>&#125;;<br><br><span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> most likely delete, this is only for passthrough implementations</span><br> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">IGalaxyOne* <span class="hljs-title">HIDL_FETCH_IGalaxyOne</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span></span>;<br><br>&#125;  <span class="hljs-comment">// namespace implementation</span><br>&#125;  <span class="hljs-comment">// namespace V1_0</span><br>&#125;  <span class="hljs-comment">// namespace galaxy_one</span><br>&#125;  <span class="hljs-comment">// namespace hardware</span><br>&#125;  <span class="hljs-comment">// namespace android</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// ANDROID_HARDWARE_GALAXY_ONE_V1_0_GALAXYONE_H</span></span><br><br></code></pre></td></tr></table></figure><p><strong>GalaxyOne.cpp:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GalaxyOne.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> android &#123;<br><span class="hljs-keyword">namespace</span> hardware &#123;<br><span class="hljs-keyword">namespace</span> galaxy_one &#123;<br><span class="hljs-keyword">namespace</span> V1_0 &#123;<br><span class="hljs-keyword">namespace</span> implementation &#123;<br><br><span class="hljs-comment">// Methods from ::android::hardware::galaxy_one::V1_0::IGalaxyOne follow.</span><br><span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">GalaxyOne::add</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> result = a + b;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;GalaxyOne::add  a = %d,b = %d,result = %d&quot;</span>,a,b,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">GalaxyOne::sub</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> result = a - b;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;GalaxyOne::sub  a = %d,b = %d,result = %d&quot;</span>,a,b,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">GalaxyOne::mul</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> result = a * b;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;GalaxyOne::mul  a = %d,b = %d,result = %d&quot;</span>,a,b,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">Return&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">GalaxyOne::div</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b)</span> </span>&#123;<br>    <span class="hljs-type">uint32_t</span> result = a / b;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;GalaxyOne::div  a = %d,b = %d,result = %d&quot;</span>,a,b,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// Methods from ::android::hidl::base::V1_0::IBase follow.</span><br><span class="hljs-function">IGalaxyOne* <span class="hljs-title">HIDL_FETCH_IGalaxyOne</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-comment">/* name */</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">ALOG</span>(<span class="hljs-string">&quot;galaxy_one service init success....&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">GalaxyOne</span>();<br>&#125;<br><br>&#125;  <span class="hljs-comment">// namespace implementation</span><br>&#125;  <span class="hljs-comment">// namespace V1_0</span><br>&#125;  <span class="hljs-comment">// namespace galaxy_one</span><br>&#125;  <span class="hljs-comment">// namespace hardware</span><br>&#125;  <span class="hljs-comment">// namespace android</span><br></code></pre></td></tr></table></figure><h4 id="5-3-4-模块编译"><a href="#5-3-4-模块编译" class="headerlink" title="5.3.4 模块编译"></a>5.3.4 模块编译</h4><p>现在除了需要的 <strong>rc</strong> 文件没有补充、<strong>galaxy-hal-service</strong> 服务没有生成外其余均已配置好了，现在进行编译生成对应的库。进入根目录下执行如下命令：(注意是在刚刚执行过的 <strong>source build&#x2F;envsetup.sh</strong> 和 <strong>lunch</strong> 的窗口下编译，若是新窗口则需要重新执行这两条命令)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mmm  hardware/interfaces/galaxy_one/1.0<br></code></pre></td></tr></table></figure><p>此时应该可以在 <strong>out&#x2F;tartget&#x2F;product&#x2F;XXX&#x2F;vendor&#x2F;lib64&#x2F;hw</strong> 和 <strong>out&#x2F;tartget&#x2F;product&#x2F;XXX&#x2F;system&#x2F;lib64&#x2F;hw</strong> 目录下找到 <strong><a href="mailto:&#97;&#110;&#100;&#114;&#x6f;&#105;&#100;&#46;&#104;&#x61;&#114;&#x64;&#119;&#97;&#114;&#x65;&#46;&#103;&#x61;&#x6c;&#97;&#x78;&#121;&#95;&#x6f;&#110;&#x65;&#x40;&#x31;&#x2e;&#x30;&#x2d;&#105;&#109;&#112;&#x6c;&#x2e;&#x73;&#x6f;">&#97;&#110;&#100;&#114;&#x6f;&#105;&#100;&#46;&#104;&#x61;&#114;&#x64;&#119;&#97;&#114;&#x65;&#46;&#103;&#x61;&#x6c;&#97;&#x78;&#121;&#95;&#x6f;&#110;&#x65;&#x40;&#x31;&#x2e;&#x30;&#x2d;&#105;&#109;&#112;&#x6c;&#x2e;&#x73;&#x6f;</a></strong> 和 <strong><a href="mailto:&#97;&#x6e;&#100;&#114;&#x6f;&#x69;&#100;&#46;&#104;&#97;&#x72;&#x64;&#x77;&#97;&#114;&#x65;&#x2e;&#x67;&#x61;&#x6c;&#97;&#x78;&#x79;&#x5f;&#111;&#x6e;&#101;&#64;&#49;&#46;&#x30;&#x2e;&#x73;&#111;">&#97;&#x6e;&#100;&#114;&#x6f;&#x69;&#100;&#46;&#104;&#97;&#x72;&#x64;&#x77;&#97;&#114;&#x65;&#x2e;&#x67;&#x61;&#x6c;&#97;&#x78;&#x79;&#x5f;&#111;&#x6e;&#101;&#64;&#49;&#46;&#x30;&#x2e;&#x73;&#111;</a></strong> 两个动态库</p><h4 id="5-3-5-service生成"><a href="#5-3-5-service生成" class="headerlink" title="5.3.5 service生成"></a>5.3.5 service生成</h4><p>上面过程将需要的动态库生成完毕，接下来我们需要生成对应的 service 可执行文件，这个过程一共分为三步：</p><p><strong>1、向&#x2F;default下的Android.bp 文件添加以下内容</strong></p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs make">cc_library &#123;<br>    name: <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0-service&quot;</span>,<br>    defaults: [<span class="hljs-string">&quot;hidl_defaults&quot;</span>],<br>    relative_install_path: <span class="hljs-string">&quot;hw&quot;</span>,<br>    vendor: true,<br>    srcs: [<br>        <span class="hljs-string">&quot;service.cpp&quot;</span><br>    ],<br>    init_rc: [<span class="hljs-string">&quot;android.hardware.galaxy_one@1.0-service.rc&quot;</span>],<br>    shared_libs: [<br>        <span class="hljs-string">&quot;liblog&quot;</span>,<br>        <span class="hljs-string">&quot;libhidlbase&quot;</span>,<br>        <span class="hljs-string">&quot;libhidltransport&quot;</span>,<br>        <span class="hljs-string">&quot;libhwbinder&quot;</span>,<br>        <span class="hljs-string">&quot;libutils&quot;</span>,<br>        <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0&quot;</span>,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、补充 service.cpp 内容</strong></p><p>内容很简单，<strong>defaultPassthroughServiceImplementation</strong> 帮我们自动注册服务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_TAG <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0-service&quot;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hardware/galaxy_one/1.0/IGalaxyOne.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/LegacySupport.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GalaxyOne.h&quot;</span></span><br> <br><span class="hljs-comment">// Generated HIDL files</span><br><span class="hljs-keyword">using</span> android::hardware::galaxy_one::V1_0::IGalaxyOne;<br><span class="hljs-keyword">using</span> android::hardware::galaxy_one::V1_0::implementation::GalaxyOne;<br> <br><span class="hljs-keyword">using</span> android::hardware::defaultPassthroughServiceImplementation;<br><span class="hljs-keyword">using</span> android::hardware::configureRpcThreadpool;<br><span class="hljs-keyword">using</span> android::hardware::joinRpcThreadpool;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">defaultPassthroughServiceImplementation</span>&lt;IGalaxyOne&gt;();<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>3、补充 rc 文件</strong></p><p>注意这里的 <strong>galaxy-hal-service</strong> 相当于这个服务的别名，系统就是根据这个文件在启动的同时也将这个 service 启动，因此在下面我们手动启动测试时没有什么作用，不过这里先补充完整。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">service galaxy-hal-service /vendor/bin/hw/android.hardware.galaxy_one@1.0-service<br>    class hal<br>    user system<br>    group system<br></code></pre></td></tr></table></figure><p>同样执行 <strong>mmm hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0</strong> 命令，完成之后就会得到如下二进制可执行文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ba">out/target/product/sailfish/vendor/bin/hw/android.hardware.galaxy_one@1.0-service<br></code></pre></td></tr></table></figure><h3 id="5-4-client端"><a href="#5-4-client端" class="headerlink" title="5.4 client端"></a>5.4 client端</h3><p>经过一系列过程之后，我们得到了三个产物<br>1、<strong><a href="mailto:&#97;&#x6e;&#100;&#114;&#x6f;&#105;&#100;&#46;&#104;&#x61;&#114;&#x64;&#x77;&#x61;&#x72;&#101;&#46;&#x67;&#x61;&#x6c;&#x61;&#x78;&#x79;&#95;&#x6f;&#x6e;&#x65;&#x40;&#49;&#46;&#48;&#x2e;&#x73;&#x6f;">&#97;&#x6e;&#100;&#114;&#x6f;&#105;&#100;&#46;&#104;&#x61;&#114;&#x64;&#x77;&#x61;&#x72;&#101;&#46;&#x67;&#x61;&#x6c;&#x61;&#x78;&#x79;&#95;&#x6f;&#x6e;&#x65;&#x40;&#49;&#46;&#48;&#x2e;&#x73;&#x6f;</a></strong><br>2、<strong><a href="mailto:&#x61;&#x6e;&#x64;&#114;&#x6f;&#105;&#x64;&#x2e;&#x68;&#x61;&#x72;&#100;&#119;&#x61;&#114;&#101;&#46;&#x67;&#x61;&#x6c;&#97;&#x78;&#121;&#x5f;&#111;&#110;&#x65;&#64;&#x31;&#x2e;&#48;&#x2d;&#105;&#x6d;&#112;&#108;&#x2e;&#x73;&#111;">&#x61;&#x6e;&#x64;&#114;&#x6f;&#105;&#x64;&#x2e;&#x68;&#x61;&#x72;&#100;&#119;&#x61;&#114;&#101;&#46;&#x67;&#x61;&#x6c;&#97;&#x78;&#121;&#x5f;&#111;&#110;&#x65;&#64;&#x31;&#x2e;&#48;&#x2d;&#105;&#x6d;&#112;&#108;&#x2e;&#x73;&#111;</a></strong><br>3、<strong><a href="mailto:&#x61;&#x6e;&#x64;&#x72;&#111;&#105;&#100;&#46;&#x68;&#x61;&#x72;&#100;&#119;&#97;&#114;&#x65;&#46;&#x67;&#x61;&#108;&#97;&#120;&#x79;&#x5f;&#x6f;&#x6e;&#101;&#64;&#x31;&#x2e;&#x30;&#x2d;&#x73;&#101;&#114;&#118;&#x69;&#99;&#101;">&#x61;&#x6e;&#x64;&#x72;&#111;&#105;&#100;&#46;&#x68;&#x61;&#x72;&#100;&#119;&#97;&#114;&#x65;&#46;&#x67;&#x61;&#108;&#97;&#120;&#x79;&#x5f;&#x6f;&#x6e;&#101;&#64;&#x31;&#x2e;&#x30;&#x2d;&#x73;&#101;&#114;&#118;&#x69;&#99;&#101;</a></strong></p><p>现在需要模拟一个客户端来测试调用，因此在 <strong>default</strong> 目录下新建 <strong>test</strong> 目录，并新建 <strong>client.cpp、Android.bp</strong> 文件，具体结构如下：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-cfccd9a1dea02880.png" style="zoom: 67%;"><p><strong>client.cpp 内容如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hardware/galaxy_one/1.0/IGalaxyOne.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/Status.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;log/log.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> android::sp;<br><span class="hljs-keyword">using</span> android::hardware::galaxy_one::V1_0::IGalaxyOne;<br><span class="hljs-keyword">using</span> android::hardware::Return;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    android::sp&lt;IGalaxyOne&gt; service = IGalaxyOne::<span class="hljs-built_in">getService</span>();<br>    <span class="hljs-keyword">if</span> (service == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;faile to get galaxy_one service......&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;success to get galaxy_one service.....&quot;</span>);<br><br>    <span class="hljs-type">uint32_t</span> addResult = service-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;galaxy_one service add: result = %d&quot;</span>,(<span class="hljs-type">int</span>)addResult);<br><br>    <span class="hljs-type">uint32_t</span> subResult = service-&gt;<span class="hljs-built_in">sub</span>(<span class="hljs-number">8</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;galaxy_one service sub: result = %d&quot;</span>,(<span class="hljs-type">int</span>)subResult);<br><br>    <span class="hljs-type">uint32_t</span> mulResult = service-&gt;<span class="hljs-built_in">mul</span>(<span class="hljs-number">3</span>,<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;galaxy_one service mul: result = %d&quot;</span>,(<span class="hljs-type">int</span>)mulResult);<br><br>    <span class="hljs-type">uint32_t</span> divResult = service-&gt;<span class="hljs-built_in">div</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;galaxy_one service div: result = %d&quot;</span>,(<span class="hljs-type">int</span>)divResult);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Android.bp 内容如下：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cc_binary &#123;<br>    name: <span class="hljs-string">&quot;galaxy_test&quot;</span>,    //表示生成的 client 名称<br>    srcs: [<br>        <span class="hljs-string">&quot;client.cpp&quot;</span><br>    ],<br>    shared_libs: [<br>        <span class="hljs-string">&quot;liblog&quot;</span>,<br>        <span class="hljs-string">&quot;android.hardware.galaxy_one@1.0&quot;</span>,<br>        <span class="hljs-string">&quot;libhidlbase&quot;</span>,<br>        <span class="hljs-string">&quot;libhidltransport&quot;</span>,<br>        <span class="hljs-string">&quot;libhwbinder&quot;</span>,<br>        <span class="hljs-string">&quot;libutils&quot;</span>,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>mmm hardware&#x2F;interfaces&#x2F;galaxy_one&#x2F;1.0</strong> 命令编译之后，可以在 <strong>out&#x2F;target&#x2F;product&#x2F;XXX&#x2F;system&#x2F;bin</strong> 目录下找到 <strong>galaxy_test</strong> 。</p><h3 id="5-5-声明使得Framework可以识别"><a href="#5-5-声明使得Framework可以识别" class="headerlink" title="5.5 声明使得Framework可以识别"></a>5.5 声明使得Framework可以识别</h3><p><strong>HIDL</strong> 想要被 <strong>framework</strong> 获取使用还需要在 <strong>manifest.xml</strong> 中注册，此文件位于 <code>device/[companyName]/[productName]/manifest.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">hal</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;hidl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>android.hardware.galaxy_one<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transport</span>&gt;</span>hwbinder<span class="hljs-tag">&lt;/<span class="hljs-name">transport</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">interface</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>IGalaxyOne<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">instance</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">instance</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">interface</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fqname</span>&gt;</span>@1.0::IGalaxyOne/default<span class="hljs-tag">&lt;/<span class="hljs-name">fqname</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">hal</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-6-添加sepolicy策略"><a href="#5-6-添加sepolicy策略" class="headerlink" title="5.6 添加sepolicy策略"></a>5.6 添加sepolicy策略</h3><p>本文暂时关闭selinux</p><h2 id="6-验证服务"><a href="#6-验证服务" class="headerlink" title="6.验证服务"></a>6.验证服务</h2><h3 id="6-1-push设备"><a href="#6-1-push设备" class="headerlink" title="6.1 push设备"></a>6.1 push设备</h3><p>现在我们一共得到 4 个产物，使用 <strong>adb</strong> 命令将其 <strong>push</strong> 到手机对应目录下：</p><p>1、<a href="mailto:&#97;&#110;&#x64;&#114;&#x6f;&#x69;&#100;&#46;&#x68;&#x61;&#114;&#100;&#x77;&#97;&#114;&#101;&#46;&#x67;&#97;&#108;&#x61;&#120;&#x79;&#x5f;&#111;&#110;&#x65;&#64;&#49;&#x2e;&#x30;&#x2d;&#105;&#x6d;&#112;&#108;&#x2e;&#115;&#x6f;">&#97;&#110;&#x64;&#114;&#x6f;&#x69;&#100;&#46;&#x68;&#x61;&#114;&#100;&#x77;&#97;&#114;&#101;&#46;&#x67;&#97;&#108;&#x61;&#120;&#x79;&#x5f;&#111;&#110;&#x65;&#64;&#49;&#x2e;&#x30;&#x2d;&#105;&#x6d;&#112;&#108;&#x2e;&#115;&#x6f;</a> &#x3D;&#x3D;&#x3D;&gt; &#x2F;vendor&#x2F;lib64&#x2F;hw<br>2、<a href="mailto:&#x61;&#x6e;&#x64;&#x72;&#111;&#x69;&#100;&#46;&#x68;&#x61;&#114;&#100;&#119;&#x61;&#114;&#101;&#x2e;&#103;&#97;&#108;&#97;&#x78;&#121;&#x5f;&#x6f;&#110;&#101;&#64;&#49;&#46;&#48;&#x2e;&#x73;&#x6f;">&#x61;&#x6e;&#x64;&#x72;&#111;&#x69;&#100;&#46;&#x68;&#x61;&#114;&#100;&#119;&#x61;&#114;&#101;&#x2e;&#103;&#97;&#108;&#97;&#x78;&#121;&#x5f;&#x6f;&#110;&#101;&#64;&#49;&#46;&#48;&#x2e;&#x73;&#x6f;</a> &#x3D;&#x3D;&#x3D;&gt; vendor&#x2F;lib64<br>3、<a href="mailto:&#x61;&#x6e;&#x64;&#x72;&#111;&#x69;&#100;&#x2e;&#x68;&#97;&#114;&#100;&#x77;&#97;&#x72;&#x65;&#46;&#x67;&#97;&#x6c;&#x61;&#x78;&#121;&#x5f;&#x6f;&#x6e;&#x65;&#64;&#49;&#46;&#x30;&#x2d;&#x73;&#x65;&#114;&#x76;&#105;&#99;&#101;">&#x61;&#x6e;&#x64;&#x72;&#111;&#x69;&#100;&#x2e;&#x68;&#97;&#114;&#100;&#x77;&#97;&#x72;&#x65;&#46;&#x67;&#97;&#x6c;&#x61;&#x78;&#121;&#x5f;&#x6f;&#x6e;&#x65;&#64;&#49;&#46;&#x30;&#x2d;&#x73;&#x65;&#114;&#x76;&#105;&#99;&#101;</a> &#x3D;&#x3D;&#x3D;&gt; &#x2F;vendor&#x2F;bin&#x2F;hw<br>4、galaxy_test &#x3D;&#x3D;&#x3D;&gt; &#x2F;system&#x2F;bin</p><h3 id="6-2-运行service"><a href="#6-2-运行service" class="headerlink" title="6.2 运行service"></a>6.2 运行service</h3><p>这里我们手动启动，用于测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./vendor/bin/hw/android.hardware.galaxy_one@1.0-service<br></code></pre></td></tr></table></figure><h3 id="6-3-运行client"><a href="#6-3-运行client" class="headerlink" title="6.3 运行client"></a>6.3 运行client</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./system/bin/galaxy_test<br></code></pre></td></tr></table></figure><p>运行成功之后可查看日志，有如下内容则表示服务建立成功：</p><img src="/2023/03/10/Android-HIDL%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/11806352-a17a33c648493e73.png" style="zoom: 75%;">]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件系统mount过程</title>
    <link href="/2023/03/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fmount%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/03/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fmount%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统mount过程"><a href="#文件系统mount过程" class="headerlink" title="文件系统mount过程"></a>文件系统mount过程</h1><blockquote><p>🍒 <strong>环境</strong>：内核版本4.5</p><p>🍉 <strong>说明</strong>：参考<a href="https://blog.csdn.net/zr_lang/article/details/39963253%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2%EF%BC%8C%E6%94%B6%E8%8E%B7%E9%A2%87%E4%B8%B0">https://blog.csdn.net/zr_lang/article/details/39963253，非常感谢，收获颇丰</a></p></blockquote><p>从用户下发mount指令到具体的文件系统进行挂载，大致经历了下面的步骤【以<code>f2fs</code>文件系统为例】。</p><img src="/2023/03/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fmount%E8%BF%87%E7%A8%8B/image-20230309225903725.png" alt="image-20230309225903725" style="zoom: 67%;"><h2 id="1-每个人该有的样子file-system-type"><a href="#1-每个人该有的样子file-system-type" class="headerlink" title="1.每个人该有的样子file_system_type"></a>1.每个人该有的样子file_system_type</h2><p>每个人在冲浪的都有自己的昵称，自己的个性标签，这仿佛是每个人共同的样子，不妨将所有的文件系统也抽象成同一个样子表示<code>file_system_type</code>，每一个文件系统肯定有</p><ul><li>name: 文件系统的名字，如xfs, ext2等</li><li>fs_flags: 说明文件系统的类型</li><li>mount: 代替早期的get_sb()，用户挂载此文件系统时使用的回调函数。</li><li>kill_sb: 删除内存中的super block，在卸载文件系统时使用。</li><li>owner: 指向实现这个文件系统的模块，通常为THIS_MODULE宏。</li><li>next: 指向文件系统类型链表的下一个文件系统类型。</li><li>fs_supers: 具有同样此文件系统类型的超级块结构，都串连在这个表头下。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include\linux\fs.h</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> &#123;</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>        <span class="hljs-type">int</span> fs_flags;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_REQUIRES_DEV         1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_BINARY_MOUNTDATA     2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_HAS_SUBTYPE          4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_USERNS_MOUNT         8       <span class="hljs-comment">/* Can be mounted by userns root */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_USERNS_DEV_MOUNT     16 <span class="hljs-comment">/* A userns mount does not imply MNT_NODEV */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_RENAME_DOES_D_MOVE   32768   <span class="hljs-comment">/* FS will handle d_move() during rename() internally. */</span></span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *(*<span class="hljs-title">mount</span>) (<span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> *, <span class="hljs-title">int</span>, <span class="hljs-title">const</span> <span class="hljs-title">char</span> *, <span class="hljs-title">void</span> *);</span><br>        <span class="hljs-type">void</span> (*kill_sb) (<span class="hljs-keyword">struct</span> super_block *);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> * <span class="hljs-title">next</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span> <span class="hljs-title">fs_supers</span>;</span><br>       <span class="hljs-comment">// ....</span><br>        <span class="hljs-comment">//为了说明方便，此处省略若干锁相关变量。</span><br>        <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在kernel的<code>/fs</code>有各种各样的文件系统，file_system_type结构一般被定义在super.c。下面以<strong>f2fs</strong>文件系统为例介绍一下他的<code>file_system_type</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs\f2fs\super.c</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> <span class="hljs-title">f2fs_fs_type</span> =</span> &#123;<br>.owner= THIS_MODULE,<br>.name= <span class="hljs-string">&quot;f2fs&quot;</span>,<br>.mount= f2fs_mount,<br>.kill_sb= kill_f2fs_super,<br>.fs_flags= FS_REQUIRES_DEV,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>owner说明f2fs模块本身拥有这个file_system_type。</p></li><li><p>name是f2fs。</p></li><li><p>fs_flags是FS_REQUIRES_DEV，表明f2fs一定要被使用在物理设备上。</p></li><li><p>mount是f2fs_mount，说明 f2fs_mount这个函数实现了f2fs的具体mount操作。在第3节阐述</p></li></ul><h2 id="2-注册账号register-filesystem"><a href="#2-注册账号register-filesystem" class="headerlink" title="2.注册账号register_filesystem"></a>2.注册账号register_filesystem</h2><p>当然，你自己想象好了自己的昵称，自己的个性表型，自己的能力，还有自己的一份简历【superblock】，不注册账号怎么冲浪嘛🏄</p><p>同理当初始化好了一个具体的文件系统，我们也要向内核进行注册<code>register_filesystem</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">register_filesystem</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file_system_type * fs)</span><br>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> ** <span class="hljs-title">p</span>;</span><br> <br>        BUG_ON(<span class="hljs-built_in">strchr</span>(fs-&gt;name, <span class="hljs-string">&#x27;.&#x27;</span>));<br>        <span class="hljs-keyword">if</span> (fs-&gt;next)<br>                <span class="hljs-keyword">return</span> -EBUSY;<br>        write_lock(&amp;file_systems_lock);<br>       <br>        <span class="hljs-comment">// 遍历全局file_systems链表，尝试查找本次要注册文件系统名。</span><br>        p = find_filesystem(fs-&gt;name, <span class="hljs-built_in">strlen</span>(fs-&gt;name));<br>        <span class="hljs-keyword">if</span> (*p) <span class="hljs-comment">// 如果不为NULL，则说明找到了重名的文件系统。注册失败。</span><br>                res = -EBUSY;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果返回NULL，说明已经到链表结尾，可以注册此文件系统。</span><br>                *p = fs; <span class="hljs-comment">// 将此文件系统链接到链表结尾。</span><br>        write_unlock(&amp;file_systems_lock);<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>file_system_type的基本操作都在fs&#x2F;filesystems.c文件里，文件不长，可以简短的浏览一下都有那些操作函数。最主要的变量莫过于此文件内的全局变量：</p><p>&#x2F;&#x2F; 此变量是文件系统类型单链表的头指针<code>static struct file_system_type *file_systems</code></p></blockquote><p>那么f2fs在哪里注册的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">init_f2fs_fs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    err = register_filesystem(&amp;f2fs_fs_type);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-开始属于f2fs的mount"><a href="#3-开始属于f2fs的mount" class="headerlink" title="3.开始属于f2fs的mount"></a>3.开始属于f2fs的mount</h2><p>在文章的开头我们可以看到，如果在用户空间执行<code>mount -t f2fs /dev/xxx /mntdir/xxx</code>，那么最终会去调用f2fs的mount函数，在第1节的f2fs_fs_type指明了f2fs文件系统的mount函数为<code>f2fs_mount</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dentry *<span class="hljs-title function_">f2fs_mount</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file_system_type *fs_type, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *dev_name, <span class="hljs-type">void</span> *data)</span><br>&#123;<br><span class="hljs-keyword">return</span> mount_bdev(fs_type, flags, dev_name, data, f2fs_fill_super);<br>&#125;<br></code></pre></td></tr></table></figure><p>看起来就是一个mount_bdev()函数，但是看参数可以看到一些重要的东西</p><ul><li>fs_type不用多说，携带file_system_type的信息，这里传递它主要是因为它携带了super block的链表和很多锁变量。</li><li>flags文件系统的通用挂载选项。</li><li>dev_name是mount操作时的设备名，如&#x2F;dev&#x2F;sda1。后面会用到这个设备名找到对应的设备信息，从而从中获得super block。</li><li>data是挂载时指定的挂载选项信息。</li><li>f2fs_fill_super是一个由f2fs特定实现的fill_super方法，用来根据f2fs文件系统的特性解析mount data并继续填充super block的字段，并且初始化挂载点的根索引节点对象和目录项对象。</li></ul><h2 id="4-挂载选项flag和data"><a href="#4-挂载选项flag和data" class="headerlink" title="4.挂载选项flag和data"></a>4.挂载选项flag和data</h2><p>在第3节中我们可以看到f2fs挂载的时候有flags和data，但是我们平常挂载的只有一个<code>- o</code>参数啊，例如<code>mount -t f2fs -o ro /dev/xxx /mntdir/xxx</code>。那么我们如何区分具体的flag和data呢？</p><p>先来看一下flags都有哪些可选值(取自<code>include/uapi/linux/fs.h</code>)，我们来尽量把它们和mount命令里的选项对应一下(man 2 mount)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * These are the fs-independent mount-flags: up to 32 flags are supported</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RDONLY        1         <span class="hljs-comment">/* 对应-o ro/rw */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSUID        2         <span class="hljs-comment">/* 对应-o suid/nosuid */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODEV         4         <span class="hljs-comment">/*  对应-o suid/nosuid */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOEXEC        8         <span class="hljs-comment">/* 对应-o exec/noexec */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SYNCHRONOUS  16         <span class="hljs-comment">/* 对应-o sync/async */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REMOUNT      32         <span class="hljs-comment">/* 对应-o remount，告诉mount这是一次remount操作 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MANDLOCK     64         <span class="hljs-comment">/* 对应-o mand/nomand */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_DIRSYNC      128        <span class="hljs-comment">/* 对应-o dirsync */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOATIME      1024       <span class="hljs-comment">/* 对应-o atime/noatime */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODIRATIME   2048       <span class="hljs-comment">/* 对应-o diratime/nodiratime */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BIND         4096       <span class="hljs-comment">/* 对应-B/--bind选项，告诉mount这是一次bind操作 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MOVE         8192       <span class="hljs-comment">/* 对应-M/--move，告诉mount这是一次move操作 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REC          16384      <span class="hljs-comment">/* rec是recursive的意思，这个flag一般不单独出现，都是伴随这其它flag，表示递归的进行操作 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_VERBOSE      32768      <span class="hljs-comment">/* 对应-v/--verbose */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SILENT       32768      <span class="hljs-comment">/* 对应-o silent/loud */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_POSIXACL     (1&lt;&lt;16)    <span class="hljs-comment">/* 让VFS不应用umask，如NFS */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_UNBINDABLE   (1&lt;&lt;17)    <span class="hljs-comment">/* 对应--make-unbindable */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_PRIVATE      (1&lt;&lt;18)    <span class="hljs-comment">/* 对应--make-private */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SLAVE        (1&lt;&lt;19)    <span class="hljs-comment">/* 对应--make-slave */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SHARED       (1&lt;&lt;20)    <span class="hljs-comment">/* 对应--make-shared */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RELATIME     (1&lt;&lt;21)    <span class="hljs-comment">/* 对应-o relatime/norelatime */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_KERNMOUNT    (1&lt;&lt;22)    <span class="hljs-comment">/* 这个一般不在应用层使用，一般内核挂载的文件系统如sysfs使用，表示使用kern_mount()进行挂载 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_I_VERSION    (1&lt;&lt;23)    <span class="hljs-comment">/* 对应-o iversion/noiversion */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_STRICTATIME  (1&lt;&lt;24)    <span class="hljs-comment">/* 对应-o strictatime/nostrictatime */</span></span><br> <br><span class="hljs-comment">/* 下面这几个flags都是内核内部使用的，它们的含义我只是通过简单的查看代码逻辑暂时猜测的 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSEC        (1&lt;&lt;28)    <span class="hljs-comment">/* 有些文件系统不支持suid，security xattr等安全标记 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BORN         (1&lt;&lt;29)    <span class="hljs-comment">/* 表示内存superblock已经创建完成 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_ACTIVE       (1&lt;&lt;30)    <span class="hljs-comment">/* 表示内存superblock正处于活动状态 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOUSER       (1&lt;&lt;31)    <span class="hljs-comment">/* 表示文件系统不能被应用层挂载使用，只能被内核使用，如rootfs */</span></span><br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Superblock flags that can be altered by MS_REMOUNT</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RMT_MASK     (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION)  <span class="hljs-comment">// 可以在remount是改变的flags</span></span><br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Old magic mount flag and mask</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_VAL 0xC0ED0000      <span class="hljs-comment">/* 过去使用的magic，现在基本被忽略了 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_MSK 0xffff0000      <span class="hljs-comment">/* 过去使用的flag的的mask */</span></span><br></code></pre></td></tr></table></figure><p>从上面可以看出，flags基本上是options中通用的那些，也就是说基本是<strong>面向所有文件系统通用的</strong>，当然还有一些是内核使用的。这些flags大部分都在VFS层被解析使用。</p><p>而data呢，把options中通用的去掉，<strong>剩下的就是每个文件系统各自支持的挂载选项</strong>。</p><p>🎈让我们来看个例子：我们选取一个与flags对应的option，如nodev。在从xfs【也是一种文件系统】中选取一个特定的option，如noquota。然后用strace跟踪一下mount的过程，执行</p><p><code>strace mount /dev/loop0 /mnt/test -o noquota,nodev</code></p><p>在接近最后的位置我们可以看到mount系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mount(<span class="hljs-string">&quot;/dev/loop0&quot;</span>, <span class="hljs-string">&quot;/mnt/test&quot;</span>, <span class="hljs-string">&quot;xfs&quot;</span>, MS_MGC_VAL|MS_NODEV, <span class="hljs-string">&quot;noquota&quot;</span>) = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>果然，nodev被解释为flag，noquota被当作了mount data。</p><h2 id="5-mount系统调用的实现（sys-mount）"><a href="#5-mount系统调用的实现（sys-mount）" class="headerlink" title="5.mount系统调用的实现（sys_mount）"></a>5.mount系统调用的实现（sys_mount）</h2><p>如果要研究mount的执行过程先要找到mount的发起位置，有些mount是内核发起的，由内核自主挂载。而绝大部分的mount都是用户通过mount系统调用发起的，我们就以后者为起点开始分析。<strong>mount系统调用</strong>（sys_mount）定义在fs&#x2F;namespace.c中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs\namespace.c</span><br><br>SYSCALL_DEFINE5(mount, <span class="hljs-type">char</span> __user *, dev_name, <span class="hljs-type">char</span> __user *, dir_name,<br>                <span class="hljs-type">char</span> __user *, type, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, flags, <span class="hljs-type">void</span> __user *, data)<br>&#123;<br>        <span class="hljs-type">int</span> ret;<br>        <span class="hljs-type">char</span> *kernel_type;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filename</span> *<span class="hljs-title">kernel_dir</span>;</span><br>        <span class="hljs-type">char</span> *kernel_dev;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data_page;<br> <br>        <span class="hljs-comment">/* 拷贝得到文件系统类型名 */</span><br>        ret = copy_mount_string(type, &amp;kernel_type);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">goto</span> out_type;<br> <br>        <span class="hljs-comment">/* 得到文件系统挂载点名 */</span><br>        kernel_dir = getname(dir_name);<br>        <span class="hljs-keyword">if</span> (IS_ERR(kernel_dir)) &#123;<br>                ret = PTR_ERR(kernel_dir);<br>                <span class="hljs-keyword">goto</span> out_dir;<br>        &#125;<br> <br>        <span class="hljs-comment">/* 拷贝得到文件系统所在的设备名 */</span><br>        ret = copy_mount_string(dev_name, &amp;kernel_dev);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">goto</span> out_dev;<br> <br>        <span class="hljs-comment">/* 拷贝得到文件系统定制的mount data */</span><br>        ret = copy_mount_options(data, &amp;data_page);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">goto</span> out_data;<br> <br>        <span class="hljs-comment">/* 到此mount所需要的fstype, dev_name, mountpoint, flags和data这几个参数都拷贝到内核空间了 */</span><br>        <span class="hljs-comment">/* 调用do_mount函数继续下面的操作 */</span><br>        ret = do_mount(kernel_dev, kernel_dir-&gt;name, kernel_type, flags,<br>                (<span class="hljs-type">void</span> *) data_page);<br> <br>        free_page(data_page);<br>out_data:<br>        kfree(kernel_dev);<br>out_dev:<br>        putname(kernel_dir);<br>out_dir:<br>        kfree(kernel_type);<br>out_type:<br>        <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-do-mount调用"><a href="#6-do-mount调用" class="headerlink" title="6.do_mount调用"></a>6.do_mount调用</h2><p>系统调用sys_mount后，会继续执行do_mount函数，该函数在VFS层。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">do_mount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *dev_name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dir_name,</span><br><span class="hljs-params">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *type_page, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-type">void</span> *data_page)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">path</span> <span class="hljs-title">path</span>;</span><br>        <span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> mnt_flags = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">/* Discard magic */</span><br>        <span class="hljs-keyword">if</span> ((flags &amp; MS_MGC_MSK) == MS_MGC_VAL)<br>                flags &amp;= ~MS_MGC_MSK;<br>        <span class="hljs-comment">/* Basic sanity checks */</span><br>        <span class="hljs-keyword">if</span> (!dir_name || !*dir_name || !<span class="hljs-built_in">memchr</span>(dir_name, <span class="hljs-number">0</span>, PAGE_SIZE))<br>                <span class="hljs-keyword">return</span> -EINVAL;<br>        <span class="hljs-keyword">if</span> (data_page)<br>                ((<span class="hljs-type">char</span> *)data_page)[PAGE_SIZE - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 把mountpoint解释成path内核结构，这里是路径名解析的过程</span><br>        <span class="hljs-comment">// 调用do_path_lookup。关于路径名解析我们后面再说</span><br>        <span class="hljs-comment">/* ... and get the mountpoint */</span><br>        retval = kern_path(dir_name, LOOKUP_FOLLOW, &amp;path);<br>        <span class="hljs-keyword">if</span> (retval)<br>                <span class="hljs-keyword">return</span> retval;<br>        retval = security_sb_mount(dev_name, &amp;path,<br>                                   type_page, flags, data_page);<br>        <span class="hljs-keyword">if</span> (!retval &amp;&amp; !may_mount())<br>                retval = -EPERM;<br>        <span class="hljs-keyword">if</span> (retval)<br>                <span class="hljs-keyword">goto</span> dput_out;<br>        <span class="hljs-comment">// 从这里开始就是一系列的对flags的解析，把通用option提出来</span><br>        <span class="hljs-comment">// 并且找出我们要mount做哪种操作，如bind, remount, newmount等</span><br>        <span class="hljs-comment">/* Default to relatime unless overriden */</span><br>        <span class="hljs-keyword">if</span> (!(flags &amp; MS_NOATIME))<br>                mnt_flags |= MNT_RELATIME;<br>        <span class="hljs-comment">/* Separate the per-mountpoint flags */</span><br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NOSUID)<br>                mnt_flags |= MNT_NOSUID;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NODEV)<br>                mnt_flags |= MNT_NODEV;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NOEXEC)<br>                mnt_flags |= MNT_NOEXEC;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NOATIME)<br>                mnt_flags |= MNT_NOATIME;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_NODIRATIME)<br>                mnt_flags |= MNT_NODIRATIME;<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_STRICTATIME)<br>                mnt_flags &amp;= ~(MNT_RELATIME | MNT_NOATIME);<br>        <span class="hljs-keyword">if</span> (flags &amp; MS_RDONLY)<br>                mnt_flags |= MNT_READONLY;<br>        <span class="hljs-comment">/* The default atime for remount is preservation */</span><br>        <span class="hljs-keyword">if</span> ((flags &amp; MS_REMOUNT) &amp;&amp;<br>            ((flags &amp; (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |<br>                       MS_STRICTATIME)) == <span class="hljs-number">0</span>)) &#123;<br>                mnt_flags &amp;= ~MNT_ATIME_MASK;<br>                mnt_flags |= path.mnt-&gt;mnt_flags &amp; MNT_ATIME_MASK;<br>        &#125;<br>        flags &amp;= ~(MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_ACTIVE | MS_BORN |<br>                   MS_NOATIME | MS_NODIRATIME | MS_RELATIME| MS_KERNMOUNT |<br>                   MS_STRICTATIME);<br>        <span class="hljs-comment">// 根据flags的指示，决定做哪种mount操作</span><br>        <span class="hljs-keyword">if</span> (flags &amp; MS_REMOUNT)<br>                retval = do_remount(&amp;path, flags &amp; ~MS_REMOUNT, mnt_flags,<br>                                    data_page);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flags &amp; MS_BIND)<br>                retval = do_loopback(&amp;path, dev_name, flags &amp; MS_REC);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flags &amp; (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))<br>                retval = do_change_type(&amp;path, flags);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flags &amp; MS_MOVE)<br>                retval = do_move_mount(&amp;path, dev_name);<br>        <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 我们这里以new mount为入手点，继续向下分析</span><br>                retval = do_new_mount(&amp;path, type_page, flags, mnt_flags,<br>                                      dev_name, data_page);<br>dput_out:<br>        path_put(&amp;path);<br>        <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上所述，我们得出do_mount主要干这么几个事：</p><ol><li><p>解析mountpoint路径名，把字符串路径名变成内核dentry或者说path结构</p></li><li><p>解析flags，把通用option分出来。</p></li><li><p>根据flags中指明mount操作的标志，决定做哪一种mount操作。</p></li><li><p>执行remount&#x2F;bind&#x2F;shared&#x2F;move&#x2F;new mount操作。</p></li></ol><p>到此mount就可能做5种mount操作（remount, bind, chang type, move和new mount）之一。我们以do_new_mount为例继续分析，do_new_mount属于最常见的情况，挂载一个新的文件系统。</p><h2 id="7-do-new-mount调用"><a href="#7-do-new-mount调用" class="headerlink" title="7.do_new_mount调用"></a>7.do_new_mount调用</h2><p>do_new_mount函数也在namespace.c里可以找到，它主要做三件事：</p><ol><li>根据fstype从全局文件系统类型(file_system_type)链表中找到对应的文件系统类型结构</li><li>用上一步得到的特定文件系统类型结构中的mount回调函数执行下面的挂载操作，最终构建一个mount结构体，其中包含vfsmount信息。</li><li>将得到的mount结构体加入全局文件系统树中</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_new_mount</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> path *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fstype, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">                        <span class="hljs-type">int</span> mnt_flags, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> *<span class="hljs-title">type</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span> *<span class="hljs-title">user_ns</span> =</span> current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vfsmount</span> *<span class="hljs-title">mnt</span>;</span><br>        <span class="hljs-type">int</span> err;<br> <br>        <span class="hljs-keyword">if</span> (!fstype)<br>                <span class="hljs-keyword">return</span> -EINVAL;<br> <br>        <span class="hljs-comment">// 根据fs类型名（如xfs）在全局文件系统类型链表上找到其对应的file_system_type结构</span><br>        type = get_fs_type(fstype);<br>        <span class="hljs-keyword">if</span> (!type)<br>                <span class="hljs-keyword">return</span> -ENODEV;<br> <br>        <span class="hljs-comment">// 调用此函数准备进入每个文件系统的个别处理函数，构建一个vfsmnt结构</span><br>        <span class="hljs-comment">// 注意这里以文件系统类型、挂载标记、设备名和挂载选项信息为参数，并没有mountpoint参数。这里只是想用type中的mount回调函数读取设备的superblock信息，填充mnt结构，然后把flag和data解析后填充到mnt结构中。</span><br>        mnt = vfs_kern_mount(type, flags, name, data);<br>        <span class="hljs-keyword">if</span> (!IS_ERR(mnt) &amp;&amp; (type-&gt;fs_flags &amp; FS_HAS_SUBTYPE) &amp;&amp;<br>            !mnt-&gt;mnt_sb-&gt;s_subtype)<br>                mnt = fs_set_subtype(mnt, fstype);<br> <br>        put_filesystem(type);<br>        <span class="hljs-keyword">if</span> (IS_ERR(mnt))<br>                <span class="hljs-keyword">return</span> PTR_ERR(mnt);<br> <br>        <span class="hljs-comment">// 准备将得到的mnt结构加入全局文件系统树</span><br>        <span class="hljs-comment">// 注意path变量，也就是mountpoint在这里</span><br>        err = do_add_mount(real_mount(mnt), path, mnt_flags);<br>        <span class="hljs-keyword">if</span> (err)<br>                mntput(mnt);<br>        <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="99-向驱动大哥学习，走进file-operations"><a href="#99-向驱动大哥学习，走进file-operations" class="headerlink" title="99.向驱动大哥学习，走进file_operations"></a>99.向驱动大哥学习，走进file_operations</h2><p>我们按照学习驱动的方式，学习整个文件系统的挂载。在学习驱动的时候，最关键的就是字符设备操作集<code>file_operations </code>，我们写驱动的时候会初始化每一个驱动对应的操作集，例如我们编写一个led驱动，我们常常写成下面的样子，每一个file_operation的操作，如open、write都在自己的驱动中指明对应的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">led_fops</span> =</span> &#123;<br>    .owner = THIS_MODULE,<br>    .open = led_open,<br>    .write = led_write,<br>    .release = led_release,<br>&#125;;<br></code></pre></td></tr></table></figure><p>那么文件系统也是通用的道理，也有文件系统自己的操作集<code>file_operations</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include\linux\fs.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-type">loff_t</span> (*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<br><span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br><span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br><span class="hljs-type">ssize_t</span> (*read_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br><span class="hljs-type">ssize_t</span> (*write_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br><span class="hljs-type">int</span> (*iterate) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);<br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *)</span>;<br><span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br><span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br><span class="hljs-type">int</span> (*mremap)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br><span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br><span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);<br><span class="hljs-type">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br><span class="hljs-type">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span> datasync);<br><span class="hljs-type">int</span> (*aio_fsync) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-type">int</span> datasync);<br><span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);<br><span class="hljs-type">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br><span class="hljs-type">ssize_t</span> (*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">int</span>);<br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<br><span class="hljs-type">int</span> (*check_flags)(<span class="hljs-type">int</span>);<br><span class="hljs-type">int</span> (*flock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br><span class="hljs-type">ssize_t</span> (*splice_write)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><span class="hljs-type">ssize_t</span> (*splice_read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><span class="hljs-type">int</span> (*setlease)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">long</span>, <span class="hljs-keyword">struct</span> file_lock **, <span class="hljs-type">void</span> **);<br><span class="hljs-type">long</span> (*fallocate)(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> mode, <span class="hljs-type">loff_t</span> offset,<br>  <span class="hljs-type">loff_t</span> len);<br><span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">struct</span> file *f);<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><br><span class="hljs-type">unsigned</span> (*mmap_capabilities)(<span class="hljs-keyword">struct</span> file *);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>对于一个具体的文件系统ext4、f2fs等，都会指明自己的file_operations，以f2fs为例</p><img src="/2023/03/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fmount%E8%BF%87%E7%A8%8B/image-20230309230859994.png" alt="image-20230309230859994" style="zoom: 67%;"><p>加入我们在用户态执行ioctl操作，那么对应的<code>f2fs_ioct</code>l就会执行。</p>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>懂得了Android I/O调优对你的应用帮助很大（上篇）</title>
    <link href="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/"/>
    <url>/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="懂得了Android-I-x2F-O调优对你的应用帮助很大（上篇）"><a href="#懂得了Android-I-x2F-O调优对你的应用帮助很大（上篇）" class="headerlink" title="懂得了Android I&#x2F;O调优对你的应用帮助很大（上篇）"></a>懂得了Android I&#x2F;O调优对你的应用帮助很大（上篇）</h1><blockquote><p>🍀转载自：<a href="https://www.cnblogs.com/mysweetAngleBaby/articles/16066846.html">https://www.cnblogs.com/mysweetAngleBaby/articles/16066846.html</a></p></blockquote><h2 id="1-I-x2F-O的基本知识"><a href="#1-I-x2F-O的基本知识" class="headerlink" title="1.I&#x2F;O的基本知识"></a>1.I&#x2F;O的基本知识</h2><p>在工作中，我发现很多工程师对I&#x2F;O的认识其实比较模糊，认为I&#x2F;O就是应用程序执行read()、write()这样的一些操作，并不清楚这些操作背后的整个流程是怎样的。</p><img src="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/26731569-b807a907e68b8792.png" style="zoom: 67%;"><p>我画了一张简图，你可以看到整个文件I&#x2F;O操作由应用程序、文件系统和磁盘共同完成。首先应用程序将I&#x2F;O命令发送给文件系统，然后文件系统会在合适的时机把I&#x2F;O操作发给磁盘。<br>这就好比CPU、内存、磁盘三个小伙伴一起完成接力跑，最终跑完的时间很大程度上取决于最慢的小伙伴。我们知道，CPU和内存相比磁盘是高速设备，整个流程的瓶颈在于磁盘I&#x2F;O的性能。所以很多时候，文件系统性能比磁盘性能更加重要，为了降低磁盘对应用程序的影响，文件系统需要通过各种各样的手段进行优化。那么接下来，我们首先来看文件系统。</p><h3 id="1-1-文件系统"><a href="#1-1-文件系统" class="headerlink" title="1.1 文件系统"></a>1.1 文件系统</h3><p>文件系统，简单来说就是存储和组织数据的方式。比如在iOS 10.3系统以后，苹果使用APFS（Apple File System）替代之前旧的文件系统HFS+。对于Android来说，现在普遍使用的是Linux常用的ext4文件系统。</p><p>关于文件系统还需要多说两句，华为在EMUI 5.0以后就使用F2FS取代ext4，Google也在最新的旗舰手机Pixel 3使用了F2FS文件系统。Flash-Friendly File System是三星是专门为NAND闪存芯片开发的文件系统，也做了大量针对闪存的优化。根据华为的测试数据，F2FS文件系统在小文件的随机读写方面比ext4更快，例如随机写可以优化60%，不足之处在于可靠性方面出现过一些问题。我想说的是，随着Google、华为的投入和规模化使用，F2FS系统应该是未来Android的主流文件系统。</p><p>还是回到文件系统的I&#x2F;O。应用程序调用read()方法，系统会通过中断从用户空间进入内核处理流程，然后经过VFS（Virtual File System，虚拟文件系统）、具体文件系统、页缓存Page Cache。下面是Linux一个通用的I&#x2F;O架构模型。</p><img src="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/26731569-a7586fb52f51be3a.png" style="zoom: 67%;"><ul><li>虚拟文件系统（VFS）。它主要用于实现屏蔽具体的文件系统，为应用程序的操作提供一个统一的接口。这样保证就算厂商把文件系统从ext4切换到F2FS，应用程序也不用做任何修改。</li><li>文件系统（File System）。ext4、F2FS都是具体文件系统实现，文件元数据如何组织、目录和索引结构如何设计、怎么分配和清理数据，这些都是设计一个文件系统必须要考虑的。<strong>每个文件系统都有适合自己的应用场景，我们不能说F2FS就一定比ext4要好。</strong>F2FS在连续读取大文件上并没有优势，而且会占用更大的空间。只是对一般应用程序来说，随机I&#x2F;O会更加频繁，特别是在启动的场景。你可以在&#x2F;proc&#x2F;filesystems看到系统可以识别的所有文件系统的列表。</li><li>页缓存（Page Cache）。在启动优化中我已经讲过Page Cache这个概念了，在读文件的时候会，先看它是不是已经在Page Cache中，如果命中就不会去读取磁盘。在Linux 2.4.10之前还有一个单独的Buffer Cache，后来它也合并到Page Cache中的Buffer Page了。</li></ul><p>具体来说，Page Cache就像是我们经常使用的数据缓存，是文件系统对数据的缓存，目的是提升内存命中率。Buffer Cache就像我们经常使用的BufferInputStream，是磁盘对数据的缓存，目的是合并部分文件系统的I&#x2F;O请求、降低磁盘I&#x2F;O的次数。需要注意的是，它们既会用在读请求中，也会用到写请求中。<br>通过&#x2F;proc&#x2F;meminfo文件可以查看缓存的内存占用情况，当手机内存不足的时候，系统会回收它们的内存，这样整体I&#x2F;O的性能就会有所降低。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">MemTotal:    2866492 kB<br>MemFree:      72192 kB<br>Buffers:      62708 kB      // Buffer Cache<br>Cached:      652904 kB      // Page Cache<br></code></pre></td></tr></table></figure><h3 id="1-2-磁盘"><a href="#1-2-磁盘" class="headerlink" title="1.2 磁盘"></a>1.2 磁盘</h3><p>磁盘指的是系统的存储设备，就像小时候我们常听的CD或者电脑使用的机械硬盘，当然还有现在比较流行的SSD固态硬盘。<br>正如我上面所说，如果发现应用程序要read()的数据没有在页缓存中，这时候就需要真正向磁盘发起I&#x2F;O请求。这个过程要先经过内核的通用块层、I&#x2F;O调度层、设备驱动层，最后才会交给具体的硬件设备处理。</p><img src="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/26731569-5a8d09f33aacf7fd.png" style="zoom: 67%;"><ul><li>通用块层。系统中能够随机访问固定大小数据块（block）的设备称为块设备，CD、硬盘和SSD这些都属于块设备。通用块层主要作用是接收上层发出的磁盘请求，并最终发出I&#x2F;O请求。它跟VFS的作用类似，让上层不需要关心底层硬件设备的具体实现。</li><li>I&#x2F;O调度层。磁盘I&#x2F;O那么慢，为了降低真正的磁盘I&#x2F;O，我们不能接收到磁盘请求就立刻交给驱动层处理。所以我们增加了I&#x2F;O调度层，它会根据设置的调度算法对请求合并和排序。这里比较关键的参数有两个，一个是队列长度，一个是具体的调度算法。我们可以通过下面的文件可以查看对应块设备的队列长度和使用的调度算法。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">/sys/block/[disk]/queue/nr_requests      // 队列长度，一般是 128。<br>/sys/block/[disk]/queue/scheduler        // 调度算法<br></code></pre></td></tr></table></figure><ul><li>块设备驱动层。块设备驱动层根据具体的物理设备，选择对应的驱动程序通过操控硬件设备完成最终的I&#x2F;O请求。例如光盘是靠激光在表面烧录存储、闪存是靠电子擦写存储数据</li></ul><h2 id="2-I-x2F-O的性能评估"><a href="#2-I-x2F-O的性能评估" class="headerlink" title="2.I&#x2F;O的性能评估"></a>2.I&#x2F;O的性能评估</h2><p>正如下图你所看到的，整个I&#x2F;O的流程涉及的链路非常长。我们在应用程序中通过打点，发现一个文件读取需要300ms。但是下面每一层可能都有自己的策略和调度算法，因此很难真正的得到每一层的耗时。</p><img src="/2023/03/09/%E6%87%82%E5%BE%97%E4%BA%86Android-I-O%E8%B0%83%E4%BC%98%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%BE%88%E5%A4%A7%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/26731569-ee5db940a613d188.png" style="zoom: 67%;"><p>在前面的启动优化内容中，我讲过Facebook和支付宝采用编译单独ROM的方法来评估I&#x2F;O性能。这是一个比较复杂但是有效的做法，我们可以通过定制源码，选择打开感兴趣的日志来追踪I&#x2F;O的性能。</p><ol><li>I&#x2F;O性能指标<br>I&#x2F;O性能评估中最为核心的指标是吞吐量和IOPS。今天文章开头所说的，“连续读取不超过550MB&#x2F;s，连续写入不超过520MB&#x2F;s”，就指的是I&#x2F;O吞吐量。<br>还有一个比较重要的指标是IOPS，它指的是每秒可以读写的次数。对于随机读写频繁的应用，例如大量的小文件存储，IOPS是关键的衡量指标。</li><li>I&#x2F;O测量<br>如果不采用定制源码的方式，还有哪些方法可以用来测量I&#x2F;O的性能呢？\</li></ol><p><strong>第一种方法：使用proc。</strong><br>总的来说，I&#x2F;O性能会跟很多因素有关，是读还是写、是否是连续、I&#x2F;O大小等。另外一个对I&#x2F;O性能影响比较大的因素是负载，I&#x2F;O性能会随着负载的增加而降低，我们可以通过I&#x2F;O的等待时间和次数来衡量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">proc/self/schedstat:<br>  se.statistics.iowait_count：IO 等待的次数<br>  se.statistics.iowait_sum：  IO 等待的时间<br></code></pre></td></tr></table></figure><p>如果是root的机器，我们可以开启内核的I&#x2F;O监控，将所有block读写dump到日志文件中，这样可以通过dmesg命令来查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 1 &amp;gt; /proc/sys/vm/block_dump<br>dmesg -c grep pid<br>.sample.io.test(7540): READ block 29262592 on dm-1 (256 sectors)<br>.sample.io.test(7540): READ block 29262848 on dm-1 (256 sectors)<br></code></pre></td></tr></table></figure><p><strong>第二种方法：使用strace。</strong><br>Linux提供了iostat、iotop等一些相关的命令，不过大部分Anroid设备都不支持。我们可以通过 strace来跟踪I&#x2F;O相关的系统调用次数和耗时。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">strace -ttT -f -p [pid]<br>read(53, &amp;quot;*****************&amp;quot;\.\.\., 1024) = 1024       &amp;lt;0.000447&amp;gt;<br>read(53, &amp;quot;*****************&amp;quot;\.\.\., 1024) = 1024       &amp;lt;0.000084&amp;gt;<br>read(53, &amp;quot;*****************&amp;quot;\.\.\., 1024) = 1024       &amp;lt;0.000059&amp;gt;<br></code></pre></td></tr></table></figure><p>通过上面的日志，你可以看到应用程序在读取文件操作符为53的文件，每次读取1024个字节。第一次读取花了447us，后面两次都使用了100us不到。这跟启动优化提到的“数据重排”是一个原因，文件系统每次读取以block为单位，而block的大小一般是4KB，后面两次的读取是从页缓存得到。<br>我们也可以通过strace统计一段时间内所有系统调用的耗时概况。不过strace本身也会消耗不少资源，对执行时间也会产生影响。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">strace -c -f -p [pid]<br><span class="hljs-meta prompt_">% </span><span class="language-bash">time     seconds  usecs/call     calls    errors  syscall</span><br>------ ----------- ----------- --------- --------- ————————<br> 97.56    0.041002          21      1987             read<br>  1.44    0.000605          55        11             write<br></code></pre></td></tr></table></figure><p>从上面的信息你可以看到，读占了97.56%的时间，一共调用了1987次，耗时0.04s，平均每次系统调用21us。同样的道理，我们也可以计算应用程序某个任务I&#x2F;O耗时的百分比。假设一个任务执行了10s，I&#x2F;O花了9s，那么I&#x2F;O耗时百分比就是90%。这种情况下，I&#x2F;O就是我们任务很大的瓶颈，需要去做进一步的优化。</p><p><strong>第三种方法：使用vmstat。</strong><br>vmstat的各个字段说明可以参考《vmstat监视内存使用情况》，其中Memory中的buff和cache，I&#x2F;O中的bi和bo，System中的cs，以及CPU中的sy和wa，这些字段的数值都与I&#x2F;O行为有关。</p><p>我们可以配合dd命令来配合测试，观察vmstat的输出数据变化。不过需要注意的是Android里面的dd命令似乎并不支持conv和flag参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">//清除Buffer和Cache内存缓存<br>echo 3 &amp;gt; /proc/sys/vm/drop_caches<br>//每隔1秒输出1组vmstat数据<br>vmstat 1<br>//测试写入速度，写入文件/data/data/test，buffer大小为4K，次数为1000次<br>dd if=/dev/zero of=/data/data/test bs=4k count=1000<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言字符串处理函数</title>
    <link href="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"/>
    <url>/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言字符串处理函数"><a href="#C语言字符串处理函数" class="headerlink" title="C语言字符串处理函数"></a>C语言字符串处理函数</h1><p>写代码时对字符和字符串的处理很频繁，但是C语言中本身没有字符串类型，字符串通常存储在<strong>常量字符串（const char* str）</strong>中或者<strong>字符数组（char str[] &#x3D; “amx”）</strong>中。<strong>常量字符串</strong>适用于那些对它不做修改的字符串函数。</p><p>首先，我们要确定在C语言中，字符串都是以\0结尾的，只不过我们创建的时候不用自己添加，是编译的时候由编译器添加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-keyword">if</span> (str[<span class="hljs-number">3</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;末尾是\\0\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/截屏2022-05-21 16.32.40.png"><h2 id="1-字符串的长度"><a href="#1-字符串的长度" class="headerlink" title="1.字符串的长度"></a>1.字符串的长度</h2><h3 id="1-1-strlen"><a href="#1-1-strlen" class="headerlink" title="1.1 strlen"></a>1.1 strlen</h3><p>作用：求字符串的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strlen</span>(str)); <span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-长度不受限制的字符串函数"><a href="#2-长度不受限制的字符串函数" class="headerlink" title="2.长度不受限制的字符串函数"></a>2.长度不受限制的字符串函数</h2><h3 id="2-1-strcpy"><a href="#2-1-strcpy" class="headerlink" title="2.1  strcpy"></a>2.1  strcpy</h3><p>作用：复制字符串</p><p>将<strong>源</strong>所指向的 C 字符串复制到<strong>目标</strong>所指向的数组中，包括终止空字符（并在该点停止）。</p><blockquote><p>为避免溢出，目标所指向的数组的大小应足够长，以包含与源相同的 C 字符串（包括终止空字符），并且不应在内存中与 source 重叠。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">20</span>];<br>    <br>    <span class="hljs-built_in">strcpy</span>(str2,str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str2);  <span class="hljs-comment">// amx</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-strcat"><a href="#2-2-strcat" class="headerlink" title="2.2 strcat"></a>2.2 strcat</h3><p>作用：连接字符串</p><p>将‎‎<strong>源</strong>‎‎字符串的副本追加到‎‎<strong>目标</strong>‎‎字符串。‎<em>‎</em>目标‎‎中的终止空字符被‎<em>‎</em>源<em>‎</em>‎的第一个字符覆盖，并且在‎<em>‎</em>目标<em>‎</em>‎中由两者串联形成的新字符串的末尾包含一个空字符。‎</p><blockquote><p>注：目的地‎‎和‎‎来源‎‎不得重叠。<strong>自己不能给自己追加。</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;hello &quot;</span>;<br>    <br>    <span class="hljs-built_in">strcat</span>(str2,str1);  <span class="hljs-comment">// 将str1添加到str2后面去</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str2);  <span class="hljs-comment">// hello amx</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-strcmp"><a href="#2-3-strcmp" class="headerlink" title="2.3 strcmp"></a>2.3 strcmp</h3><p>作用：比较两个字符串</p><img src="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/d04949f8-1e4a-482b-be1c-b1de518ec939.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;hello &quot;</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strcmp</span>(str1,str2));  <span class="hljs-comment">// -7</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-长度受限制的字符串函数"><a href="#3-长度受限制的字符串函数" class="headerlink" title="3.长度受限制的字符串函数"></a>3.长度受限制的字符串函数</h2><h3 id="3-1-strncpy"><a href="#3-1-strncpy" class="headerlink" title="3.1 strncpy"></a>3.1 strncpy</h3><p>作用：<strong>Copy characters from string</strong>从字符串中复制字符</p><p>将<strong>源</strong>的前<strong>num</strong>字符复制到<strong>目标</strong>。如果在复制<strong>num</strong>个字符之前找到<strong>源</strong>C 字符串（由空字符指示）的末尾，则<strong>目标</strong>将填充零，直到向其写入总共<strong>num</strong>个字符。</p><blockquote><p>如果源的长度超过 num，则不会在目标末尾隐式追加空字符。</p><p>因此，在这种情况下，<strong>目标</strong>不应被视为以空值结尾的 C 字符串（这样读取它会溢出）。</p><p>目的地和来源不得重叠（重叠时，请参阅 memmove 以了解更安全的替代方案）。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">20</span>];<br>    <br>    <span class="hljs-built_in">strncpy</span>(str2,str1,<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str2);  <span class="hljs-comment">// hello</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-strncat"><a href="#3-2-strncat" class="headerlink" title="3.2 strncat"></a>3.2 strncat</h3><p>作用：将<strong>源</strong>的前<strong>num</strong>个字符追加到<strong>目标</strong>，加上一个终止空字符。</p><blockquote><p>如果源中 C 字符串的长度小于<strong>num</strong>，则仅复制直到终止空字符的内容。</p><p>如果source拷贝进去之后desination还有原本存在的字符会主动追加一个’\0’。</p><p>如果追加长度num大于strlen(source),则只追加source原本的字符串和一个’\0’</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;HI!&quot;</span>;<br>    <br>    <span class="hljs-built_in">strncat</span>(str2,str1,<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str2);  <span class="hljs-comment">// HI!hello</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-strncmp"><a href="#3-3-strncmp" class="headerlink" title="3.3 strncmp"></a>3.3 strncmp</h3><p>作用：将 C 字符串<strong>str1</strong>的<strong>最多 num</strong>个字符与 C 字符串<strong>str2</strong>的字符数进行比较。</p><blockquote><p>此函数开始比较每个字符串的第一个字符。如果它们彼此相等，则继续向后比较，直到字符不同，直到达到终止空字符，或者直到两个字符串中的<strong>num</strong>字符匹配，以先发生的情况为准。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello amx&quot;</span>;<br>    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;hellaaaa&quot;</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strncmp</span>(str1,str2,<span class="hljs-number">4</span>));  <span class="hljs-comment">// 0</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strncmp</span>(str1,str2,<span class="hljs-number">5</span>));  <span class="hljs-comment">// 14</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-安全的字符串函数"><a href="#4-安全的字符串函数" class="headerlink" title="4.安全的字符串函数"></a>4.安全的字符串函数</h2><blockquote><p>为了减轻程序员添加结束符和处理字符串截断的负担，可以使用strlcpy和strlcat函数。</p><p>🍭文档：<a href="https://gratisoft.us/todd/papers/strlcpy.html">https://gratisoft.us/todd/papers/strlcpy.html</a></p></blockquote><h3 id="4-1-strlcpy"><a href="#4-1-strlcpy" class="headerlink" title="4.1 strlcpy"></a>4.1 strlcpy</h3><p>作用：</p><p><strong>strlcpy源代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">strlcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">size_t</span> dsize)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *osrc = src;<br>    <span class="hljs-type">size_t</span> nleft = dsize;<br>    <span class="hljs-comment">/* Copy as many bytes as will fit. */</span><br>    <span class="hljs-keyword">if</span> (nleft != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (--nleft != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((*dst++ = *src++) == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* Not enough room in dst, add NUL and traverse rest of src. */</span><br>    <span class="hljs-keyword">if</span> (nleft == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (dsize != <span class="hljs-number">0</span>)<br>            *dst = <span class="hljs-string">&#x27;\0&#x27;</span>;        <span class="hljs-comment">/* NUL-terminate dst */</span><br>        <span class="hljs-keyword">while</span> (*src++);<br>    &#125;<br>    <span class="hljs-keyword">return</span>(src - osrc - <span class="hljs-number">1</span>);    <span class="hljs-comment">/* count does not include NUL */</span><br>&#125;<br></code></pre></td></tr></table></figure><p> <code>strlcpy</code>将 <code>src</code> 按字符拷贝到 <code>dst</code>中，最多拷贝<code>dszie-1</code>个字符，拷贝结束后在 <code>dst</code> 末尾添加 <code>0x00</code>结束符，返回值是 <code>src</code>的长度。一般将 <code>dsize</code>置为<code>dst</code>的大小。相较于strncpy，<strong>strlcpy有两个优点</strong>：</p><ul><li>当<code>strlen(src)</code>大于等于<code>dsize</code>时自动在<code>dst</code>末尾添加结束符；</li><li>返回值大于等于<code>dsize</code>时确定发生字符串截断。以上两点帮助程序员进行判断，方便后续处理。</li></ul><h3 id="4-2-strlcat"><a href="#4-2-strlcat" class="headerlink" title="4.2 strlcat"></a>4.2 strlcat</h3><p>作用：</p><p><strong>strlcat源代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">strlcat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">size_t</span> dsize)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *odst = dst;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *osrc = src;<br>    <span class="hljs-type">size_t</span> n = dsize;<br>    <span class="hljs-type">size_t</span> dlen;<br>    <span class="hljs-comment">/* Find the end of dst and adjust bytes left but don&#x27;t go past end. */</span><br>    <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span> &amp;&amp; *dst != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        dst++;<br>    dlen = dst - odst;<br>    n = dsize - dlen;<br><br>    <span class="hljs-keyword">if</span> (n-- == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>(dlen + <span class="hljs-built_in">strlen</span>(src));<br>    <span class="hljs-keyword">while</span> (*src != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n != <span class="hljs-number">0</span>) &#123;<br>            *dst++ = *src;<br>            n--;<br>        &#125;<br>        src++;<br>    &#125;<br>    *dst = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span>(dlen + (src - osrc));    <span class="hljs-comment">/* count does not include NUL */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>dlen</code>是 <code>dst</code>中原有字符串的长度（不包含<code>0x00</code>结束符）；<code>dsize</code>是 <code>dst</code>缓冲区的总大小（包含结束符）。 它首先找到 <code>dst</code>中源字符串的结束符，然后计算剩余空间大小，如果为0，则返回。如果有剩余空间，就依次往其中添加<code>src</code>字符串，直至<code>dst</code>缓冲区填满，返回值是<code>dst</code>原字符串长度与<code>src</code>长度之和。相比较strncat，<strong>strlcat的优点是</strong>：</p><ul><li>第三个参数大小直接带入<code>dst</code>的大小，不需要计算剩余空间；</li><li>返回值可以用来判断是否发生字符串截断。</li></ul><h2 id="5-字符串查找"><a href="#5-字符串查找" class="headerlink" title="5.字符串查找"></a>5.字符串查找</h2><h3 id="5-1-strstr"><a href="#5-1-strstr" class="headerlink" title="5.1 strstr"></a>5.1 strstr</h3><p>作用：返回一个指向<strong>str1</strong>中第一次出现的<strong>str2</strong>的指针，如果<strong>str2</strong> 不是 <strong>str1</strong>的一部分，则返回空指针</p><blockquote><p>匹配过程不包括终止空字符，但碰到它就此停止。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] =<span class="hljs-string">&quot;This is a simple string&quot;</span>;  <br>    <span class="hljs-type">char</span>* pch;<br>    pch = <span class="hljs-built_in">strstr</span>(str,<span class="hljs-string">&quot;is&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p&quot;</span>,*pch);  <span class="hljs-comment">// 0X69</span><br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-strtok"><a href="#5-2-strtok" class="headerlink" title="5.2 strtok"></a>5.2 strtok</h3><p>作用：将字符串拆分为标记</p><p>对该函数的一系列调用将str拆分为标记，这些标记是由分隔符中的任何字符分隔的连续字符序列。</p><h2 id="6-错误信息报告"><a href="#6-错误信息报告" class="headerlink" title="6.错误信息报告"></a>6.错误信息报告</h2><h3 id="6-1-strerror"><a href="#6-1-strerror" class="headerlink" title="6.1 strerror"></a>6.1 strerror</h3><p>作用：<strong>string</strong>获取指向错误消息字符串的指针</p><p>错误码是程序员知道的，但是要转化为用户能看懂的错误信息，就需要使用函数将其转化为错误信息。</p><p>解释<strong>errnum</strong>的值，生成一个字符串，其中包含一条描述错误条件的消息，就好像被库的函数设置为<strong>errno</strong>一样。</p><blockquote><p>errno在头文件&lt;errno.h&gt;中</p><p>errno是一个全局的错误码变量</p><p>当C语言的库函数在执行过程中，发生错误，就会把对应的错误码，赋值到errno中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE * pFile;<br>    <span class="hljs-comment">//打开文件</span><br>    pFile = fopen (<span class="hljs-string">&quot;unexist.ent&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (pFile == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error opening file unexist.ent: %s\n&quot;</span>,strerror(errno));<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Win opening file!&quot;</span>);<br>    &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/4b271827-30e6-493f-a1b7-59db778d01d7.png"><h2 id="7-字符分类函数"><a href="#7-字符分类函数" class="headerlink" title="7.字符分类函数"></a>7.字符分类函数</h2><p>函数使用需要的头文件<code>#include &lt;ctype.h&gt;</code></p><img src="/2023/03/07/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/df04e811-541d-4e15-9bfe-3525a4827235.png"><p><strong>字符转换</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">tolower</span>(c);<span class="hljs-comment">//转小写字母</span><br><span class="hljs-built_in">toupper</span>(c);<span class="hljs-comment">//转大写字母</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;I Am A Good Student&quot;</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(str[i])&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isupper</span>(str[i]))&#123;<br>            str[i] = <span class="hljs-built_in">tolower</span>(str[i]);<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str);  <span class="hljs-comment">// i am a good student</span><br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Binder系统学习笔记</title>
    <link href="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Binder系统学习笔记"><a href="#Binder系统学习笔记" class="headerlink" title="Binder系统学习笔记"></a>Binder系统学习笔记</h1><h2 id="1-Binder系统的两大核心"><a href="#1-Binder系统的两大核心" class="headerlink" title="1.Binder系统的两大核心"></a>1.Binder系统的两大核心</h2><h3 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h3><p>A进程想要把数据传递给B进程，这就涉及到了<strong>IPC</strong>（Inter Process Communication 跨进程通信），如下图所示：</p><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230305230100824.png" alt="image-20230305230100824" style="zoom:80%;"><p>例如A进程想要通过<code>led_open</code> 或者 <code>led_ctl</code> 打开led，但是当前A进程没有权限，那么会通过RPC进程通信：</p><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230305230747468.png" alt="image-20230305230747468" style="zoom:80%;"><p>从这个图来看，从底下来看仿佛是A进程调用了一个本地的方法led_open&#x2F;led_ctl，然后把数据发给B，由B进程来操作硬件！【整个过程就是RPC】</p><blockquote><p><strong>RPC</strong>:(Reomote Procedure Call 远程过程调用) ：客户端将调用一个本地方法，而这个本地方法则是负责透明的与远程服务端进行过程间通信。这个本地方法会将相关参数顺序打包到一个消息中，然后把这个消息发送给服务端提供的方法，服务端的方法会从消息中解出序列化发出来的参数，然后执行，最后仍以同样的方式将方法的返回值发送给客户端。</p></blockquote><h3 id="1-2-binder系统中的IPC和RPC"><a href="#1-2-binder系统中的IPC和RPC" class="headerlink" title="1.2 binder系统中的IPC和RPC"></a>1.2 binder系统中的IPC和RPC</h3><p>binder系统中IPC需要具备下面三个要素：</p><ul><li><strong>源</strong>：在上面的例子中，源就是进程A</li><li><strong>目的</strong>：1）B 向 servicemanager 注册led服务；2）A 向 servicemanager 查询led服务，得到一个handle</li><li><strong>数据</strong>：就是一个char buf，用来存放通信的数据</li></ul><p><strong>实际的RPC过程中我们需要思考下面的问题</strong>：</p><ol><li>A进程需要调用B进程的什么函数</li><li>A进程需要传递什么参数给B进程</li><li>A进程会得到B进程的什么返回值</li></ol><blockquote><p>第2步A进程通过IPC将buf传输数据给B；</p><p>第3步同样B进程处理完以后通过IPC将数据返回给A</p></blockquote><h2 id="2-Binder机制分析"><a href="#2-Binder机制分析" class="headerlink" title="2 Binder机制分析"></a>2 Binder机制分析</h2><h3 id="2-1-servicemanager的作用"><a href="#2-1-servicemanager的作用" class="headerlink" title="2.1 servicemanager的作用"></a>2.1 servicemanager的作用</h3><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d12a5c80-9140-4483-bbf4-3ac05cd8a5f9.png" style="zoom: 67%;"><p>代码路径：frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">bs</span>;</span><br><br>    bs = binder_open(<span class="hljs-number">128</span>*<span class="hljs-number">1024</span>);  <span class="hljs-comment">// 打开binder驱动【bs是描述binder驱动的结构体】</span><br>    <span class="hljs-keyword">if</span> (!bs) &#123;<br>        ALOGE(<span class="hljs-string">&quot;failed to open binder driver\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 告诉binder驱动我就是servicemanager</span><br>    <span class="hljs-keyword">if</span> (binder_become_context_manager(bs)) &#123;<br>        ALOGE(<span class="hljs-string">&quot;cannot become context manager (%s)\n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    svcmgr_handle = BINDER_SERVICE_MANAGER;<br>    binder_loop(bs, svcmgr_handler);  <span class="hljs-comment">// 循环监听binder驱动，完成相应服务的函数调用</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个疑惑：svcmgr_handle是什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">svcmgr_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_transaction_data *txn,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_io *msg,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_io *reply)</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">switch</span>(txn-&gt;code) &#123;<br>    <span class="hljs-keyword">case</span> SVC_MGR_GET_SERVICE:<br>    <span class="hljs-keyword">case</span> SVC_MGR_CHECK_SERVICE:<br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">case</span> SVC_MGR_ADD_SERVICE:<br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">case</span> SVC_MGR_LIST_SERVICES: &#123;<br>       <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    bio_put_uint32(reply, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到svcmgr_handler实际上是一个函数【这个函数里面会根据传进来的txn结构体中的code来决定，到底是去注册服务还是调用服务】</p><ul><li>如果是<code>SVC_MGR_ADD_SERVICE</code>，就是注册服务</li><li>如果是<code>SVC_MGR_CHECK_SERVICE</code>，就是检查服务是否存在</li><li>如果是<code>SVC_MGR_GET_SERVICE</code>，就是获取服务</li></ul><blockquote><p>这里正好对应上了开头思维导图上的最后一项servicemanager的作用</p></blockquote><h3 id="1-3-2-server端作用"><a href="#1-3-2-server端作用" class="headerlink" title="1.3.2 server端作用"></a>1.3.2 server端作用</h3><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1a4196fb-da3b-4125-99f4-a1a9516218fd.png" style="zoom: 50%;"><p>我们先看一下注册服务的流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">svcmgr_publish</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs, <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *ptr)</span><br>&#123;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);<br>    bio_put_string16_x(&amp;msg, name);<br>    bio_put_obj(&amp;msg, ptr);<br><br>    <span class="hljs-keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    status = bio_get_uint32(&amp;reply);<br><br>    binder_done(bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端注册服务时会调用<code>svcmgr_publish</code>函数，这个函数里面最主要的是去调用<code>binder_call</code>函数</p><p><strong>binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE)</strong></p><ul><li>bs：描述binder驱动的结构体</li><li>msg：表示要注册服务的相关信息的binder_io结构体</li><li>reply：表示servicemanager回复的数据</li><li>target：注册时target传的是BINDER_SERVICE_MANAGER，该值表示的就是servicemanager</li><li>SVC_MGR_ADD_SERVICE：表示调用目标的函数，该函数的CODE值为SVC_MGR_ADD_SERVICE【在注册时相当于调用servicemanager的addservice服务】</li></ul><h3 id="1-3-3-client端作用"><a href="#1-3-3-client端作用" class="headerlink" title="1.3.3 client端作用"></a>1.3.3 client端作用</h3><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f955b7ac-25ac-4cd8-82b1-af135a447d3b.png" style="zoom: 50%;"><p>client端首先会去获取服务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">svcmgr_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs, <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);<br>    bio_put_string16_x(&amp;msg, name);<br><br>    <span class="hljs-keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_CHECK_SERVICE))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    handle = bio_get_ref(&amp;reply);<br><br>    <span class="hljs-keyword">if</span> (handle)<br>        binder_acquire(bs, handle);<br><br>    binder_done(bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> handle;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里同样也会去调用binder_call函数</p><p><strong>binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE)</strong></p><ul><li>bs：描述binder驱动的结构体</li><li>msg：表示即将查询服务的相关信息的binder_io结构体</li><li>reply：表示servicemanager回复的数据，数据里面会包含刚刚想要查询服务的进程</li><li>target：注册时target传的是BINDER_SERVICE_MANAGER，该值表示的就是servicemanager</li><li>SVC_MGR_CHECK_SERVICE：表示调用目标的函数，该函数的CODE值为SVC_MGR_CHECK_SERVICE【在注册时相当于调用servicemanager的getservice服务】</li></ul><h3 id="1-3-4-理解binder-call函数"><a href="#1-3-4-理解binder-call函数" class="headerlink" title="1.3.4 理解binder_call函数"></a>1.3.4 理解binder_call函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">binder_call</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs,</span><br><span class="hljs-params">                <span class="hljs-keyword">struct</span> binder_io *msg, <span class="hljs-keyword">struct</span> binder_io *reply,</span><br><span class="hljs-params">                <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">uint32_t</span> code)</span><br>&#123;<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_write_read</span> <span class="hljs-title">bwr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-type">uint32_t</span> cmd;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_transaction_data</span> <span class="hljs-title">txn</span>;</span><br>    &#125; __attribute__((packed)) writebuf;<br>    <span class="hljs-type">unsigned</span> readbuf[<span class="hljs-number">32</span>];<br><br>    <span class="hljs-keyword">if</span> (msg-&gt;flags &amp; BIO_F_OVERFLOW) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;binder: txn buffer overflow\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> fail;<br>    &#125;<br><br>    writebuf.cmd = BC_TRANSACTION;<br>    writebuf.txn.target.handle = target;<br>    writebuf.txn.code = code;<br>    writebuf.txn.flags = <span class="hljs-number">0</span>;<br>    writebuf.txn.data_size = msg-&gt;data - msg-&gt;data0;<br>    writebuf.txn.offsets_size = ((<span class="hljs-type">char</span>*) msg-&gt;offs) - ((<span class="hljs-type">char</span>*) msg-&gt;offs0);<br>    writebuf.txn.data.ptr.buffer = (<span class="hljs-type">uintptr_t</span>)msg-&gt;data0;<br>    writebuf.txn.data.ptr.offsets = (<span class="hljs-type">uintptr_t</span>)msg-&gt;offs0;<br><br>    bwr.write_size = <span class="hljs-keyword">sizeof</span>(writebuf);<br>    bwr.write_consumed = <span class="hljs-number">0</span>;<br>    bwr.write_buffer = (<span class="hljs-type">uintptr_t</span>) &amp;writebuf;<br><br>    hexdump(msg-&gt;data0, msg-&gt;data - msg-&gt;data0);<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        bwr.read_size = <span class="hljs-keyword">sizeof</span>(readbuf);<br>        bwr.read_consumed = <span class="hljs-number">0</span>;<br>        bwr.read_buffer = (<span class="hljs-type">uintptr_t</span>) readbuf;<br><br>        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);<br><br>        <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;binder: ioctl failed (%s)\n&quot;</span>, strerror(errno));<br>            <span class="hljs-keyword">goto</span> fail;<br>        &#125;<br><br>        res = binder_parse(bs, reply, (<span class="hljs-type">uintptr_t</span>) readbuf, bwr.read_consumed, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> fail;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>binder_call就是rpc中的远程调用函数</strong></p><p>在注册服务，获取服务，调用服务中的接口函数都是使用了binder_call函数，我们来分析一下binder_call函数具体在干嘛：</p><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3bdaac93-c274-45df-b04b-2a106eb4a42c.png" style="zoom: 67%;"><p><strong>binder_call内部实现：</strong></p><ol><li>构造参数msg，该值是一个binder_io类型的数据</li><li>将binder_io数据转化为<code>binder_write_read</code>类型的数据，因为binder驱动的ioctl中传递的是<code>binder_write_read</code>类型的数据</li></ol><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9b6e2287-0653-4646-8533-7cf9bdaf8b79.png" style="zoom: 67%;"><ol start="3"><li>客户端会调用ioctl发送数据</li></ol><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4f6deea3-edd7-44e5-9d8a-01d697da89d2.png" style="zoom: 67%;"><ol start="4"><li>服务端会调用ioctl接收数据</li></ol><h2 id="3-C程序实现Hello服务"><a href="#3-C程序实现Hello服务" class="headerlink" title="3.C程序实现Hello服务"></a>3.C程序实现Hello服务</h2><h3 id="3-1-server端和client端编写思路"><a href="#3-1-server端和client端编写思路" class="headerlink" title="3.1 server端和client端编写思路"></a>3.1 server端和client端编写思路</h3><p><strong>client端：</strong></p><ul><li>打开驱动，binder_open</li><li>获取服务的handle【服务以进程的形式存在，就是获得服务对应进程的handle】</li><li>构造参数binder_io</li><li>调用函数binder_call进行远程服务访问</li><li>返回binder_io，取出返回值</li><li>释放获得的handle</li></ul><p><strong>server端：</strong></p><ul><li>打开驱动，binder_open</li><li>调用svcmgr_publish注册服务</li><li>ioctl去读取binder驱动的数据</li><li>解析数据，将binder_write_read类型的数据转换为binder_io类型的数据</li><li>根据解析出的数据中的CODE值，去调用当前服务的对应函数</li><li>把返回值转换为binder_io</li></ul><h3 id="3-2-hello服务的server端"><a href="#3-2-hello服务的server端" class="headerlink" title="3.2 hello服务的server端"></a>3.2 hello服务的server端</h3><ul><li>test_server.h</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义hello服务的CODE编码，来表示当前应该调用服务的哪一个函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _TEST_SERVER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _TEST_SERVER_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO_SVR_CMD_SAYHELLO     1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO_SVR_CMD_SAYHELLO_TO  2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GOODBYE_SVR_CMD_SAYGOODBYE     1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GOODBYE_SVR_CMD_SAYGOODBYE_TO  2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// _TEST_SERVER_H</span></span><br></code></pre></td></tr></table></figure><ul><li>test_server.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/* Copyright 2008 The Android Open Source Project</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;private/android_filesystem_config.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;binder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test_server.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">svcmgr_publish</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs, <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *ptr)</span><br>&#123;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);<br>    bio_put_string16_x(&amp;msg, name);<br>    bio_put_obj(&amp;msg, ptr);<br><br>    <span class="hljs-keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    status = bio_get_uint32(&amp;reply);<br><br>    binder_done(bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sayhello</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;say hello : %d\n&quot;</span>, ++cnt);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sayhello_to</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;say hello to %s : %d\n&quot;</span>, name, ++cnt);<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">hello_service_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_transaction_data *txn,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_io *msg,</span><br><span class="hljs-params">                   <span class="hljs-keyword">struct</span> binder_io *reply)</span><br>&#123;<br>    <span class="hljs-comment">/* 根据txn-&gt;code知道要调用哪一个函数</span><br><span class="hljs-comment">     * 如果需要参数, 可以从msg取出</span><br><span class="hljs-comment">     * 如果要返回结果, 可以把结果放入reply</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/* sayhello</span><br><span class="hljs-comment">     * sayhello_to</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-type">uint16_t</span> *s;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">512</span>];<br>    <span class="hljs-type">size_t</span> len;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">uint32_t</span> strict_policy;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-comment">// Equivalent to Parcel::enforceInterface(), reading the RPC</span><br>    <span class="hljs-comment">// header with the strict mode policy mask and the interface name.</span><br>    <span class="hljs-comment">// Note that we ignore the strict_policy and don&#x27;t propagate it</span><br>    <span class="hljs-comment">// further (since we do no outbound RPCs anyway).</span><br>    strict_policy = bio_get_uint32(msg);<br><br>    <span class="hljs-keyword">switch</span>(txn-&gt;code) &#123;<br>    <span class="hljs-keyword">case</span> HELLO_SVR_CMD_SAYHELLO:<br>        sayhello();<br>        bio_put_uint32(reply, <span class="hljs-number">0</span>); <span class="hljs-comment">/* no exception */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">case</span> HELLO_SVR_CMD_SAYHELLO_TO:<br>        <span class="hljs-comment">/* 从msg里取出字符串 */</span><br>        s = bio_get_string16(msg, &amp;len);  <span class="hljs-comment">//&quot;IHelloService&quot;</span><br>        s = bio_get_string16(msg, &amp;len);  <span class="hljs-comment">// name</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            name[i] = s[i];<br>        name[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        <span class="hljs-comment">/* 处理 */</span><br>        i = sayhello_to(name);<br><br>        <span class="hljs-comment">/* 把结果放入reply */</span><br>        bio_put_uint32(reply, <span class="hljs-number">0</span>); <span class="hljs-comment">/* no exception */</span><br>        bio_put_uint32(reply, i);<br>        <br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;unknown code %d\n&quot;</span>, txn-&gt;code);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">bs</span>;</span><br>    <span class="hljs-type">uint32_t</span> svcmgr = BINDER_SERVICE_MANAGER;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">int</span> ret;<br><br>    bs = binder_open(<span class="hljs-number">128</span>*<span class="hljs-number">1024</span>);<br>    <span class="hljs-keyword">if</span> (!bs) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to open binder driver\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* add service */</span><br>    ret = svcmgr_publish(bs, svcmgr, <span class="hljs-string">&quot;hello&quot;</span>, hello_service_handler);<br>    <span class="hljs-keyword">if</span> (ret) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to publish hello service\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* read data */</span><br>        <span class="hljs-comment">/* parse data, and process */</span><br>        <span class="hljs-comment">/* reply */</span><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    binder_set_maxthreads(bs, <span class="hljs-number">10</span>);<br><br>    binder_loop(bs, hello_service_handler);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-hello服务的client端"><a href="#3-3-hello服务的client端" class="headerlink" title="3.3 hello服务的client端"></a>3.3 hello服务的client端</h3><ul><li>test_client.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c">&lt;&gt;<span class="hljs-comment">/* Copyright 2008 The Android Open Source Project</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;private/android_filesystem_config.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;binder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test_server.h&quot;</span></span><br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">svcmgr_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_state *bs, <span class="hljs-type">uint32_t</span> target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);<br>    bio_put_string16_x(&amp;msg, name);<br><br>    <span class="hljs-keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_CHECK_SERVICE))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    handle = bio_get_ref(&amp;reply);<br><br>    <span class="hljs-keyword">if</span> (handle)<br>        binder_acquire(bs, handle);<br><br>    binder_done(bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> handle;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">g_bs</span>;</span><br><span class="hljs-type">uint32_t</span> g_hello_handle;<br><span class="hljs-type">uint32_t</span> g_goodbye_handle;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sayhello</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br><br>    <span class="hljs-comment">/* 构造binder_io */</span><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, <span class="hljs-string">&quot;IHelloService&quot;</span>);<br><br>    <span class="hljs-comment">/* 放入参数 */</span><br><br>    <span class="hljs-comment">/* 调用binder_call */</span><br>    <span class="hljs-keyword">if</span> (binder_call(g_bs, &amp;msg, &amp;reply, g_hello_handle, HELLO_SVR_CMD_SAYHELLO))<br>        <span class="hljs-keyword">return</span> ;<br>    <br>    <span class="hljs-comment">/* 从reply中解析出返回值 */</span><br><br>    binder_done(g_bs, &amp;msg, &amp;reply);<br>    <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sayhello_to</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> iodata[<span class="hljs-number">512</span>/<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>, <span class="hljs-title">reply</span>;</span><br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">int</span> exception;<br><br>    <span class="hljs-comment">/* 构造binder_io */</span><br>    bio_init(&amp;msg, iodata, <span class="hljs-keyword">sizeof</span>(iodata), <span class="hljs-number">4</span>);<br>    bio_put_uint32(&amp;msg, <span class="hljs-number">0</span>);  <span class="hljs-comment">// strict mode header</span><br>    bio_put_string16_x(&amp;msg, <span class="hljs-string">&quot;IHelloService&quot;</span>);<br><br>    <span class="hljs-comment">/* 放入参数 */</span><br>    bio_put_string16_x(&amp;msg, name);<br><br>    <span class="hljs-comment">/* 调用binder_call */</span><br>    <span class="hljs-keyword">if</span> (binder_call(g_bs, &amp;msg, &amp;reply, g_hello_handle, HELLO_SVR_CMD_SAYHELLO_TO))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">/* 从reply中解析出返回值 */</span><br>    exception = bio_get_uint32(&amp;reply);<br>    <span class="hljs-keyword">if</span> (exception)<br>        ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>        ret = bio_get_uint32(&amp;reply);<br><br>    binder_done(g_bs, &amp;msg, &amp;reply);<br><br>    <span class="hljs-keyword">return</span> ret;<br>    <br>&#125;<br><br><br><span class="hljs-comment">/* ./test_client hello</span><br><span class="hljs-comment"> * ./test_client hello &lt;name&gt;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">bs</span>;</span><br>    <span class="hljs-type">uint32_t</span> svcmgr = BINDER_SERVICE_MANAGER;<br>    <span class="hljs-type">uint32_t</span> handle;<br>    <span class="hljs-type">int</span> ret;<br><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage:\n&quot;</span>);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s &lt;hello&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s &lt;hello&gt; &lt;name&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    bs = binder_open(<span class="hljs-number">128</span>*<span class="hljs-number">1024</span>);<br>    <span class="hljs-keyword">if</span> (!bs) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to open binder driver\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    g_bs = bs;<br><br>    <span class="hljs-comment">/* get service */</span><br>    handle = svcmgr_lookup(bs, svcmgr, <span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!handle) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to get hello service\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    g_hello_handle = handle;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Handle for hello service = %d\n&quot;</span>, g_hello_handle);<br><br>    <span class="hljs-comment">/* send data to server */</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello&quot;</span>))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>) &#123;<br>            sayhello();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span>) &#123;<br>            ret = sayhello_to(argv[<span class="hljs-number">2</span>]);<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;get ret of sayhello_to = %d\n&quot;</span>, ret);      <br>        &#125;<br>    &#125;<br><br>    binder_release(bs, handle);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3f3601eb-c63d-46bb-9692-1dfdc4d24690.png"><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><img src="/2023/03/05/Binder%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/b20537c9-9aff-4da7-84ae-dd1dbcb30baf.png">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 8.1从零开始写HAL</title>
    <link href="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/"/>
    <url>/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-8-1从零开始写HAL"><a href="#Android-8-1从零开始写HAL" class="headerlink" title="Android 8.1从零开始写HAL"></a>Android 8.1从零开始写HAL</h1><blockquote><p>🍛版权声明：本文为CSDN博主「Qidi_Huang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>🍜原文链接：<a href="https://blog.csdn.net/Qidi_Huang/article/details/107426961">https://blog.csdn.net/Qidi_Huang/article/details/107426961</a></p></blockquote><h2 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1.定义接口"></a>1.定义接口</h2><p>【前言】<br>我们都知道从 <code>Android 8.0</code> 开始， Google 启动了 <code>Treble 项目</code>，自此开始推行 Binder 化的 HAL 实现。除少数类型 HAL 外，在 Android 9.0 及其之后的版本，Google 甚至要求大部分<strong>外设</strong>(peripherals) 必须支持使用 Binder 化的 HAL，否则都不再视为合规。因此，本文中的 HAL 指的是用 HIDL 语言描述、使用 Binder 方式实现的 HAL。</p><p>在阅读本系列文章前，如果你已经大致了解 <code>Android SELinux</code> 概念（比如 <code>*.te</code> 文件和 <code>file_contexts</code>），以及 Binder 的基本调用方法（比如知道序列化的概念、 transact()&#x2F;onTransact()的调用时机），对于理解本文的内容会很有帮助。</p><p>根据项目不同，有的时候我们也许希望在设备上使用一种新的外设，比如某种传感器；或者有的时候，我们可能需要在 Android native 层运行一个特定进程，用来辅助处理来自 Android Frameworks 的数据，或者用于和其它 native 层的进程进行交互。对于前一种场景，我们需要为外设编写全新的 HAL；对于后一种场景，我们不需要编写 HAL，但需要实现一个很类似的 vendor service。这二者的实现方式极其类似，区别只在于他们使用的设备节点不同（一个使用<code>/dev/hwbinder</code>，另一个使用 <code>/dev/vndbinder</code>），还有各自申请的 sepolicy 权限有别。</p><p>以下正文以实现一个全新的 HAL 为例进行说明，但并不涉及对设备节点的操作。</p><h3 id="1-1-明确HAL接口"><a href="#1-1-明确HAL接口" class="headerlink" title="1.1 明确HAL接口"></a>1.1 明确HAL接口</h3><p>Android 大量采用面向接口编程的理念，HAL 也不例外。常用的 HAL 模块接口已经由 Google 和业界充分讨论并预定义，比如 Audio 和 Camera，这些模块需要支持的功能也已经明确，其接口描述可以在 <code>/hardware/interfaces/</code> 目录下找到。</p><p>同理，我们实现自己的 HAL 时，也应该先明确新 HAL 要支持的功能，再根据需求需要设计要暴露给给其它进程的接口。</p><p><strong>为了说明方便，我们不以真实的外设 HAL 来描述，而是做一系列假设，自己给自己设计需求。虽然这样的 HAL 不对应具体的使用场景，但道理是相通的，完全可以照猫画虎、举一反三。</strong></p><p>我们假设新 HAL 需要支持 3 个功能：</p><ul><li>允许其它进程主动设置状态</li><li>允许其它进程注册回调函数</li><li>允许其它进程注销回调函数</li></ul><p>给 <strong>新外设</strong>取名为 <code>demoComponent</code>，给<strong>新 HAL 的进程</strong>取名为 <code>demoService</code>。给支持上述 3 项功能的接口分别取名为 <code>setStatus() </code>、 <code>registerCallback()</code> 和 <code>unregisterCallback()</code>。假设其它进程所设置的“状态”是一个 <code>DemoData</code> 结构体，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-built_in">string</span>  name;<br>    <span class="hljs-type">int</span>     value;<br>&#125; DemoData;<br></code></pre></td></tr></table></figure><p>假设回调函数方法为 <code>onCallbackEvent()</code>， 参数同样为 <code>DemoData</code> 结构。</p><h3 id="1-2-编写接口描述文件"><a href="#1-2-编写接口描述文件" class="headerlink" title="1.2 编写接口描述文件"></a>1.2 编写接口描述文件</h3><p>通常，经过前述步骤明确接口之后，我们就可以写出完整的头文件来了，继而对应实现各接口。但是在 HAL 实现过程中，我们首先要写的不是头文件，而是创作出用 HIDL 语言编写的 <code>*.hal</code> 接口描述文件。（<strong>不过，在 Android R 上将支持用 AIDL 语言来编写接口描述文件，以后可能逐步废弃 HIDL 语言</strong>）</p><p>按照目前的开发规范，我们的自定义接口描述文件通常放在 <code>/vendor/&lt;CompanyName&gt;/hardware/interfaces/&lt;ComponentName&gt;/&lt;SubComponentName&gt;/&lt;VersionCode&gt;/</code> 目录下。 根据我们前文的假设，这里的<code>&lt;ComponentName&gt;</code>就是 demoComponent。<code>&lt;SubComponentName&gt;</code> 可有可无，在这个例子中对应的是 demoService。VersionCode 表示 HAL 接口的版本号，因为我们编写的是一个全新的 HAL，所以版本号是 1.0。</p><p>因为我们的实现涉及 <strong>HAL 进程、回调函数、参数数据</strong> 3 个部分，所以对应的 hal 文件也有 3 个，分别是：</p><ul><li><strong>IDemoServiceDef.hal</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">package vendor.harman.hardware.demoComponent.demoService@<span class="hljs-number">1.0</span>;<br><br>import IDemoCallback;<br><br>interface IDemoServiceDef &#123;<br><br>    setStatus(DemoData data) generates (<span class="hljs-type">int32_t</span> status);<br>    registerCallback(IDemoCallback cb) generates (<span class="hljs-type">int32_t</span> status);<br>    unregisterCallback(IDemoCallback cb) generates (<span class="hljs-type">int32_t</span> status);<br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li><strong>IDemoCallback.hal</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">package vendor.harman.hardware.demoComponent.demoService@<span class="hljs-number">1.0</span>;<br><br>interface IDemoCallback &#123;<br><br>   onCallbackEvent(DemoData payload) generates (<span class="hljs-type">int32_t</span> status);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>types.hal</strong>:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">package vendor.harman.hardware.demoComponent.demoService@<span class="hljs-number">1.0</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DemoData</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-built_in">string</span>  name;<br>    <span class="hljs-type">int32_t</span> value;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里有四个基本点需要注意。</p><ol><li><p><strong>数据类型描述文件的文件名是个固定名称</strong> <code>types.hal</code>；接口描述文件的文件名要以<strong>大写字母 I</strong> 开头写作 <code>IXxxx.hal</code>，并且相应地以<code>interface IXxxx &#123;&#125; </code>进行描述；<strong>generates</strong> 后加数据类型表示接口的返回值类型。</p></li><li><p>每个<code> *.hal</code> 文件都需要在文件头声明它所属的包。这里的包名为<code> package vendor.harman.hardware.demoComponent.demoService@1.0;</code>。</p></li><li><p>HIDL 语言所使用的数据类型和 C&#x2F;C++&#x2F;Java 的数据类型稍有区别。举个简单例子，对比 DemoData 结构体的原始写法与 HIDL 写法，可以看到 int32 被替换成了 int32_t。 再比如说，HIDL 数据类型也不支持 C&#x2F;C++ 的原始指针。关于 HIDL 数据类型的详细介绍可以参考《HIDL 数据类型》。</p></li><li><p>另外，<code>*.hal</code> 文件之间相互引用时，使用 <code>import</code> 关键字进行声明。</p></li></ol><p>这些固定形式是由 HIDL 框架决定的，我们必须遵从。</p><p>编写完成后用 <code>ls</code> 命令查看，就是下图中 3 个绿色文件的样子（<code>Android.*</code> 是自动生成的，1.3节就要讲到。<code>default/</code> 的含义和作用留待第2章进行介绍）：</p><img src="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/20200717231917282.png"><h3 id="1-3-生成-Makefile"><a href="#1-3-生成-Makefile" class="headerlink" title="1.3 生成 Makefile"></a>1.3 生成 Makefile</h3><p>编写好接口描述文件后，我们需要执行脚本 <code>/vendor/&lt;CompanyName&gt;/hardware/interfaces/update-makefiles.sh</code> 为接口描述文件自动生成 2 个 Makefile —— <code>Android.bp</code> 和 <code>Android.mk</code>。</p><p>有了这 2 个 Makefile，在编译阶段就可以自动从接口描述文件生成 Binder 框架的源文件、头文件以和对应的库，而无需我们手动敲一遍，十分方便。</p><h2 id="2-实现-HAL-主体"><a href="#2-实现-HAL-主体" class="headerlink" title="2.实现 HAL 主体"></a>2.实现 HAL 主体</h2><h3 id="2-1-配置HAL"><a href="#2-1-配置HAL" class="headerlink" title="2.1 配置HAL"></a>2.1 配置HAL</h3><p>因为不同的产品可能使用不同的外设，所以每个产品都有自己的资源清单 <code>manifest.xml</code>，位于目录 <code>/device/&lt;CompanyName&gt;/&lt;PlatformName&gt;/&lt;ProductName&gt;/</code> 下。清单中会列出该款产品支持的所有外设、服务和它们的 HAL 类型。</p><p>我们也应该把正在创建的 demoComponent HAL 添加进这个清单里。以我用的 Intel 平台为例，产品代号就不说了，<code>manifest.xml</code> 位于 <code>/device/harman/broxton/XXXX/</code> 目录下。添加完成后看起来类似下面这个样子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;device&quot;</span>&gt;</span><br><br>    ......<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hal</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;hidl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>vendor.harman.hardware.demoComponent.demoService<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transport</span>&gt;</span>hwbinder<span class="hljs-tag">&lt;/<span class="hljs-name">transport</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">interface</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>IDemoServiceDef<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">instance</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">instance</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">interface</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">hal</span>&gt;</span><br><br>    ......<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sepolicy</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>27.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sepolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 <code>&lt;hal format=&quot;hidl&quot;&gt;</code> 表示 HAL 使用 HIDL 描述； <code>&lt;name&gt;</code> 的值可以看出来就是接口描述文件所在的位置，但中间少了个 <strong>“.interfaces”</strong> ；<code>&lt;transport&gt;</code> 表示 HAL 实现所依赖的 binder 类型；<code>&lt;version&gt;</code> 表示 HAL 版本，回忆上一节，我们在编写接口描述文件时，文件存放路径里也有个 HAL 版本号，这两个版本号要一致； <code>&lt;interface&gt;</code> 节点用来标明 HAL 接口，下属的<code> &lt;name&gt;</code> 指定了 HAL 的接口描述文件为 <code>IDemoServiceDef.hal</code>， <code>&lt;instance&gt;</code> 指定了 HAL 的实现位于 <code>default/</code> 目录下。</p><p>default&#x2F; <strong>目录需要我们自己创建，位于</strong> <code>/vendor/&lt;CompanyName&gt;/hardware/interfaces/&lt;ComponentName&gt;/&lt;SubComponentName&gt;/&lt;VersionCode&gt;/</code>。 还是以我用的平台为例，完整路径为 <code>/vendor/harman/hardware/interfaces/demoComponent/demoService/1.0/default</code>。</p><h3 id="2-2-实现HAL主体"><a href="#2-2-实现HAL主体" class="headerlink" title="2.2 实现HAL主体"></a>2.2 实现HAL主体</h3><p>接下来我们要实现 demoComponent HAL 的主体。 因为 <strong>Binder 化后的 HAL 是以服务进程的形式运行在 Android native 层</strong>的，所以我给这个主体取名为 demoService。在 <code>default/</code> 目录下新建 <code>DemoServiceImpl.h</code> 和<code>DemoServiceImpl.cpp</code>。</p><p>这之后要做的事大家就很熟悉了 —— 在 <code>DemoServiceImpl.h</code> 里引用必要的头文件、声明类和方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hardware/hardware.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/IServiceManager.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/IPCThreadState.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/IDemoServiceDef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/IDemoCallback.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> android;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoServiceImpl</span> : <span class="hljs-keyword">public</span> IDemoServiceDef &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DemoServiceImpl</span>();<br>    ~<span class="hljs-built_in">DemoServiceImpl</span>() &#123;&#125;<br><br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> <span class="hljs-keyword">override</span></span>;<br><br><br><span class="hljs-keyword">private</span>:<br>    android::sp&lt;IDemoCallback&gt; callback = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong><code>DemoServiceImpl</code> 类继承自 <code>IDemoServiceDef</code> 类，并对接口进行覆写，同时声明了一个 <code>IDemoCallback</code> 指针用来保存回调函数。</strong></p><p>大家可能会困惑<strong>IDemoServiceDef</strong> 类和接口声明是哪里来的？我们可以通过名字推测它是由 <strong>IDemoServiceDef.hal</strong> 生成的。实际上和推测一样，编译阶段自动生成的文件会被放在 <code>/out/soong/.intermediates/vendor/harman/hardware/interfaces/demoComponent/demoService/1.0/</code> 目录，头文件和源文件可以分别在 <code>vendor.harman.hardware.demoComponent.demoService@1.0_genc++_headers</code> 和 <code>vendor.harman.hardware.demoComponent.demoService@1.0_genc++ </code>中找到。 <strong>在 <code>DemoServiceImpl.h</code> 里需要 <code>#include</code> 引用这些自动生成的头文件。</strong></p><p>下方展示的是自动生成的头文件 <code>IDemoServiceDef.h</code> 的部分代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HIDL_GENERATED_VENDOR_HARMAN_HARDWARE_DEMOCOMPONENT_DEMOSERVICE_V1_0_IDEMOSERVICEDEF_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HIDL_GENERATED_VENDOR_HARMAN_HARDWARE_DEMOCOMPONENT_DEMOSERVICE_V1_0_IDEMOSERVICEDEF_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hidl/base/1.0/IBase.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/IDemoCallback.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/types.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hidl/manager/1.0/IServiceNotification.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/HidlSupport.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/MQDescriptor.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/Status.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/NativeHandle.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/misc.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> vendor &#123;<br><span class="hljs-keyword">namespace</span> harman &#123;<br><span class="hljs-keyword">namespace</span> hardware &#123;<br><span class="hljs-keyword">namespace</span> demoComponent &#123;<br><span class="hljs-keyword">namespace</span> demoService &#123;<br><span class="hljs-keyword">namespace</span> V1_0 &#123;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IDemoServiceDef</span> : <span class="hljs-keyword">public</span> ::android::hidl::base::V1_0::IBase &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isRemote</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><br><br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">virtual</span> ::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// ....省略</span><br>&#125;;<br><br><span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoServiceDef&gt;&amp;)</span></span>;<br><br>&#125;  <span class="hljs-comment">// namespace V1_0</span><br>&#125;  <span class="hljs-comment">// namespace demoService</span><br>&#125;  <span class="hljs-comment">// namespace demoComponent</span><br>&#125;  <span class="hljs-comment">// namespace hardware</span><br>&#125;  <span class="hljs-comment">// namespace harman</span><br>&#125;  <span class="hljs-comment">// namespace vendor</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// HIDL_GENERATED_VENDOR_HARMAN_HARDWARE_DEMOCOMPONENT_DEMOSERVICE_V1_0_IDEMOSERVICEDEF_H</span></span><br></code></pre></td></tr></table></figure><p>然后在 <code>DemoServiceImpl.cpp</code> 中实现各方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceImpl.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><br>DemoServiceImpl::<span class="hljs-built_in">DemoServiceImpl</span>() &#123;<br><br>&#125;<br><br>::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">DemoServiceImpl::setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoServiceImpl setStatus&quot;</span>);<br>    <span class="hljs-comment">// 省略设置状态的代码</span><br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService invokes callback&quot;</span>);<br>    <span class="hljs-comment">// 在最后执行回调函数发送通知</span><br>    callback-&gt;<span class="hljs-built_in">onCallbackEvent</span>(sta);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">DemoServiceImpl::registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoServiceImpl registerCallback&quot;</span>);<br>    <span class="hljs-comment">// 保存回调函数</span><br>    callback = cb;<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService callback function saved&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>::android::<span class="hljs-function">hardware::Return&lt;<span class="hljs-type">int32_t</span>&gt; <span class="hljs-title">DemoServiceImpl::unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoServiceImpl unregisterCallback&quot;</span>);<br>    <span class="hljs-keyword">if</span> (callback == cb) &#123;<br>        <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService callback function cleared.&quot;</span>);<br>        <span class="hljs-comment">// 清空回调函数</span><br>        callback = <span class="hljs-literal">nullptr</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService callback function mismatch, uncleared.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这 3 个接口的实现写得很简单，直接看代码注释就可以，无需赘言。</p><h3 id="2-3-将-HAL-注册为-Binder-服务"><a href="#2-3-将-HAL-注册为-Binder-服务" class="headerlink" title="2.3 将 HAL 注册为 Binder 服务"></a>2.3 将 HAL 注册为 Binder 服务</h3><p><strong>因为 Binder 化的 HAL 以独立本地进程的形式运行</strong>，<strong>所以必定需要 main() 函数作为进程启动入口</strong>。我们当然可以把 main() 写在 DemoServiceImpl.cpp 中，但为了与接口实现进行区分，我在<code>default/ </code>目录下新建源文件 <code>DemoService.cpp</code>，在该文件中实现且仅实现 main() 函数。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_TAG <span class="hljs-string">&quot;vendor.harman.demoComponent.demoService@1.0-service&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/log.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/ProcessState.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/LegacySupport.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceImpl.h&quot;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-comment">/* argc */</span>, <span class="hljs-type">char</span>* <span class="hljs-comment">/* argv */</span> [])</span> </span>&#123;<br>    android::ProcessState::<span class="hljs-built_in">initWithDriver</span>(<span class="hljs-string">&quot;/dev/hwbinder&quot;</span>);  <span class="hljs-comment">// 初始化 Binder 驱动</span><br>    <span class="hljs-keyword">auto</span> service = std::<span class="hljs-built_in">make_unique</span>&lt;DemoServiceImpl&gt;();      <span class="hljs-comment">// 构造 DemoServiceImpl 实例</span><br>    android::hardware::<span class="hljs-built_in">configureRpcThreadpool</span>(<span class="hljs-number">4</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/* callerWillJoin */</span>);<br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;DemoService registerAsService&quot;</span>);<br>    android::<span class="hljs-type">status_t</span> status = service-&gt;<span class="hljs-built_in">registerAsService</span>();  <span class="hljs-comment">// 注册为 Binder 服务</span><br>    <span class="hljs-keyword">if</span> (status != android::OK) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Unable to register DemoService (%d)&quot;</span>, status);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    android::hardware::<span class="hljs-built_in">joinRpcThreadpool</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在 <strong>main()</strong> 函数中主要干了些事：使用设备节点 <code>/dev/hwbinder</code> 初始化 Binder 驱动，并以单例（Singleton）的方式将 <code>DemoServiceImpl</code> 类的一个实例注册为 Binder 服务。</p><p><strong>如果你希望 HAL 进程也能与其它本地进程交互，那么在初始化驱动的时候应该使用</strong> <code>/dev/vndbinder</code>。</p><h2 id="3-实现-Bp、Bn-端"><a href="#3-实现-Bp、Bn-端" class="headerlink" title="3.实现 Bp、Bn 端"></a>3.实现 Bp、Bn 端</h2><p><strong>【前言】</strong></p><p>既然 Binder 化的 HAL 依赖于 Binder 机制进行实现，那么我们自然必须按照 Binder 框架，相应编写 <strong>demoComponent HAL</strong> 的 <strong>Bp</strong> 端和 <strong>Bn</strong> 端。只有这样，才能打通客户端进程调用到服务端进程 —— 我们的 demoService —— 的通路。</p><h3 id="3-1-定义demoService接口类"><a href="#3-1-定义demoService接口类" class="headerlink" title="3.1 定义demoService接口类"></a>3.1 定义demoService接口类</h3><p>要将 demoService 接入 Binder，就必须定义一个我们自己的接口类，继承 Binder 的接口基类 <code>IInterface</code>，并实现所有 Binder 通信过程中要用到的方法。不过我们并不需要事无巨细地完成这项繁杂的工作，因为 Binder 框架提供了数个模板类和宏，大大方便了我们实现。</p><p>还记得在上一节《实现 HAL 主体》里我们创建了 <code>default/</code> 目录。在该目录下新建头文件 <code>DemoServiceBinderInterface.h</code>，并在这个头文件里定义接口类 <code>IDemoService</code>。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/IInterface.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vendor/harman/hardware/demoComponent/demoService/1.0/IDemoCallback.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEMOSERVICE_NAME <span class="hljs-string">&quot;com.qidi.demoService&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><span class="hljs-keyword">using</span> ::vendor::harman::hardware::demoComponent::demoService::V1_0::IDemoCallback;<br><span class="hljs-keyword">using</span> ::vendor::harman::hardware::demoComponent::demoService::V1_0::DemoData;<br><br><span class="hljs-keyword">namespace</span> android &#123;<br><br>    <span class="hljs-comment">// command codes for binder transactions</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">eDemoServiceTransactionID</span><br>    &#123;<br>        SET_STATUS = android::IBinder::FIRST_CALL_TRANSACTION,<br>        REGISTER_CALLBACK,<br>        UNREGISTER_CALLBACK<br>    &#125;;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">IDemoService</span>: <span class="hljs-keyword">public</span> IInterface &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">DECLARE_META_INTERFACE</span>(DemoService);<br><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>= <span class="hljs-number">0</span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了定义类 <code>IDemoService</code>，我们还在头文件 <code>DemoServiceBinderInterface.h</code> 里以<strong>枚举数据的形式</strong>定义了和 demoService Binder 调用相关的 Command code。 三个 Command code <code>SET_STATUS</code>、<code>REGISTER_CALLBACK</code> 和 <code>UNREGISTER_CALLBACK</code> 分别对应 demoService 的三个接口。<strong>第一个 Command code 必须赋值为</strong> <code>android::IBinder::FIRST_CALL_TRANSACTION</code>。</p><p>宏 <code>DECLARE_META_INTERFACE()</code> 主要用来声明用于 Binder 通信的成员变量 <code>descriptor</code> 和通用接口 <code>asInterface()</code> 、 <code>getInterfaceDescriptor()</code>。 相关代码位于 <code>IInterface.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span><br><span class="hljs-meta">    static const ::android::String16 descriptor;                        \</span><br><span class="hljs-meta">    static ::android::sp<span class="hljs-string">&lt;I##INTERFACE&gt;</span> asInterface(                     \</span><br><span class="hljs-meta">            const ::android::sp<span class="hljs-string">&lt;::android::IBinder&gt;</span>&amp; obj);              \</span><br><span class="hljs-meta">    virtual const ::android::String16&amp; getInterfaceDescriptor() const;  \</span><br><span class="hljs-meta">    I##INTERFACE();                                                     \</span><br><span class="hljs-meta">    virtual ~I##INTERFACE();                                            \</span><br></code></pre></td></tr></table></figure><p>至此，demoService 的接口类就定义好了。</p><h3 id="3-2-声明-Bp、Bn-端"><a href="#3-2-声明-Bp、Bn-端" class="headerlink" title="3.2 声明 Bp、Bn 端"></a>3.2 声明 Bp、Bn 端</h3><p>有了接口类之后，就可以正式着手 Bp、Bn 端的工作了。依照先声明后实现的顺序，我们继续在 <code>default/</code> 目录下新建头文件 <code>BpDemoService.h</code> 和 <code>BnDemoService.h</code>。<strong>Binder 框架提供了模板类<code>BpInterface&lt;&gt;</code>和 <code>BnInterface&lt;&gt;</code> 来简化这一过程</strong>。</p><ul><li><strong><code>BpDemoService.h</code> 代码如下：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><br><span class="hljs-keyword">namespace</span> android &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">BpDemoService</span>: <span class="hljs-keyword">public</span> BpInterface&lt;android::IDemoService&gt; &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">BpDemoService</span>(<span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; impl);<br><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span></span>;<br>    &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Bp 端头文件中将 <code>IDemoService</code> 作为参数传入 <code>BpInterface&lt;&gt;</code> 模板，所以需要引用 <code>DemoServiceBinderInterface.h</code>。由于模板类的设计，文件中声明的 demoService 的 3 个接口将被整合到 Binder 框架代码中。我们即便不去关注其中的细节也没关系，只要负责填入接口类和接口声明，剩下的交给 Binder 框架就好。当然，如果你充满好奇且时间充裕，也可以一头扎进去理一理思路。 <code>BpInterface&lt;&gt;</code> 模板类的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> INTERFACE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BpInterface</span> : <span class="hljs-keyword">public</span> INTERFACE, <span class="hljs-keyword">public</span> BpRefBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span>                    <span class="hljs-title">BpInterface</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; remote)</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IBinder*            <span class="hljs-title">onAsBinder</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong><code>BnDemoService.h</code> 代码如下：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> android &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">BnDemoService</span>: <span class="hljs-keyword">public</span> BnInterface&lt;IDemoService&gt; &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">status_t</span> <span class="hljs-title">onTransact</span><span class="hljs-params">( <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                Parcel* reply, <span class="hljs-type">uint32_t</span> flags = <span class="hljs-number">0</span>)</span></span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Bn 端头文件的内容与 Bp 端类似，但需要注意，由于 Binder 框架的设计原因，这里的方法名 <code>onTransact()</code> 及参数都是固定的，我们不能写成其它形式。</strong> <code>BnInterface&lt;&gt;</code> 模板类在 <code>IInterface.h</code> 中的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> INTERFACE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BnInterface</span> : <span class="hljs-keyword">public</span> INTERFACE, <span class="hljs-keyword">public</span> BBinder<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> sp&lt;IInterface&gt;      <span class="hljs-title">queryLocalInterface</span><span class="hljs-params">(<span class="hljs-type">const</span> String16&amp; _descriptor)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> String16&amp;     <span class="hljs-title">getInterfaceDescriptor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IBinder*            <span class="hljs-title">onAsBinder</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-3-实现-Bp、Bn-端"><a href="#3-3-实现-Bp、Bn-端" class="headerlink" title="3.3 实现 Bp、Bn 端"></a>3.3 实现 Bp、Bn 端</h3><p>声明之后，该进行实现了。继续在 <code>default/</code> 目录下新建源文件 <code>BpDemoService.cpp</code> 和 <code>BnDemoService.cpp</code>。</p><p>实现过程只是顺水推舟而已，直接看代码吧。</p><ul><li><strong>BpDemoService.cpp:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/Log.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/IServiceManager.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/Parcel.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;BpDemoService.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_D ALOGD</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_E ALOGE</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> android;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><br><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">BpDemoService::setStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> DemoData&amp; sta)</span> </span>&#123;<br>    Parcel data, reply;<br><br>    data.<span class="hljs-built_in">writeInterfaceToken</span>(IDemoService::<span class="hljs-built_in">getInterfaceDescriptor</span>());<br>    data.<span class="hljs-built_in">write</span>(&amp;sta, <span class="hljs-built_in">sizeof</span>(DemoData));<br><br>    <span class="hljs-type">status_t</span> status = <span class="hljs-built_in">remote</span>()-&gt;<span class="hljs-built_in">transact</span>(SET_STATUS, data, &amp;reply);<br>    <span class="hljs-keyword">if</span> (status != NO_ERROR) &#123;<br>        <span class="hljs-built_in">LOG_E</span>(<span class="hljs-string">&quot;BpDemoService::setStatus transact failed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> reply.<span class="hljs-built_in">readInt32</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">BpDemoService::registerCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>&#123;<br>    Parcel data, reply;<br><br>    data.<span class="hljs-built_in">writeInterfaceToken</span>(IDemoService::<span class="hljs-built_in">getInterfaceDescriptor</span>());<br>    data.<span class="hljs-built_in">write</span>(&amp;cb, <span class="hljs-built_in">sizeof</span>(::android::sp&lt;IDemoCallback&gt;));<br><br>    <span class="hljs-type">status_t</span> status = <span class="hljs-built_in">remote</span>()-&gt;<span class="hljs-built_in">transact</span>(REGISTER_CALLBACK, data, &amp;reply);<br>    <span class="hljs-keyword">if</span> (status != NO_ERROR) &#123;<br>        <span class="hljs-built_in">LOG_E</span>(<span class="hljs-string">&quot;BpDemoService::registerCallback transact failed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> reply.<span class="hljs-built_in">readInt32</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">BpDemoService::unregisterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ::android::sp&lt;IDemoCallback&gt;&amp; cb)</span> </span>&#123;<br>    Parcel data, reply;<br><br>    data.<span class="hljs-built_in">writeInterfaceToken</span>(IDemoService::<span class="hljs-built_in">getInterfaceDescriptor</span>());<br>    data.<span class="hljs-built_in">write</span>(&amp;cb, <span class="hljs-built_in">sizeof</span>(::android::sp&lt;IDemoCallback&gt;));<br><br>    <span class="hljs-type">status_t</span> status = <span class="hljs-built_in">remote</span>()-&gt;<span class="hljs-built_in">transact</span>(UNREGISTER_CALLBACK, data, &amp;reply);<br>    <span class="hljs-keyword">if</span> (status == NO_ERROR) &#123;<br>        <span class="hljs-built_in">LOG_E</span>(<span class="hljs-string">&quot;BpDemoService::unregisterCallback transact failed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> reply.<span class="hljs-built_in">readInt32</span>();<br>&#125;<br><br>BpDemoService::<span class="hljs-built_in">BpDemoService</span>(<span class="hljs-type">const</span> sp&lt;IBinder&gt; &amp;impl) : <span class="hljs-built_in">BpInterface</span>&lt;IDemoService&gt;(impl) &#123;&#125;<br><span class="hljs-built_in">IMPLEMENT_META_INTERFACE</span>(DemoService, DEMOSERVICE_NAME);<br><br></code></pre></td></tr></table></figure><p>Bp 端的源文件里使用了宏 <code>IMPLEMENT_META_INTERFACE()</code>，扩展之后即是宏 <code>DECLARE_META_INTERFACE()</code> 所声明的接口的实现。</p><p>这个宏同样定义在 <code>IInterface.h</code> 中，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span><br><span class="hljs-meta">    const ::android::String16 I##INTERFACE::descriptor(NAME);           \</span><br><span class="hljs-meta">    const ::android::String16&amp;                                          \</span><br><span class="hljs-meta">            I##INTERFACE::getInterfaceDescriptor() const &#123;              \</span><br><span class="hljs-meta">        return I##INTERFACE::descriptor;                                \</span><br><span class="hljs-meta">    &#125;                                                                   \</span><br><span class="hljs-meta">    ::android::sp<span class="hljs-string">&lt;I##INTERFACE&gt;</span> I##INTERFACE::asInterface(              \</span><br><span class="hljs-meta">            const ::android::sp<span class="hljs-string">&lt;::android::IBinder&gt;</span>&amp; obj)               \</span><br><span class="hljs-meta">    &#123;                                                                   \</span><br><span class="hljs-meta">        ::android::sp<span class="hljs-string">&lt;I##INTERFACE&gt;</span> intr;                               \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (obj != NULL) &#123;                                              \</span><br><span class="hljs-meta">            intr = static_cast<span class="hljs-string">&lt;I##INTERFACE*&gt;</span>(                          \</span><br><span class="hljs-meta">                obj-&gt;queryLocalInterface(                               \</span><br><span class="hljs-meta">                        I##INTERFACE::descriptor).get());               \</span><br><span class="hljs-meta">            <span class="hljs-keyword">if</span> (intr == NULL) &#123;                                         \</span><br><span class="hljs-meta">                intr = new Bp##INTERFACE(obj);                          \</span><br><span class="hljs-meta">            &#125;                                                           \</span><br><span class="hljs-meta">        &#125;                                                               \</span><br><span class="hljs-meta">        return intr;                                                    \</span><br><span class="hljs-meta">    &#125;                                                                   \</span><br><span class="hljs-meta">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span><br><span class="hljs-meta">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span><br></code></pre></td></tr></table></figure><ul><li><strong>BnDemoService.cpp:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/Log.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utils/Errors.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binder/Parcel.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;BnDemoService.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DemoServiceBinderInterface.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_D ALOGD</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_E ALOGE</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> android;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> vendor::harman::hardware::demoComponent::demoService::V1_0;<br><span class="hljs-keyword">using</span> ::vendor::harman::hardware::demoComponent::demoService::V1_0::DemoData;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BnDemoService::onTransact</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel &amp;data, Parcel *reply, <span class="hljs-type">uint32_t</span> flags)</span> </span>&#123;<br>    <span class="hljs-type">status_t</span> retCode = NO_ERROR;<br>    <span class="hljs-keyword">switch</span> (code) &#123;<br>        <span class="hljs-keyword">case</span> SET_STATUS:&#123;<br>            <span class="hljs-built_in">LOG_D</span>(<span class="hljs-string">&quot;BnDemoService SET_STATUS()&quot;</span>);<br>            <span class="hljs-built_in">CHECK_INTERFACE</span>(IDemoService, data, reply);<br>            DemoData sta;<br>            data.<span class="hljs-built_in">read</span>(&amp;sta, <span class="hljs-built_in">sizeof</span>(DemoData));<br>            reply-&gt;<span class="hljs-built_in">writeInt32</span>(<span class="hljs-built_in">setStatus</span>(sta));<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> REGISTER_CALLBACK:&#123;<br>            <span class="hljs-built_in">LOG_D</span>(<span class="hljs-string">&quot;BnDemoService REGISTER_CALLBACK()&quot;</span>);<br>            <span class="hljs-built_in">CHECK_INTERFACE</span>(IDemoService, data, reply);<br>            ::android::sp&lt;IDemoCallback&gt; rcb;<br>            data.<span class="hljs-built_in">read</span>(&amp;rcb, <span class="hljs-built_in">sizeof</span>(::android::sp&lt;IDemoCallback&gt;));<br>            reply-&gt;<span class="hljs-built_in">writeInt32</span>(<span class="hljs-built_in">registerCallback</span>(rcb));<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> UNREGISTER_CALLBACK: &#123;<br>            <span class="hljs-built_in">LOG_D</span>(<span class="hljs-string">&quot;BnDemoService UNREGISTER_CALLBACK()&quot;</span>);<br>            <span class="hljs-built_in">CHECK_INTERFACE</span>(IDemoService, data, reply);<br>            sp&lt;IDemoCallback&gt; urcb;<br>            data.<span class="hljs-built_in">read</span>(&amp;urcb, <span class="hljs-built_in">sizeof</span>(::android::sp&lt;IDemoCallback&gt;));<br>            reply-&gt;<span class="hljs-built_in">writeInt32</span>(<span class="hljs-built_in">unregisterCallback</span>(urcb));<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>: &#123;<br>            <span class="hljs-built_in">LOG_E</span>(<span class="hljs-string">&quot;BnDemoService::onTransact(0x%x,0x%x)&quot;</span>, code, flags);<br>            retCode = BBinder::<span class="hljs-built_in">onTransact</span>(code, data, reply, flags);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> retCode;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Bn 端的源文件里对 <code>onTransact()</code> 进行实现，使用 <code>switch...case...</code> 对 Command code 进行处理。<strong>在每个 case 的末尾可以看到对 demoService 里各个方法的调用</strong>，并将调用的返回值写入 reply。</p><h2 id="4-编译与打包"><a href="#4-编译与打包" class="headerlink" title="4.编译与打包"></a>4.编译与打包</h2><h3 id="4-1-编写Makefile"><a href="#4-1-编写Makefile" class="headerlink" title="4.1 编写Makefile"></a>4.1 编写Makefile</h3><p><strong>这里说的 Makefile 是指 <code>Android.bp</code>（当然也可以使用 <code>Android.mk</code>，语法稍有区别）</strong>。</p><p>在 <code>default/</code> 目录下新建文件 <code>Android.bp</code>，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cc_defaults &#123;<br>    name: <span class="hljs-string">&quot;demoSvc_v1_0_default&quot;</span>,<br>    shared_libs: [<br>        <span class="hljs-string">&quot;libhidlbase&quot;</span>,<br>        <span class="hljs-string">&quot;libhidltransport&quot;</span>,<br>        <span class="hljs-string">&quot;liblog&quot;</span>,<br>        <span class="hljs-string">&quot;libutils&quot;</span>,<br>        <span class="hljs-string">&quot;libhardware&quot;</span>,<br>        <span class="hljs-string">&quot;libbinder&quot;</span>,<br>        <span class="hljs-string">&quot;vendor.harman.hardware.demoComponent.demoService@1.0_vendor&quot;</span>,<br>    ],<br>    cflags: [<br>        <span class="hljs-string">&quot;-Wall&quot;</span>,<br>        <span class="hljs-string">&quot;-Wextra&quot;</span>,<br>        <span class="hljs-string">&quot;-Werror&quot;</span>,<br>    ],<br>&#125;<br><br>cc_binary &#123;<br>    name: <span class="hljs-string">&quot;vendor.harman.demoComponent.demoService@1.0-service&quot;</span>,<br>    defaults: [<span class="hljs-string">&quot;demoSvc_v1_0_default&quot;</span>],<br>    init_rc: [<span class="hljs-string">&quot;vendor.harman.demoComponent.demoService@1.0-service.rc&quot;</span>],<br>    vendor: <span class="hljs-literal">true</span>,<br>    relative_install_path: <span class="hljs-string">&quot;hw&quot;</span>,<br><br>    include_dirs:[<span class="hljs-string">&quot;vendor/harman/hardware/interfaces/demoComponent/demoService/1.0/default&quot;</span>],<br>    srcs: [<br>        <span class="hljs-string">&quot;DemoService.cpp&quot;</span>,<br>        <span class="hljs-string">&quot;DemoServiceImpl.cpp&quot;</span>,<br>        <span class="hljs-string">&quot;BpDemoService.cpp&quot;</span>,<br>        <span class="hljs-string">&quot;BnDemoService.cpp&quot;</span><br>    ],<br>    shared_libs: [<br>        <span class="hljs-string">&quot;libbase&quot;</span>,<br>        <span class="hljs-string">&quot;libprotobuf-cpp-lite&quot;</span>,<br>        <span class="hljs-string">&quot;vendor.harman.hardware.demoComponent.demoService@1.0_vendor&quot;</span><br>    ],<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>目标 demoSvc_v1_0_default 可以理解成是将和 Binder 框架相关的库打包而成的一个总的库文件，<a href="mailto:&#118;&#101;&#110;&#x64;&#x6f;&#114;&#46;&#104;&#97;&#114;&#x6d;&#97;&#x6e;&#x2e;&#x68;&#97;&#114;&#x64;&#119;&#x61;&#x72;&#101;&#46;&#x64;&#x65;&#109;&#111;&#x43;&#x6f;&#x6d;&#112;&#x6f;&#110;&#x65;&#x6e;&#x74;&#x2e;&#x64;&#101;&#x6d;&#111;&#83;&#x65;&#114;&#x76;&#105;&#99;&#x65;&#64;&#49;&#46;&#x30;&#95;&#x76;&#101;&#110;&#x64;&#x6f;&#x72;">&#118;&#101;&#110;&#x64;&#x6f;&#114;&#46;&#104;&#97;&#114;&#x6d;&#97;&#x6e;&#x2e;&#x68;&#97;&#114;&#x64;&#119;&#x61;&#x72;&#101;&#46;&#x64;&#x65;&#109;&#111;&#x43;&#x6f;&#x6d;&#112;&#x6f;&#110;&#x65;&#x6e;&#x74;&#x2e;&#x64;&#101;&#x6d;&#111;&#83;&#x65;&#114;&#x76;&#105;&#99;&#x65;&#64;&#49;&#46;&#x30;&#95;&#x76;&#101;&#110;&#x64;&#x6f;&#x72;</a> 是通过接口描述文件自动生成的，同样可以在 &#x2F;out&#x2F;soong&#x2F;.intermediates&#x2F;… 目录下找到；</p></li><li><p>目标 <a href="mailto:&#118;&#101;&#110;&#x64;&#111;&#x72;&#x2e;&#x68;&#x61;&#114;&#x6d;&#x61;&#110;&#46;&#100;&#101;&#x6d;&#x6f;&#x43;&#111;&#109;&#x70;&#x6f;&#x6e;&#x65;&#x6e;&#x74;&#x2e;&#100;&#x65;&#109;&#111;&#x53;&#101;&#x72;&#x76;&#105;&#99;&#x65;&#x40;&#49;&#x2e;&#48;&#45;&#x73;&#101;&#x72;&#118;&#105;&#99;&#x65;">&#118;&#101;&#110;&#x64;&#111;&#x72;&#x2e;&#x68;&#x61;&#114;&#x6d;&#x61;&#110;&#46;&#100;&#101;&#x6d;&#x6f;&#x43;&#111;&#109;&#x70;&#x6f;&#x6e;&#x65;&#x6e;&#x74;&#x2e;&#100;&#x65;&#109;&#111;&#x53;&#101;&#x72;&#x76;&#105;&#99;&#x65;&#x40;&#49;&#x2e;&#48;&#45;&#x73;&#101;&#x72;&#118;&#105;&#99;&#x65;</a> 就是最终要生成的可执行文件；</p></li><li><p>属性 vendor: true 表示这是一个自定义的文件；</p></li><li><p>属性 relative_install_path: “hw” 和前一个属性共同作用，表示生成文件的相对存放位置在 <code>out/target/product/&lt;ProductName&gt;/vendor/bin/hw/ </code>目录；</p></li><li><p>属性 srcs 属性下包含了我们在之前几篇文章里编写的所有源文件 —— DemoService.cpp、DemoServiceImpl.cpp、BpDemoService.cpp 和 BnDemoService.cpp。</p></li></ul><h3 id="4-2-编写HAL启动脚本"><a href="#4-2-编写HAL启动脚本" class="headerlink" title="4.2 编写HAL启动脚本"></a>4.2 编写HAL启动脚本</h3><p>基于上述的 Makefile 在 <code>default/</code> 目录下<strong>手动（mm 命令）</strong>进行编译，我们能得到名为 <code>vendor.harman.demoComponent.demoService@1.0-service</code> 的可执行文件。为了让 demoComponent HAL 随系统启动而启动，我们还需要编写 <code>*.rc</code> 脚本，并在脚本中标注进程名、可执行文件、用户组等信息。</p><p>一般以可执行文件名作为脚本名，也就是 <code>vendor.harman.demoComponent.demoService@1.0-service.rc</code>。</p><p>在 <code>default/</code> 目录下新建脚本，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">service MyDemoService /vendor/bin/hw/vendor.harman.demoComponent.demoService@1.0-service<br>    class main<br>    user system<br>    group system<br>    capabilities sys_nice net_bind_service net_admin net_raw<br></code></pre></td></tr></table></figure><ul><li><p>关键字 service 用来定义一个进程（或称为本地服务），后面第一个参数 MyDemoService 是进程名，第二个参数是可执行文件的绝对路径；</p></li><li><p>class main 表示把 MyDemoService 归属到 main 类；</p></li><li><p>user system 和 group system 表示 MyDemoService 的用户和组用户都是 system；</p></li><li><p>capabilities 指定了一些权限相关的属性。</p></li></ul><h3 id="4-3-打包可执行文件到系统镜像"><a href="#4-3-打包可执行文件到系统镜像" class="headerlink" title="4.3 打包可执行文件到系统镜像"></a>4.3 打包可执行文件到系统镜像</h3><p>要实现 demoComponent HAL 随系统启动而启动，需要将它的 <code>可执行文件</code> 和 <code>*.rc</code> 文件都打包进系统镜像。通过修改产品的 Makefile 可以实现这一目的。</p><p>先在 <code>/device/&lt;CompanyName&gt;/&lt;PlatformName&gt;/common/</code> 路径下为 demoComponent HAL 新建一个名为 <code>demoComponent/</code> 的专属目录，再在这个目录下创建名为 <code>device_demoComponent.mk</code> 的 Makefile。（其实叫什么名字都可以，但是用 demoComponent 更直观）</p><p><strong>如此一来我们就有了 <code>/device/harman/broxton/common/demoComponent/device_demoComponent.mk</code>。</strong> 除去注释，Makefile 内容只有一句话：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">############################</span><br><span class="hljs-comment"># DemoService</span><br><span class="hljs-comment">############################</span><br><br>PRODUCT_PACKAGES += vendor.harman.demoComponent.demoService@1.0-service<br></code></pre></td></tr></table></figure><p>这句话表示要将可执行文件 <code>vendor.harman.demoComponent.demoService@1.0-service</code> 打包进系统镜像，确切地说是打包进 <code>vendor.img</code>。</p><p>切记，不要忘了把我们新建的 Makefile 添加到产品的 Makefile 中。 产品 Makefile 一般位于 <code>/device/&lt;CompanyName&gt;/&lt;PlatformName&gt;/&lt;ProductName&gt;/device.mk</code>，所以我们在 <code>/device/harman/broxton/XXXX/device.mk</code> 中增加以下语句（以 diff 形式展示）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">diff --git a/XXXX/device.mk b/XXXX/device.mk<br>index b0866f3d2..d7a7d8ef7 100755<br>--- a/XXXX/device.mk<br>+++ b/XXXX/device.mk<br>@@ -1,5 +1,6 @@<br> <span class="hljs-keyword">include</span> device/harman/broxton/common/device_common.mk<br> <span class="hljs-keyword">include</span> <span class="hljs-variable">$(LOCAL_PATH)</span>/audio/device_audio.mk<br>+<span class="hljs-keyword">include</span> device/harman/broxton/common/demoComponent/device_demoComponent.mk<br> <span class="hljs-keyword">include</span> device/harman/broxton/common/tuner/device_radioTuner.mk<br> <span class="hljs-keyword">include</span> device/harman/broxton/common/speech/vpa.mk<br></code></pre></td></tr></table></figure><p>注意上面以 <code>+</code> 开头的 <code>include</code> 语句，就是在引用我们的新建 Makefile。</p><hr><p><strong>【结语】</strong></p><p>打包已经完成，我们的 demoComponent HAL 正跃跃欲试。但如果你将打包好的系统镜像烧写到设备上，会发现 demoComponent HAL 不能按照预期工作，甚至连自启动都做不到。相反，我们会在 logcat 或 dmesg 里发现有很多日志提示我们没有操作权限。 下一节《添加执行权限》将介绍如何给 demoComponent HAL 添加必要的权限。</p><p>如果你急切地想看一看刚刚写好的 HAL 进程运行的样子，可以执行命令 <code>setenforce 0</code> 将设备的 SELinux 策略暂时关闭。 这样尽管系统仍然会报告权限错误，但不会禁止运行。</p><h2 id="5-添加执行权限"><a href="#5-添加执行权限" class="headerlink" title="5.添加执行权限"></a>5.添加执行权限</h2><p><strong>【前言】</strong></p><p>demoComponent HAL 已经成功编译且打包到系统镜像中，但到目前为止还没有被赋予访问 Binder 的权限。所以我们至少会看到，在将 demoService 注册为 Binder 服务时，日志中会打印类似下方的提示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[   <span class="hljs-number">10.368517</span>] type=<span class="hljs-number">1400</span> <span class="hljs-built_in">audit</span>(<span class="hljs-number">1483292256.112</span>:<span class="hljs-number">14</span>): avc: denied &#123; add &#125; ...<br></code></pre></td></tr></table></figure><p>这篇文章就是要说明完善 demoComponent HAL 所需要的 SELinux 权限的方法。</p><h3 id="5-1-编写策略文件"><a href="#5-1-编写策略文件" class="headerlink" title="5.1 编写策略文件"></a>5.1 编写策略文件</h3><p>依各公司习惯不同，用于配置产品权限的文件一般放在 <code>/device/&lt;CompanyName&gt;/sepolicy/</code> 或 <code>/device/&lt;CompanyName&gt;/common/sepolicy/</code> 目录下（也不排除是其它路径的可能性，但肯定是在<code>device/</code> 目录下的某个 <code>sepolicy/ </code>子目录）。在这个目录下，再为不同的部件分别创建相应的子目录，并在这个子目录中新建 <code>*.te</code> 文件和 <code>*_contexts</code> 文件，以添加必要的权限。</p><p>还是以我正在使用的平台为例，创建新目录 <code>/device/harman/sepolicy/demoComponent/</code>，并在该目录下新建如下图所示的文件：</p><img src="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/20200720203213989.png"><p>说明下各文件的内容和作用：</p><ul><li><strong>file_contexts:</strong><ul><li>首先编写 <code>file_contexts</code> 文件。这个文件名是由 SELinux 框架固定的。我们在 <code>file_contexts</code> 中将 demoService 的可执行文件定义为安全对象。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> demoService executable binary as a security object</span><br>/vendor/bin/hw/vendor.harman.demoComponent.demoService@<span class="hljs-number">1.0</span>-service   u:object_r:demoService_exec:s0<br></code></pre></td></tr></table></figure><ul><li><strong>hwservice_contexts:</strong><ul><li>然后，因为 demoComponent HAL 依赖 hwbinder 进行通信，所以我们还需要编写 <code>hwservice_contexts</code>。这个文件名也是由 SELinux 框架固定的。我们在这个文件中将新增的接口定义为一个安全对象，作用和 file_contexts 类似。（如果使用 vndbinder，则应编写 vndservice_contexts）</li><li>从 Android 8.0 开始，SELinux 也一分为二成为了 system 部分和 vendor 部分。其中 vendor 部分又因为不同部件使用的 binder 节点不同，从原先唯一的的 <code>service_contexts</code> 中剥离出了 <code>hwservice_contexts</code> 和 <code>vndservice_contexts</code> 两个文件。当使用 &#x2F;dev&#x2F;hwbinder 时手动创建前者并在文件中添加定义，当使用 &#x2F;dev&#x2F;vndbinder 时创建后者并同样在文件中添加定义。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> HAL interface as a security object</span><br>vendor.harman.hardware.demoComponent.demoService::IDemoServiceDef  u:object_r:vendor_demoService_hwservice:s0<br></code></pre></td></tr></table></figure><ul><li><strong>hwservicemanager.te</strong>:<ul><li>由于我们使用的是 hwbinder 节点，所以还应该编写 hwservicemanager.te。文件名也是固定的。在这个文件中声明 demoService 需要使用 hwbinder。（如果使用 vndbinder，则应编写 vndservicemanager.te）</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># grant demoService permission of using hwbinder</span><br><span class="hljs-built_in">hwbinder_use</span>(demoService)<br></code></pre></td></tr></table></figure><ul><li><strong>hwservice.te:</strong><ul><li>同理，编写 <code>hwservice.te</code>。文件名依然是固定的。在这个文件中为 demoService 定义了专属的 hwservice 类型，在添加 “注册服务” 权限时会用到。（如果使用 vndbinder，则应编写 <code>vndservice.te</code>）</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> demoService as hwservice_manager, so it can be added as a hwservice</span><br>type vendor_demoService_hwservice, hwservice_manager_type;<br></code></pre></td></tr></table></figure><ul><li><strong>demoService.te:</strong><ul><li>接着编写 demoService.te 文件。 这个文件通常以需要添加权限的对象为名。在这个文件中，我们为 demoService 定义了一个专属的安全域，赋予可 demoService 的执行文件以需要的文件属性，并且为 demoService 域添加和 Binder 操作相关的必要权限，比如 “注册为服务”、“允许 hwbinder 调用” 等。</li><li>不同的 HAL 进程或本地服务要操作的文件不同，其实现的作用也不同，所以这个文件里的内容差异也很大。依照最小权限规则，根据自己的实际需要添加权限即可。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> a security domain for demo service</span><br>type demoService, domain;<br><br><span class="hljs-meta"># specify demo service attributes</span><br>type demoService_exec, exec_type, file_type, vendor_file_type;<br><br><span class="hljs-meta"># initialize demo service domain</span><br><span class="hljs-built_in">init_daemon_domain</span>(demoService)<br><br><span class="hljs-built_in">add_hwservice</span>(demoService, vendor_demoService_hwservice)<br><br><span class="hljs-built_in">binder_call</span>(demoService, vndservicemanager)<br><span class="hljs-built_in">binder_call</span>(demoService, hwservicemanager)<br><span class="hljs-built_in">binder_call</span>(demoService, system_app)<br><br>allow demoService vndbinder_device:chr_file rw_file_perms;<br>allow demoService hwservicemanager_prop:file r_file_perms;<br></code></pre></td></tr></table></figure><ul><li><strong>system_app.te:</strong><ul><li>最后，还要为用户进程添加调用权限。我们通常会以 APP 对 demoService 的调用为例说明调用过程，所以这里新建 <code>system_app.te</code>。为 system_app 添加通过 hwservice_manager 查找服务、以及通过 binder 调用 demoService 的权限。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"># <span class="hljs-function">APP access priviledges <span class="hljs-keyword">for</span> demoService</span><br><span class="hljs-function"><span class="hljs-title">binder_call</span><span class="hljs-params">(system_app, demoService)</span></span><br><span class="hljs-function">allow system_app vendor_demoService_hwservice:hwservice_manager find;</span><br></code></pre></td></tr></table></figure><h3 id="5-2-应用策略文件"><a href="#5-2-应用策略文件" class="headerlink" title="5.2 应用策略文件"></a>5.2 应用策略文件</h3><p>为了使新增的安全规则生效，需要将刚刚创建的目录添加到 Makefile 中，这样一来编译镜像时就可以扫描到了。我们一般把这个改动添加到 <code>/device/&lt;CompanyName&gt;/&lt;PlatformName&gt;/&lt;ProductName&gt;/BoardConfig.mk</code>。</p><p>这里我改动的文件是 <code>/device/harman/broxton/XXXX/BoardConfig.mk</code>，修改部分如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile">diff --git a/XXXX/BoardConfig.mk b/XXXX/BoardConfig.mk<br>index 4979507a7..8e700f22d 100755<br>--- a/XXXX/BoardConfig.mk<br>+++ b/XXXX/BoardConfig.mk<br>@@ -72,6 +72,12 @@ BOARD_SEPOLICY_DIRS += device/harman/sepolicy/vold<br> INTEL_AUDIO_HAL=imc<br> BOARD_SEPOLICY_DIRS += device/harman/sepolicy/audio<br>+<br>+<span class="hljs-comment">########################################################</span><br>+<span class="hljs-comment"># DemoService</span><br>+<span class="hljs-comment">########################################################</span><br>+BOARD_SEPOLICY_DIRS += device/harman/sepolicy/demoComponent<br>+<br></code></pre></td></tr></table></figure><hr><p><strong>【结语】</strong></p><p>完全编译后，烧写镜像到设备上。待设备启动后，执行命令 <code>ps -A | grep -i demo</code> ，终于可以看到我们的 demoComponent HAL 进程已经随系统启动成功。</p><img src="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/2020072020305469.png"><p>如果在系统刚启动时执行命令 <code>logcat | grep -i demo</code>，还可以看到 demoComponent HAL 注册为 Binder 服务的日志打印：</p><img src="/2023/03/05/Android-8-1%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99HAL/20200720203133940.png"><h2 id="6-感谢"><a href="#6-感谢" class="headerlink" title="6.感谢"></a>6.感谢</h2><p>🎊再次感谢大佬【Qidi_Huang】的精彩博客！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理学习笔记</title>
    <link href="/2023/03/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="《哈工大编译原理》学习笔记"><a href="#《哈工大编译原理》学习笔记" class="headerlink" title="《哈工大编译原理》学习笔记"></a>《哈工大编译原理》学习笔记</h1><blockquote><p>本系列博客主要记录自己学习编译原理的笔记，并手写一个C语言编译器</p><ul><li>☃️<strong>编译原理学习资料</strong>：哈工大陈鄞老师的《编译原理》</li></ul></blockquote><ul><li><p>✏️第一章：<a href="https://anmuxixixi.github.io/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/">编译原理绪论</a></p></li><li><p>🖊️第二章：<a href="https://anmuxixixi.github.io/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/">词法及文法</a></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二、语言及其文法</title>
    <link href="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/"/>
    <url>/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="二、语言及文法"><a href="#二、语言及文法" class="headerlink" title="二、语言及文法"></a>二、语言及文法</h1><h2 id="1-字母表"><a href="#1-字母表" class="headerlink" title="1.字母表"></a>1.字母表</h2><p>字母表Σ是一个有穷符号集合；这里的符号可以是字母、数字、标点符号……下面的例子都是字母表</p><ul><li>二进制字母表：{0,1}</li><li>ASCII字符集</li><li>Unicode字符集</li></ul><p>字母表有下面几种运算：</p><ul><li>乘积</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235051480.png" alt="image-20230302235051480" style="zoom:50%;"><ul><li>n次幂</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235116133.png" alt="image-20230302235116133" style="zoom:50%;"><ul><li>正闭包</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235140690.png" alt="image-20230302235140690" style="zoom:50%;"><ul><li>克林闭包</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235156202.png" alt="image-20230302235156202" style="zoom:50%;"><h2 id="2-串"><a href="#2-串" class="headerlink" title="2.串"></a>2.串</h2><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235218276.png" alt="image-20230302235218276" style="zoom: 50%;"><p>下面介绍一下串上的运算：</p><ul><li>连接</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235351581.png" alt="image-20230302235351581" style="zoom: 50%;"><ul><li>幂</li></ul><img src="/2023/03/02/%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/image-20230302235405401.png" alt="image-20230302235405401" style="zoom:50%;"><h2 id="3-文法的定义"><a href="#3-文法的定义" class="headerlink" title="3.文法的定义"></a>3.文法的定义</h2>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、编译原理绪论</title>
    <link href="/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="一、编译原理绪论"><a href="#一、编译原理绪论" class="headerlink" title="一、编译原理绪论"></a>一、编译原理绪论</h1><h2 id="1-什么是编译"><a href="#1-什么是编译" class="headerlink" title="1.什么是编译"></a>1.什么是编译</h2><p>🫁<strong>编译</strong>：将高级语言【源语言】翻译成汇编语言或机器语言【目标语言】的过程</p><img src="/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/image-20230302225554584.png" alt="image-20230302225554584" style="zoom:67%;"><p>我们把C语言中的x &#x3D; 2编译成汇编语言<code>MOV X,2</code>，或是直接编译成机器语言<code>C706 0000 0002</code></p><p><strong>下面我们看一下整个编译的流程：</strong></p><img src="/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/image-20230302225855228.png" alt="image-20230302225855228" style="zoom: 67%;"><ul><li>预处理器：把存储在不同文件中的源程序聚合在一起；把被称为宏的缩写语句转换为原始语句</li><li>可重定位的机器代码：汇编器生成的可重定位起始代码在内存中存放的起始位置不是固定的，所有地址都是相对于起始位置的相对地址</li><li>加载器：修改可重定位地址；将修改后的指令和数据放在内存中适合的位置</li><li>链接器：将多个可重定位的机器代码文件（包括库文件）连接到一起；解决外部内部地址问题</li></ul><h2 id="2-编译器的结构"><a href="#2-编译器的结构" class="headerlink" title="2.编译器的结构"></a>2.编译器的结构</h2><img src="/2023/03/02/%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/image-20230302230959458.png" alt="image-20230302230959458" style="zoom:67%;"><p>编译器大致可以分为三个部分：</p><ul><li><p>前端部分，与源语言相关，也就是与我们写的高级语言C&#x2F;Java等有关</p></li><li><p>后端部分，与目标语言相关，也就是生成的目标机器语言</p></li><li><p>中间部分：机器无关代码优化器</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kernel下输入输出console如何实现</title>
    <link href="/2023/02/25/kernel%E4%B8%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BAconsole%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/02/25/kernel%E4%B8%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BAconsole%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="kernel下输入输出console如何实现"><a href="#kernel下输入输出console如何实现" class="headerlink" title="kernel下输入输出console如何实现"></a>kernel下输入输出console如何实现</h1><blockquote><p>🍛<strong>大部分内容转载自</strong>：</p><ul><li><a href="https://www.cnblogs.com/lifexy/p/7993136.html">https://www.cnblogs.com/lifexy/p/7993136.html</a></li><li><a href="https://blog.csdn.net/skyflying2012/article/details/41078349?spm=1001.2014.3001.5506">https://blog.csdn.net/skyflying2012/article/details/41078349?spm=1001.2014.3001.5506</a></li></ul></blockquote><h2 id="1-在驱动调试中-使用printk-是最简单-最方便的办法"><a href="#1-在驱动调试中-使用printk-是最简单-最方便的办法" class="headerlink" title="1.在驱动调试中,使用printk(),是最简单,最方便的办法"></a>1.在驱动调试中,使用printk(),是最简单,最方便的办法</h2><p>✨<strong>先说结论，当uboot命令行中设置不同的console参数，输出到的设备不同：</strong></p><ul><li><p>当uboot的命令行里的<strong>“console&#x3D;tty1”</strong>时,表示printk()输出在开发板的LCD屏上</p></li><li><p>当uboot的命令行里的<strong>“console&#x3D;ttySA0,115200”</strong>时,表示printk()输出在串口UART0上,波特率&#x3D;115200</p></li><li><p>当uboot的命令行里的<strong>“console&#x3D;tty1 console&#x3D;ttySA0,115200”</strong>时,表示printk()同时输出在串口上,以及开发板的LCD屏上</p></li></ul><p>内核又是怎么根据上面命令行参数来确定printk()的输出设备？</p><h2 id="2-以console-ttySA0-115200为例分析printk"><a href="#2-以console-ttySA0-115200为例分析printk" class="headerlink" title="2.以console=ttySA0,115200为例分析printk"></a>2.以<code>console=ttySA0,115200</code>为例分析printk</h2><h3 id="2-1-命令行激活-setup"><a href="#2-1-命令行激活-setup" class="headerlink" title="2.1 命令行激活__setup"></a>2.1 命令行激活__setup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel\printk\printk.c</span><br>__setup(<span class="hljs-string">&quot;console=&quot;</span>, console_setup);<br></code></pre></td></tr></table></figure><p>**__setup()**的作用就是：若uboot传递进来的命令行字符串里含有“console&#x3D;”,便调用console_setup()函数,并对“console&#x3D;”后面带的字符串”ttySA0,115200”进行分析</p><h3 id="2-2-调用console-setup函数"><a href="#2-2-调用console-setup函数" class="headerlink" title="2.2 调用console_setup函数"></a>2.2 调用console_setup函数</h3><p>我们以ttySA0,115200为例，分析一个<code>console_setup</code>函数，这里注意一下，这里结构体和数组同名，都是<code>console_cmdline</code>，区分一下🐖</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CMDLINECONSOLES 8</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console_cmdline</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span>name[<span class="hljs-number">16</span>];<span class="hljs-comment">/* Name of the driver    */</span><br><span class="hljs-type">int</span>    index;<span class="hljs-comment">/* Minor dev. to use    */</span><br><span class="hljs-type">char</span>*options;<span class="hljs-comment">/* Options for the driver   */</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console_cmdline</span> <span class="hljs-title">console_cmdline</span>[<span class="hljs-title">MAX_CMDLINECONSOLES</span>];</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">console_setup</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span>                    <span class="hljs-comment">//*str=&quot;ttySA0,115200&quot;</span><br>&#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-keyword">sizeof</span>(console_cmdline[<span class="hljs-number">0</span>].name)];     <span class="hljs-comment">// char name[16]</span><br>    <span class="hljs-type">char</span> *s, *options;<br>    <span class="hljs-type">int</span> idx; <br><br>    <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;                    <br>            <span class="hljs-built_in">strcpy</span>(name, <span class="hljs-string">&quot;ttyS&quot;</span>);<br>            <span class="hljs-built_in">strncpy</span>(name + <span class="hljs-number">4</span>, str, <span class="hljs-keyword">sizeof</span>(name) - <span class="hljs-number">5</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">strncpy</span>(name, str, <span class="hljs-keyword">sizeof</span>(name) - <span class="hljs-number">1</span>);   <span class="hljs-comment">//*name=&quot;ttySA0,115200&quot;</span><br>    &#125;<br><br>    name[<span class="hljs-keyword">sizeof</span>(name) - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">if</span> ((options = <span class="hljs-built_in">strchr</span>(str, <span class="hljs-string">&#x27;,&#x27;</span>)) != <span class="hljs-literal">NULL</span>)   <span class="hljs-comment">// 找到&#x27;,&#x27;,返回给options</span><br>            *(options++) = <span class="hljs-number">0</span>;                <span class="hljs-comment">//*options=&quot;115200&quot;</span><br><br><br>    <span class="hljs-keyword">for</span> (s = name; *s; s++)                                     <span class="hljs-comment">//*s=&quot;0&quot;</span><br>            <span class="hljs-keyword">if</span> ((*s &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; *s &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || *s == <span class="hljs-string">&#x27;,&#x27;</span>)<br>                    <span class="hljs-keyword">break</span>;<br><br>idx = simple_strtoul(s, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>);   <span class="hljs-comment">//和strtoul()一样,将s中的&quot;0&quot;提出来,所以idx=0</span><br>    *s = <span class="hljs-number">0</span>;<br><br>add_preferred_console(name, idx, options);      <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的代码和注释得到，最终调用add_preferred_console(“ttySA”, 0, “115200”)函数来添加控制台</p><h3 id="2-3-调用add-preferred-console函数"><a href="#2-3-调用add-preferred-console函数" class="headerlink" title="2.3 调用add_preferred_console函数"></a>2.3 调用add_preferred_console函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add_preferred_console</span><span class="hljs-params">(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> idx, <span class="hljs-type">char</span> *options)</span><br>&#123;<br><span class="hljs-keyword">return</span> __add_preferred_console(name, idx, options, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __add_preferred_console(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> idx, <span class="hljs-type">char</span> *options, <span class="hljs-type">char</span> *brl_options)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console_cmdline</span> *<span class="hljs-title">c</span>;</span><br><span class="hljs-type">int</span> i;<br><br>    <span class="hljs-comment">// MAX_CMDLINECONSOLES=8,表示最多添加8个控制台</span><br>    <span class="hljs-comment">// 这是直接将c指向了全局变量console_cmdline</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, c = console_cmdline; i &lt; MAX_CMDLINECONSOLES &amp;&amp; c-&gt;name[<span class="hljs-number">0</span>]; i++, c++) &#123;<br>        <span class="hljs-comment">// 该console名字和下标好已经存在了【目的是为了去重】</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(c-&gt;name, name) == <span class="hljs-number">0</span> &amp;&amp; c-&gt;index == idx) &#123;<br><span class="hljs-keyword">if</span> (!brl_options)<br>selected_console = i;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>    <br>    <span class="hljs-comment">// i == 8,表示数组存满了</span><br><span class="hljs-keyword">if</span> (i == MAX_CMDLINECONSOLES)<br><span class="hljs-keyword">return</span> -E2BIG;<br><span class="hljs-keyword">if</span> (!brl_options)<br>selected_console = i; <span class="hljs-comment">// 将selected_console设置为最新添加的console_cmdline的下标号</span><br><br>strlcpy(c-&gt;name, name, <span class="hljs-keyword">sizeof</span>(c-&gt;name));<br>c-&gt;options = options;<br>braille_set_options(c, brl_options);<br><br>c-&gt;index = idx;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>__add_preferred_console</code>将name idx options保存到数组下一个成员console_cmdline结构体中，如果数组中已有重名，则不添加，并置selected_console为最新添加的console_cmdline的下标号。</p><p>比如cmdline中有“console&#x3D;ttyS0,115200 console&#x3D;ttyS1,9600”</p><p>则在console_cmdline[8]数组中console_cmdline[0]代表ttyS0，console_cmdline[1]代表ttyS1，而selected_console&#x3D;1.</p><h3 id="2-4-kernel下如何选择printk-console"><a href="#2-4-kernel下如何选择printk-console" class="headerlink" title="2.4 kernel下如何选择printk console"></a>2.4 kernel下如何选择printk console</h3><p>根据<a href="https://anmuxixixi.github.io/2023/02/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E5%86%85%E6%A0%B8%E8%BE%93%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/">printk的实现原理</a>，printk最后调用console_unlock实现log_buf数据刷出到指定设备。</p><p>这里先不关心printk如何处理log buf数据(比如添加内容级别)，只关心printk如何一步步找到指定的输出设备，根据printk.c代码，可以找到如下线索。</p><p><strong>printk-&gt;vprintk-&gt;console_unlock-&gt;call_console_drivers</strong></p><p>看线索最底层的call_console_drivers</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> *<span class="hljs-title">console_drivers</span>;</span> <span class="hljs-comment">// 全局</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> for_each_console(con) \</span><br><span class="hljs-meta">for (con = console_drivers; con != NULL; con = con-&gt;next)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">call_console_drivers</span><span class="hljs-params">(<span class="hljs-type">int</span> level, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *text, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> *<span class="hljs-title">con</span>;</span><br><br>trace_console(text, len);<br><br><span class="hljs-keyword">if</span> (level &gt;= console_loglevel &amp;&amp; !ignore_loglevel)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (!console_drivers)<br><span class="hljs-keyword">return</span>;<br><br>for_each_console(con) &#123;<br><span class="hljs-keyword">if</span> (exclusive_console &amp;&amp; con != exclusive_console)  <span class="hljs-comment">// 如果指明了唯一的console，且当前不是那个console</span><br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (!(con-&gt;flags &amp; CON_ENABLED))  <span class="hljs-comment">// 当前的console不是enabled的</span><br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (!con-&gt;write)   <span class="hljs-comment">// 当前console没有write函数</span><br><span class="hljs-keyword">continue</span>;<br>con-&gt;write(con, text, len);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历console_drivers链表所有console struct，调用所有<u><strong>ENABLE</strong></u>的console的write方法将log buf中start到end的内容发出。</p><blockquote><p>到这里就很明了了，kernel下每次printk打印，首先存log_buf，然后遍历console_drivers，找到合适console，刷出log。</p><p>console_drivers链表的成员是哪里来的，接着来看下一部分，kernel下console的注册</p></blockquote><h3 id="2-5-console驱动注册"><a href="#2-5-console驱动注册" class="headerlink" title="2.5 console驱动注册"></a>2.5 console驱动注册</h3><p>接下来来搜索该数组，看看printk()如何调用控制台的硬件处理函数的。搜索到在<code>Printk.c</code>里的<code>register_console(struct console *console)</code>函数,有用到console_cmdline[]</p><p>显然,register_console()函数就用来注册控制台的,继续搜索register_console</p><img src="/2023/02/25/kernel%E4%B8%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BAconsole%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/image-20230225225234632.png" alt="image-20230225225234632" style="zoom:67%;"><p>我们以<code>drivers\tty\serial\serial_ks8695.c</code>为例，进行分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ks8695_console_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>add_preferred_console(SERIAL_KS8695_DEVNAME, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>register_console(&amp;ks8695_console);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>console_initcall(ks8695_console_init); <span class="hljs-comment">// 声明控制台初始化函数</span><br></code></pre></td></tr></table></figure><p>上面通过register_console()来注册<code>ks8695_console</code>结构体,该结构体成员如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERIAL_KS8695_DEVNAME<span class="hljs-string">&quot;ttyAM&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> <span class="hljs-title">ks8695_console</span> =</span> &#123;<br>.name= SERIAL_KS8695_DEVNAME,  <span class="hljs-comment">// 控制台名称</span><br>.write= ks8695_console_write,   <span class="hljs-comment">// 打印串口数据的硬件处理函数</span><br>.device= uart_console_device,    <span class="hljs-comment">// tty驱动</span><br>.setup= ks8695_console_setup,   <span class="hljs-comment">// 用来设置UART的波特率，发送，接收等功能</span><br>.flags= CON_PRINTBUFFER,        <span class="hljs-comment">// 标志位</span><br>.index= <span class="hljs-number">-1</span>,                     <span class="hljs-comment">// 索引</span><br>.data= &amp;ks8695_reg,            <span class="hljs-comment">// 寄存器</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在register_console()里，便会通过<code>ttyAM</code>来匹配console_cmdline[i]的名称,当匹配成功，printk()调用的console结构体便是ks8695_console了</p><p>☃️当驱动加载的时候，会走到MODULE_INIT，然后走到对应驱动注册的init函数中，在这里就是<code>ks8695_console_init</code>，紧接着会调用<code>register_console</code>，这里的register_console就是<code>printk.c</code>中的register_console。</p><hr><p>因此我们来看下printk.c中的register_console</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">register_console</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> console *newcon)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> *<span class="hljs-title">bcon</span> =</span> <span class="hljs-literal">NULL</span>;<br> <br>    <span class="hljs-comment">//如果注册的是bootconsole（kernel早期启动打印），需要检查console_drivers中</span><br>    <span class="hljs-comment">//没有“real console”也就是说bootconsole必须是第一个注册的console。</span><br>    <span class="hljs-keyword">if</span> (console_drivers &amp;&amp; newcon-&gt;flags &amp; CON_BOOT) &#123;<br>        <span class="hljs-comment">/* find the last or real console */</span><br>        for_each_console(bcon) &#123;<br>            <span class="hljs-keyword">if</span> (!(bcon-&gt;flags &amp; CON_BOOT)) &#123;<br>                printk(KERN_INFO <span class="hljs-string">&quot;Too late to register bootconsole %s%d\n&quot;</span>,<br>                    newcon-&gt;name, newcon-&gt;index);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span> (console_drivers &amp;&amp; console_drivers-&gt;flags &amp; CON_BOOT)<br>        bcon = console_drivers;<br> <br>    <span class="hljs-comment">//preferred console为console_cmdline中最后一个console</span><br>    <span class="hljs-keyword">if</span> (preferred_console &lt; <span class="hljs-number">0</span> || bcon || !console_drivers)<br>        preferred_console = selected_console;<br> <br>    <span class="hljs-keyword">if</span> (newcon-&gt;early_setup)<br>        newcon-&gt;early_setup();<br> <br>    <span class="hljs-keyword">if</span> (preferred_console &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;index &lt; <span class="hljs-number">0</span>)<br>            newcon-&gt;index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;setup == <span class="hljs-literal">NULL</span> ||<br>            newcon-&gt;setup(newcon, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">0</span>) &#123;<br>            newcon-&gt;flags |= CON_ENABLED;<br>            <span class="hljs-keyword">if</span> (newcon-&gt;device) &#123;<br>                newcon-&gt;flags |= CON_CONSDEV;<br>                preferred_console = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">//检查newcon是否是cmdline指定的console，如果是，则使能(CON_ENABLE)并初始化该console</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_CMDLINECONSOLES &amp;&amp; console_cmdline[i].name[<span class="hljs-number">0</span>];<br>            i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(console_cmdline[i].name, newcon-&gt;name) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;index &gt;= <span class="hljs-number">0</span> &amp;&amp;<br>            newcon-&gt;index != console_cmdline[i].index)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;index &lt; <span class="hljs-number">0</span>)<br>            newcon-&gt;index = console_cmdline[i].index;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;setup &amp;&amp;<br>            newcon-&gt;setup(newcon, console_cmdline[i].options) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        newcon-&gt;flags |= CON_ENABLED;<br>        newcon-&gt;index = console_cmdline[i].index;<br>        <span class="hljs-keyword">if</span> (i == selected_console) &#123;<br>            <span class="hljs-comment">//如果newcon是cmdline指定的最新的console，则置位CONSDEV</span><br>            newcon-&gt;flags |= CON_CONSDEV;<br>            preferred_console = selected_console;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">//该console没有使能，退出</span><br>    <span class="hljs-keyword">if</span> (!(newcon-&gt;flags &amp; CON_ENABLED))<br>        <span class="hljs-keyword">return</span>;<br> <br>    <span class="hljs-comment">//如果有bootconsole，则newcon不需要输出register之前的log，因为如果bootconsole和newcon是同一个设备</span><br>    <span class="hljs-comment">//则之前的log就输出2次</span><br>    <span class="hljs-keyword">if</span> (bcon &amp;&amp; ((newcon-&gt;flags &amp; (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV))<br>        newcon-&gt;flags &amp;= ~CON_PRINTBUFFER;<br> <br>    <span class="hljs-comment">//把newcon加入console_drivers链表，对于置位CON_CONSDEV的con，放在链表首</span><br>    console_lock();<br>    <span class="hljs-keyword">if</span> ((newcon-&gt;flags &amp; CON_CONSDEV) || console_drivers == <span class="hljs-literal">NULL</span>) &#123;<br>        newcon-&gt;next = console_drivers;<br>        console_drivers = newcon;<br>        <span class="hljs-keyword">if</span> (newcon-&gt;next)<br>            newcon-&gt;next-&gt;flags &amp;= ~CON_CONSDEV;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        newcon-&gt;next = console_drivers-&gt;next;<br>        console_drivers-&gt;next = newcon;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newcon-&gt;flags &amp; CON_PRINTBUFFER) &#123;<br>        <span class="hljs-comment">//如果newcon置位PRINTBUFFER,则将log全部刷出</span><br>        raw_spin_lock_irqsave(&amp;logbuf_lock, flags);<br>        con_start = log_start;<br>        raw_spin_unlock_irqrestore(&amp;logbuf_lock, flags);<br>        <span class="hljs-comment">//修改printk输出的指定唯一exclusive_console为newcon</span><br>        <span class="hljs-comment">//保证将之前的log只输出到newcon</span><br>        exclusive_console = newcon;<br>    &#125;<br>    <span class="hljs-comment">//解锁console，刷出log到newcon</span><br>    console_unlock();<br>    console_sysfs_notify();<br> <br>    <span class="hljs-comment">//如果有bootconsole，则unregister bootconsole（从console_drivers中删掉）</span><br>    <span class="hljs-comment">//并告诉使用者现在console切换</span><br>    <span class="hljs-keyword">if</span> (bcon &amp;&amp;<br>        ((newcon-&gt;flags &amp; (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &amp;&amp;<br>        !keep_bootcon) &#123;<br>        printk(KERN_INFO <span class="hljs-string">&quot;console [%s%d] enabled, bootconsole disabled\n&quot;</span>,<br>            newcon-&gt;name, newcon-&gt;index);<br>        for_each_console(bcon)<br>            <span class="hljs-keyword">if</span> (bcon-&gt;flags &amp; CON_BOOT)<br>                unregister_console(bcon);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        printk(KERN_INFO <span class="hljs-string">&quot;%sconsole [%s%d] enabled\n&quot;</span>,<br>            (newcon-&gt;flags &amp; CON_BOOT) ? <span class="hljs-string">&quot;boot&quot;</span> : <span class="hljs-string">&quot;&quot;</span> ,<br>            newcon-&gt;name, newcon-&gt;index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果之前注册了bootconsole，则不会将该次register之前的log刷出，防止bootconsole和该次注册的newcon是同一个物理设备时，log打印2次。</p><p>如果没有bootconsole，则会指定exclusive_console&#x3D;newcon，console_unlock时，刷新全部log到该指定exclusive console。</p><p>console_unlock结束时会将exclusive_console置NULL，所以exclusive console默认情况下就是NULL。</p><p>最后会unregister bootconsole，是将bootconsole从console_drivers中删除，这样之后的printk就不会向bootconsole输出了。</p><p>有意思的一个地方是，在unregister bootconsole之前的printk：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">printk(KERN_INFO <span class="hljs-string">&quot;console [%s%d] enabled, bootconsole disabled\n&quot;</span>,<br>            newcon-&gt;name, newcon-&gt;index);<br></code></pre></td></tr></table></figure><p><u>因为此时bootconsole还没删掉，而newconsole已经加入console_drivers，如果bootconsole和newconsole是同一个物理设备，我们会看到这句printk会出现2次哦！</u></p><p>如果在cmdline指定2个I&#x2F;O设备，如<code>&quot;console==ttyS0,115200 console=ttyS1,115200&quot;</code>，因ttyS设备都是serial driver中注册的real console，所以会看到kernel的打印分别出现在2个串口上！</p><p><u><strong>boot console</strong>和<strong>real console</strong>差别在于bootconsole注册于kernel启动早期，方便对于kernel早期启动进行调试打印。</u></p><p>那这些console是在哪里调用register_console进行注册的？</p><ul><li><p>bootconsole的注册，如arch&#x2F;arm&#x2F;kernel&#x2F;early_printk.c，是在parse_args参数解析阶段注册bootconsole。</p><ul><li>在start_kernel中console_init函数也会遍历.con_initcall.init段中所有注册函数，而这些注册函数也可以来注册bootconsole。</li><li>.con_initcall.init段中函数的注册可以使用宏定义console_initcall。这些函数中调用register_console，方便在kernel初期实现printk打印。</li></ul></li><li><p>realconsole的注册，是在各个driver，如serial加载时完成。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】linux内核输出的日志去哪里了</title>
    <link href="/2023/02/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E5%86%85%E6%A0%B8%E8%BE%93%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/"/>
    <url>/2023/02/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E5%86%85%E6%A0%B8%E8%BE%93%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h1 id="linux内核输出的日志去哪里了"><a href="#linux内核输出的日志去哪里了" class="headerlink" title="linux内核输出的日志去哪里了"></a>linux内核输出的日志去哪里了</h1><blockquote><p>🍕转载自：<a href="https://mp.weixin.qq.com/s/mdDLw6AIp9ws9LTaHg64pg">https://mp.weixin.qq.com/s/mdDLw6AIp9ws9LTaHg64pg</a></p><p>🥯感谢大佬精彩的文章！！！</p></blockquote><p><img src="/2023/02/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91linux%E5%86%85%E6%A0%B8%E8%BE%93%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/image-20230221230542976.png" alt="image-20230221230542976">我们可以根据这张图，来理解printk的整体架构。</p><h2 id="1-printk实现简述"><a href="#1-printk实现简述" class="headerlink" title="1.printk实现简述"></a>1.printk实现简述</h2><h3 id="1-1-内核态printk"><a href="#1-1-内核态printk" class="headerlink" title="1.1 内核态printk"></a>1.1 内核态printk</h3><p>在内核编码时，如果想要输出一些信息，通常并不会直接使用printk，而是会使用其衍生函数，比如 pr_err &#x2F; pr_info &#x2F; pr_debug 等，这些衍生函数附带了日志级别、所属模块等其他信息，比较友好，但其最终还是调用了printk。</p><p>printk函数会将每次输出的日志，放到内核为其专门分配的名为<strong>ring buffer</strong>的一个槽位里。</p><ul><li><p>ring buffer其实就是一个用数组实现的环形队列，不过既然是环形队列，就会有一个问题，即当ring buffer满了的时候，下一条新的日志，会覆盖最开始的旧的日志。</p></li><li><p>ring buffer的大小，可以通过内核参数来修改。</p></li><li><p>printk在将日志放到ring buffer后，会再调用系统console的相关方法，将还未输出到系统控制台的消息，继续输出到控制台，这个后面会详细说，这里就暂不赘述。</p></li></ul><p>以上就是printk在内核态的实现。</p><h3 id="1-2-用户态printk"><a href="#1-2-用户态printk" class="headerlink" title="1.2 用户态printk"></a>1.2 用户态printk</h3><p>在用户态，我们有几个方式，可以查看printk输出的内核日志，比如使用dmesg命令，cat &#x2F;proc&#x2F;kmsg文件，或者是使用klogctl函数等，这些方式分别对应于全景图中用户态的橙色、绿色、和蓝色的部分。</p><p><strong>（1）dmesg命令</strong></p><p><strong>dmesg命令，在默认情况下，是通过读取&#x2F;dev&#x2F;kmsg文件</strong>，来实现查看内核日志的。</p><p>当该命令运行时，dmesg会先调用open函数，打开&#x2F;dev&#x2F;kmsg文件，该打开操作在内核中的逻辑，会为dmesg分配一个file实例，在这个file实例里，会有一个seq变量，该变量记录着下一条要读取的内核日志在ring buffer中的位置。</p><p>刚打开&#x2F;dev&#x2F;kmsg文件时，这个seq指向的就是ring buffer中最开始的那条日志。</p><p>之后，dmesg会以打开的&#x2F;dev&#x2F;kmsg文件为媒介，不断的调用read函数，从内核中读取日志消息，每读取出一条，seq的值都会加一，即指向下一条日志的位置，依次往复，直到所有的内核日志读取完毕，dmesg退出。</p><p>以上就是dmesg的主体实现。</p><p><strong>（2）cat &#x2F;proc&#x2F;kmsg 命令</strong></p><p>第二种查看内核日志的方式，是通过 cat &#x2F;proc&#x2F;kmsg 命令。</p><p>该命令和dmesg命令的实现机制基本类似，都是通过读文件，只不过cat读取的是&#x2F;proc&#x2F;kmsg文件，而dmesg读取的是&#x2F;dev&#x2F;kmsg文件。</p><p>读取这两个文件最大的区别是，&#x2F;dev&#x2F;kmsg文件每次打开时，内核都会为其分配一个单独的seq变量，而&#x2F;proc&#x2F;kmsg文件每次打开时，用的都是同一个全局的静态seq变量，叫做syslog_seq。</p><p>syslog_seq指向的也是下一条要读取的内核日志在ring buffer中的位置，但因为它是一个全局的静态变量，当有多个进程要读取&#x2F;proc&#x2F;kmsg文件时，就会有一个比较严重的问题，即内核日志会被这几个进程随机抢占读取，也就是说，每个进程读到的都是整个内核日志的一部分，是不完整的，这也是dmesg命令默认不使用&#x2F;proc&#x2F;kmsg文件的原因。</p><p><strong>（3）klogctl函数</strong></p><p>第三种查看内核日志的方式，是通过klogctl函数。</p><p>该函数是glibc对syslog系统调用的一个简单封装，其具体使用方式，可以参考全景图中用户态的蓝色部分。</p><p>klogctl函数可以指定很多命令，在上图的示例中，我们使用的是SYSLOG_ACTION_READ命令，以此来模拟 cat &#x2F;proc&#x2F;kmsg 行为。</p><p>其实在内核层面，cat &#x2F;proc&#x2F;kmsg命令，使用的就是klogctl对应的syslog系统调用的SYSLOG_ACTION_READ命令的处理逻辑，所以示例中的klogctl函数相关代码，和 cat &#x2F;proc&#x2F;kmsg 命令其实是等价的。</p><p>也就是说，klogctl函数在内核里使用的也是syslog_seq变量，它也有和&#x2F;proc&#x2F;kmsg文件同样的问题。</p><p><strong>（4）系统控制台</strong></p><p>其实还有一种方式可以查看内核日志，就是通过系统控制台。</p><p>但这种方式和前面讲的三种方式都不一样，它是完全被动的，是内核在调用printk函数，将日志信息放到ring buffer后，再去通知系统控制台，告知其可以输出这些日志。</p><p>系统控制台也是通过一个console_seq变量，记录下一条要输出内核日志的所在位置。</p><p>系统控制台输出的内容，是被日志级别过滤过的，内核默认的日志过滤级别是7，即debug级别以上的日志，比如info &#x2F; err 等，这些都会输出，但debug级别不会输出。</p><p>该日志过滤级别，可以通过很多方式改变，比如说，可以通过内核参数 loglevel，所以，如果发现系统控制台没有输出想要的日志信息，先看下其是否被过滤掉了。</p><h2 id="2-kernel日志调试设置"><a href="#2-kernel日志调试设置" class="headerlink" title="2.kernel日志调试设置"></a>2.kernel日志调试设置</h2><h3 id="2-1-查看日志级别"><a href="#2-1-查看日志级别" class="headerlink" title="2.1 查看日志级别"></a>2.1 查看日志级别</h3><p>输入<code>cat proc/sys/kernel/printk</code></p><p>这四个数字依次对应 console_loglevel，default_message_loglevel，minimum_console_loglevel，default_console_loglevel。</p><ul><li><p><strong>console_loglevel：</strong>控制台使用的日志级别；</p></li><li><p><strong>default_message_loglevel：</strong>调用 printk() 未指定日志级别时使用的日志级别；</p></li><li><p><strong>minimum_console_loglevel：</strong>允许设置的控制台日志级别（console_loglevel）最小值；</p></li><li><p><strong>default_console_loglevel：</strong>系统启动时使用的日志级别。</p></li></ul><h3 id="2-2-修改kernel日志级别"><a href="#2-2-修改kernel日志级别" class="headerlink" title="2.2 修改kernel日志级别"></a>2.2 修改kernel日志级别</h3><p>（1）最直接的方法就是：<code>echo xxx &gt; proc/sys/kernel/printk</code>，其余方式参考：<a href="https://blog.csdn.net/qq_34597963/article/details/128669281">https://blog.csdn.net/qq_34597963/article/details/128669281</a></p><p>日志级别如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_EMERG      KERN_SOH <span class="hljs-string">&quot;0&quot;</span>    /* system is unusable */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_ALERT      KERN_SOH <span class="hljs-string">&quot;1&quot;</span>    /* action must be taken immediately */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_CRIT       KERN_SOH <span class="hljs-string">&quot;2&quot;</span>    /* critical conditions */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_ERR        KERN_SOH <span class="hljs-string">&quot;3&quot;</span>    /* error conditions */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_WARNING    KERN_SOH <span class="hljs-string">&quot;4&quot;</span>    /* warning conditions */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_NOTICE     KERN_SOH <span class="hljs-string">&quot;5&quot;</span>    /* normal but significant condition */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_INFO       KERN_SOH <span class="hljs-string">&quot;6&quot;</span>    /* informational */</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define KERN_DEBUG      KERN_SOH <span class="hljs-string">&quot;7&quot;</span>    /* debug-level messages */</span><br><br>-----------------<br><br>致命级(KERN_EMESG),<br>警戒级(KERN_ALERT),<br>临界级(KERN_CRIT),<br>错误级(KERN_ERR),<br>告警级(KERN_WARN)<br>注意级(KERN_NOTICE),<br>通知级(KERN_INFO),<br>调试级(KERN_DEBUG).<br></code></pre></td></tr></table></figure><p>（2）在kernel中修改log默认等级</p><p>找到<code>/include/linux/printk.h</code>，在下面这个函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">console_verbose</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><p>修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">console_loglevel = CONSOLE_LOGLEVEL_MIN; <span class="hljs-comment">//CONSOLE_LOGLEVEL_MOTORMOUTH;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-Android-Init进程日志打印不全"><a href="#2-3-Android-Init进程日志打印不全" class="headerlink" title="2.3 Android Init进程日志打印不全"></a>2.3 Android Init进程日志打印不全</h3><blockquote><p>参考：<a href="https://blog.csdn.net/superlee1125/article/details/114099144?spm=1001.2014.3001.5506">https://blog.csdn.net/superlee1125/article/details/114099144?spm=1001.2014.3001.5506</a></p></blockquote><p>在抓Android内核的log时，init进程的log往往打印不全，这是因为内核限制了log的输出，在内核代码中找到下面的文件，并按照下面的提示把代码注释掉，然后重新编译内核，再刷到设备中，init进程的打印就完整了。</p><p>内核代码中找到这个文件 <code>kernel/printk/printk.c</code>，在下面这个函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">devkmsg_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kiocb *iocb, <span class="hljs-keyword">struct</span> iov_iter *from)</span><br></code></pre></td></tr></table></figure><p>注释掉下面这两句话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">/* Ratelimit when not explicitly enabled. */</span><br>    <span class="hljs-keyword">if</span> (!(devkmsg_log &amp; DEVKMSG_LOG_MASK_ON)) &#123;<br>-       <span class="hljs-keyword">if</span> (!___ratelimit(&amp;user-&gt;rs, current-&gt;comm))<br>-           <span class="hljs-keyword">return</span> ret;<br>+       <span class="hljs-comment">//if (!___ratelimit(&amp;user-&gt;rs, current-&gt;comm))</span><br>+           <span class="hljs-comment">//return ret;</span><br>    &#125;<br>    buf = kmalloc(len+<span class="hljs-number">1</span>, GFP_KERNEL);<br></code></pre></td></tr></table></figure><h3 id="2-4-Android修改日志级别"><a href="#2-4-Android修改日志级别" class="headerlink" title="2.4 Android修改日志级别"></a>2.4 Android修改日志级别</h3><p>以Android 10.0 qcom平台为例，修改如下：<code>device/qcom/common/rootdir/etc/init.qcom.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">case &quot;$buildvariant&quot; in<br>    &quot;userdebug&quot; | &quot;eng&quot;)<br>        #set default loglevel to KERN_INFO<br>        echo &quot;6 6 1 7&quot; &gt; /proc/sys/kernel/printk  ##### 根据需要进行修改<br><br>        ;;<br>    *)<br>        #set default loglevel to KERN_WARNING<br>        echo &quot;4 4 1 4&quot; &gt; /proc/sys/kernel/printk<br>        ;;<br>esac<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android通用内核GKI</title>
    <link href="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/"/>
    <url>/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/</url>
    
    <content type="html"><![CDATA[<h1 id="Android通用内核GKI"><a href="#Android通用内核GKI" class="headerlink" title="Android通用内核GKI"></a>Android通用内核GKI</h1><h2 id="1-GKI概述"><a href="#1-GKI概述" class="headerlink" title="1.GKI概述"></a>1.GKI概述</h2><p><strong>快速了解</strong>： GKI全称为Generic kernel Image。自2019年开始，来自Google Android的Kernel team经过多年准备，开始在Android 11.0的研发版本上推行GKI设计。GKI的目标在于消除Android阵营Linux Kernel的碎片化状态。 <strong>GKI的终极目标是由Google统一发布boot.image镜像给全球用户使用</strong>。GKI是Google Treble项目的重要举措之一。</p><h3 id="1-1-谷歌为什么要提出GKI"><a href="#1-1-谷歌为什么要提出GKI" class="headerlink" title="1.1 谷歌为什么要提出GKI"></a>1.1 谷歌为什么要提出GKI</h3><p>直接搬运官网，讲的太详细了。</p><p><u><strong>Android 通用内核 (ACK)</strong></u> 是所有 Android 产品内核的基础。供应商内核和设备内核位于 ACK 的下游。供应商通过修改内核源代码并添加设备驱动程序，添加了对 SoC 和外围设备的支持。这些修改内容可能很多，以至于设备上运行的代码中有多达 50% 是树外代码（并非来自上游 Linux 和 AOSP 通用内核）。</p><p>因此，设备内核由以下部分组成：</p><ul><li>上游：来自 kernel.org 的 Linux 内核</li><li>AOSP：AOSP 通用内核的其他 Android 专用补丁程序</li><li>供应商：供应商提供的 SoC 和外围设备支持以及优化补丁程序</li><li>原始设备制造商 (OEM)&#x2F;设备：其他设备驱动程序和自定义项</li></ul><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230217234034047.png" alt="image-20230217234034047" style="zoom: 67%;"><p>Kernel从Linux分支一路到OEM厂商，不断进行修改，全球这么多vendor厂商，这么多oem厂商，每家都来这么一套自己的kernel，碎片化太太太严重了，谷歌真的很难维护。用官网的话，<strong>内核碎片化会对 Android 社区产生若干负面影响</strong>。</p><ul><li>安全更新需要耗费大量人力<ul><li>Android 安全公告 (ASB) 中引用的安全补丁程序必须向后移植到每个设备内核中。但是，由于存在内核碎片化问题，向正常使用的 Android 设备传播安全修复的代价非常之高。</li></ul></li><li>很难合并长期支持的更新<ul><li>长期支持 (LTS) 版本包含安全修复和其他重大问题修复。事实证明，使用最新的 LTS 版本是提供安全修复的最有效方式。我们发现，ASB 报告的内核安全问题中有 90% 都已在保持最新状态的 Pixel 设备上得到修复。</li></ul></li><li>妨碍 Android 平台进行版本升级<ul><li>由于碎片化问题，很难向正常使用的设备添加需要更改内核的 Android 新功能。Android 框架代码必须假设支持的内核版本多达 5 个，并且没有针对新的平台版本进行任何内核更改（Android 10 支持内核版本 3.18、4.4、4.9、4.14 和 4.19；在某些情况下，这些版本自 2017 年 Android 8 发布以来还未添加新功能）。</li></ul></li><li>很难将内核更改贡献回上游 Linux<ul><li>对内核进行完所有更改后，大多数旗舰设备附带的内核版本已经至少存在 18 个月了。例如，<code>kernel.org</code> 于 2017 年 11 月发布了 4.14 版内核，而首批使用 4.14 版内核的 Android 手机于 2019 年春季才发布。</li><li>上游内核发布与产品发布之间的这种长时间延迟导致 Android 社区很难将所需的功能和驱动程序馈送到上游内核中，因此解决碎片化问题并非易事。</li></ul></li></ul><h3 id="1-2-谷歌如何解决碎片化"><a href="#1-2-谷歌如何解决碎片化" class="headerlink" title="1.2 谷歌如何解决碎片化"></a>1.2 谷歌如何解决碎片化</h3><p>通用内核映像 (GKI) 项目通过统一核心内核并将 SoC 和板级支持从核心内核移至可加载模块中，解决了内核碎片化问题。GKI 内核为内核模块提供了稳定的内核模块接口 (KMI)，因此模块和内核可以独立进行更新。</p> <img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230217234449847.png" style="zoom: 80%;"><p>从图中可以看到，Google 会提供 KMI 接口，用于 vendor modules 和 GKI 的通讯。</p><blockquote><p>直白点说，就是谷歌把所有通用的Kernel放在了<code>Generic Kernel</code>里面，把通用的Moudules放在了<code>GKI Modules</code>里面。而与硬件强相关的，与各厂商紧密联系的模块放在了<code>Vendor Modules</code>里面。这样的好处是什么，我用户可以快速升级，只要到谷歌官网找到最新的GKI，就可以用上最新，最安全的Kernel！而与硬件强相关的，晚点升级也没事，既然手机能用，说明各大厂商对于驱动等早就适配好了。</p></blockquote><h3 id="1-3-GKI发展历程"><a href="#1-3-GKI发展历程" class="headerlink" title="1.3 GKI发展历程"></a>1.3 GKI发展历程</h3><p>Gogole GKI 分为下面两个阶段推进：</p><blockquote><p><em>•</em> I. GKI 兼容性：Android 11(R) + linux-5.4 require GKI compatibility test.</p><p><em>•</em> II. GKI 产品化：Android 12(S) + linux-5.x 及之后 require GKI kernel</p></blockquote><p><strong>GKI 1.0 - GKI 兼容性要求</strong></p><p>对于 Android 11 平台版本，为了保证与 Treble 兼容，必须对运行 v5.4 内核的设备进行 GKI 测试。</p><p>具备 GKI 兼容性是指设备通过将 GKI 启动映像刷写到 <code>boot</code> 分区并将 GSI 系统映像刷写到 <code>system</code> 分区来安装通用系统映像 (GSI) 和 GKI 内核，因此通过了 VTS 和 CTS-on-GSI+GKI 测试。设备可以附带不同的产品内核，并且可以使用 GKI 未提供的可加载模块。不过，产品内核和 GKI 内核都必须从相同的 <code>vendor_boot</code> 和 <code>vendor</code> 分区加载模块。因此，所有产品内核都必须具有相同的二进制内核模块接口 (KMI)。供应商可以扩展产品内核的 KMI，前提是它与 GKI KMI 兼容。GKI 1.0 不要求供应商模块可卸载。</p><p><strong>GKI 2.0 - GKI 产品</strong></p><p>搭载 Android S (2021) 平台版本且使用内核版本 v5.x（5.x 是 2020 年年底被选为 LTS 的内核版本）或更高版本的设备必须附带 GKI 内核。将提供已签名的启动映像，并通过 LTS 和重大问题修复定期对其进行更新。由于 KMI 将保持二进制稳定性，因此无需对供应商映像进行任何更改，即可安装这些启动映像。</p><h2 id="2-GKI后各镜像的变化"><a href="#2-GKI后各镜像的变化" class="headerlink" title="2.GKI后各镜像的变化"></a>2.GKI后各镜像的变化</h2><h3 id="2-1-boot分区变化"><a href="#2-1-boot分区变化" class="headerlink" title="2.1 boot分区变化"></a>2.1 boot分区变化</h3><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230219232030518.png" style="zoom:67%;"><p><code>boot</code> 分区包括头文件、内核以及内含启动 ramdisk 通用部分的 CPIO 归档。</p><p><code>boot</code> 分区使用 v3 版启动头文件后，先前的 <code>boot</code> 分区的以下部分将不复存在：</p><ul><li>第二阶段引导加载程序：如果设备具有第二阶段引导加载程序，则必须将相应引导加载程序存储在自己的分区中。</li><li>DTB：DTB 存储在供应商启动分区中。</li></ul><p><code>boot</code> 分区包含一个 CPIO压缩包，内含以下 GKI 组件：</p><ul><li>位于 <code>/lib/modules/</code> 的 GKI 内核模块</li><li><code>first_stage_init</code> 及其依赖的库</li><li><code>fastbootd</code> 和 <code>recovery</code>（用于 A&#x2F;B 和虚拟 A&#x2F;B 设备）</li></ul><h3 id="2-2-出现vendor-boot分区"><a href="#2-2-出现vendor-boot分区" class="headerlink" title="2.2 出现vendor_boot分区"></a>2.2 出现vendor_boot分区</h3><p><code>vendor_boot</code> 分区随 GKI 引入。该分区是采用A&#x2F;B 分区，包含一个头文件、供应商 ramdisk 和设备树 Blob。vendor ramdisk 是一个 CPIO 压缩包，其中包含设备启动所需的供应商模块。这包括用于启用关键 SoC 功能的模块，以及启动设备和显示启动画面所需的存储和显示驱动程序。</p><p>该 CPIO 压缩包包含：</p><ul><li>第一阶段 <code>init</code> 供应商内核模块，位于 <code>/lib/modules/</code></li><li><code>modprobe</code> 配置文件，位于 <code>/lib/modules</code></li><li><code>modules.load</code> 文件，用于指示要在第一阶段 <code>init</code> 期间加载的模块</li></ul><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><blockquote><p>全志的文档写的太好，非常感谢😸</p></blockquote><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230219232422846.png"><p>上图是 boot 分区支持 GKI 的变化情况，这张图很有指导意义，其中关键点有：</p><ul><li>boot.img 变为 boot.img + vendor-boot.img，其中 boot.img 中放的是 GKI 镜像 + ramdisk，<u>vendor-boot.img 中放的是需要启动加载的 vendor 模块 ko</u>；</li><li>启动过程中，需要 bootloader 加载并整合 boot.img 和 vendor-boot.img中的两个ramdisk</li><li>与 GKI 对应的，Google 还推出 GSI，也就是通用 system 镜像；</li><li>vendor.img 可以存放不需要要启动加载的 ko，这个跟以前是一样的。</li></ul><p>bootloader 开发需要注意的地方有：</p><ul><li>boot header V3.0</li><li>DTB 的存放位置从 boot.img 改到了 vendor-boot</li><li>启动过程中 boot 需要加载 boot.img 和 vendor-boot.img 中的 ramdisk 并做整合，而且 boot.img 的 ramdisk 优先级高</li></ul><h3 id="2-4-ramdisk拼接"><a href="#2-4-ramdisk拼接" class="headerlink" title="2.4 ramdisk拼接"></a>2.4 ramdisk拼接</h3><ul><li>Android 11中，ramdisk 分为两份，一份为<strong>boot_ramdisk</strong>，存放在 <strong>boot.img</strong>中。一份为<strong>vendor_boot_ramdisk</strong> 存放在 <strong>vendor_boot.img</strong> 中。</li><li>在 bootloader 启动时需要先后加载 boot_ramdisk，vendor_boot_ramdisk 并进行前后拼接。</li><li>ramdisk 用的是 cpio.lz4 格式，可以进行简单的首尾拼接，<u><strong>但是 bootloader 需要注意两个ramdisk 中间必须紧密拼接，不能对齐再拼接，否则会导致内核解压时失败</strong></u>，同时拼接后改变ramdisk 的大小。</li></ul><h2 id="3-如何下载最新的GKI"><a href="#3-如何下载最新的GKI" class="headerlink" title="3.如何下载最新的GKI"></a>3.如何下载最新的GKI</h2><h3 id="3-1-安卓官网描述"><a href="#3-1-安卓官网描述" class="headerlink" title="3.1 安卓官网描述"></a>3.1 安卓官网描述</h3><p>Android官网：<a href="https://source.android.com/docs/core/architecture/kernel/gki-android12-5_10-release-builds?hl=zh-cn">https://source.android.com/docs/core/architecture/kernel/gki-android12-5_10-release-builds?hl=zh-cn</a></p><p>如果要使用<code>boot.img</code>，选择boot-xxx.img</p><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230221223931378.png" alt="image-20230221223931378" style="zoom:67%;"><p>如果使用GKI，则点击kernel，选择image</p><img src="/2023/02/19/Android%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8GKI/image-20230221224045860.png" alt="image-20230221224045860" style="zoom:67%;"><blockquote><p>boot-xxx.img中的kernel和这个image是完全一模一样的！！！</p></blockquote><h3 id="3-2-全志文档"><a href="#3-2-全志文档" class="headerlink" title="3.2 全志文档"></a>3.2 全志文档</h3><p>根据全志文档，Android 12下载编译流程如下：</p><p><strong>1）下载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir android-kernel<br>cd android-kernel/<br>repo init -u https://android.googlesource.com/kernel/manifest -b common-android12-5.4<br>repo sync<br>repo start --all android12-5.4<br></code></pre></td></tr></table></figure><p><strong>2） 使用 Google 源码编译 GKI 镜像</strong></p><p>在 google 源码目录下运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">BUILD_BOOT_IMG=1 SKIP_VENDOR_BOOT=1 KERNEL_BINARY=Image GKI_RAMDISK_PREBUILT_BINARY=gki-<br>ramdisk.img BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh<br></code></pre></td></tr></table></figure><p>编译过程中在 LTO vmlinux.o 阶段可能会卡主一段时间（大概十分钟），属于正常现场，第一次编译会比较耗时。</p><p>编译完成以后，boot.img存放在<code>android-kernel/out/android12-5.4/dist/boot.img</code></p><h2 id="4-GKI启动流程"><a href="#4-GKI启动流程" class="headerlink" title="4. GKI启动流程"></a>4. GKI启动流程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">boot0<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">uboot: 加载boot.img中的GKI和ramdisk_1，加载vendor-boot.img的ramdisk_2，整合ramdisk_1和</span><br>ramdisk_2,jump to GKI<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">GKI: core kernel init</span><br>--&gt; kernel init： load modules ko<br>--&gt; android bringup<br></code></pre></td></tr></table></figure><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><ul><li><a href="https://bbs.16rd.com/thread-583693-1-1.html">https://bbs.16rd.com/thread-583693-1-1.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/240117889">https://zhuanlan.zhihu.com/p/240117889</a></li><li><a href="https://source.android.com/docs/core/architecture/kernel/generic-kernel-image?hl=zh-cn">https://source.android.com/docs/core/architecture/kernel/generic-kernel-image?hl=zh-cn</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>udev设备管理</title>
    <link href="/2023/02/16/udev%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <url>/2023/02/16/udev%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="udev设备管理器"><a href="#udev设备管理器" class="headerlink" title="udev设备管理器"></a>udev设备管理器</h1><p>🍋🍋🍋<strong>十分推荐阅读</strong>：<a href="http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf">http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf</a></p><h2 id="1-为什么会出现udev"><a href="#1-为什么会出现udev" class="headerlink" title="1.为什么会出现udev"></a>1.为什么会出现udev</h2><p><strong>devfs</strong>(设备文件系统)是由Linux2.4内核引入的，当时被许多工程师基于了高度的评价，devfs的出现使得设备驱动程序能够自主的管理自己的设备文件。比如，可以通过程序在设备初始化的时候在 &#x2F;dev 目录下创建设备文件，卸载时将他删除，而且设备驱动程序可以指定设备名，所有者和权限位，而且用户空间程序可以修改所有者和权限位，并且不再需要为设备驱动程序分配主设备号以及次设备号，在程序中可以直接给 register_chrdev()传递0主设备号用来获取可用的主设备号。并且可以在 devfs_register() 中指定次设备号。</p><p>🦋尽管devfs有这样和那样的优点，但是，在Linux 2.6内核中，devfs被认为是过时的方法，并最终被抛弃了，<strong>udev取代了它</strong>。</p><p>🐬<strong>Linux VFS内核维护者Al Viro指出了几点udev取代devfs的原因：</strong></p><ul><li>devfs所做的工作被确信可以在用户态来完成。</li><li>devfs被加入内核之时，大家期望它的质量可以迎头赶上</li><li>发现devfs有一些可修复和无法修复的bug。</li><li>对于可修复的bug，几个月前就已经被修复了，其维护者认为一切良好</li><li>对于后者，在相当长的一段时间内没有改观</li><li>devfs的维护者和作者对它感到失望并且已经停止了对代码的维护工作</li></ul><h2 id="2-udev简介"><a href="#2-udev简介" class="headerlink" title="2.udev简介"></a>2.udev简介</h2><p>udev是一个设备管理工具，**<u>udev以守护进程的形式运行</u>**，通过侦听内核发出来的uevent来管理&#x2F;dev目录下的设备文件。udev在用户空间运行，而不在内核空间 运行。它能够根据系统中的硬件设备的状态动态更新设备文件，包括设备文件的创建，删除等。设备文件通常放在&#x2F;dev目录下。使用udev后，在&#x2F;dev目录下就只包含系统中真正存在的设备。</p><blockquote><p><strong>DEVFS与UDEV的一个显著区别：</strong></p><ul><li>采用devfs，当一个<strong>并不存在的&#x2F;dev节点</strong>被打开的时候，devfs能<strong>自动加载对应的驱动</strong>，而<strong>udev则不这么做</strong></li><li>这是因为udev的设计者认为Linux应该在设备被发现的时候加载驱动模块，而不是当它被访问的时候。udev的设计者认为devfs所提供的打开&#x2F;dev节点时自动加载驱动的功能<strong>对一个配置正确的计算机来说是多余的</strong>。系统中所有的设备都应该产生热插拔事件并加载恰当的驱动， 而udev能注意到这点并且为它创建对应的设备节点</li></ul></blockquote><h2 id="3-udev的配置文件"><a href="#3-udev的配置文件" class="headerlink" title="3.udev的配置文件"></a>3.udev的配置文件</h2><p>主要的udev配置文件是&#x2F;etc&#x2F;udev&#x2F;udev.conf文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">udev_root=<span class="hljs-string">&quot;/dev/&quot;</span><br><br>udev_rules=<span class="hljs-string">&quot;/etc/udev/rules.d/&quot;</span><br><br>udev_log=<span class="hljs-string">&quot;err&quot;</span><br></code></pre></td></tr></table></figure><ul><li>udev_root：代表着设备文件添加到哪。</li><li>udev_rules：代表着udev的规则存储的目录。这个目录存储的是以.rules结束的文件。每一个文件处理一系列规则来帮助udev分配名字给设备文件以保证能被内核识别。你的&#x2F;etc&#x2F;udev&#x2F;rules.d下面可能有好几个udev规则文件，这些文件一部分是udev包安装的，另外一部分则是可能是别的硬件或者软件包生成的。该目录下有多个文件时，udev读取文件是按照文件名的ASCII字母顺序来读取的，如果udev一旦找到了与新加入的设备匹配的规则，udev 就会根据规则定义的措施对新设备进行配置。同时不再读后续的规则文件。</li><li>udev_log：代表着udev的日志级别，用syslog记录错误信息。</li></ul><h2 id="4-udev的工作流程图"><a href="#4-udev的工作流程图" class="headerlink" title="4.udev的工作流程图"></a>4.udev的工作流程图</h2><img src="/2023/02/16/udev%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20230215234615127.png" style="zoom:80%;"><h2 id="5-udev的匹配规则"><a href="#5-udev的匹配规则" class="headerlink" title="5.udev的匹配规则"></a>5.udev的匹配规则</h2><p>在&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;文件夹下有一系列的.rules文件，在这些文件中有一些匹配规则：</p><h3 id="5-1-udev规则的所有操作符"><a href="#5-1-udev规则的所有操作符" class="headerlink" title="5.1 udev规则的所有操作符"></a>5.1 udev规则的所有操作符</h3><ul><li><p>&#x3D;&#x3D; ：比较键、值，若等于，则该条件满足；</p></li><li><p>!&#x3D;  ：比较键、值，若不等于，则该条件满足；</p></li><li><p>&#x3D;   ：对一个键赋值；</p></li><li><p>+&#x3D; ：为一个表示多个条目的键赋值。</p></li><li><p>:&#x3D;  ：对一个键赋值，并拒绝之后所有对该键的改动。目的是防止后面的规则文件对该键赋值。</p></li></ul><h3 id="5-2-udev规则的匹配键"><a href="#5-2-udev规则的匹配键" class="headerlink" title="5.2 udev规则的匹配键"></a>5.2 <strong>udev规则的匹配键</strong></h3><ul><li>ACTION：事件(uevent)的行为，例如：add(添加设备)、remove(删除设备)。</li><li>KERNEL：内核设备名称，例如：sda,cdrom。</li><li>DEVPATH：设备的devpath路径。</li><li>SUBSYSTEM：设备的子系统名称，例如：sda的子系统为block。</li><li>BUS：设备在devpath 里的总线名称，例如：usb。</li><li>DRIVER：设备在devpath 里的设备驱动名称，例如：ide-cdrom。</li><li>ID：设备在devpath 里的识别号。</li><li>SYSFS{filename}：设备的devpath 路径下，设备的属性文件“filename”里的内容。</li></ul><blockquote><p>例如：SYSFS{model}&#x3D;&#x3D;“ST936701SS”表示：如果设备的型号为ST936701SS，则该设备匹配该匹配键。</p><p>在一条规则中，可以设定最多五条SYSFS的匹配键。</p></blockquote><ul><li>ENV{key}：环境变量。在一条规则中，可以设定最多五条环境变量的匹配键。</li><li>PROGRAM：调用外部命令。</li><li>RESULT：外部命令PROGRAM 的返回结果。例如：</li></ul><blockquote><p>PROGRAM&#x3D;&#x3D;”&#x2F;lib&#x2F;udev&#x2F;scsi_id-g -s $devpath”, RESULT&#x3D;&#x3D;“35000c50000a7ef67”</p><p>调用外部命令&#x2F;lib&#x2F;udev&#x2F;scsi_id查询设备的SCSIID，如果返回结果为35000c50000a7ef67，则该设备匹配该匹配键。</p></blockquote><h3 id="5-3-udev-的重要赋值键"><a href="#5-3-udev-的重要赋值键" class="headerlink" title="5.3 udev 的重要赋值键"></a>5.3 udev 的重要赋值键</h3><ul><li>NAME：在&#x2F;dev下产生的设备文件名。只有第一次对某个设备的NAME的赋值行为生效，之后匹配的规则再对该设备的NAME赋值行为将被忽略。如果没有任何规则对设备的NAME赋值，udev将使用内核设备名称来产生设备文件。</li><li>SYMLINK：为&#x2F;dev&#x2F;下的设备文件产生符号链接。由于udev只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的udev规则所产生的文件，推荐使用符号链接。</li><li>OWNER, GROUP, MODE：为设备设定权限。</li><li>ENV{key}：导入一个环境变量。</li><li>RUN:运行后面的程序。</li></ul><h3 id="5-4-udev-的值和可调用的替换操作符"><a href="#5-4-udev-的值和可调用的替换操作符" class="headerlink" title="5.4 udev 的值和可调用的替换操作符"></a>5.4 udev 的值和可调用的替换操作符</h3><p>在键值对中的键和操作符都介绍完了，最后是值(value)。Linux用户可以随意地定制udev规则文件的值。例如：my_root_disk,my_printer。同时也可以引用下面的替换操作符：</p><ul><li>$kernel, %k：设备的内核设备名称，例如：sda、cdrom。</li><li>$number, %n：设备的内核号码，例如：sda3的内核号码是3。</li><li>$devpath, %p：设备的devpath路径。</li><li>$id, %b：设备在devpath里的ID号。</li><li>$sysfs{file}，%s{file}：设备的sysfs里file的内容。其实就是设备的属性值。例如：sysfs{size}表示该设备(磁盘) 的大小。</li><li>$env{key}, %E{key}：一个环境变量的值。</li><li>$major, %M：设备的major号。</li><li>$minor %m：设备的minor号。</li><li>$result, %c：PROGRAM返回的结果。</li><li>$parent, %P：父设备的设备文件名。</li><li>$root, %r：udev_root的值，默认是&#x2F;dev&#x2F;。</li><li>$tempnode, %N：临时设备名。</li><li>%%：符号%本身。</li><li>$$： 符 号 ：符号：符号本身。</li></ul><p>注意：在匹配的过程中，要匹配所有的比较键都满足时，才算匹配成功。</p><h2 id="6-udev的使用方法"><a href="#6-udev的使用方法" class="headerlink" title="6.udev的使用方法"></a>6.udev的使用方法</h2><ol><li>使用udevadm 命令来查看设备的信息：在使用udev时需要获得该设备的一些信息，来用于匹配规则。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">udevadm info -a -p $(udevadm info -q path -n /dev/sdb)<br></code></pre></td></tr></table></figure><p>其中&#x2F;dev&#x2F;sdb是插入设备后设备在&#x2F;dev下的名字。</p><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs shell">Udevadm info starts with the device specified by the devpath and then<br>walks up the chain of parent devices. It prints for every device<br>found, all possible attributes in the udev rules key format.<br>A rule to match, can be composed by the attributes of the device<br>and the attributes from one single parent device.<br><br>  looking at device &#x27;/devices/pci0000:00/0000:00:10.0/host20/target20:0:1/20:0:1:0/block/sdb&#x27;:<br>    KERNEL==&quot;sdb&quot;<br>    SUBSYSTEM==&quot;block&quot;<br>    DRIVER==&quot;&quot;<br>    ATTR&#123;alignment_offset&#125;==&quot;0&quot;<br>    ATTR&#123;capability&#125;==&quot;50&quot;<br>    ATTR&#123;discard_alignment&#125;==&quot;0&quot;<br>    ATTR&#123;events&#125;==&quot;&quot;<br>    ATTR&#123;events_async&#125;==&quot;&quot;<br>    ATTR&#123;events_poll_msecs&#125;==&quot;-1&quot;<br>    ATTR&#123;ext_range&#125;==&quot;256&quot;<br>    ATTR&#123;hidden&#125;==&quot;0&quot;<br>    ATTR&#123;inflight&#125;==&quot;       0        0&quot;<br>    ATTR&#123;range&#125;==&quot;16&quot;<br>    ATTR&#123;removable&#125;==&quot;0&quot;<br>    ATTR&#123;ro&#125;==&quot;0&quot;<br>    ATTR&#123;size&#125;==&quot;41943040&quot;<br>    ATTR&#123;stat&#125;==&quot;      85        0     4184       20        0        0        0        0        0        8       20&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:10.0/host20/target20:0:1/20:0:1:0&#x27;:<br>    KERNELS==&quot;20:0:1:0&quot;<br>    SUBSYSTEMS==&quot;scsi&quot;<br>    DRIVERS==&quot;sd&quot;<br>    ATTRS&#123;blacklist&#125;==&quot;&quot;<br>    ATTRS&#123;device_blocked&#125;==&quot;0&quot;<br>    ATTRS&#123;device_busy&#125;==&quot;0&quot;<br>    ATTRS&#123;dh_state&#125;==&quot;detached&quot;<br>    ATTRS&#123;eh_timeout&#125;==&quot;10&quot;<br>    ATTRS&#123;evt_capacity_change_reported&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_inquiry_change_reported&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_lun_change_reported&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_media_change&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_mode_parameter_change_reported&#125;==&quot;0&quot;<br>    ATTRS&#123;evt_soft_threshold_reached&#125;==&quot;0&quot;<br>    ATTRS&#123;inquiry&#125;==&quot;&quot;<br>    ATTRS&#123;iocounterbits&#125;==&quot;32&quot;<br>    ATTRS&#123;iodone_cnt&#125;==&quot;0x7a&quot;<br>    ATTRS&#123;ioerr_cnt&#125;==&quot;0x3&quot;<br>    ATTRS&#123;iorequest_cnt&#125;==&quot;0x7a&quot;<br>    ATTRS&#123;model&#125;==&quot;VMware Virtual S&quot;<br>    ATTRS&#123;queue_depth&#125;==&quot;32&quot;<br>    ATTRS&#123;queue_ramp_up_period&#125;==&quot;120000&quot;<br>    ATTRS&#123;queue_type&#125;==&quot;simple&quot;<br>    ATTRS&#123;rev&#125;==&quot;1.0 &quot;<br>    ATTRS&#123;scsi_level&#125;==&quot;3&quot;<br>    ATTRS&#123;state&#125;==&quot;running&quot;<br>    ATTRS&#123;timeout&#125;==&quot;180&quot;<br>    ATTRS&#123;type&#125;==&quot;0&quot;<br>    ATTRS&#123;vendor&#125;==&quot;VMware, &quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:10.0/host20/target20:0:1&#x27;:<br>    KERNELS==&quot;target20:0:1&quot;<br>    SUBSYSTEMS==&quot;scsi&quot;<br>    DRIVERS==&quot;&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:10.0/host20&#x27;:<br>    KERNELS==&quot;host20&quot;<br>    SUBSYSTEMS==&quot;scsi&quot;<br>    DRIVERS==&quot;&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00/0000:00:10.0&#x27;:<br>    KERNELS==&quot;0000:00:10.0&quot;<br>    SUBSYSTEMS==&quot;pci&quot;<br>    DRIVERS==&quot;mptspi&quot;<br>    ATTRS&#123;broken_parity_status&#125;==&quot;0&quot;<br>    ATTRS&#123;class&#125;==&quot;0x010000&quot;<br>    ATTRS&#123;config&#125;==&quot;&quot;<br>    ATTRS&#123;consistent_dma_mask_bits&#125;==&quot;32&quot;<br>    ATTRS&#123;d3cold_allowed&#125;==&quot;0&quot;<br>    ATTRS&#123;device&#125;==&quot;0x0030&quot;<br>    ATTRS&#123;dma_mask_bits&#125;==&quot;32&quot;<br>    ATTRS&#123;driver_override&#125;==&quot;(null)&quot;<br>    ATTRS&#123;enable&#125;==&quot;1&quot;<br>    ATTRS&#123;irq&#125;==&quot;17&quot;<br>    ATTRS&#123;local_cpulist&#125;==&quot;0-3&quot;<br>    ATTRS&#123;local_cpus&#125;==&quot;00000000,00000000,00000000,0000000f&quot;<br>    ATTRS&#123;msi_bus&#125;==&quot;1&quot;<br>    ATTRS&#123;numa_node&#125;==&quot;-1&quot;<br>    ATTRS&#123;revision&#125;==&quot;0x01&quot;<br>    ATTRS&#123;subsystem_device&#125;==&quot;0x1976&quot;<br>    ATTRS&#123;subsystem_vendor&#125;==&quot;0x15ad&quot;<br>    ATTRS&#123;vendor&#125;==&quot;0x1000&quot;<br><br>  looking at parent device &#x27;/devices/pci0000:00&#x27;:<br>    KERNELS==&quot;pci0000:00&quot;<br>    SUBSYSTEMS==&quot;&quot;<br>    DRIVERS==&quot;&quot;<br></code></pre></td></tr></table></figure><ol start="2"><li>编写.rules文件的规则：进入&#x2F;etc&#x2F;udev&#x2F;rules.d文件夹：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc/udev/rules.d<br></code></pre></td></tr></table></figure><p>新建文件10-usb.rules：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi 10-usb.rules<br></code></pre></td></tr></table></figure><p>在10-usb.rules文件中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">KERNEL==&quot;sdb&quot;,SUBSYSTEM==&quot;block&quot;,ACTION==&quot;add&quot;,SYMLINK+=&quot;USB_link&quot;<br></code></pre></td></tr></table></figure><p>然后保存，退出。</p><ol start="3"><li>使得udev文件生效的方法：通常，使得配置后的文件生效，需要采用热插拔的方法更新udev规则，不过有更简单的方法如下：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">udevadm test /sys/class/block/sdb<br></code></pre></td></tr></table></figure><p>4.结果如下：在&#x2F;dev文件夹下</p><img src="/2023/02/16/udev%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/20201228214401604.png"><h2 id="7-热插拔能自动设备，冷插拔怎么办？"><a href="#7-热插拔能自动设备，冷插拔怎么办？" class="headerlink" title="7.热插拔能自动设备，冷插拔怎么办？"></a>7.热插拔能自动设备，冷插拔怎么办？</h2><p>由于冷插拔的设备开机时就已经存在，在udev启动前已经被插入。针对这种情况，sysfs下的设备都存在uevent文件，向该文件写一个“add”,内核会重新发送netlink，之后udev就可以收到设备的详细信息了，从而创建&#x2F;dev下对应的设备节点。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://blog.csdn.net/chengziwang/article/details/111873757">https://blog.csdn.net/chengziwang/article/details/111873757</a></li><li><a href="https://gitee.com/low-level-of-logic/RaspberryPi/blob/master/docs/">https://gitee.com/low-level-of-logic/RaspberryPi/blob/master/docs/</a></li><li><a href="https://blog.csdn.net/woyimibayi/article/details/78320915">https://blog.csdn.net/woyimibayi/article/details/78320915</a></li><li><a href="http://m.wfuyu.com/server/23483.html">http://m.wfuyu.com/server/23483.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【实验】/dev目录无法同时挂载两个文件系统</title>
    <link href="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="【实验】-x2F-dev目录无法同时挂载两个文件系统"><a href="#【实验】-x2F-dev目录无法同时挂载两个文件系统" class="headerlink" title="【实验】&#x2F;dev目录无法同时挂载两个文件系统"></a>【实验】&#x2F;dev目录无法同时挂载两个文件系统</h1><p>先介绍一下我的开发板，NXP的IMX6ULL，里面是原生的Linux内核，版本为<code>4.1.5</code>。</p><p>下面开始做实验，证明&#x2F;dev目录无法同时挂载两个文件系统。</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p><strong>1.开机后查看当前的挂载的设备</strong></p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215220652226.png" alt="image-20230215220652226" style="zoom:67%;"><blockquote><p>可以看到此时devtmpfs大小为88.3M</p></blockquote><p><strong>2.尝试手动挂载&#x2F;dev</strong></p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215220610703.png" alt="image-20230215220610703" style="zoom:67%;"><p>我们知道tmpfs挂载后默认是RAM的一半</p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215220830308.png" alt="image-20230215220830308" style="zoom:67%;"><blockquote><p>可以发现devtmpfs跟随tmpfs一起办成了RAM的一半大小</p></blockquote><p><strong>3.再次确认挂载情况</strong></p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215220510027.png"><p><strong>4.查看此时&#x2F;dev目录是否正常</strong></p><img src="/2023/02/15/%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91-dev%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E5%90%8C%E6%97%B6%E6%8C%82%E8%BD%BD%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230215221013735.png"><blockquote><p>此时&#x2F;dev目录下为空，访问不到任何目录</p></blockquote><h2 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h2><p>通过实验我们可以发现：</p><ul><li>可以同时给<code>/dev</code>挂载两个文件系统，但是有问题</li><li>当系统以<code>devtmpfs</code>挂载后，再次以<code>tmpfs</code>挂载后，<code>devtmpfs</code>会随<code>tmpfs</code>大小一起变化，如果<code>tmpfs</code>挂载时不指明大小，默认为内存的一半</li><li>给<code>/dev</code>挂载两个文件系统后，<code>/dev</code>目录无法正常访问</li></ul><p><strong>说明：本文水平有限，可能存在诸多问题，请指正！</strong></p>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tmpfs文件系统与安卓</title>
    <link href="/2023/02/14/tmpfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%89%E5%8D%93/"/>
    <url>/2023/02/14/tmpfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%89%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="tmpfs文件系统与安卓"><a href="#tmpfs文件系统与安卓" class="headerlink" title="tmpfs文件系统与安卓"></a>tmpfs文件系统与安卓</h1><h2 id="1-什么是tmpfs文件系统"><a href="#1-什么是tmpfs文件系统" class="headerlink" title="1.什么是tmpfs文件系统"></a>1.什么是tmpfs文件系统</h2><p>先来看一下Kernel文档对于tmpfs文件系统的描述：<a href="https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt">https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">Tmpfs is a file system <span class="hljs-built_in">which</span> keeps all files <span class="hljs-keyword">in</span> virtual memory.<br><br>Everything <span class="hljs-keyword">in</span> tmpfs is temporary <span class="hljs-keyword">in</span> the sense that no files will be created on your hard drive. If you unmount a tmpfs instance, everything stored there <span class="hljs-keyword">in</span> is lost.<br><br>tmpfs puts everything into the kernel internal caches and grows andshrinks to accommodate the files it contains and is able to swap unneeded pages out to swap space. It has maximum size limits <span class="hljs-built_in">which</span> can be adjusted on the fly via <span class="hljs-string">&#x27;mount -o remount ...&#x27;</span><br><br>If you compare it to ramfs (<span class="hljs-built_in">which</span> was the template to create tmpfs) you gain swapping and <span class="hljs-built_in">limit</span> checking. Another similar thing is the RAMdisk (/dev/ram*), <span class="hljs-built_in">which</span> simulates a fixed size hard disk <span class="hljs-keyword">in</span> physical RAM, <span class="hljs-built_in">where</span> you have to create an ordinary filesystem on top. Ramdisks cannot swap and you <span class="hljs-keyword">do</span> not have the possibility to resize them. <br></code></pre></td></tr></table></figure><ul><li><p>tmpfs是一个将所有文件保存在虚拟内存中的文件系统。</p></li><li><p>tmpfs中的所有内容都是临时的，因为不会在硬盘上创建任何文件。如果卸载tmpfs实例，存储在其中的所有东西都丢失了</p></li><li><p>tmpfs将所有内容放入内核内部缓存，并进行增长和收缩以容纳其中包含的文件，并能够将不需要的页面交换出来以交换空间。它具有size限制，可以通过“mount-o remount…”进行动态调整</p></li><li><p>如果将其与ramfs（创建tmpfs的模板）进行比较，则会获得交换和限制检查。另一个类似的东西是RAMdisk（&#x2F;dev&#x2F;ram*），它在物理ram中模拟固定大小的硬盘，您必须在上面创建一个普通的文件系统。Ramdisks无法互换，您无法调整其大小。</p></li></ul><p><strong>我们总结一下tmpfs的特点：</strong></p><ol><li>由于是构建在内存中，存放在tmpfs中的所有数据在卸载或者断后丢失。【临时性】</li><li>内存的访问速度远远大于磁盘IO操作，即使使用了虚拟内存，性能仍然优于磁盘。【快速读写】</li><li>tmpfs一开始使用很小的空间，但是随着文件的复制和创建，tmpfs文件系统会分配更多的内存，并按照需求动态增加文件系统的空间，而且tmpfs文件系统会动态缩小文件并释放内存资源</li><li>像普通块设备需要mkfs格式化文件系统后才可以使用，但是tmpfs是独立的文件系统，只要挂载就可以使用。</li></ol><h2 id="2-Android中的tmpfs文件系统"><a href="#2-Android中的tmpfs文件系统" class="headerlink" title="2.Android中的tmpfs文件系统"></a>2.Android中的tmpfs文件系统</h2><p>Android中挂载tmpfs文件系统的时机主要在安卓init进程中的第一阶段挂载和第二阶段挂载【基于Android S】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FirstStageMain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br><br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/dev&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="hljs-string">&quot;mode=0755&quot;</span>));<br>    <br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/mnt&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=1000&quot;</span>));<br>    <br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/debug_ramdisk&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=0&quot;</span>));<br>    <br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, kSecondStageRes, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=0&quot;</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br># --------------------------------------------------------------------------------------<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SecondStageMain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-built_in">MountExtraFilesystems</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">MountExtraFilesystems</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// /apex is used to mount APEXes</span><br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/apex&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=0&quot;</span>));<br><br>    <span class="hljs-comment">// /linkerconfig is used to keep generated linker configuration</span><br>    <span class="hljs-built_in">CHECKCALL</span>(<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/linkerconfig&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>                    <span class="hljs-string">&quot;mode=0755,uid=0,gid=0&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看一下安卓真实运行环境中的挂载情况</p><img src="/2023/02/14/tmpfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%89%E5%8D%93/image-20230214223605505.png" style="zoom:80%;"><p>🐖【个人猜想】为什么类似&#x2F;dev，&#x2F;apex这种需要使用tmpfs文件系统：</p><ul><li>像安卓的设备创建后都在&#x2F;dev目录下，驱动会以&#x2F;dev&#x2F;xxx的文件形式存在，所以会发生大量的IO操作，显然使用tmpfs更快</li><li>像ART，VNDK等都存在于&#x2F;apex中，安卓启动的时候虚拟机ART创建都在&#x2F;apex中</li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://www.bilibili.com/video/BV1HG4y1K76E/">https://www.bilibili.com/video/BV1HG4y1K76E/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手动挂载apex包到loop设备</title>
    <link href="/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/"/>
    <url>/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="【实验】手动挂载apex镜像"><a href="#【实验】手动挂载apex镜像" class="headerlink" title="【实验】手动挂载apex镜像"></a>【实验】手动挂载apex镜像</h1><h2 id="1-loop设备"><a href="#1-loop设备" class="headerlink" title="1.loop设备"></a>1.loop设备</h2><p>在类 UNIX 系统里，loop 设备是一种伪设备(pseudo-device)，或者也可以说是仿真设备。它能使我们像块设备一样访问一个文件。</p><p>这要先从mount的流程来理解，挂载操作，实际上就是把设备上的文件系统&#x2F;目录文件连接到指定的目录（directory）下，在操作系统层面就是把挂载设备和挂载目录的对应关系加到内核中的Vfsmount里的对应表单里（内核启动后会从硬盘上加载到内存里），这样我们就可以通过访问目录路径来访问设备上的数据了。</p><p>loop mount是另一种mount方式，如果说普通mount解决了实际硬件存储设备的挂载，bind mount解决了目录到目录的挂载，那么loop mount则解决了将<strong>档案文件</strong>到目录的挂载</p><p>档案，英文Archive，与文件（file）不同，是一个打包好的文件集，里面一般包含许多文件, 比如 tar，jar，iso ，img就是常见的档案格式</p><p>那又是怎么实现将档案文件挂载到目录下呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs she">实际上，系统先把档案文件（比如某个.iso文件）映射到loop设备上<br>#losetup  /dev/loop0   xxxx.iso        使系统误认为xxxx.iso为存储设备/dev/loop0<br><br>再欺骗mount命令，使他认为  /dev/loop0真的是个设备在运行，挂载到指定目录<br>#mount   -t   xxxx.iso   /dev/loop0    /loop设备路径    <br><br></code></pre></td></tr></table></figure><p>但前提是，被访问的loop设备里的档案文件具有linux识别的文件系统，像tar, jar, zip 这样的档案，只是一种压缩格式，本身不是文件系统，即使通过loop mount挂载上去了，直接访问他也读不出什么数据，这很好理解，就像在windows下不装任何解压软件，就无法打开压缩文件一样。<u><strong>所有一般我们都是拿img、iso映射到loop设备。</strong></u></p><h2 id="2-apex包结构"><a href="#2-apex包结构" class="headerlink" title="2.apex包结构"></a>2.apex包结构</h2><p>APEX文件格式如下</p><img src="/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/20200601191934566.png"><p>从顶层看，APEX文件是一个Zip文件，其中的文件均是未压缩的。</p><p>其中的四个文件有<code>apex_manifest.json</code>，<code>AndroidManifest.xml</code>，<code>apex_pubkey</code>，<code>apex_payload.img</code></p><ul><li><p>apex_manifest.json文件包括package name和版本，用来标识该APEX文件</p></li><li><p>AndroidManifest.xml可以允许APEX文件使用一些apk的工具，像adb、package manager、 app install app等。举个例子APEX文件可以使用aapt检查文件的metadata。该文件还包括packcage name和版本号，这些内容通常也会再apex_manifest.json文件中。</p></li><li><p>apex_payload.img是依赖dm-verity的EXT4文件系统镜像。该镜像在运行时通过一个回环设备加载。具体地说，metadata和hash tree是通过libavb创建的。apex_payload.img还没有被解析，因为要求该文件是可挂载的。一些常规文件包含在该镜像中。</p></li><li><p>apex_pubkey是用来给文件系统签名的公钥。该公钥确保下载的apex文件是以编译阶段相同的方式签名。</p></li></ul><h2 id="3-开始实验"><a href="#3-开始实验" class="headerlink" title="3.开始实验"></a>3.开始实验</h2><ol><li><p><strong>将apex解压缩，上传到Linux中</strong></p><img src="/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/image-20230204111723539.png"></li></ol><p>其实apex包就是个压缩包，将后缀名改成<code>.zip</code>，自行使用Windows解压工具进行解压</p><p><strong>上传后我们可以看下它的文件结构和它的文件系统属性</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Android/system$ file apex_payload.img <br>apex_payload.img: Linux rev 1.0 ext2 filesystem data, UUID=7d1522e1-9dfa-5edb-a43e-98e3a4d20250 (extents) (large files) (huge files)<br><br>amx@amxxxx:~/Android/system$ tune2fs -l apex_payload.img <br>tune2fs 1.44.5 (15-Dec-2018)<br>Filesystem volume name:   &lt;none&gt;<br>Last mounted on:          &lt;not available&gt;<br>Filesystem UUID:          7d1522e1-9dfa-5edb-a43e-98e3a4d20250<br>Filesystem magic number:  0xEF53<br>Filesystem revision <span class="hljs-comment">#:    1 (dynamic)</span><br>Filesystem features:      ext_attr dir_index filetype extent sparse_super large_file huge_file uninit_bg dir_nlink extra_isize shared_blocks<br>Filesystem flags:         signed_directory_hash <br>Default mount options:    user_xattr acl<br>Filesystem state:         clean<br>Errors behavior:          Continue<br>Filesystem OS <span class="hljs-built_in">type</span>:       Linux<br>Inode count:              32<br>Block count:              8213<br>Reserved block count:     0<br>Free blocks:              8<br>Free inodes:              5<br>First block:              0<br>Block size:               4096<br>Fragment size:            4096<br>Blocks per group:         32768<br>Fragments per group:      32768<br>Inodes per group:         32<br>Inode blocks per group:   2<br>Filesystem created:       Thu Jan  1 08:00:01 1970<br>Last mount time:          n/a<br>Last write time:          Thu Jan  1 08:00:01 1970<br>Mount count:              0<br>Maximum mount count:      -1<br>Last checked:             Thu Jan  1 08:00:01 1970<br>Check interval:           0 (&lt;none&gt;)<br>Lifetime writes:          32 MB<br>Reserved blocks uid:      0 (user root)<br>Reserved blocks gid:      0 (group root)<br>First inode:              11<br>Inode size:               256<br>Required extra isize:     32<br>Desired extra isize:      32<br>Default directory <span class="hljs-built_in">hash</span>:   half_md4<br>Directory Hash Seed:      7d1522e1-9dfa-5edb-a43e-98e3a4d20250<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>查看当前空闲的loop设备</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Android/system$ sudo losetup -f<br>/dev/loop0<br></code></pre></td></tr></table></figure><p>可以看到当前空闲的loop设备为<code>/dev/loop0</code>，所以我们打算将apex与&#x2F;dev&#x2F;loop0进行关联</p><ol start="3"><li><strong>将apex镜像与loop设备关联</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Android/system$ sudo losetup /dev/loop0 apex_payload.img<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>将loop设备挂载到目标节点上</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">amx@amxxxx:~/Android/system$ sudo mount -o ro /dev/loop0 /home/amx/Android/apex/com.android.i18n<br></code></pre></td></tr></table></figure><p>这里我模仿了安卓将它挂载到了<code>/home/amx/Android/apex/com.android.i18n</code></p><blockquote><p>这里只能使用ro只读形式挂载，因为apex_playload.img采用了ext4文件系统，且在文件系统中添加了<code>shared_block</code>属性，该属性不允许随意修改镜像文件，也是为了将镜像文件尽量压缩到最小（从名字就可以看出来共享块）。这里可以通过改变inode结构改变这个属性，但是有点难度，需要了解ext文件系统才行。</p></blockquote><ol start="5"><li><strong>查看是否挂载成功</strong></li></ol><img src="/2023/02/04/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDapex%E5%8C%85%E5%88%B0loop%E8%AE%BE%E5%A4%87/image-20230204111215939.png"><p>可以看到我们可以像访问块设备一样访问apex包啦</p><ol start="6"><li><strong>说明</strong></li></ol><p>真实的安卓环境中是先system&#x2F;apex下面的apex包挂载到对应的版本目录下，例如adb会先挂载到<code>/apex/com.android.adb@300009</code>，然后再将<code>/apex/com.android.adb@300009</code>以bind方式挂载到<code>/apex/com.android.adb</code></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><ul><li><a href="https://blog.csdn.net/shengxia1999/article/details/52081286?spm=1001.2014.3001.5506">https://blog.csdn.net/shengxia1999/article/details/52081286?spm=1001.2014.3001.5506</a></li><li><a href="https://blog.csdn.net/qq_28351465/article/details/106458089?spm=1001.2014.3001.5506">https://blog.csdn.net/qq_28351465/article/details/106458089?spm=1001.2014.3001.5506</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓开机动画</title>
    <link href="/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <url>/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓S开机动画流程"><a href="#安卓S开机动画流程" class="headerlink" title="安卓S开机动画流程"></a>安卓S开机动画流程</h1><p>开机动画是<strong>在SurfaceFlinger实例通过调用startBootAnim()启动的</strong>，BootAnim是如何启动和结束的，总体框架图如下：</p><img src="/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/整体架构2.png"><h2 id="1-SurfaceFlinger进程启动"><a href="#1-SurfaceFlinger进程启动" class="headerlink" title="1.SurfaceFlinger进程启动"></a>1.SurfaceFlinger进程启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">/frameworks/native/services/surfaceflinger/surfaceflinger.rc</span><br>service surfaceflinger /system/bin/surfaceflinger<br>    class core animation<br>    user system<br>    group graphics drmrpc readproc<br>    capabilities SYS_NICE<br>    onrestart restart zygote<br>    task_profiles HighPerformance<br>    socket pdx/system/vr/display/client     stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0<br>    socket pdx/system/vr/display/manager    stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0<br>    socket pdx/system/vr/display/vsync      stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0<br><br></code></pre></td></tr></table></figure><p>init进程会根据surfaceflinger.rc配置启动surfaceflinger进程，surfaceflinger进程(&#x2F;system&#x2F;bin&#x2F;surfaceflinger)启动，会走到main函数里面。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">/frameworks/native/services/surfaceflinger/Android.bp</span><br>filegroup &#123;<br>    name: &quot;surfaceflinger_binary_sources&quot;,<br>    srcs: [<br>        &quot;:libsurfaceflinger_sources&quot;,<br>        &quot;main_surfaceflinger.cpp&quot;,<br>    ],<br>&#125;<br><br>cc_binary &#123;<br>    name: &quot;surfaceflinger&quot;,<br>    defaults: [&quot;libsurfaceflinger_binary&quot;],<br>    init_rc: [&quot;surfaceflinger.rc&quot;],<br>    srcs: [<br>        &quot;:surfaceflinger_binary_sources&quot;,<br>        // Note: SurfaceFlingerFactory is not in the filegroup so that it<br>        // can be easily replaced.<br>        &quot;SurfaceFlingerFactory.cpp&quot;,<br>    ],<br>    shared_libs: [<br>        &quot;libSurfaceFlingerProp&quot;,<br>    ],<br><br>     logtags: [&quot;EventLog/EventLogTags.logtags&quot;],<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到编译surfaceflinger二进制进程的源文件为<code>surfaceflinger_binary_sources</code>和<code>SurfaceFlingerFactory.cpp</code>，其中surfaceflinger_binary_sources来源于<code>main_surfaceflinger.cpp</code></p><h2 id="2-注册启动surfaceflinger服务"><a href="#2-注册启动surfaceflinger服务" class="headerlink" title="2.注册启动surfaceflinger服务"></a>2.注册启动surfaceflinger服务</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// /frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>**)</span> </span>&#123;<br><span class="hljs-comment">// ...</span><br><br>    sp&lt;SurfaceFlinger&gt; flinger = surfaceflinger::<span class="hljs-built_in">createSurfaceFlinger</span>(); <span class="hljs-comment">//创建surfaceflinger服务实例</span><br><br><span class="hljs-comment">// ...</span><br>    flinger-&gt;<span class="hljs-built_in">init</span>();  <span class="hljs-comment">// 初始化flinger实例</span><br><br>    <span class="hljs-comment">// 向ServiceManager注册surfaceflinger服务</span><br>    <span class="hljs-function">sp&lt;IServiceManager&gt; <span class="hljs-title">sm</span><span class="hljs-params">(defaultServiceManager())</span></span>;<br>    sm-&gt;<span class="hljs-built_in">addService</span>(<span class="hljs-built_in">String16</span>(SurfaceFlinger::<span class="hljs-built_in">getServiceName</span>()), flinger, <span class="hljs-literal">false</span>,<br>                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);<br><br><span class="hljs-comment">// ...</span><br><br>    flinger-&gt;<span class="hljs-built_in">run</span>();   <span class="hljs-comment">// 启动surfaceflinger服务</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用SurfaceFlinger对象的init方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    mStartPropertySetThread = <span class="hljs-built_in">getFactory</span>().<span class="hljs-built_in">createStartPropertySetThread</span>(presentFenceReliable);<br><br>    <span class="hljs-keyword">if</span> (mStartPropertySetThread-&gt;<span class="hljs-built_in">Start</span>() != NO_ERROR) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Run StartPropertySetThread failed!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Done initializing&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>SurfaceFlinger调用init方法时会获取mStartPropertySetThread，调用该对象的Start方法，其实是准备启动一个线程去启动BootAnimation</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// /frameworks/native/services/surfaceflinger/StartPropertySetThread.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">StartPropertySetThread::Start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;SurfaceFlinger::StartPropertySetThread&quot;</span>, PRIORITY_NORMAL);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StartPropertySetThread::threadLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Set property service.sf.present_timestamp, consumer need check its readiness</span><br>    <span class="hljs-built_in">property_set</span>(kTimestampProperty, mTimestampPropertyValue ? <span class="hljs-string">&quot;1&quot;</span> : <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-comment">// 清除BootAnimation退出标志位service.bootanim.exit</span><br>    <span class="hljs-built_in">property_set</span>(<span class="hljs-string">&quot;service.bootanim.exit&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-comment">// 设置bootanim的进度为0</span><br>    <span class="hljs-built_in">property_set</span>(<span class="hljs-string">&quot;service.bootanim.progress&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-comment">// 通过service.bootanim.exit</span><br>    <span class="hljs-built_in">property_set</span>(<span class="hljs-string">&quot;ctl.start&quot;</span>, <span class="hljs-string">&quot;bootanim&quot;</span>);<br>    <span class="hljs-comment">// 立即退出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里一开始看起来比较疑惑，首先是StartPropertySetThread::Start函数，在<code>StartPropertySetThread.h</code>表明StartPropertySetThread继承自父类Thread，而父类Thread是由&lt;utils&#x2F;Thread.h&gt; 引入的，所以这里是子类引用父类方法，这里的run函数就是就是thread的run方法。这里会启动一个线程去运行，线程名为”StartPropertySetThread”，线程优先级为PRIORITY_NORMAL。线程启动以后，最终会调用 <code>_threadLoop</code> 函数，它会去调用threadLoop函数。这里整个函数调用栈就清楚了：</li></ul><img src="/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/线程函数调用.png"><ul><li>当系统属性发生改变时，init进程就会接收到一个系统属性变化通知，这个通知最终是由在init进程中的函数handle_property_set_fd来处理</li></ul><h2 id="3-bootanim进程启动"><a href="#3-bootanim进程启动" class="headerlink" title="3.bootanim进程启动"></a>3.bootanim进程启动</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// /frameworks/base/cmds/bootanimation/bootanimation_main.cpp</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    setpriority(PRIO_PROCESS, <span class="hljs-number">0</span>, ANDROID_PRIORITY_DISPLAY);<br><br>    <span class="hljs-type">bool</span> noBootAnimation = bootAnimationDisabled();<br>    ALOGI_IF(noBootAnimation,  <span class="hljs-string">&quot;boot animation disabled&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!noBootAnimation) &#123;<br>        <span class="hljs-comment">// 启动Binder线程池</span><br>        sp&lt;ProcessState&gt; <span class="hljs-title function_">proc</span><span class="hljs-params">(ProcessState::self())</span>;<br>        ProcessState::self()-&gt;startThreadPool();<br>        <br>        sp&lt;BootAnimation&gt; boot = new BootAnimation(audioplay::createAnimationCallbacks());<br><br>        waitForSurfaceFlinger();<br>        <br>        boot-&gt;run(<span class="hljs-string">&quot;BootAnimation&quot;</span>, PRIORITY_DISPLAY);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">bootAnimationDisabled</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> value[PROPERTY_VALUE_MAX];<br>    <span class="hljs-comment">// 如果debug.sf.nobootanimation=1，则不会显示动画</span><br>    property_get(<span class="hljs-string">&quot;debug.sf.nobootanimation&quot;</span>, value, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-keyword">if</span> (atoi(value) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-comment">// 如果ro.boot.quiescent=1，则不显示开机动画</span><br>    property_get(<span class="hljs-string">&quot;ro.boot.quiescent&quot;</span>, value, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-keyword">if</span> (atoi(value) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Only show the bootanimation for quiescent boots if this system property is set to enabled</span><br>        <span class="hljs-keyword">if</span> (!property_get_bool(<span class="hljs-string">&quot;ro.bootanim.quiescent.enabled&quot;</span>, <span class="hljs-literal">false</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断完BootAnimation是不是disabled之后，如果noBootAnimation为false，则创建一个BootAnimation对象。创建完了BootAnimation对象后，调用其run方法，由于BootAnimation也继承了Thread，所以最终也会走到对应的threadLoop方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BootAnimation::threadLoop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> r;<br><br>    <span class="hljs-keyword">if</span> (mZipFileName == <span class="hljs-literal">NULL</span>) &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r = <span class="hljs-built_in">movie</span>();  <span class="hljs-comment">// 调用movie方法</span><br>    &#125;<br>    <span class="hljs-comment">// 销毁 opengl 和 egl</span><br>    <span class="hljs-built_in">eglMakeCurrent</span>(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);<br>    <span class="hljs-built_in">eglDestroyContext</span>(mDisplay, mContext);<br>    <span class="hljs-built_in">eglDestroySurface</span>(mDisplay, mSurface);<br>    mFlingerSurface.<span class="hljs-built_in">clear</span>();<br>    mFlingerSurfaceControl.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">eglTerminate</span>(mDisplay);<br>    IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">stopProcess</span>();<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BootAnimation::movie</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    String8 desString;<br>    <span class="hljs-comment">// 读取 desc.txt 配置文件</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">readFile</span>(<span class="hljs-string">&quot;desc.txt&quot;</span>, desString)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">char</span> <span class="hljs-type">const</span>* s = desString.<span class="hljs-built_in">string</span>();<br><br>    <span class="hljs-comment">// 解析描述文件</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;pcount ; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r=<span class="hljs-number">0</span> ; !part.count || r&lt;part.count ; r++) &#123;<br>            <span class="hljs-comment">// opengl 绘制操作</span><br>            <span class="hljs-built_in">glClearColor</span>(<br>                    part.backgroundColor[<span class="hljs-number">0</span>],<br>                    part.backgroundColor[<span class="hljs-number">1</span>],<br>                    part.backgroundColor[<span class="hljs-number">2</span>],<br>                    <span class="hljs-number">1.0f</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j=<span class="hljs-number">0</span> ; j&lt;fcount &amp;&amp; (!<span class="hljs-built_in">exitPending</span>() || part.playUntilComplete) ; j++) &#123;<br>                <span class="hljs-function"><span class="hljs-type">const</span> Animation::Frame&amp; <span class="hljs-title">frame</span><span class="hljs-params">(part.frames[j])</span></span>;<br>                <span class="hljs-type">nsecs_t</span> lastFrame = <span class="hljs-built_in">systemTime</span>();<br>                ...<br>                <span class="hljs-keyword">if</span> (r &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, frame.tid);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ...<br>                    <span class="hljs-built_in">initTexture</span>(frame);<br>                &#125;<br>                <br>                <span class="hljs-comment">// specify the y center as ceiling((mHeight - animation.height) / 2)</span><br>                <span class="hljs-comment">// which is equivalent to mHeight - (yc + animation.height)</span><br>                <span class="hljs-built_in">glDrawTexiOES</span>(xc, mHeight - (yc + animation.height),<br>                              <span class="hljs-number">0</span>, animation.width, animation.height);<br>                <span class="hljs-built_in">eglSwapBuffers</span>(mDisplay, mSurface);<br><br>                <span class="hljs-comment">// 不断绘制时检测是否需要退出</span><br>                <span class="hljs-built_in">checkExit</span>();<br>            &#125;<br>            <span class="hljs-comment">// 如果退出了就跳出结束绘制</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exitPending</span>() &amp;&amp; !part.count)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// free the textures for this part</span><br>        <span class="hljs-keyword">if</span> (part.count != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j=<span class="hljs-number">0</span> ; j&lt;fcount ; j++) &#123;<br>                <span class="hljs-function"><span class="hljs-type">const</span> Animation::Frame&amp; <span class="hljs-title">frame</span><span class="hljs-params">(part.frames[j])</span></span>;<br>                <span class="hljs-built_in">glDeleteTextures</span>(<span class="hljs-number">1</span>, &amp;frame.tid);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 读取 service.bootanim.exit 值是否是 1 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXIT_PROP_NAME <span class="hljs-string">&quot;service.bootanim.exit&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BootAnimation::checkExit</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Allow surface flinger to gracefully request shutdown</span><br>    <span class="hljs-type">char</span> value[PROPERTY_VALUE_MAX];<br>    <span class="hljs-built_in">property_get</span>(EXIT_PROP_NAME, value, <span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-type">int</span> exitnow = <span class="hljs-built_in">atoi</span>(value);<br>    <span class="hljs-keyword">if</span> (exitnow) &#123;<br>        <span class="hljs-built_in">requestExit</span>();<br>        <span class="hljs-keyword">if</span> (mAudioPlayer != <span class="hljs-literal">NULL</span>) &#123;<br>            mAudioPlayer-&gt;<span class="hljs-built_in">requestExit</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动动画底层采用的是 opengles 的方式来渲染绘制的，绘制的内容是本地的一个启动动画资源包，在绘制的过程中会不断的判断是否需要退出，读取的字段是 service.bootanim.exit ，为 1 代表需要 break 退出循环绘制。因此我们只需要找到 service.bootanim.exit 在哪里设置为 1 的，便可找到退出启动动画的入口。关闭动画的入口还是在 SurfaceFlinger 中只是这个调用流程比较复杂而已：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(IBinder token,</span></span><br><span class="hljs-params"><span class="hljs-function">                                boolean clearHide, boolean isForward, boolean reallyResume)</span> </span>&#123;<br>    ActivityClientRecord r = <span class="hljs-built_in">performResumeActivity</span>(token, clearHide);<br>    <span class="hljs-keyword">if</span> (r != null) &#123;<br>        <span class="hljs-keyword">if</span> (!r.onlyLocalRequest) &#123;<br>            r.nextIdle = mNewActivities;<br>            mNewActivities = r;<br>            <span class="hljs-comment">// 添加了一个 IdleHandler 消息</span><br>            Looper.<span class="hljs-built_in">myQueue</span>().<span class="hljs-built_in">addIdleHandler</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Idler</span>());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> Idler implements MessageQueue.IdleHandler &#123;<br>    @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> boolean <span class="hljs-built_in">queueIdle</span>() &#123;<br>        ActivityClientRecord a = mNewActivities;<br>        <span class="hljs-keyword">if</span> (a != null) &#123;<br>            mNewActivities = null;<br>            IActivityManager am = ActivityManagerNative.<span class="hljs-built_in">getDefault</span>();<br>            ActivityClientRecord prev;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (a.activity != null &amp;&amp; !a.activity.mFinished) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 调用 AMS 的 activityIdle</span><br>                        am.<span class="hljs-built_in">activityIdle</span>(a.token, a.createdConfig, stopProfiling);<br>                    &#125; <span class="hljs-built_in">catch</span> (RemoteException ex) &#123;<br>                        <span class="hljs-comment">// Ignore</span><br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">while</span> (a != null);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><br>@<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">activityIdle</span><span class="hljs-params">(IBinder token, Configuration config, boolean stopProfiling)</span> </span>&#123;<br>    <span class="hljs-built_in">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        ActivityStack stack = ActivityRecord.<span class="hljs-built_in">getStackLocked</span>(token);<br>        <span class="hljs-keyword">if</span> (stack != null) &#123;<br>            ActivityRecord r = mStackSupervisor.<span class="hljs-built_in">activityIdleInternalLocked</span>(token, <span class="hljs-literal">false</span>, config);<br>        &#125;<br>    &#125;<br>    Binder.<span class="hljs-built_in">restoreCallingIdentity</span>(origId);<br>&#125;<br><br><span class="hljs-comment">// Checked.</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> ActivityRecord <span class="hljs-title">activityIdleInternalLocked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> IBinder token, boolean fromTimeout,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                Configuration config)</span> </span>&#123;<br>    ActivityRecord r = ActivityRecord.forTokenLocked(token);<br>    <span class="hljs-keyword">if</span> (r != null) &#123;<br>        ...<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFrontStack</span>(r.task.stack) || fromTimeout) &#123;<br>                booting = <span class="hljs-built_in">checkFinishBootingLocked</span>();<br>            &#125;<br>    &#125;<br>    ...<br>        <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> boolean <span class="hljs-title">checkFinishBootingLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> boolean booting = mService.mBooting;<br>    boolean enableScreen = <span class="hljs-literal">false</span>;<br>    mService.mBooting = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!mService.mBooted) &#123;<br>        mService.mBooted = <span class="hljs-literal">true</span>;<br>        enableScreen = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (booting || enableScreen) &#123;<br>        mService.<span class="hljs-built_in">postFinishBooting</span>(booting, enableScreen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> booting;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enableScreenAfterBoot</span><span class="hljs-params">()</span> </span>&#123;<br>    mWindowManager.<span class="hljs-built_in">enableScreenAfterBoot</span>();<br>    <span class="hljs-built_in">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-built_in">updateEventDispatchingLocked</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">performEnableScreen</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">synchronized</span>(mWindowMap) &#123;<br>        <span class="hljs-keyword">if</span> (!mBootAnimationStopped) &#123;<br>            <span class="hljs-comment">// 向SurfaceFlinger 进程发起关闭开机界面的消息</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                IBinder surfaceFlinger = ServiceManager.<span class="hljs-built_in">getService</span>(<span class="hljs-string">&quot;SurfaceFlinger&quot;</span>);<br>                <span class="hljs-keyword">if</span> (surfaceFlinger != null) &#123;<br>                    Parcel data = Parcel.<span class="hljs-built_in">obtain</span>();<br>                    data.<span class="hljs-built_in">writeInterfaceToken</span>(<span class="hljs-string">&quot;android.ui.ISurfaceComposer&quot;</span>);<br>                    <span class="hljs-comment">// 向SurfaceComposer发送</span><br>                    surfaceFlinger.<span class="hljs-built_in">transact</span>(IBinder.FIRST_CALL_TRANSACTION, <span class="hljs-comment">// BOOT_FINISHED</span><br>                                            data, null, <span class="hljs-number">0</span>);<br>                    data.<span class="hljs-built_in">recycle</span>();<br>                &#125;<br>            &#125; <span class="hljs-built_in">catch</span> (RemoteException ex) &#123;<br>                ...<br>            &#125;<br>            mBootAnimationStopped = <span class="hljs-literal">true</span>;<br>        &#125;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ----------------------------------------------------------------------</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ISurfaceComposerTag</span> &#123;<br>    BOOT_FINISHED = IBinder::FIRST_CALL_TRANSACTION,<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// /frameworks/native/libs/gui/ISurfaceComposer.cpp</span><br><span class="hljs-type">status_t</span> BnSurfaceComposer::<span class="hljs-built_in">onTransact</span>(<br>    <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-type">uint32_t</span> flags)&#123;<br>    <span class="hljs-keyword">switch</span>(code) &#123;<br>            <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">case</span> BOOT_FINISHED: &#123;<br>            <span class="hljs-built_in">CHECK_INTERFACE</span>(ISurfaceComposer, data, reply);<br>            <span class="hljs-built_in">bootFinished</span>();<br>            <span class="hljs-keyword">return</span> NO_ERROR;<br>        &#125;<br>            <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// ----------------------------------------------------------------------</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::bootFinished</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 把 service.bootanim.exit 属性设置为 1 ，bootanim 进程读到 1 时就会退出开机启动动画</span><br>    <span class="hljs-built_in">property_set</span>(<span class="hljs-string">&quot;service.bootanim.exit&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭开机启动动画的流程还是比较复杂的，我们来缕一缕整个逻辑，我们的 Launcher 进程启动后会启动我们 Launcher Activity 界面，而 Activity 的生命周期调用都是由 ActivityThread 来执行的，其中就会执行到 handleResumeActivity 方法，在该方法中会添加一个 IdleHandler 消息，会调用到 AMS 的 activityIdle 方法，AMS 会调用 WMS 的 enableScreenAfterBoot 方法，WMS 会跨进程通知 SurfaceFlinger 去关闭我们的开机启动动画。</p><h2 id="4-开机动画包里有什么"><a href="#4-开机动画包里有什么" class="headerlink" title="4.开机动画包里有什么"></a>4.开机动画包里有什么</h2><p>这里建议先看一下官方文档：&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;bootanimation&#x2F;FORMAT.md</p><p>开机动画指的是以bootanimation.zip方式存在，启动的时候会依次选择一个bootanimation.zip加载</p><ol><li>&#x2F;system&#x2F;media&#x2F;bootanimation-encrypted.zip (if getprop(“vold.decrypt”) &#x3D; ‘1’)</li><li>&#x2F;system&#x2F;media&#x2F;bootanimation.zip</li><li>&#x2F;oem&#x2F;media&#x2F;bootanimation.zip</li></ol><p><code>bootanimation.zip</code> 文件中包含：</p><img src="/2023/01/25/%E5%AE%89%E5%8D%93%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB/压缩文件.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">desc.txt - a text file<br>part0  \<br>part1   \  directories full of PNG frames<br>...     /<br>partN  /<br></code></pre></td></tr></table></figure><p><strong>“desc.txt”</strong>：<strong>用来描述用户自定义的开机动画是如何显示的</strong>。</p><p>以下面的例子为例：</p><blockquote><p>1280 720 1</p><p>p 1 1 part0</p><p>p 0 1 part1</p></blockquote><p>第一行的三个数字分别表示开机动画在屏幕中的显示宽度、高度以及帧速(fps)。剩余的每一行都用来描述一个动画片断，这些行必须要以字符“p”来开头，后面紧跟着两个数字以及一个文件目录路径名称。</p><p>第一个数字表示一个片断的循环显示次数，如果它的值等于0，那么就表示无限循环地显示该动画片断。</p><p>第二个数字表示每一个片断在两次循环显示之间的时间间隔。这个时间间隔是以一个帧的时间为单位的。</p><p>文件目录下面保存的是一系列png文件，这些png文件会被依次显示在屏幕中。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul><li><a href="https://blog.51cto.com/u_11176305/3796348">https://blog.51cto.com/u_11176305/3796348</a></li><li><a href="https://www.cnblogs.com/lufeibin/p/13529981.html">https://www.cnblogs.com/lufeibin/p/13529981.html</a></li><li><a href="https://blog.csdn.net/weixin_36044720/article/details/117277602?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_36044720/article/details/117277602?spm=1001.2014.3001.5506</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-Treble计划</title>
    <link href="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/"/>
    <url>/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<ul><li>🕊️本文来自视频：<a href="https://www.youtube.com/watch?v=zbebx1Kvqho">https://www.youtube.com/watch?v=zbebx1Kvqho</a></li><li>引用部分博客：<a href="https://new.qq.com/rain/a/20191016A070PF00">https://new.qq.com/rain/a/20191016A070PF00</a></li><li><a href="https://www.freesion.com/article/69471423144/">https://www.freesion.com/article/69471423144/</a></li></ul><h2 id="1-Andriod进入Treble之前存在什么问题"><a href="#1-Andriod进入Treble之前存在什么问题" class="headerlink" title="1.Andriod进入Treble之前存在什么问题"></a>1.Andriod进入Treble之前存在什么问题</h2><p>在Android 8.0（Android Oreo）之前那个时代，苹果手机一旦有了新的系统更新，用户都能在短时间内更新系统，对用户来说实在太简单了，用户只需要点击更新下载新系统就可以完美的拥有最新的系统功能。而对于安卓用户而言，当安卓发布新的源码以后，会经过下面一系列的操作，用户才能用上真正的全新安卓系统。</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/生成过程.png" style="zoom: 80%;"><ol><li>发布源码：Google将新系统源码发布至AOSP</li><li>启动硬件适配：芯片制造商如<strong>三星</strong>、<strong>高通</strong>、<strong>联发科</strong>、<strong>华为</strong>等对源码进行修改，确保自家的芯片在新版Android能正常运行和发挥性能</li><li>OEM适配：OEM 厂商进一步修改新系统</li><li>OEM测试：OEM 厂商对系统进行内部测试</li><li>推送给用户：试无误后的新版系统通过 OTA 推送给用户</li></ol><p>这样带来的问题是什么，用谷歌开发团队的话来说，整个过程会花费5-12个月的时间……寄🐓</p><p>虽然Google在提交AOSP源码上非常迅速，但是芯片制造商和OEM厂商往往因为技术问题、第三方系统定制原因等导致整体的进程偏慢，最终形成了用户茫茫然的等待，从以往的数据统计我们也可以看出，Android手机中新系统的覆盖率寥寥无几。</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/licheng.png" style="zoom: 50%;"><blockquote><p>可以看到自从安卓8.0退出Treble以来，安卓9.0开始突飞猛进，更新的用户几乎是8.0的一倍</p></blockquote><h2 id="2-Treble计划"><a href="#2-Treble计划" class="headerlink" title="2.Treble计划"></a>2.Treble计划</h2><h3 id="2-1-Treble简介"><a href="#2-1-Treble简介" class="headerlink" title="2.1 Treble简介"></a>2.1 Treble简介</h3><p>Android 8.0 版本的一项新元素是 Project Treble。这是 Android架构方面的一项重大改变，主要解决Android 版本碎片化问题，更方便快捷的升级到最新版本。其中最核心的一点是将AOSP代码和供应商（Vendor）代码做好解耦。贴一张张架构前后的对比图：</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/架构变化.png"><ul><li>升级前：Framework代码和Vendor的代码耦合，即使谷歌发布会完最新AOSP代码，设备厂商也需要花费很多时间处理和Vendor代码适配问题【Reworked】，所以升级会花费很大量的时间</li></ul><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/新架构.png"><ul><li>新的架构：Treble在Framework和Vendor实现代码中间定义一个稳定的接口，这样Framework代码和Vendor的代码实现解耦，这样设备厂商能够快速的升级AOSP，只要接口不变，系统还能正常起来。</li></ul><p>下面我们具体看一下以前的Framework层和HAL层是怎么交互的？</p><p><strong>Android O之前版本的框架：</strong></p><p>在此之前的Android 系统架构当中，Android Framework 与Android HAL是打包成一个system.img的，而且Framework 与HAL之间是紧耦合的，通过链接的方式使用相应的硬件相关so库。老版本的android 的系统框架当中framework与HAL之间的一般架构框架是：</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/框架.png"><p>所以每次Android framework的升级需要对应的Android HAL升级。所以这样每次Android 升级都需要Android 设备制造商投入大量的人力物理去升级相应的Vendor HAL Implemetation.</p><p><strong>Android O及之后的版本的框架：</strong></p><p>在Android O以及以后的版本当中，Android 更新了新的框架设计在新的框架设计当中，引入了一套叫HIDL的语言来定义Freamework与HAL之间的接口，新的架构如下图：</p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/HIDL.png"><p>跟以往的Android 版本相比较，Android O里使用HIDL来解耦System Framework 与Vendor HAL Implemetation之间的关系【，从而简化降低Android系统升级的影响与难度。并且目前看起来，Android Framework与Vendor HAL Implemetation会存放在不同的分区当中，Android Framework会在system分区当中，而Vendor HAL Implemetation会在一个新定义的分区(Vendor.img)当中，这样刷新的system.img 才不会影响到Vendor HAL Implemetation。</p><p><strong>更清晰的调用关系</strong></p><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/O之前.png" style="zoom:70%;"><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/O之后.png" style="zoom:70%;"><h3 id="2-2-Treble新技术"><a href="#2-2-Treble新技术" class="headerlink" title="2.2 Treble新技术"></a>2.2 Treble新技术</h3><img src="/2023/01/14/Android-Treble%E8%AE%A1%E5%88%92/架构对比.png"><p><strong>Treble架构中为了实现系统和供应商的分离，引入了许多新技术。关键技术包括：</strong></p><ul><li>HIDL：HAL接口定义语言，用于指定HAL和其他用户之间的接口的一直接口描述语言(IDL)</li><li>HAL：运行Android8.0或者更高版本的设备必须支持使用HIDL语言编写的HAL，分为binderized HAL（绑定式）和passthrough HAL（直通式）。</li><li>设备树叠加层(DTO)：将设备数(DT)分割为主DT和叠加DT。叠加DT由ODM厂商提供，存放在ODM分区。通过对叠加DT的修改升级，可以实现在DT中增加设备节点和修改设备属性。</li><li>供应商原生开发套件(VNDK)：提供了一组让供应商实现其HAL的专用库。</li><li>供应商接口对象(VINTF)：用于汇总设备的相关信息并通过可查询的API提供该信息。</li><li>SELinux：Android8.0实现SELinux策略的模块化和兼容性，目标是使SOC供应商和ODM生产商能够以隔离方式自定义SELinux配置，而无需跨分区修改。</li></ul><h2 id="修改历史"><a href="#修改历史" class="headerlink" title="修改历史"></a>修改历史</h2><ul><li>2023&#x2F;01&#x2F;14：首次编写《Android-Treble计划》</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何搭建hexo部署到github</title>
    <link href="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/"/>
    <url>/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/</url>
    
    <content type="html"><![CDATA[<blockquote><p>🏓本文的内容是记录搭建hexo博客，并且部署到github上<br>🐖哈哈哈，我就是课代表<br>🍔所有内容均来自于：<strong>B站CodeSheep</strong></p></blockquote><h2 id="1-安装Nodejs"><a href="#1-安装Nodejs" class="headerlink" title="1.安装Nodejs"></a>1.安装Nodejs</h2><h3 id="1-1-安装Nodejs"><a href="#1-1-安装Nodejs" class="headerlink" title="1.1 安装Nodejs"></a>1.1 安装Nodejs</h3><p>Nodejs官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/nodejs安装.png" alt="image-20230114121402814" style="zoom: 67%;"><p>直接无脑下一步安装，安装完成后<code>node -v</code>查看版本确认是否安装成功</p><h3 id="1-2-更换镜像"><a href="#1-2-更换镜像" class="headerlink" title="1.2 更换镜像"></a>1.2 更换镜像</h3><p>由于npm包管理工具实在太慢了，所以打算使用淘宝镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>最后可以通过<code>cnpm -v</code>查看一下cnpm是否安装成功</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/安装npm.png" alt="image-20230114121402814" style="zoom: 67%;"><h2 id="2-安装Hexo并初始化hexo项目"><a href="#2-安装Hexo并初始化hexo项目" class="headerlink" title="2.安装Hexo并初始化hexo项目"></a>2.安装Hexo并初始化hexo项目</h2><h3 id="2-1-安装hexo"><a href="#2-1-安装hexo" class="headerlink" title="2.1 安装hexo"></a>2.1 安装hexo</h3><p>先通过npm安装hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装完成以后，可以通过<code>hexo -v</code> 查看是否安装成功</p><h3 id="2-2-初始化hexo项目"><a href="#2-2-初始化hexo项目" class="headerlink" title="2.2 初始化hexo项目"></a>2.2 初始化hexo项目</h3><ol><li>本地创建一个文件夹，用于存放hexo的所有内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir hexo-blog<br></code></pre></td></tr></table></figure><ol start="2"><li>进入该项目文件夹，进行初始化</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br></code></pre></td></tr></table></figure><ol start="3"><li>本地打开该项目</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>通过<code>localhost:4000</code>进行访问</p><h3 id="2-3-创建一个新的项目"><a href="#2-3-创建一个新的项目" class="headerlink" title="2.3 创建一个新的项目"></a>2.3 创建一个新的项目</h3><p>创建自己的新博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new &quot;如何搭建hexo部署到github&quot;<br></code></pre></td></tr></table></figure><p>生成静态文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><p>启动项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><p>通过<code>localhost:4000</code>进行访问</p><h2 id="3-将hexo部署到github"><a href="#3-将hexo部署到github" class="headerlink" title="3.将hexo部署到github"></a>3.将hexo部署到github</h2><h3 id="3-1-新建一个github仓库"><a href="#3-1-新建一个github仓库" class="headerlink" title="3.1 新建一个github仓库"></a>3.1 新建一个github仓库</h3><blockquote><p>这里需要注意一下，创建的仓库名必须与你的username是一样的，比如我的usrname是anmuxixixi，则创建的仓库名为anmuxixixi.github.io；详情见GitHub如何创建一个Page</p></blockquote><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/创建github.jpg" alt="image-20230114121402814" style="zoom: 60%;"><h3 id="3-2-安卓hexo针对git的deploy组件"><a href="#3-2-安卓hexo针对git的deploy组件" class="headerlink" title="3.2 安卓hexo针对git的deploy组件"></a>3.2 安卓hexo针对git的deploy组件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/安装插件.png" alt="image-20230114121402814" style="zoom: 80%;"><h3 id="3-2-部署到github"><a href="#3-2-部署到github" class="headerlink" title="3.2 部署到github"></a>3.2 部署到github</h3><p>打开项目的<code>_config.xml</code>，设置<code>deploy</code>属性</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/设置deploy.png" alt="image-20230114121402814" style="zoom: 80%;"><blockquote><p> 这个repo对应的仓库名就是我们的<strong>github仓库地址</strong></p></blockquote><p>将其部署到github上</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo cl</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>浏览器输入<code>https://anmuxixixi.github.io/</code></p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/打开仓库.png" alt="image-20230114121402814" style="zoom: 50%;"><h2 id="4-设置主题"><a href="#4-设置主题" class="headerlink" title="4.设置主题"></a>4.设置主题</h2><h3 id="4-1-安装主题"><a href="#4-1-安装主题" class="headerlink" title="4.1 安装主题"></a>4.1 安装主题</h3><ul><li>Hexo官方设置主题的网站：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></li><li>Fluid主题：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></li><li>Fluid主题文档：<a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></li></ul><p>打开github，下载好Fluid主题，将其解压放在themes文件夹下</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/下载主题.png" alt="image-20230114121402814" style="zoom: 80%;"><p>打开<code>_config.xml</code>，设置<code>theme</code>为<code>fluid</code>，设置<code>language</code>为<code>zh-CN</code></p><p>启动后看下整体的效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><h3 id="4-2-简单的页面设置"><a href="#4-2-简单的页面设置" class="headerlink" title="4.2 简单的页面设置"></a>4.2 简单的页面设置</h3><ol><li>修改网页导航栏标题</li></ol><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/修改网页标题.png" alt="image-20230114203236266" style="zoom:67%;"><p>其对应的效果如下</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/标题栏.png"><ol start="2"><li>修改背景图片</li></ol><p>自己复制一张图片，将名字修改为<code>default.png</code></p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/背景.png"><ol start="3"><li>修改中间打字机文字</li></ol><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/打字机.png" alt="image-20230114203653973" style="zoom:79%;"><ol start="4"><li>整体效果如下</li></ol><p><a href="https://anmuxixixi.github.io/">https://anmuxixixi.github.io/</a></p><p>欢迎品尝🌭</p><img src="/2023/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/zhengti.png">]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
